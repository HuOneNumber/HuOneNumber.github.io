<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML Standard阅读初体验</title>
    <url>/2021/03/09/tech/HTML%20Standard/</url>
    <content><![CDATA[<h1 id="Abstract："><a href="#Abstract：" class="headerlink" title="Abstract："></a>Abstract：</h1><p>通过背景、针对人群、发展历程等几个方面说明了HTML规范的意义和适用范围，同时对规范中的表单序列化、对其他规范的兼容性、可扩展性三个设计目标进行详细说明。其次引入元素、节点、DOM树等概念简单介绍了HTML，最后举例来说明Web可能存在的安全问题并提供了易行的解决方法。</p>
<h1 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h1><p>通览目录和前言的介绍，对近期所要学习的内容即HTM规范及其重要性有了一个初步的了解，比如对一些基础知识，譬如元素和节点两个概念的区别、DOM树的概念理解更加清晰。</p>
<p>另一方面，在之前的前端学习中，只考虑到兼容性，至于安全性，除了post、HTTPS比get和HTTP安全以外就不甚了解，有些攻击甚至能威胁到服务器中的数据。</p>
<p>如同规范里所说，“对于完整理解本规范的某些技术性部分，必须熟悉DOM的基础”，同时，在阅读途中也能了解到不仅限于所阅读的内容，比如1.10.2中所举的例子，也顺带去了解一下事件的捕获和冒泡机制，这些都要求我需要花更多的时间精力，但我想也才能更好的理解HTML规范，同时全英文的规范阅读对我的英语水平也将有极大的提升，相信不久，目前较为吃力的我也能逐渐以英语来记录我的笔记，</p>
<p>总而言之，我目前的认知，阅读并理解HTML规范，就如同使用产品之前看说明书一样，能有助于安全、有效的开发的同时，也减少了后期的维护成本。</p>
]]></content>
      <categories>
        <category>日记随笔</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建的想法</title>
    <url>/2021/03/09/diary/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<p>长久的坚持学习并监督自己发布到博客上绝非易事，在我从刚开始浏览他人博客，到自己学习搭建博客这段时间，发现很多人的文章已是很早之前，或许是工作生活和其他压力，早将此事抛之脑后。</p>
<p>我更希望这个博客记载着我从一个前端小白到略懂一二的树洞，也正如我网站的标语，慢慢来，深几度。</p>
]]></content>
      <categories>
        <category>日记随笔</category>
      </categories>
  </entry>
  <entry>
    <title>W3C阅读初体验</title>
    <url>/2021/03/07/tech/W3C/</url>
    <content><![CDATA[<p>对于technical report，一旦评审表明工作组满足了新标准的要求，进入Candidate Recommendation 阶段。W3C成员可以就规范是否适合作为W3C建议提供反馈，而工作组收集经验，以证明规范在实践中可行。下一阶段是Proposed Recommendation，以最终完成对W3C成员的评审。如果主管确定W3C成员评审支持其成为标准的规范，则将其发布为W3C Recommendation 。</p>
<p>流程：WD –&gt;CR–&gt;PR–&gt;REC</p>
<h4 id="成熟度级别："><a href="#成熟度级别：" class="headerlink" title="成熟度级别："></a>成熟度级别：</h4><p><strong>Working Draft (WD)：</strong>工作草案是W3C已发布以供社区（包括W3C成员，公众和其他技术组织）审查的文档。</p>
<p><strong>Candidate Recommendation (CR)：</strong>是指满足产生该建议书及其依存关系的工作组的技术要求，或对工作组未维护并已得到广泛审核的建议书进行实质性更正的文档。</p>
<p><strong>Proposed Recommendation（PR）：</strong>是W3C主任已接受的，具有足以成为REC的有质量的文件。</p>
<p><strong>W3C Recommendation (REC)：</strong>W3C建议书是在广泛建立共识之后得到W3C成员和主任认可的规范或准则或要求集。随着技术发展，REC可能会变成An Edited Recommendation、An Amended Recommendation、A Superseded Recommendation、An Obsolete Recommendation。</p>
<p><strong>技术报告的一般要求</strong>：</p>
<p>1、在技​​术报告开发过程中发布的每个文档都必须是公共文档；</p>
<p>2、每个文档都必须明确指出其成熟度，并且必须包含有关文档状态的信息；</p>
<p>3、每个技术报告均由小组主席任命的一名或多名编辑人员进行编辑；</p>
<p>4、不需要发布不符合团队发布规则（例如，命名、状态信息、样式和版权要求）的技术报告；</p>
<p>5、W3C技术报告的主要语言是英语，W3C鼓励将其技术报告翻译成其他语言。</p>
<p><strong>对规范更改的类别：</strong>No changes to text content 、Corrections that do not affect conformance 、Corrections that do not add new features  、New features，前两个被认为是 editorial changes, 后面两个是 substantive changes.</p>
<h4 id="修改W3C-Recommendation"><a href="#修改W3C-Recommendation" class="headerlink" title="修改W3C Recommendation"></a><strong>修改W3C Recommendation</strong></h4><p>Errata Management是很重要的一部分，对于读者和实施者报告的错误，工作组必须保留记录。工作组可以要求对REC进行重新发布，或者如果没有工作组授权维护REC，则W3C 可以重新发布该REC，以进行更正，而不会导致对规范文本的任何更改。</p>
]]></content>
      <categories>
        <category>日记随笔</category>
      </categories>
      <tags>
        <tag>W3C</tag>
      </tags>
  </entry>
  <entry>
    <title>02-HTML中的JavaScript</title>
    <url>/2021/01/23/note/JavaScript/02-HTML%E4%B8%AD%E7%9A%84JavaScript/</url>
    <content><![CDATA[<h2 id="2-1-lt-script-gt-元素"><a href="#2-1-lt-script-gt-元素" class="headerlink" title="2.1　&lt;script&gt;元素"></a>2.1　<code>&lt;script&gt;</code>元素</h2><p>将JavaScript插入HTML的主要方法是使用<code>&lt;script&gt;</code>元素。<code>&lt;script&gt;</code>元素有下列8个属性。</p>
<ul>
<li><code>async</code>：可选。只对外部脚本文件有效。详见2.13。</li>
<li><code>charset</code>：可选。使用<code>src</code>属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li>
<li><code>crossorigin</code>：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。<code>crossorigin=&quot;anonymous&quot;</code>配置文件请求不必设置凭据标志。<code>crossorigin=&quot;use-credentials&quot;</code>设置凭据标志，意味着出站请求会包含凭据。</li>
<li><code>defer</code>：可选。只对外部脚本文件有效。详见2.12</li>
<li><code>integrity</code>：可选。允许比对接收到的资源的加密签名和指定的加密签名，以验证子资源完整性（SRI，Subresource Integrity）。如果不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。</li>
<li><code>language</code>：废弃。</li>
<li><code>src</code>：可选。表示包含要执行的代码的外部文件。</li>
<li><code>type</code>：可选。代替<code>language</code>，表示代码块中脚本语言的内容类型（也称MIME类型）。按照惯例，这个值始终都是<code>&quot;text/javascript&quot;</code>。JavaScript文件的MIME类型通常是<code>&quot;application/x-javascript&quot;</code>，不过给type属性这个值有可能导致脚本被忽略。如果这个值是<code>module</code>，则代码会被当成ES6模块，而且只有这时候代码中才能出现<code>import</code>和<code>export</code>关键字。</li>
</ul>
<p>使用<code>&lt;script&gt;</code>的方式有两种：通过它直接在网页中嵌入JavaScript代码，以及通过它在网页中包含外部JavaScript文件。</p>
<p>要嵌入行内JavaScript代码，直接把代码放在<code>&lt;script&gt;</code>元素中就行，包含在<code>&lt;script&gt;</code>内的代码会被从上到下解释。在在<code>&lt;script&gt;</code>元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在使用行内JavaScript代码时，要注意代码中不能出现字符串<code>&lt;/script&gt;</code>。因为浏览器解析行内脚本的方式决定了它会将其当成结束的<code>&lt;/script&gt;</code>标签。想避免这个问题，只需要转义字符“\”即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// console.log(&quot;&lt;\/script&gt;&quot;);</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">sayScript</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;); </span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要包含外部文件中的JavaScript，就必须使用<code>src</code>属性。这个属性的值是一个URL，指向包含JavaScript代码的文件，与解释行内JavaScript一样，在解释外部JavaScript文件时，页面也会阻塞。阻塞时间也包含下载文件的时间。在XHTML文档中，可以忽略结束标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>　按照惯例，外部JavaScript文件的扩展名是.js。但不是必需的，因为浏览器不会检查所包含JavaScript文件的扩展名。这就为使用服务器端脚本语言动态生成JavaScript代码，或者在浏览器中将JavaScript扩展语言（如TypeScript、React的JSX）转译为JavaScript提供了可能性。不过服务器经常会根据文件扩展来确定响应的正确MIME类型。如果不使用.js扩展名，一定要确保服务器能返回正确的MIME类型。</p>
</blockquote>
<p>使用了<code>src</code>属性的<code>&lt;script&gt;</code>元素不应该再在<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签中再包含其他JavaScript代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。</p>
<p><code>&lt;script&gt;</code>元素的一个强大也备受争议的特性是，可以包含来自外部域的JavaScript文件。跟<code>&lt;img&gt;</code>元素很像，<code>&lt;script&gt;</code>元素的src属性可以是一个完整的URL，而且这个URL指向的资源可以跟包含它的HTML页面不在同一个域中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.somewhere.com/afile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器在解析这个资源时，会向<code>src</code>属性指定的路径发送一个<code>GET</code>请求，以取得相应资源，这个初始的请求不受浏览器同源策略限制，但返回并被执行的JavaScript则受限制。</p>
<p>来自外部域的代码会被当成加载它的页面的一部分来加载和解释。这个能力可以让我们通过不同的域分发JavaScript。在包含外部域的JavaScript文件时，要确保该域是自己所有的，或者该域是一个可信的来源。<code>&lt;script&gt;</code>标签的<code>integrity</code>属性可以防范这种问题。</p>
<p>浏览器会按照<code>&lt;script&gt;</code>在页面中出现的顺序依次解释它们，前提是它们没有使用<code>defer</code>和<code>async</code>属性。第二个<code>&lt;script&gt;</code>元素必须在第一个<code>&lt;script&gt;</code>元素的代码解释完毕才能开始解释。</p>
<h3 id="2-1-1-标签占位符"><a href="#2-1-1-标签占位符" class="headerlink" title="2.1.1　标签占位符"></a>2.1.1　标签占位符</h3><p>过去，所有<code>&lt;script&gt;</code>元素都被放在页面的<code>&lt;head&gt;</code>标签内，这种做法的主要目的是把外部的CSS和JavaScript文件都集中放到一起。不过，这也就意味着必须把所有JavaScript代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到<code>&lt;body&gt;</code>的起始标签时开始渲染）。</p>
<p>现代Web应用程序通常将所有JavaScript引用放在<code>&lt;body&gt;</code>元素中的页面内容后面，页面会在处理JavaScript代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-推迟执行脚本"><a href="#2-1-2-推迟执行脚本" class="headerlink" title="2.1.2　推迟执行脚本"></a>2.1.2　推迟执行脚本</h3><p><code>defer</code>属性表示脚本在执行的时候不会改变页面的结构。也就是脚本会被延迟到整个页面都解析完毕后再运行。相当于告诉浏览器立即下载，但延迟执行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里是页面内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然这个例子中的<code>&lt;script&gt;</code>元素包含在页面的<code>&lt;head&gt;</code>中，但它们会在浏览器解析到结束的<code>&lt;/html&gt;</code>标签后才会执行。HTML5规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在<code>DOMContentLoaded</code>事件之前执行。不过在实际当中，这都不一定。因此最好只包含一个这样的脚本。</p>
<p><code>defer</code>属性只对外部脚本文件才有效，因此支持HTML5的浏览器会忽略行内脚本的<code>defer</code>属性。有些浏览器则会忽略<code>defer</code>，按照通常的做法来处理脚本。因此把要推迟执行的脚本放在页面底部比较好。</p>
<h3 id="2-1-3-异步执行脚本"><a href="#2-1-3-异步执行脚本" class="headerlink" title="2.1.3　异步执行脚本"></a>2.1.3　异步执行脚本</h3><p><code>async</code>属性与<code>defer</code>都会告诉浏览器立即开始下载。不不同的是，标记为<code>async</code>的脚本并不保证能按照它们出现的次序执行。给脚本添加<code>async</code>属性的目的是告诉浏览器，该异步脚本下载和执行，可以同时加载页面和加载其他脚本。因此，异步脚本不应该在加载期间修改DOM。</p>
<p>异步脚本保证会在页面的<code>load</code>事件前执行，但可能会在<code>DOMContentLoaded</code>。不推荐使用这个方法。</p>
<h3 id="2-1-4-动态加载脚本"><a href="#2-1-4-动态加载脚本" class="headerlink" title="2.1.4　动态加载脚本"></a>2.1.4　动态加载脚本</h3><p>除了<code>&lt;script&gt;</code>标签，JavaScript可以使用DOM API，向DOM中动态添加<code>script</code>元素同样可以加载指定的脚本。默认情况下，以这种方式创建的<code>&lt;script&gt;</code>元素是以异步方式加载的，相当于添加了<code>async</code>属性。不过不是所有浏览器都支持<code>async</code>属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src = <span class="string">&#x27;gibberish.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 添加script.async = false;可以统一加载行为</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br></pre></td></tr></table></figure>
<p>但以这种方式获取的资源对浏览器预加载器是不可见的。会严重影响它们在资源获取队列中的优先级。可以在文档头部显式声明它们，让预加载器知道这些动态请求文件的存在。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;gibberish.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-行内代码与外部文件"><a href="#2-2-行内代码与外部文件" class="headerlink" title="2.2　行内代码与外部文件"></a>2.2　行内代码与外部文件</h2><p>通常认为最佳实践是尽可能将JavaScript代码放在外部文件中。理由如下。</p>
<ul>
<li><strong>可维护性</strong>。JavaScript代码如果分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。</li>
<li><strong>缓存</strong>。浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这意味着页面加载更快。</li>
<li><strong>适应未来</strong>。</li>
</ul>
<p>如果浏览器支持SPDY/HTTP2，在配置浏览器请求外部文件时，以轻量、独立JavaScript组件形式向客户端送达脚本更具优势。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;mainA.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="2-3-文档模式"><a href="#2-3-文档模式" class="headerlink" title="2.3　文档模式"></a>2.3　文档模式</h2><p>IE5.5发明了文档模式的概念，使用<code>doctype</code>切换文档模式。文档模式有三种：</p>
<ol>
<li><strong>混杂模式</strong>（quirks mode），支持一些非标准的特性。</li>
<li><strong>标准模式</strong>（standards mode）。具有兼容标准的行为。</li>
<li><strong>准标准模式</strong>（almost standards mode）。支持很多标准的特性，但是又没有规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。</li>
</ol>
<p>虽然这模式的主要区别只体现在通过CSS渲染的内容方面，但对JavaScript也有一些关联影响。</p>
<p>混杂模式在所有浏览器中都以省略文档开头的<code>doctype</code>声明作为开关。这种约定并不合理，因为混杂模式在不同浏览器中的差异非常大。</p>
<p>标准模式通过下列几种文档类型声明开启：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 4.01 Strict --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XHTML 1.0 Strict --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HTML5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>准标准模式与标准模式非常接近，很少需要区分。它通过过渡性文档类型（<code>Transitional</code>）和框架集文档类型（<code>Frameset</code>）来触发：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 4.01 Transitional --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML 4.01 Frameset --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="2-4-lt-noscript-gt-元素"><a href="#2-4-lt-noscript-gt-元素" class="headerlink" title="2.4　&lt;noscript&gt;元素"></a>2.4　<code>&lt;noscript&gt;</code>元素</h2><p><code>&lt;noscript&gt;</code>元素用于给不支持JavaScript的浏览器提供替代内容。可以包含任何可以出现在<code>&lt;body&gt;</code>中的HTML元素，<code>&lt;script&gt;</code>除外。在下列两种情况下，浏览器将显示包含在<code>&lt;noscript&gt;</code>中的内容：</p>
<ul>
<li>浏览器不支持脚本；</li>
<li>浏览器对脚本的支持被关闭。</li>
</ul>
<p>任何一个条件被满足，包含在<code>&lt;noscript&gt;</code>中的内容就会被渲染。否则，浏览器不会渲染<code>&lt;noscript&gt;</code>中的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This page requires a JavaScript-enabled browser.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>02-应用层</title>
    <url>/2021/05/10/note/Computer%20Networking/02-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络：自顶向下方法</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Positioned Layout Module Level 3</title>
    <url>/2021/03/07/note/W3C%20CSS/Positioned%20Layout%20Module%20Level%203/</url>
    <content><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>|name|postion|<br>|:—-:|:—-|:—-:|:—-|<br>|Value:|static<a class="link"   href="https://www.w3.org/TR/css-values-4/#comb-one" >|<i class="fas fa-external-link-alt"></i></a>relative | absolute | sticky | fixed|<br>|Initial:|static|<br>|Applies to:|除了table-column-group 和table-column以外的所有元素|<br>|Inherited:|不继承|</p>
<h1 id="2-static-定位"><a href="#2-static-定位" class="headerlink" title="2 static 定位"></a>2 static 定位</h1><p>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</p>
<p>静态定位的元素不会受到 top, bottom, left, right影响。</p>
<h1 id="3-relative-定位"><a href="#3-relative-定位" class="headerlink" title="3 relative 定位"></a>3 relative 定位</h1><p>相对定位元素的定位是相对其正常位置。</p>
<h1 id="4-absolute-定位"><a href="#4-absolute-定位" class="headerlink" title="4 absolute 定位"></a>4 absolute 定位</h1><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:</p>
<h1 id="5-sticky-定位"><a href="#5-sticky-定位" class="headerlink" title="5 sticky 定位"></a>5 sticky 定位</h1><p>sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。</p>
<p>position: sticky; 基于用户的滚动位置来定位。</p>
<p>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</p>
<p>它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</p>
<p>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>
<p>这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<h1 id="6-fixed-定位"><a href="#6-fixed-定位" class="headerlink" title="6 fixed 定位"></a>6 fixed 定位</h1><p>元素的位置相对于浏览器窗口是固定位置。</p>
<p>即使窗口是滚动的它也不会移动：</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>W3C CSS</category>
      </categories>
      <tags>
        <tag>W3C</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>02-HTML网页和结构</title>
    <url>/2021/01/21/note/Webkit/02-HTML%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>HTML网页是利用HTML语言编写的文档，它是一种半结构化的数据表现方式。它的结构特征可以归纳为三种：树状结构、层次结构和框结构。</p>
<h2 id="2-1-网页构成"><a href="#2-1-网页构成" class="headerlink" title="2.1 网页构成"></a>2.1 网页构成</h2><h3 id="2-1-1-基本元素和树状结构"><a href="#2-1-1-基本元素和树状结构" class="headerlink" title="2.1.1 基本元素和树状结构"></a>2.1.1 基本元素和树状结构</h3><p>现在的网页基本上都是动态网页（Dynamic HTML），这就需要JavaScript代码用来控制网页内部的逻辑，CSS用来描述网页的显示信息。</p>
<p>整个网页可以看成一种树状结构，其树根是html，这是网页的根元素（或称节点）。根下面包含两个子节点head和body。</p>
<h3 id="2-1-2-HTML-5新特性"><a href="#2-1-2-HTML-5新特性" class="headerlink" title="2.1.2 HTML.5新特性"></a>2.1.2 HTML.5新特性</h3><p>HTML5引入的对2D和3D图形以及多媒体方面的支持，将彻底改变网页的渲染方式和复杂度，包括但是不限于：</p>
<ol>
<li><strong>video元素</strong>，支持在网页中播放视频。</li>
<li><strong>Canvas 2D</strong>，Canvas 2D通过定义一个新的“canvas”元素，网页开发者利用该元素的2D绘图上下文（graphics context）调用标准定义的接口，绘制常见的2D图形，例如点、线、矩形、多边形等。</li>
<li><strong>WebGL</strong>（也就是Canvas 3D）。WebGL则是使用“canvas”元素的3D绘图上下文调用标准定义的接口，绘制3D图形，这些接口类似于OpenGL ES的接口。</li>
<li><strong>CSS3 3D变换</strong>（transform）和<strong>转换</strong>（transition）。CSS3 3D的变换和转换则可以作用于HTML的任意可视元素，制造出各种炫丽的3D效果。<h2 id="2-2-网页结构"><a href="#2-2-网页结构" class="headerlink" title="2.2 网页结构"></a>2.2 网页结构</h2></li>
</ol>
<h3 id="2-2-1-框结构"><a href="#2-2-1-框结构" class="headerlink" title="2.2.1 框结构"></a>2.2.1 框结构</h3><p>框结构可以用来对网页的布局进行分割，将网页分成几个框。网页开发者也可以让网页嵌入其他的网页，frameset、frame和iframe可以用来在当前网页中嵌入新的框结构。多框结构的网页非常不适合移动领域，因为该结构对触控操作来说是不方便的。</p>
<h3 id="2-2-2-层次结构"><a href="#2-2-2-层次结构" class="headerlink" title="2.2.2 层次结构"></a>2.2.2 层次结构</h3><p>网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是某些元素可能不同于它的父元素所在的层次，同时CSS部分的代码也会对网页的分层策略产生重要影响。</p>
<p>对于需要复杂变换和处理的元素，WebKit 为它们构建新层其实是为了渲染引擎在处理上的方便和高效。</p>
<h2 id="2-3-WebKit的网页渲染过程"><a href="#2-3-WebKit的网页渲染过程" class="headerlink" title="2.3 WebKit的网页渲染过程"></a>2.3 WebKit的网页渲染过程</h2><h3 id="2-3-1-加载和渲染"><a href="#2-3-1-加载和渲染" class="headerlink" title="2.3.1 加载和渲染"></a>2.3.1 加载和渲染</h3><p>浏览器的主要作用就是将用户输入的“URL”转变成可视化的图像，包含两个过程，一是网页加载过程，就是从“URL”到构建DOM树；二是网页渲染过程，从DOM树到生成可视化图像。这两个过程也会交叉，统称这两个过程为网页的渲染过程。</p>
<p>网页通常比我们的屏幕可视面积要大，当前可见的区域称为<strong>视图</strong>（viewport），浏览器在渲染网页的时候，一般会加入滚动条以帮助翻滚网页。</p>
<h3 id="2-3-2-WebKit的渲染过程"><a href="#2-3-2-WebKit的渲染过程" class="headerlink" title="2.3.2 WebKit的渲染过程"></a>2.3.2 WebKit的渲染过程</h3><p>网页的一般渲染过程中的数据包括网页内容、DOM、内部表示和图像，模块则包括HTML解释器、CSS解释器、JavaScript 引擎以及布局和绘图模块。</p>
<p>根据数据的流向，将渲染过程分成三个阶段，第一个阶段是从网页的URL到构建DOM树，第二个阶段是从DOM树到构建WebKit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。</p>
<h4 id="2-3-2-1-第一个阶段：从网页的URL到构建DOM树"><a href="#2-3-2-1-第一个阶段：从网页的URL到构建DOM树" class="headerlink" title="2.3.2.1 第一个阶段：从网页的URL到构建DOM树"></a>2.3.2.1 第一个阶段：从网页的URL到构建DOM树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/lirgHwQ6LBcDU7u.png"
                      alt="uSXBGLwftTz59OfO__thumbnail.png"
                ></p>
<p>具体的过程如下：</p>
<ol>
<li>当用户输入网页URL的时候，WebKit调用其资源加载器加载该URL对应的网页。</li>
<li>加载器依赖网络模块建立连接，发送请求并接收答复。</li>
<li>WebKit接收到各种网页或者资源的数据，某些资源可能是同步或异步获取的。</li>
<li>网页被交给HTML解释器转变成一系列的词语（Token）。</li>
<li>解释器根据词语构建节点（Node），形成DOM树。</li>
<li>如果节点是JavaScript代码的话，调用JavaScript引擎解释并执行。</li>
<li>JavaScript代码可能会修改DOM树的结构。</li>
<li>如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载它们，但是它们是异步的，不会阻碍当前DOM树的继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。</li>
</ol>
<p>在上述的过程中，网页在加载和渲染过程中会发出“DOMConent”事件和DOM的“onload”事件，分别在DOM树构建完之后，以及DOM树建完并且网页所依赖的资源都加载完之后发生，因为某些资源的加载并不会阻碍DOM树的创建，所以这两个事件多数时候不是同时发生的。</p>
<h4 id="2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文"><a href="#2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文" class="headerlink" title="2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文"></a>2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/BxFNhne3Lwm76ld.png"
                      alt="5zAmE3T5IrREBagI__thumbnail.png"
                ></p>
<p>这一阶段的具体过程如下。</p>
<ol>
<li>CSS文件被CSS解释器解释成内部表示结构。</li>
<li>CSS解释器工作完之后，在DOM树上附加解释后的样式信息，这就是RenderObject树。</li>
<li>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文，这中间还有复杂的内部过程。</li>
</ol>
<p>RenderObject树的建立并不表示DOM树会被销毁，图中的四个内部表示结构一直存在，直到网页被销毁。</p>
<h4 id="2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。"><a href="#2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。" class="headerlink" title="2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。"></a>2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/XrFjB2oaqOKkg85.png"
                      alt="3oObbcPTpx9gzPCi__thumbnail.png"
                ></p>
<p>图中这一阶段对应的具体过程如下。</p>
<ol>
<li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的绘图具体实现类。</li>
<li>绘图实现类有简单或复杂的实现。在Chromium中，它的实现相当复杂，需要Chromium的合成器来完成复杂的多进程和GPU加速机制。</li>
<li>绘图实现类将 2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来同浏览器界面一起显示。</li>
</ol>
<p>现代浏览器为了绘图上的高效性和安全性，可能会在这一过程中引入复杂的机制。而且，绘图也从之前单纯的软件渲染，到现在的GPU硬件渲染、混合渲染模型等方式。</p>
<p>现代网页很多是动态网页，这意味着在渲染完成之后，由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>04-资源加载和网络栈</title>
    <url>/2021/01/21/note/Webkit/04-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%A0%88/</url>
    <content><![CDATA[<p>使用网络栈下载网页和网页中的资源是渲染引擎工作过程的第一步，也是非常消耗时间的步骤。</p>
<h2 id="4-1-WebKit资源加载机制"><a href="#4-1-WebKit资源加载机制" class="headerlink" title="4.1 WebKit资源加载机制"></a>4.1 WebKit资源加载机制</h2><h3 id="4-1-1资源"><a href="#4-1-1资源" class="headerlink" title="4.1.1资源"></a>4.1.1资源</h3><p>网页本身就是一种资源，而且网页还需要依赖很多其他类型的资源，例如图片、视频等。</p>
<p>HTML支持的资源主要包括以下类型。</p>
<ol>
<li><strong>HTML</strong>：HTML页面，包括各式各样的HTML元素。</li>
<li><strong>JavaScript</strong>：JavaScript 代码，可以内嵌在HTML文件中，也可以以单独的文件存在。</li>
<li><strong>CSS样式表</strong>：CSS样式资源，可以内嵌在HTML文件之外，也可以以单独文件存在。</li>
<li><strong>图片</strong>：各种编码格式的图片资源，还有一些特殊的图片资源，例如SVG中所需的图片资源。</li>
<li><strong>SVG</strong>：用于绘制SVG的2D矢量图形表示。</li>
<li><strong>CSS Shader</strong>：支持CSS Shader文件，目前WebKit支持该功能。</li>
<li><strong>视频、音频和字幕</strong>：多媒体资源及支持音视频的字幕文件（TextTrack）。</li>
<li><strong>字体文件</strong>：CSS支持自定义字体，CSS3引入的自定义字体文件。</li>
<li><strong>XSL样式表</strong>：使用XSLT语言编写的XSLT代码文件。</li>
</ol>
<p>上面这些资源在WebKit 中有不同的类来表示它们，它们的公共基类是<strong>CachedResource</strong>。其中HTML文本的类型叫MainResource类，与其对应的资源类型叫CachedRawResource类。</p>
<p>资源类的前面的Cached字样，是因为效率问题而引入的缓存机制，所有对资源的请求都会先获取缓存中的信息，以决定是否向服务器提出资源请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/SejVWMfxqd1UJwC.png"
                      alt="0daCvmpdLOgUMBoZ__thumbnail.png"
                ></p>
<h3 id="4-1-2-资源缓存"><a href="#4-1-2-资源缓存" class="headerlink" title="4.1.2 资源缓存"></a>4.1.2 资源缓存</h3><p>资源的缓存机制的基本思想是建立一个资源的缓存池，当WebKit需要请求资源的时候，先从资源池中查找是否存在相应的资源。WebKit从资源池中查找资源的关键字是URL。如果没有，WebKit创建一个新的CachedResource子类的对象，并发送真正的请求给服务器，WebKit收到资源后将其设置到该资源类的对象中去，以便于缓存后下次使用。这里的缓存指的是内存缓存，而不同于在网络栈部分的磁盘缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/NrcO3mnTpqWfUKH.png"
                      alt="DADmcG38TQhFjPbK__thumbnail.png"
                ></p>
<h3 id="4-1-3-资源加载器"><a href="#4-1-3-资源加载器" class="headerlink" title="4.1.3 资源加载器"></a>4.1.3 资源加载器</h3><p>按照加载器的类型来分，WebKit 总共有三种类型的加载器。</p>
<ol>
<li>针对每种资源类型的<strong>特定加载器</strong>，特点是仅加载某一种资源。这些资源加载器没有公共基类，作用就是当需要请求资源时，由资源加载器负责加载并隐藏背后复杂的逻辑。加载器属于它的调用者。例如image元素需要图片资源，对应的特定资源加载器是ImageLoader类。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/UpEoau5rzePs2xg.png"
                      alt="3IcXzyYa57u2Lz0U__thumbnail.png"
                ></p>
<ol start="2">
<li><strong>资源缓存机制的资源加载器</strong>，特点是所有特定加载器都共享它来查找并插入缓存资源——<strong>CachedResourceLoader类</strong>。特定加载器先是通过缓存机制的资源加载器来查找是否有缓存资源，它属于HTML的文档对象。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/YqjmButO51IrWMH.png"
                      alt="Lql2quYaEeTXRUBf__thumbnail.png"
                ></p>
<ol start="3">
<li><strong>通用的资源加载器</strong>——ResourceLoader类，是在WebKit需要从网络或者文件系统获取资源的时候使用该类只负责获得资源的数据，因此被所有特定资源加载器所共享。它属于CachedResource类，但它同CachedResourceLoader类没有继承关系，这容易混淆。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/oCLGxvzqYsTiM4B.png"
                      alt="yxLtJhDragnUUhta__thumbnail.png"
                ></p>
<h3 id="4-1-4-过程"><a href="#4-1-4-过程" class="headerlink" title="4.1.4 过程"></a>4.1.4 过程</h3><p>下图是一个带有资源缓存机制的资源加载的全过程，包括资源已经在缓存中和不在缓存中两种情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/S5sq3j2B7AJkh8Z.png"
                      alt="gVXqqiTMWy0JHXYe__thumbnail.png"
                ></p>
<p>通常一些资源的加载是异步执行的，资源的获取和加载不会阻碍当前WebKit的渲染过程，例如图片、CSS文件。但网页也存在某些特别的资源会阻碍主线程的渲染过程，例如JavaScript代码文件。这会严重影响WebKit下载资源的效率，因为后面可能还有许多需要下载的资源。</p>
<p>webkit的解决方案：当前的主线程被阻碍时，WebKit 会启动另外一个线程去遍历后面的HTML网页，收集需要的资源URL，然后发送请求，避免被阻碍。同时WebKit 能够并发下载这些资源，甚至并发下载JavaScript代码资源。</p>
<h3 id="4-1-5-资源的生命周期"><a href="#4-1-5-资源的生命周期" class="headerlink" title="4.1.5 资源的生命周期"></a>4.1.5 资源的生命周期</h3><p>同CachedResourceLoader对象一样，资源池也属于HTML文档对象。资源池采用LRU（Least Recent Used）算法来替换其中的资源，从而加入新的资源。</p>
<p>另一方面，当一个资源加载后，通常它会被放入资源池，以便之后使用。在HTTP协议的规范中规定，浏览器可以发送消息确认是否需要更新，如果有，浏览器则重新获取该资源；否则就需要利用该资源。</p>
<h2 id="4-2-Chromium多进程资源加载"><a href="#4-2-Chromium多进程资源加载" class="headerlink" title="4.2 Chromium多进程资源加载"></a>4.2 Chromium多进程资源加载</h2><h3 id="4-2-1-多进程"><a href="#4-2-1-多进程" class="headerlink" title="4.2.1 多进程"></a>4.2.1 多进程</h3><p>在带有资源缓存机制的资源加载过程描述中，ResourceHandle类之下的部分，是不同移植对获取资源的不同实现。在Chromium中，获取资源的方式是利用多进程的资源加载架构。下图描述了关于Chromium如何利用多进程架构来完成资源的加载，主要是多个Renderer进程和Browser 进程之间的调用栈涉及的主要类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zRYpIGO153oBacy.png"
                      alt="sqo0VXyFsDg0m6zY__thumbnail.png"
                ></p>
<p>Renderer进程在网页的加载过程中需要获取资源，但是由于安全性（当沙箱模型打开的时候，Renderer进程是没有权限去获取资源的）和效率上（资源共享等问题）的考虑，Renderer进程的资源获取实际上是通过进程间通信将任务交给Browser进程来完成，Browser 进程有权限从网络或者本地获取资源。</p>
<p>在Chromium架构的Renderer进程中，ResourceHandleInternal 类通过IPCResource-LoaderBridge类同Browser进程通信。IPCResourceL oaderBridge类继承自ResourceL oaderBridge类，其作用是负责发起请求的对象和回复结果的解释工作，实际消息的接收和派发交给ResourceDispatcher类来处理。</p>
<p>在Browser进程中，首先由ResourceMessageFilter类来过滤Renderer进程的消息，如果与资源请求相关，则该过滤类转发请求给ResourceDispatcherHostImpl类，随即ResourceDispatcherHostlmpl类创建Browser进程中的ResourceLoader 对象来处理。</p>
<p>ResourceLoader类是Chromium浏览器实际的资源加载类，它负责管理向网络发起的请求、从网络接收过来的认证请求、请求的回复管理等工作。因为这其中每项都有专门的类来负责，但都是由ResourceLoader 类统一管理。从网络或者本地文件读取信息的是URLRequest类，实际上它承担了建立网络连接、发送请求数据和接受回复数据的任务，URLRequest 之后的工作将在“网络栈”章节中来解读。</p>
<h3 id="4-2-2-工作方式和资源共享"><a href="#4-2-2-工作方式和资源共享" class="headerlink" title="4.2.2 工作方式和资源共享"></a>4.2.2 工作方式和资源共享</h3><p>资源请求有同步和异步两种方式。前面说了ResourceLoader类承担了Browser进程中有关资源的总体管理任务，对于同步和异步两种资源请求方式，ResourceLoader类使用SyncResourceHandle类和AsyncResourceHandle类来向Renderer进程发送状态消息，并接收Renderer进程对这些消息的反馈，下图描述了这些类之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/oaZmxBWi7Gp9IN3.png"
                      alt="byBPW6KAwIpeU5mS__thumbnail.png"
                ></p>
<p>图中还有两个ResourceHandle子类，第一个是LayeredResourceHandle类，它同SyncResourceHandle类和AsyncResourceHandle类不一样，自己不直接参与资源的处理，而是将处理转给另一个ResourceHandle对象。LayeredResourceHandle 类没有实际意义，仅是BufferedResourceHandle的父类。该缓冲类用来缓冲网络或者文件传过来的数据，直到数据足够满足需求然后转给设置的另一个ResourceHandle对象。Throttling-ResourceHandle类是在面对很多个资源请求时仅使用一个URLRequest对象来获取资源，这可以有效地减少网络的开销，因为不需要重新建立多个网络连接。</p>
<p>此外，在Chromium中还有很多ResourceHandle的子类，它们的作用各异。</p>
<ol>
<li><strong>RedirectToFileResourceHandler</strong>：继承自LayeredResourceHandle类，在接收到的数据转给另一个ResourceHandler类的同时，转存到文件。</li>
<li><strong>treamResourceHandler</strong>：继承自LayeredResourceHandle 类，在接收到的数据转给另一个ResourceHandler的同时，转存到数据流。</li>
<li><strong>CertificateResourceHandler</strong>：主要处理证书类的资源请求。</li>
</ol>
<p>资源统一交由Browser进程来处理，这使得资源在不同网页间的共享变得很容易。接下来面临一个问题，因为每个Renderer 进程某段时间内可能有多个请求，同时还有多个Renderer进程，Browser进程需要处理大量的资源请求，这就需要一个处理这些请求的调度器，这就是Chromium中的ResourceScheduler.</p>
<h2 id="4-3-网络栈"><a href="#4-3-网络栈" class="headerlink" title="4.3 网络栈"></a>4.3 网络栈</h2><h3 id="4-3-1-WebKit的网络设施"><a href="#4-3-1-WebKit的网络设施" class="headerlink" title="4.3.1 WebKit的网络设施"></a>4.3.1 WebKit的网络设施</h3><p>WebKit的资源加载其实是交由各个移植来实现的，所以WebCore其实并没有什么特别的基础设施，每个移植的网络实现是非常不一样的。</p>
<p>在WebKit的代码结构中，网络部分代码在“WebKit/Source/WebCore/platform/network”中。主要是一些HTTP消息头、MIME消息、状态码等信息的描述和处理，没有实质的网络连接和各种针对网络的优化。</p>
<h3 id="4-3-2-Chromium网络栈"><a href="#4-3-2-Chromium网络栈" class="headerlink" title="4.3.2 Chromium网络栈"></a>4.3.2 Chromium网络栈</h3><p>前面讲到资源加载，描述到URLRequest类的时候戛然而止，这是因为URLRequest类之下的部分是网络栈的内容。</p>
<h4 id="4-3-2-1-网络栈基本组成"><a href="#4-3-2-1-网络栈基本组成" class="headerlink" title="4.3.2.1 网络栈基本组成"></a>4.3.2.1 网络栈基本组成</h4><p>下图是“net”所包括的主要子目录，也是Chromium网络栈的主要模块。这里面除了一些基础的部分，例如HTTP协议、DNS解析等模块，还包含了Chromium为了减少网络时间而引入的新技术，例如SPDY、QUIC等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/nOMpuIyAZlef94V.png"
                      alt="i4uSsMXfcjQTaa2X__thumbnail.png"
                ></p>
<h4 id="4-3-2-2-网络栈结构"><a href="#4-3-2-2-网络栈结构" class="headerlink" title="4.3.2.2 网络栈结构"></a>4.3.2.2 网络栈结构</h4><p>下图描述了从URLRequest类到Socket类之间的调用过程。以HTTP协议为例，图中列出建立TCP的socket连接过程中涉及的类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/G1TS9n3xUDeQcmR.png"
                      alt="icP92vja3jnJnFsb__thumbnail.png"
                ></p>
<p>首先是URLRequest类被上层调用并启动请求的时候，它会根据URL的“scheme”来决定需要创建什么类型的请求。“scheme”也就是URL的协议类型，例如“http://”、“fle://”，也可以是自定义的scheme，例如Android系统的“fle://android asset/”。URLRequest对象创建的是一个URLRequestJob子类的一个对象，例如图中的URLRequestHttpJob类。为了支持自定义的scheme：处理方式，Chromium使用工厂模式。URLRequestJob 类和它的工厂类URLRequestJobFactory 的管理工作都由URLRequestJlobManager类负责。基本的思路是，用户可以在该类中注册多个工厂，当有URLRequest请求时，先由工厂检查它是否需要处理该“scheme”，如果没有，工厂管理类继续交给下一个工厂“类来处理。最后，如果没有任何工厂能够处理，Chromium则交给内置的工厂来检查和处理是否为“http://“、“http:/“或者“fle://”</p>
<p>等，图4-15用来描述这些类的关系。.</p>
<p>其次，当URLRequestHttpJob对象被创建后，该对象首先从Cookie管理器中获取与该URL相关联的信息。之后，它同样借助于HttpTransactionFactory对象创建一个HttpTransaction 对象来表示开启一-个 HTTP连接的事务（当然这里的概念不同于数据库中的事务概念）。通常情况下，HtpTransactionFactory 对象对应的是一个它的子类HtpCache对象。HtpCache类使用本地磁盘缓存机制（稍后会介绍），如果该请求对应的回复已经在磁盘缓存中，那么Chromium无需再建立HttpTransaction来发起连接，而是直接从磁盘中获取即可。如果磁盘中没有该URL的缓存，同时如果目前该URL请求对应的HttpTransaction已经建立，那么只要等待它的回复即可。当这些条件都不满足的时候，Chromium 实际上才会真正创建HttpTransaction对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/hCIzoRZM2B4udwF.png"
                      alt="3x9ruL4MGbG59Khg__thumbnail.png"
                ></p>
<p>再次，HttpNetworkTransaction 类使用HttpNetworkSession 类来管理连接会话。</p>
<p>HttpNetworkSession类通过它的成员HttpStreamFactory 对象来建立TCP Socket连接，之后Chromium创建HttpStream对象。HttpStreamFactory对象将和网络之间的数据读写交给自己新创建的一一个HttpStream子类的对象来处理。</p>
<p>最后是套接字的建立。Chromium中与服务器建立连接的套接字是StreamSocket类，它是一一个抽象类，在POSIX系统和Windows系统上有着分别不同的实现。同时，为了支持SSL机制，StreamSocket类还有-一个子类一SSLSocket。图4-16显示了这些类和它们之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/g3BnOhN1L8UfWqZ.png"
                      alt="Ssn77qEXGwUk9Sqv__thumbnail.png"
                ></p>
<h4 id="4-3-2-3-代理"><a href="#4-3-2-3-代理" class="headerlink" title="4.3.2.3 代理"></a>4.3.2.3 代理</h4><p>当用户设置代理时，上面的网络栈结构是如何组织的呢？用户代理依赖以下类来处理。</p>
<ol>
<li>ProxyService：对于一个URL，HttpStreamFactory 类使用ProxyService类来获取代理信息。ProxyService类首先会检查当前的代理设置是不是最新的，如果不是，它依赖ProxyConfigService来重新获取代理信息。该类不处理实际任务，而是使用ProxyResolver类来做实际的代理工作。</li>
<li>ProxyConfigService：获取代理信息的类，可获取平台上的代理设置，在Linux、Windows.上有不同的实现。</li>
<li>ProxyScriptFetcher：Chromium 支持代理的JavaScript脚本，该类负责从代理的URL中获取该脚本。</li>
<li>ProxyResolver：实际负责代理的解释和执行，通常启用新的线程来处理，因为当前可能会被域名的解析所阻碍。</li>
<li>ProxyResolverV8：ProxyResolver的子类，使用V8引擎来解析和执行脚本。</li>
</ol>
<p>下图不仅描述上面这些类，也描述了Chromium中获取网络代理的过程。图中数字代表获取网络代理的次序，其中的分支3.1和4.1分别表示简单的代理设置和代理脚本设置的处理过程。</p>
<h4 id="4-3-2-4-域名解析（DNS）"><a href="#4-3-2-4-域名解析（DNS）" class="headerlink" title="4.3.2.4 域名解析（DNS）"></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/rLt2XjCBhMSAqKv.png"
                      alt="Fb9e4AescqSYA2fZ__thumbnail.png"
                >4.3.2.4 域名解析（DNS）</h4><p>通常情况下，用户都是使用域名来访问网络资源的，所以在建立TCP连接前需要解析域名。Chromium中使用HostResolverImpl类来解析域名，具体调用的函数是“getaddrinfo（）”，该函数是一个阻塞式的函数，所以Chromium理所当然使用单独的线程来处理它，这是Chromium的原则之一。因此当调试Chromium的进程时，会看到很多线程被创建然后退出。</p>
<p>为了考虑效率，使用HostCache类来保存解析后的域名，最多时会有多达1000个的域名和地址映射关系会被存储起来。看起来DNS的解析很简单，好像也没有什么值得深究的，其实不然，域名解析也可以有优化的空间，因为优化可以有效的减少用户等待的时间。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>03-HTTP报文</title>
    <url>/2021/01/23/note/HTTP/03-HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h1 id="3-1-报文流"><a href="#3-1-报文流" class="headerlink" title="3.1 报文流"></a><strong>3.1 报文流</strong></h1><p><strong>HTTP报文</strong>是在HTTP应用程序之间发送的数据块，这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。</p>
<p>HTTP使用术语<strong>流入</strong>（inbound）和<strong>流出</strong>（outbound）来描述<strong>事务处理</strong>（transaction）的方向。报文流人源端服务器，工作完成之后，会流回用户的Agent代理中。</p>
<p>不管是请求报文还是响应报文，所有报文都会向下游（downstream）流动（参见下图）。所有报文的发送者都在接收者的上游（upstream）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s3.ax1x.com/2021/03/07/6KjBQK.png"
                      alt="图片"
                ></p>
<h1 id="3-2-报文的组成部分"><a href="#3-2-报文的组成部分" class="headerlink" title="3.2 报文的组成部分"></a><strong>3.2 报文的组成部分</strong></h1><p>HTTP报文由三个部分组成：<strong>起始行</strong>（start line）、<strong>首部</strong>（header）、<strong>主体</strong>（body）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/ogVj38LN9yG6nIC.png"
                      alt="P7vBtkoxgAKyyS5X__thumbnail.png"
                ></p>
<p><strong>起始行</strong>：所有的HTTP报文都以一个起始行作为开始。请求报文的起始行（请求行）说明了要做些什么。响应报文的起始行（响应行）说明发生了什么。</p>
<p><strong>首部：</strong>首部字段向请求/响应报文中添加一些附加信息。本质上来说，它们只是一些名/值对的列表。</p>
<p><strong>主体：</strong>是一个可选的数据块。与起始行和首部不同的是，主体中可以包含文本或二进制数据，也可以为空。</p>
<p><strong>注意：</strong>起始行和首部就是由行分隔的ASCII文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符和一个换行符。这个行终止序列可以写做<strong>CRLF</strong>。尽管HTTP规范中说明应该用CRLF来表示行终止，但稳健的应用程序也应该接受单个换行符作为行的终止。有些老的，或不完整的HTTP应用程序并不总是既发送回车符，又发送换行符。</p>
<p>一组HTTP首部总是应该以一个空行（单个CRLF）结束，甚至即使没有首部和实体的主体部分也应如此。但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误地）省略了最后的CRLF。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个CRLF的报文。</p>
<h1 id="3-3-报文的语法"><a href="#3-3-报文的语法" class="headerlink" title="3.3 报文的语法"></a><strong>3.3 报文的语法</strong></h1><p>所有的HTTP报文都可以分为两类：<strong>请求报文</strong>（request message）和<strong>响应报文</strong>（response message）。请求报文会向Web服务器请求一个动作。响应报文会将请求的结果返回给客户端。</p>
<p><strong>请求报文的格式：</strong></p>
<p>&lt;method&gt;   &lt;request-URL&gt;   &lt;version&gt;</p>
<p>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<p><strong>响应报文的格式</strong>（注意，只有起始行的语法有所不同）：</p>
<p>&lt;version&gt;   &lt;status&gt;   &lt;reason-phrase&gt;</p>
<p>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<table>
<thead>
<tr>
<th align="center">方法（method）</th>
<th align="left">客户端希望服务器对资源执行的动作。比如GET、HEAD或POST。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/iURbS7VjBqCysQm.png"
                      alt="JVU6YJ5CStQ6fuwP__original.png"
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求URL（request-URL）</td>
<td align="left">命名了所请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题一一服务器可以假定自已是URL的主机/端口。</td>
</tr>
<tr>
<td align="center">版本（version）</td>
<td align="left">报文所使用的HTTP版本，其格式看起来是这样的：HTTP/&lt;major&gt;.&lt;minor&gt;&lt;br&gt;其中主要版本号（major）和次要版本号（minor）都是整数。</td>
</tr>
<tr>
<td align="center">状态码（status-code）</td>
<td align="left">这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/ME7orix3fHetk9y.png"
                      alt="cBAdbLFKVflDpijz__original.png"
                ></td>
</tr>
<tr>
<td align="center">原因短语（reason-phrase）</td>
<td align="left">是状态码的文本解释，包含行终止序列之前的所有文本。原因短语只对人类有意义，因此比如，尽管响应行HTTP/1.0 200 NOT OK和HTTP/1.0 200 OK中原因短语的含义不同，但都被当作成功指示处理。首部类别有<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/HqwTFOltuPZXsgj.png"
                      alt="ikG9ABzA6A0jtwzf__original.png"
                ></td>
</tr>
<tr>
<td align="center">首部（header）</td>
<td align="left">可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（：），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。</td>
</tr>
<tr>
<td align="center">实体的主体部分（entity-body）</td>
<td align="left">实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时报文只是以一个CRLF结束。</td>
</tr>
</tbody></table>
<h1 id="3-4-方法"><a href="#3-4-方法" class="headerlink" title="3.4 方法"></a>3.4 方法</h1><h2 id="3-4-1-安全方法"><a href="#3-4-1-安全方法" class="headerlink" title="3.4.1 安全方法"></a>3.4.1 安全方法</h2><p>get和head被认为是<strong>安全方法</strong>，使用这个方法的HTTP请求不会产生什么动作，安全方法并不一定什么动作都不执行（这由web开发者决定），安全方法的目的是允许HTTP应用程序开发者通知用户，什么时候会使用某个可能引起某些动作的不安全办法。</p>
<h2 id="3-4-2-GET"><a href="#3-4-2-GET" class="headerlink" title="3.4.2 GET"></a>3.4.2 GET</h2><p>GET是最常用的方法。通常用于请求服务器发送某个资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/wIh17JbefUpj2cx.png"
                      alt="vMYdA5h28E8iGYte.png"
                ></p>
<h2 id="3-4-3-HEAD"><a href="#3-4-3-HEAD" class="headerlink" title="3.4.3 HEAD"></a>3.4.3 HEAD</h2><p>HEAD与GET很类似，但服务器<strong>只返回首部</strong>（服务器开发者必须确保HEAD和GET返回的首部相同），不返回主体部分。这就允许客户端在未获取实际资源下，对资源的首部进行检查。比如：</p>
<pre><code>1. 在不获取资源的情况下了解资源的情况（比如，判断其类型）；
2. 通过查看响应中的状态码，看看某个对象是否存在；
3. 通过查看首部，测试资源是否被修改了。</code></pre>
<p><a href="https://imgtu.com/i/6Kvs10"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s3.ax1x.com/2021/03/07/6Kvs10.png"
                      alt="6Kvs10.png"
                ></a></p>
<h2 id="3-4-4-PUT"><a href="#3-4-4-PUT" class="headerlink" title="3.4.4 PUT"></a>3.4.4 PUT</h2><p>与GET从服务器读取文档相反，PUT方法会向服务器写入文档，让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，如果那个URL已经存在的话，就用这个主体来替代它。</p>
<p>因为PUT允许用户对内容进行修改，所以很多Web服务器都要求在执行PUT之前，用密码登录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/wWQNdqk2Anpe8zT.png"
                      alt="x85Mw4z8E5dy9VE8__original.png"
                ></p>
<h2 id="3-4-5-POST"><a href="#3-4-5-POST" class="headerlink" title="3.4.5 POST"></a>3.4.5 POST</h2><p>POST方法起初是用来向服务器输入数据的。通常用于HTML的表单,表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/9VYrF4E3nqBUyou.png"
                      alt="mA1PogAoYtDt18l2__original.png"
                ></p>
<h2 id="3-4-6-TRACE"><a href="#3-4-6-TRACE" class="headerlink" title="3.4.6 TRACE"></a>3.4.6 TRACE</h2><p>客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p>
<p>TRACE请求会在目的服务器端发起一一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改过。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/YLdEcsn372eZOQx.png"
                      alt="gaypKsmoMOkPfmZx__thumbnail.png"
                ></p>
<p>TRACE方法主要用于诊断：用于验证请求是否如愿穿过了请求/响应链，也可以用来查看代理和其他应用程序对用户请求所产生效果。</p>
<p>缺点在于，它假定中间应用程序对各种不同类型请求的处理是相同的。很多HTTP应用程序会根据方法的不同做出不同的处理。比如，代理可能会将POST请求直接发送给服务器，而将GET请求发送给另一个HTTP应用程序（比如Web缓存）。TRACE并不提供区分这些方法的机制。通常，中间应用程序会自行决定对TRACE请求的处理方式。</p>
<p>TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<h2 id="3-4-7-OPTIONS"><a href="#3-4-7-OPTIONS" class="headerlink" title="3.4.7 OPTIONS"></a>3.4.7 OPTIONS</h2><p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法，不用实际访问资源就能判定访问各种资源。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/LZoh1mYOnzbvjyP.png"
                      alt="pxQXtSaXDHxS2MDN__original.png"
                ></p>
<h2 id="3-4-8-DELETE"><a href="#3-4-8-DELETE" class="headerlink" title="3.4.8 DELETE"></a>3.4.8 DELETE</h2><p>DELETE方法使服务器删除请求URL所指定的资源。但客户端应用程序无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/WArJ5qpBh8MfduN.png"
                      alt="rR3ReKiKi4Jtrp49__original.png"
                ></p>
<h2 id="3-4-9-扩展方法"><a href="#3-4-9-扩展方法" class="headerlink" title="3.4.9 扩展方法"></a>3.4.9 扩展方法</h2><p>HTTP被设计成字段可扩展的，这样新的特性不会使老的软件失效。<strong>扩展方法</strong>指的就是没有在HTTP/1.1规范中定义的方法。服务器会为它所管理的资源实现一些HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。这些方法是WebDAV HTTP扩展包含的所有方法，这些方法有助于通过HTTP将Web内容发布到Web服务器上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/YVcSisOCRAnqfNw.png"
                      alt="mpgIfTZw1n97EtyM__original.png"
                ></p>
<p>不是所有的扩展方法都是在正式规范中定义的。如果你定义了一个扩展方法，很可能大部分HTTP应用程序都无法理解。同样，你的HTTP应用程序也可能会遇到一些其他应用程序在用，但并不理解的扩展方法。</p>
<p>如果能够在不破坏端到端行为的情况下，将带有未知方法的报文传递给下游服务器的话，代理会尝试传递这些报文。否则，它们会以501 Not Implemented（无法实现）状态码进行响应。</p>
<h1 id="3-5-状态码"><a href="#3-5-状态码" class="headerlink" title="3.5 状态码"></a>3.5 状态码</h1><h2 id="3-5-1-100-199——信息性状态码"><a href="#3-5-1-100-199——信息性状态码" class="headerlink" title="3.5.1 100~199——信息性状态码"></a>3.5.1 100~199——信息性状态码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/njNxWLmrZi7p6Ad.png"
                      alt="OBMDQjDvnWkV8qEA__original.png"
                ></p>
<p>100 Continue状态码的目的是对这样的情况进行优化：HTTP客户端应用程序有一个实体的主体部分要发送给服务器，但希望在发送之前查看服务器是否会接受这个实体。</p>
<h2 id="3-5-2-客户端与100-Continue"><a href="#3-5-2-客户端与100-Continue" class="headerlink" title="3.5.2 客户端与100 Continue"></a>3.5.2 客户端与100 Continue</h2><p>如果客户端在向服务器发送一个实体之前，需要发送值为100 Continue的Expect请求首部</p>
<p>客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时，才应该使用100 Continue。有些出错的HTTP应用程序会不合时宜地发送这些代码。</p>
<h2 id="3-5-3-服务端与100-Continue"><a href="#3-5-3-服务端与100-Continue" class="headerlink" title="3.5.3 服务端与100 Continue"></a>3.5.3 服务端与100 Continue</h2><p>如果服务器收到了带有值为100Continue的Expect首部的请求，它会用100Continue响应或错误码来进行响应。</p>
<p>如果服务器在发送100Continue响应之前就收到了部分（或全部）的实体，说明客户端已经决定继续发送数据了，服务器就不需要发送这个状态码了。但服务器读完请求之后，还是应该为请求发送一个最终状态码（它可以跳过100 Continue状态）。</p>
<h2 id="3-5-4-代理与100-Continue"><a href="#3-5-4-代理与100-Continue" class="headerlink" title="3.5.4 代理与100 Continue"></a>3.5.4 代理与100 Continue</h2><p>如果代理从客户端收到了一条带有100 Continue期望的请求。只有在代理明确知道下一跳服务器只能与HTTP/1.1之前的版本兼容下，才以417Expectation Failed错误进行响应。</p>
<h2 id="3-5-5-200-299——成功状态码"><a href="#3-5-5-200-299——成功状态码" class="headerlink" title="3.5.5 200~299——成功状态码"></a>3.5.5 200~299——成功状态码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/Vxfu5ZyME6leHCF.png"
                      alt="QBPeIRliYQsYNLuK__original.png"
                ></p>
<h2 id="3-5-6-300-399——重定向状态码"><a href="#3-5-6-300-399——重定向状态码" class="headerlink" title="3.5.6 300~399——重定向状态码"></a>3.5.6 300~399——重定向状态码</h2><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应。</p>
<p>当客户端发起一个POST请求，并收到302重定向状态码时，它会接受Location首部的重定向URL，并向那个URL发起一个GET请求（而不会像原始请求中那样发起POST请求）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/NRtELYoTXVarSln.png"
                      alt="oGhhDOehHAx00rMn__original.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/YmuybaU6ArJcptg.png"
                      alt="XF0C2S71UASlrXHQ__original.png"
                ></p>
<h2 id="3-5-7-400-499客户端错误状态码"><a href="#3-5-7-400-499客户端错误状态码" class="headerlink" title="3.5.7 400 ~ 499客户端错误状态码"></a>3.5.7 400 ~ 499客户端错误状态码</h2><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/7pnr4jqIVCBSauo.png"
                      alt="SuFepcMWJ5V5SOwN__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/KiPoMw6E8TDVg4J.png"
                      alt="ExnzaZcMsofo4KWN__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/nc4oUDgG3ajEmYP.png"
                      alt="sxIk4IJaPzMS7Ne4__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/EVZ4FvC9MzWcoDj.png"
                      alt="rm9ffFKOAEKrqtAt__original.png"
                ></p>
<h2 id="3-5-8-500-599服务器错误状态码"><a href="#3-5-8-500-599服务器错误状态码" class="headerlink" title="3.5.8 500 ~ 599服务器错误状态码"></a>3.5.8 500 ~ 599服务器错误状态码</h2><p>客户端碰上了服务器的缺陷，或服务器上的子元素，比如某个网关资源出错。代理与服务器进行交流时，经常会出现问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/7psD1IPEoObnWMR.png"
                      alt="DUHKLkEagQ3ZDgjR__original.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/IlsfA8QPiTBHwu2.png"
                      alt="VJNKGRtGQtYaylvE__thumbnail.png"
                ></p>
<h1 id="3-6-首部"><a href="#3-6-首部" class="headerlink" title="3.6 首部"></a>3.6 首部</h1><h2 id="3-6-1-通用首部"><a href="#3-6-1-通用首部" class="headerlink" title="3.6.1 通用首部"></a>3.6.1 通用首部</h2><p>这些是客户端和服务器都可以使用的通用首部。</p>
<h3 id="3-6-1-1-通用的信息性首部"><a href="#3-6-1-1-通用的信息性首部" class="headerlink" title="3.6.1.1 通用的信息性首部"></a>3.6.1.1 通用的信息性首部</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/v4Q5j9HXtCdc1zN.png"
                      alt="V734hBj5Y6U1RI57__thumbnail.png"
                ></p>
<h3 id="3-6-1-2-通用缓存首部"><a href="#3-6-1-2-通用缓存首部" class="headerlink" title="3.6.1.2 通用缓存首部"></a>3.6.1.2 通用缓存首部</h3><p>通用的缓存首部说明了如何或什么时候进行缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/VLXOKi8ZhvFI1nw.png"
                      alt="T71nzrW361shYFJ5__thumbnail.png"
                ></p>
<h2 id="3-6-2-请求首部"><a href="#3-6-2-请求首部" class="headerlink" title="3.6.2 请求首部"></a>3.6.2 请求首部</h2><h3 id="3-6-2-1-请求的信息性首部"><a href="#3-6-2-1-请求的信息性首部" class="headerlink" title="3.6.2.1 请求的信息性首部"></a>3.6.2.1 请求的信息性首部</h3><p>请求首部是请求报文特有的。它们为服务器提供了一些额外信息，服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/lsM5Kfg48YoP9qi.png"
                      alt="KPMKowkYZnhblPBY__original.png"
                ></p>
<h3 id="3-6-2-2-Accept首部"><a href="#3-6-2-2-Accept首部" class="headerlink" title="3.6.2.2 Accept首部"></a>3.6.2.2 Accept首部</h3><p>Accept首部为客户端告知服务器，它们想要什么，可以使用什么以及最重要的，它们不想要什么。服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/NL9IDkWtnG8XKms.png"
                      alt="QudS2T1wJAKUiu3E__thumbnail.png"
                ></p>
<h3 id="3-6-2-3-条件请求首部"><a href="#3-6-2-3-条件请求首部" class="headerlink" title="3.6.2.3 条件请求首部"></a>3.6.2.3 条件请求首部</h3><p>客户端希望为请求加上某些限制。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/TiKQAZL12P3deFB.png"
                      alt="kARldOx2NxiRp3Yl__thumbnail.png"
                ></p>
<h3 id="3-6-2-4-安全请求首部"><a href="#3-6-2-4-安全请求首部" class="headerlink" title="3.6.2.4 安全请求首部"></a>3.6.2.4 安全请求首部</h3><p>HTTP本身支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务更安全。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/zHDcERg2XVL57MQ.png"
                      alt="qhEP6oHR0Zg4fdkz__thumbnail.png"
                ></p>
<h3 id="3-6-2-5-代理请求首部"><a href="#3-6-2-5-代理请求首部" class="headerlink" title="3.6.2.5 代理请求首部"></a>3.6.2.5 代理请求首部</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/BsS43JHeQt1WXTP.png"
                      alt="lo4882tb0k3K2GqB__thumbnail.png"
                ></p>
<h2 id="3-6-3-响应首部"><a href="#3-6-3-响应首部" class="headerlink" title="3.6.3 响应首部"></a>3.6.3 响应首部</h2><p>响应报文有自己的首部集，以便为客户端提供信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/anlcrxXGjLEovim.png"
                      alt="FJfB5VYZPrChGkOf__thumbnail.png"
                ></p>
<h3 id="3-6-3-1-协商首部"><a href="#3-6-3-1-协商首部" class="headerlink" title="3.6.3.1 协商首部"></a>3.6.3.1 协商首部</h3><p>如果资源有多种表示方法，可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/kYGZnurlPKtR4Ne.png"
                      alt="dPebT46CLDYXaQdJ__thumbnail.png"
                ></p>
<h3 id="3-6-3-2-安全响应首部"><a href="#3-6-3-2-安全响应首部" class="headerlink" title="3.6.3.2 安全响应首部"></a>3.6.3.2 安全响应首部</h3><p>安全请求首部就是HTTP的质询/响应认证机制的响应侧。这里指的是质询首部。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/sKVmAupEkH7PDdF.png"
                      alt="DBM3vYt6qfYjHjQs__thumbnail.png"
                ></p>
<h2 id="3-6-4-实体首部"><a href="#3-6-4-实体首部" class="headerlink" title="3.6.4 实体首部"></a>3.6.4 实体首部</h2><h3 id="3-6-4-1-实体的信息性首部"><a href="#3-6-4-1-实体的信息性首部" class="headerlink" title="3.6.4.1 实体的信息性首部"></a>3.6.4.1 实体的信息性首部</h3><p>实体首部指的是实体主体部分的首部，可以告知报文的接收者它在对什么进行处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/YjxnPD95oaKuGwA.png"
                      alt="aAXJrr32FXIPhq3H__thumbnail.png"
                ></p>
<h3 id="3-6-4-2-内容首部"><a href="#3-6-4-2-内容首部" class="headerlink" title="3.6.4.2 内容首部"></a>3.6.4.2 内容首部</h3><p>内容首部提供与实体内容有关的特定信息，说明了其类型、尺寸以及处理所需的有用信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/SZKRAdHu6BzwFil.png"
                      alt="bXPOXXEC81SN4OHC__thumbnail.png"
                ></p>
<h3 id="3-6-4-3-实体缓存首部"><a href="#3-6-4-3-实体缓存首部" class="headerlink" title="3.6.4.3 实体缓存首部"></a>3.6.4.3 实体缓存首部</h3><p>实体的缓存首部提供了与被缓存实体有关的信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/HaWqdwCSjFBxfGM.png"
                      alt="8xWGuWX0sDXFv2m4__thumbnail.png"
                ></p>
<h2 id="3-6-5-扩展首部"><a href="#3-6-5-扩展首部" class="headerlink" title="3.6.5 扩展首部"></a>3.6.5 扩展首部</h2><p>扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP规范中去。即使不知道这些扩展首部的含义，HTTP程序也要接受它们并对其进行转发。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>02-URL与资源</title>
    <url>/2021/01/22/note/HTTP/02-URL%E4%B8%8E%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="2-1-URL语法"><a href="#2-1-URL语法" class="headerlink" title="2.1 URL语法"></a><strong>2.1 URL语法</strong></h2><p><strong>URI</strong>：统一资源标识符（Uniform Resource Identifier）,它包括了URL（统一资源定位符），它是通过描述资源位置来标识资源，以及URN（统一资源名），它则是通过名字来识别资源。</p>
<table>
    <tr>
    <th>组件</th>
    <th>描述</th>
    <th>默认值</th>
  </tr>
  <tr>
    <td>方案</td>
    <td>用什么协议获取资源，大小写无关，比如http</td>
    <td>无</td>
  </tr>
  <tr>
    <td>用户</td>
    <td>某些方案下访问资源时需要的用户名，比如FTP</td>
    <td>匿名</td>
  </tr>
  <tr>
    <td>密码</td>
    <td>用户名后面可能包含的密码，由冒号（：）分隔</td>
    <td>E-mail地址</td>
  </tr>
  <tr>
    <td>主机</td>
    <td>服务器位置，也就是资源在哪里，可以是域名（会被解析）或IP地址</td>
    <td>无</td>
  </tr>
  <tr>
    <td>端口</td>
    <td>资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80）</td>
    <td>方案特有</td>
  </tr>
  <tr>
    <td>路径</td>
    <td>资源路径，服务器上的本地资源名，由斜杠（/）分隔</td>
    <td>无</td>
  </tr>
  <tr>
    <td>参数</td>
    <td>某些方案会用这个组件来指定输入参数。参数为名/值对。可以包含多个参数字段，它们相互之间以及与路径其余部分用分号（；）分隔</td>
    <td>无</td>
  </tr>
  <tr>
    <td>查询</td>
    <td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用“？”将其与其余部分分隔开来。按照常规，查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&”分隔：</td>
    <td>无</td>
  </tr>
  <tr>
    <td>片段</td>
    <td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td>
    <td>无</td>
  </tr>
</table>

<h2 id="2-2-URL快捷方式"><a href="#2-2-URL快捷方式" class="headerlink" title="2.2 URL快捷方式"></a><strong>2.2 URL快捷方式</strong></h2><p><strong>URL</strong>有两种方式，<strong>绝对URL</strong>（包含访问资源所需的全部信息）以及<strong>相对URL</strong>（不完整，需要对基础URL进行解析）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/7wAHV2voSXks6Mg.png"
                      alt="nVR0IK7EBcmYWYVR__thumbnail.png"
                ></p>
<p>基础URL是作为相对URL的参考点使用的。来自以下几个地方：</p>
<p><strong>1、在资源中显示提供</strong></p>
<p>有些资源会显式地指定基础URL。比如，HTML文档中可能会包含一个定义了基础URL的HTML标记&#60;BASE&#62;，通过它来转换那个HTML文档中的所有相对URL。</p>
<p><strong>2、封装资源的基础URL</strong></p>
<p>如果在一个没有显式指定基础URL的资源中发现了一个相对URL，可以将它所属资源的URL作为基础。</p>
<p><strong>3、没有基础URL</strong></p>
<p>在某些情况下，没有基础URL，通常意味着你有一个相对URL；但有可能只是一个不完整或损坏了的URL。</p>
<p>要把相对URL转换成绝对URL，首先将他们划分成组件段，这一步称为<strong>分解URL，</strong>接下来的过程如下，<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/1oSkgrTnAKeCQMO.png"
                      alt="V4KlexQcZcfQ12Rf__thumbnail.png"
                ></p>
<p><strong>自动扩展URL：</strong>用户不需要输入完整的URL，浏览器自动扩展。有两种方式：</p>
<p>1、<strong>主机名扩展</strong></p>
<p>在主机名扩展中，只要有些小提示，浏览器通常就可以在没有帮助的情况下，将你输入的主机名扩展为完整的主机名。但是，这些主机名扩展技巧可能会为其他一些HTTP应用程序带来问题，比如代理。</p>
<p><strong>2、历史扩展</strong></p>
<p>浏览器用来节省用户输入URL时间的另一种技巧是，将以前用户访问过的URL历史存储起来。当你输入URL时，它们就可以将你输入的URL与历史记录中URL的前缀进行匹配，并提供–些完整的选项供你选择。注意，与代理共同使用时，URL自动扩展的行为可能会有所不同。6.5.6节将对此进行进-一步讨论。</p>
<h2 id="2-3-URL字符"><a href="#2-3-URL字符" class="headerlink" title="2.3 URL字符"></a><strong>2.3 URL字符</strong></h2><p>URL的特性是<strong>可移植的（portable）</strong>、<strong>可读的</strong>、<strong>完整的</strong>，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符值或数据进行编码，这样就实现了可移植性和完整性。这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数。示例如下,</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/XB2YNyRzlgj6AUP.png"
                      alt="TbL6jXX4SEtdJlWZ__thumbnail.png"
                ></p>
<p><strong>字符限制</strong>，在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCI可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用。</p>
<p>URL的每个组件都会有自己的安全和不安全字符（与方案有关），因此只有从用户那里接收URL的应用程序才能够判断需要对哪些字符进行编码。这个URL就是可在各应用程序之间共享的规范形式；也就无需操心其他应用程序会被字符的任何特殊含义所迷惑了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/L6M7WIq8ADEe4Bh.png"
                      alt="bnXzZF9va3GSkGou__thumbnail.png"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Web机器人</title>
    <url>/2021/03/02/note/HTTP/09-Web%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<p>Web机器人是能够在无需人类干预的情况下自动进行一系列Web事务处理的软件程序。</p>
<h2 id="9-1-爬虫及爬行方式"><a href="#9-1-爬虫及爬行方式" class="headerlink" title="9.1 爬虫及爬行方式"></a>9.1 爬虫及爬行方式</h2><p>Web爬虫会递归地对各种信息性Web站点进行遍历，获取第一个Web页面，然后获取那个页面指向的所有Web页面，然后是那些页面指向的所有Web页面，依此类推。</p>
<h3 id="9-1-1-从哪儿开始：根集"><a href="#9-1-1-从哪儿开始：根集" class="headerlink" title="9.1.1 从哪儿开始：根集"></a>9.1.1 从哪儿开始：根集</h3><p>爬虫开始访问的URL初始集合被称作根集（root set），挑选根集时，应该从足够多不同的站点中选择URL，这样才能爬遍尽可能多的链接,从而获取大部分页面。</p>
<p>通常，一个好的根集会包括一些大的流行Web站点、一个新创建页面的列表和一个不经常被链接的无名页面列表。很多因特网搜索引擎使用的那些爬虫，都提供了向根集中提交新页面或无名页面的方式。这个根集会随时间推移而增长，是所有新爬虫的种子列表。</p>
<h3 id="9-1-2-链接的提取以及相对链接的标准化"><a href="#9-1-2-链接的提取以及相对链接的标准化" class="headerlink" title="9.1.2 链接的提取以及相对链接的标准化"></a>9.1.2 链接的提取以及相对链接的标准化</h3><p>爬虫在Web上移动时，会不停地对HTML页面进行解析。它要对所解析的每个页面上的URL链接进行分析，并将这些链接添加到需要爬行的页面列表中去。爬虫要将这些链接提取出来，并将相对URL转换为绝对形式。</p>
<h3 id="9-1-3-避免环路的出现及原因"><a href="#9-1-3-避免环路的出现及原因" class="headerlink" title="9.1.3 避免环路的出现及原因"></a>9.1.3 避免环路的出现及原因</h3><p>机器人在Web上爬行时，要特别小心不要陷入循环，或环路（cycle）之中，所以机器人必须知道它们到过何处，以避免环路的出现。</p>
<p>至少出于下列三个原因：</p>
<ol>
<li>不停地获取相同的页面上，消耗掉网络带宽。</li>
<li>爬虫不断地获取相同的页面时，可能击垮另一端的Web服务器。</li>
<li>爬虫应用程序会被重复的内容所充斥。<h3 id="9-1-4-URL管理的相关技术"><a href="#9-1-4-URL管理的相关技术" class="headerlink" title="9.1.4 URL管理的相关技术"></a>9.1.4 URL管理的相关技术</h3></li>
</ol>
<p>由于URL的数量巨大，所以使用复杂的数据结构以便快速判定哪些URL是曾经访问过的。以下列出了大规模Web爬虫对其访问过的地址进行管理时使用的一些有用的技术。</p>
<ol>
<li><strong>树和散列表</strong></li>
</ol>
<p>用搜索树或散列表来记录已访问的URL。这些是加速URL查找的软件数据结构。</p>
<ol start="2">
<li><strong>有损的存在位图</strong></li>
</ol>
<p>为了减小空间，比如使用存在位数组。用一个散列函数将每个URL都转换成一个定长的数字，这个数字在数组中有个相关的“存在位”。爬行过一个URL时，就将相应的“存在位”置位。</p>
<ol start="3">
<li><strong>检查点</strong></li>
</ol>
<p>一定要将已访问URL列表保存到硬盘上，以防机器人程序崩溃。</p>
<ol start="4">
<li><strong>分类</strong></li>
</ol>
<p>为每个机器人分配一个特定的URL“片”，机器人个体之间可能需要相互通信，来回传送URL，以覆盖出故障的对等实体的爬行范围，或协调其工作。</p>
<h3 id="9-1-5-别名与机器人环路及解决方案"><a href="#9-1-5-别名与机器人环路及解决方案" class="headerlink" title="9.1.5 别名与机器人环路及解决方案"></a>9.1.5 别名与机器人环路及解决方案</h3><p>如果两个URL看起来不一样，但实际指向的是同一资源，就称这两个URL互为“别名”。由于URL“别名”的存在，即使使用正确的数据结构，有时也很难分辨出是否访问过。</p>
<p>表9-1列出了不同URL指向同一资源的几种简单方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/SqrtPoMVR6lBGa9.png"
                      alt="image.png"
                ></p>
<p>通过将URL“规范化”为标准格式来消除上面那些显而易见的别名。机器人首先可先通过下列步骤将每个URL都转化为规范化的格式。</p>
<p>（1）如果没有指定端口的话，就向主机名中舔加”：80”.</p>
<p>（2）将所有转义符%xx都转换成等价字符。</p>
<p>（3）删除#标签。</p>
<p>机器人需要知道Web服务器是否是大小写无关的才能避免表9-1d中的别名问题。</p>
<p>机器人需要知道Web服务器上这个目录下的索引页面配置才能知道表9-1e中的情况是否是别名。</p>
<p>即使机器人知道表9-1f中的主机名和IP地址都指向同一台计算机，它也还要知道Web服务器是否配置为进行虚拟主机操作，才能知道这个URL是不是别名。</p>
<h3 id="9-1-6-文件系统连接环路"><a href="#9-1-6-文件系统连接环路" class="headerlink" title="9.1.6 文件系统连接环路"></a>9.1.6 文件系统连接环路</h3><p>文件系统中的符号连接会造成特定的潜在环路。在图9-3a中，subdir是个普通的目录。在图9-3b中，subdir是个指回到”/”的符号连接。在这两个图中，都假设文件/index.html中包含了一个指向文件subdir/index.html的超链。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/l8ZcPbUIfi3pEnA.png"
                      alt="image _1_.png"
                ></p>
<h3 id="9-1-7-动态虚拟Web空间"><a href="#9-1-7-动态虚拟Web空间" class="headerlink" title="9.1.7 动态虚拟Web空间"></a>9.1.7 动态虚拟Web空间</h3><p>应用程序在传输中构造出包含了到同一服务器上虚构URL链接的HTML，请求这些虚构的URL时，服务器就会捏造出一个带有新的虚构URL的新HTML页面来。</p>
<h3 id="9-1-8-避免循环和重复"><a href="#9-1-8-避免循环和重复" class="headerlink" title="9.1.8 避免循环和重复"></a>9.1.8 避免循环和重复</h3><ol>
<li><strong>规范化URL</strong></li>
</ol>
<p>将URL转换为标准形式以避免语法上的别名</p>
<ol start="2">
<li><strong>广度优先的爬行</strong></li>
</ol>
<p>以广度优先的方式来调度URL去访问Web站点，就可以将环路的影响最小化。</p>
<ol start="3">
<li><strong>节流</strong></li>
</ol>
<p>限制一段时间内机器人可以从一个web站点获取的页面数量，也可以限制重复的页面总数和对服务器的访问总数。</p>
<ol start="4">
<li><strong>限制URL的大小</strong></li>
</ol>
<p>机器人可能会拒绝爬行超出特定长度（通常是1KB）的URL，如果环路使URL的长度增加，长度限制就会最终终止这个环路。</p>
<ol start="5">
<li><strong>URL/站点黑名单</strong></li>
</ol>
<p>维护一个与机器人环路和陷阱相对应的已知站点及URL列表，这就要求有人工进行干预。</p>
<ol start="6">
<li><strong>模式检测</strong></li>
</ol>
<p>文件系统的符号连接和类似的错误配置所造成的环路会遵循某种模式，比如，URL会随着组件的复制逐渐增加。有些机器人会将具有重复组件的URL当作潜在的环路。</p>
<ol start="7">
<li><strong>内容指纹</strong></li>
</ol>
<p>获取页面内容中的字节，并计算出一个校验和，这是页面内容的压缩表示形式。必须要求两个不同页面拥有相同校验和的几率非常低。如MD5这样的报文摘要函数。</p>
<p>有些Web服务器会在传输过程中对页面进行动态的修改（比如访问计数等），所以有时机器人会在校验和的计算中忽略Web页面内容中的某些部分，但仍可能会阻碍重复检测。</p>
<ol start="8">
<li><strong>人工监视</strong></li>
</ol>
<p>诊断和日志功能，能很方便地监视机器人的进展。</p>
<h2 id="9-2-机器人的HTTP"><a href="#9-2-机器人的HTTP" class="headerlink" title="9.2 机器人的HTTP"></a>9.2 机器人的HTTP</h2><h3 id="9-2-1-识别请求首部"><a href="#9-2-1-识别请求首部" class="headerlink" title="9.2.1 识别请求首部"></a>9.2.1 识别请求首部</h3><p>机器人倾向于只支持最小的HTTP集，但鼓励机器人实现者们使用包括如下内容。</p>
<ol>
<li><strong>User-Agent</strong>，将发起请求的机器人名字告知服务器。</li>
<li><strong>From，</strong>提供机器人的用户/管理者的E-mail地址。</li>
<li><strong>Accept</strong>，告知服务器可以发送哪些媒体类型，有助于机器人能选择性接收（文本、图片等）</li>
<li><strong>Referer，</strong>提供包含了当前请求URL的文档的URL，有些站点管理者会记录机器人是如何找到指向其站点内容的链接。<h3 id="9-2-2-虚拟主机"><a href="#9-2-2-虚拟主机" class="headerlink" title="9.2.2 虚拟主机"></a>9.2.2 虚拟主机</h3></li>
</ol>
<p>在默认情况下，大多数服务器都被配置为提供一个特定的站点。随着虚拟主机的流行，不包含Host首部的话，爬虫向提供两个站点的服务器发起请求时，可能会使机器人将错误的内容与一个特定的URL关联起来。</p>
<h3 id="9-2-3-条件请求"><a href="#9-2-3-条件请求" class="headerlink" title="9.2.3 条件请求"></a>9.2.3 条件请求</h3><p>尽量减少机器人所要获取内容的数量，所以只在内容发生变化时才重新获取。通过对时间戳或实体标签进行比较。这与HTTP缓存查看已获取资源的本地副本是否有效的方法非常相似。</p>
<h3 id="9-2-4-对响应的处理"><a href="#9-2-4-对响应的处理" class="headerlink" title="9.2.4 对响应的处理"></a>9.2.4 对响应的处理</h3><p>使用了某些HTTP特性（比如条件请求）的机器人，以及那些想要更好地探索服务器，并与服务器进行交互的机器人则要能够对各种不同类型的HTTP响应进行处理。</p>
<ol>
<li>状态码</li>
</ol>
<p>机器人至少应该能够处理一些常见的，以及预期的状态码。它们还应该能够根据响应的一般类别对它并不十分理解的状态码进行处理。</p>
<p>2、实体</p>
<p>除了HTTP首部所嵌的信息之外，机器人也会在实体中查信息。有些服务器会在发送HTML页面之前先对其内容进行解析，并将元标签http-equiv指令作为首部包含进去。标签http-equiv为内容编写者提供了一种覆盖这些首部的方式。</p>
<h3 id="9-2-5-User-Agent导向"><a href="#9-2-5-User-Agent导向" class="headerlink" title="9.2.5 User-Agent导向"></a>9.2.5 User-Agent导向</h3><p>站点管理者应该设计一个处理机器人请求的策略。比如，为所有其他特性不太丰富的浏览器和机器人开发一些页面，而不是将其内容限定在特定浏览器所支持的范围。</p>
<h2 id="9-3-行为不当的机器人"><a href="#9-3-行为不当的机器人" class="headerlink" title="9.3 行为不当的机器人"></a>9.3 行为不当的机器人</h2><ol>
<li><strong>失控机器人</strong></li>
</ol>
<p>机器人发起HTTP请求的速度快，如果机器人存在编程逻辑错误，或陷入了环路，可能会使服务器过载，并拒绝为任何其他人提供服务。</p>
<ol start="2">
<li><strong>失效的URL</strong></li>
</ol>
<p>有些机器人会去访问URL列表，这些列表可能有大量不存在的URL发起请求。</p>
<ol start="3">
<li><strong>很长的错误URL</strong></li>
</ol>
<p>由于环路和编程错误的存在，机器人可能会向Web站点请求一些很大的、无意义的URL，降低Web服务器的性能，使Web服务器的访问日志杂乱不堪。</p>
<ol start="3">
<li><strong>爱打听的机器人</strong></li>
</ol>
<p>有些机器人可能会得到一些指向私有数据的URL，敏感的数据站点的实现者可能不希望通过因特网能够访问到这些数据。</p>
<ol start="4">
<li><strong>动态网关访问</strong></li>
</ol>
<p>机器人并不总是知道它们访问的是什么内容。机器人可能会获取一个内容来自网关应用程序的URL.在这种情况下，获取的数据可能会有特殊的目的，计算的开销可能很高。很多Web站点管理员并不喜欢那些去请求网关文档的幼稚机器人。</p>
<h2 id="9-4-拒绝机器人访问"><a href="#9-4-拒绝机器人访问" class="headerlink" title="9.4 拒绝机器人访问"></a>9.4 拒绝机器人访问</h2><p>“拒绝机器人访问标准”，有Web服务器都可以在服务器的文档根目录中提供一个可选的、名为robots.txt的文件，这个文件包含说明了机器人可以访问服务器的哪些部分。如果机器人遵循这个自愿约束标准，它会在访问那个站点的所有其他资源之前，从Web站点请求robots.txt文件。</p>
<h2 id="9-5-搜索引擎"><a href="#9-5-搜索引擎" class="headerlink" title="9.5 搜索引擎"></a>9.5 搜索引擎</h2><h3 id="9-5-1-现代搜索引擎结构"><a href="#9-5-1-现代搜索引擎结构" class="headerlink" title="9.5.1 现代搜索引擎结构"></a>9.5.1 现代搜索引擎结构</h3><p>现在的搜索引擎都构建了一些名为“全文索引”的复杂本地数据库，这些索引就像Web上所有文档的卡片目录一样。搜索引擎爬虫会搜集Web页面，并将其添加到全文索引中去。同时，搜索引擎用户会通过Google这样的Web搜索网关对全文索引进行查询。全文索引充其量也就是Web的一个快照。现代搜索引擎的高层结构如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/hOn2rbS9uoQZtAi.png"
                      alt="image _2_.png"
                ></p>
<h3 id="9-5-2-发布查询请求"><a href="#9-5-2-发布查询请求" class="headerlink" title="9.5.2 发布查询请求"></a>9.5.2 发布查询请求</h3><p>网关程序对搜索请求进行解析，并将查询转换成搜索全文索引所需的表达式。</p>
<h3 id="9-6-3-对结果进行排序，并提供查询结果"><a href="#9-6-3-对结果进行排序，并提供查询结果" class="headerlink" title="9.6.3 对结果进行排序，并提供查询结果"></a>9.6.3 对结果进行排序，并提供查询结果</h3><p>一旦搜索引擎通过其索引得到了查询结果，网关应用程序会获取结果，并将其拼成结果页面提供给终端用户，并尝试着对结果进行排名。相关性排名（relevancy ranking）是对一系列搜索结果的评分和排序处理。</p>
<p>为了更好地辅助这一进程，在爬行Web的过程中都会进行数据统计。比如，对指向指定页面的链接进行计数有助于判断其流行程度，还可以用此信息来衡量提供结果的顺序。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>08-集成点：网关、隧道及中继</title>
    <url>/2021/01/23/note/HTTP/08-%E9%9B%86%E6%88%90%E7%82%B9%EF%BC%9A%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93%E5%8F%8A%E4%B8%AD%E7%BB%A7/</url>
    <content><![CDATA[<h2 id="8-1-网关"><a href="#8-1-网关" class="headerlink" title="8.1 网关"></a>8.1 网关</h2><p>HTTP扩展和接口的发展是由用户需求驱动的。单个应用程序无法处理复杂资源的需求。网关（gateway）抽象出一种能够到达资源的方法，网关是资源和应用程序之间的粘合剂。应用程序可以（通过HTTP或其他已定义的接口）请求网关来处理某条请求，网关可以提供响应。</p>
<p>常见网关类型：服务器协议转换器、服务器端安全网关、客户端安全网关、应用程序服务器。</p>
<h2 id="8-2-协议网关"><a href="#8-2-协议网关" class="headerlink" title="8.2 协议网关"></a>8.2 协议网关</h2><p><strong>客户端和服务器端网关</strong>：Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。用一个斜杠来分隔客户端和服务器端协议，并以此对网关进行描述：&lt;客户端协议&gt;/&lt;服务器端协议&gt;</p>
<p>将HTTP流量导向网关时所使用的方式与将流量导向代理的方式相同。最常见的方式是，显式地配置浏览器使用网关，对流量进行透明的拦截，或者将网关配置为替代者（反向代理）。</p>
<h3 id="8-2-1-HTTP-：服务器端Web网关"><a href="#8-2-1-HTTP-：服务器端Web网关" class="headerlink" title="8.2.1 HTTP/*：服务器端Web网关"></a>8.2.1 HTTP/*：服务器端Web网关</h3><p>请求流入原始服务器时，服务器端Web网关会将客户端HTTP请求转换为其他协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/dR1Lzwym7V2TJQj.png"
                      alt="h5rMSRFnKAI0fo2a.png"
                ></p>
<h3 id="8-2-2-HTTP-HTTPS：服务器端安全网关"><a href="#8-2-2-HTTP-HTTPS：服务器端安全网关" class="headerlink" title="8.2.2 HTTP/HTTPS：服务器端安全网关"></a>8.2.2 HTTP/HTTPS：服务器端安全网关</h3><p>可以通过网关对所有的输入Web请求加密，以提供额外的隐私和安全性保护。客户端可以用普通的HTTP浏览Web内容，但网关会自动加密用户的对话。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/7xU9GV2eOCZDTS8.png"
                      alt="XsHGngySl0b7vnU1__thumbnail.png"
                ></p>
<h3 id="8-2-3-HTTPS-HTTP客户端安全加速器网关"><a href="#8-2-3-HTTPS-HTTP客户端安全加速器网关" class="headerlink" title="8.2.3 HTTPS/HTTP客户端安全加速器网关"></a>8.2.3 HTTPS/HTTP客户端安全加速器网关</h3><p>HTTPS/HTTP网关位于Web服务器之前，通常作为不可见的拦截网关或反向代理使用。它们接收安全的HTTPS流量，对安全流量进行解密，并向Web服务器发送普通的HTTP请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/eJQEum4ya71WjHX.png"
                      alt="wt2ibTUjzYWa44Kf__thumbnail.png"
                ></p>
<h2 id="8-3-资源网关"><a href="#8-3-资源网关" class="headerlink" title="8.3 资源网关"></a>8.3 资源网关</h2><p>最常见的网关是<strong>应用程序服务器</strong>，它会将目标服务器与网关结合在一个服务器中实现，它是服务器端网关，与服务器端的应用程序相连，并与客户端通过HTTP进行通信。</p>
<p>客户端通过HTTP连接到应用程序服务器，应用程序服务器将请求通过网关<strong>应用程序编程接口</strong>（Application Programming Interface，API）发送给运行在服务器上的应用程序，然后它向服务器返回响应或响应数据，服务器将其转发给客户端。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/c7Zw3JOpstbk8Hx.png"
                      alt="SW60nADbd4fHQVhN__thumbnail.png"
                ></p>
<h3 id="8-3-1-CGI"><a href="#8-3-1-CGI" class="headerlink" title="8.3.1 CGI"></a>8.3.1 CGI</h3><p>第一个流行的应用程序网关API就是<strong>通用网关接口</strong>（Common Gateway Interface，CGI）。CGI是一个标准接口集，Web服务器可以用它来装载程序以响应对特定URL的HTTP请求，并收集程序的输出数据，将其放在HTTP响应中回送。</p>
<p>CGI的处理对用户来说是不可见的，但可见的是URL中出现字符cgi和可能出现的“？”。</p>
<p>CGI广泛用于动态HTML、信用卡处理、数据库查询等。CGI应用程序是独立于服务器的，所以几乎可以用任意语言来实现。它能很好地保护服务器，防止糟糕的扩展对服务器造成破坏。</p>
<p>但是这种分离会造成性能的耗费。为每条CGI请求引发一个新进程的开销很高，会限制使用CGI的服务器的性能，并且会加重服务端机器资源的负担。</p>
<p>一种新型CGI（快速CGI）解决了这个问题。这个接口模拟了CGI，但它是作为持久守护进程运行的，消除了为每个请求建立或拆除新进程所带来的性能损耗。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/XAQ51W2SCxuTVJl.png"
                      alt="lMjXhzVkWBBSUTH4__original.png"
                ></p>
<h3 id="8-3-2-服务器扩展API"><a href="#8-3-2-服务器扩展API" class="headerlink" title="8.3.2 服务器扩展API"></a>8.3.2 服务器扩展API</h3><p>多数服务器都会为开发者提供一个或多个扩展API，这些扩展通常都会绑定在服务器自身的结构上，为Web开发者提供了强大的接口，以便将自己的模块与HTTP服务器直接相连，它允许程序员将自己的代码嫁接到服务器上，或者用自己的代码将服务器的一个组件完整地替换出来。</p>
<h2 id="8-4-应用程序接口和Web服务"><a href="#8-4-应用程序接口和Web服务" class="headerlink" title="8.4 应用程序接口和Web服务"></a>8.4 应用程序接口和Web服务</h2><p>HTTP可以作为连接应用程序的基础软件来使用，在将应用程序连接起来的过程中，通过web服务标准解决两个应用程序之间进行协议接口的协商，以便应用程序可以进行数据的交换。</p>
<p>Web服务是构建在标准的Web技术（比如HTTP）之上的。Web服务可以用XML通过SOAP来交换信息。XML提供了一种创建数据对象的定制信息，并对其进行解释的方法<strong>SOAP</strong>（Simple Object Access Protocol，简单对象访问协议）是向HTTP报文中添加XML信息的标准方式。</p>
<h2 id="8-5-隧道"><a href="#8-5-隧道" class="headerlink" title="8.5 隧道"></a>8.5 隧道</h2><p>通过<strong>Web 隧道</strong>（Web tunnel）可以通过HTTP应用程序访问使用非HTTP协议的应用程序。使用Web隧道最常见的原因就是要在HTTP连接中嵌入非HTTP流量，这样这类流量就可以穿过只允许Web流量通过的防火墙了。</p>
<h3 id="8-5-1-用CONNECT建立HTTP隧道"><a href="#8-5-1-用CONNECT建立HTTP隧道" class="headerlink" title="8.5.1 用CONNECT建立HTTP隧道"></a>8.5.1 用CONNECT建立HTTP隧道</h3><p>Web隧道是用HTTP的CONNECT方法建立起来的。CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/a9AcYRv3lokKyni.png"
                      alt="eW9jkF1kxuU5siZD__thumbnail.png"
                ></p>
<ol>
<li><strong>CONNECT请求</strong></li>
</ol>
<p>除了起始行之外，CONNECT的语法与其他HTTP方法类似。一个后面跟着冒号和端口号的主机名取代了请求URI。主机和端口都必须指定。</p>
<ol start="2">
<li><strong>CONNECT响应</strong></li>
</ol>
<p>发送请求之后，客户端会等待来自网关的响应。响应码200表示成功。通常响应中的原因短语通常被设置为“Conection Established”，这个响应并不需要包含Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。</p>
<h3 id="8-5-2-数据隧道、定时及连接管理"><a href="#8-5-2-数据隧道、定时及连接管理" class="headerlink" title="8.5.2 数据隧道、定时及连接管理"></a>8.5.2 数据隧道、定时及连接管理</h3><p>管道化数据对网关是不透明的，所以网关不能改变分组的顺序和分组流。一旦隧道建立起来了，数据就可以在任意时间流向任意方向了。</p>
<p>客户端可以在发送了CONNECT请求之后，接收响应之前，发送隧道数据，这样可以更快地将数据发送给服务器。但网关必须能够正确处理跟在请求之后的数据，尤其是网关不能假设网络I/O请求只会返回首部数据，网关必须确保在连接准备就绪时，将与首部一同读进来的数据发送给服务器。如果客户端发现回送的响应是认证请求，或其他非200但不致命的错误状态，就必须做好重发请求数据的准备。</p>
<p>如果隧道的任意一个端点断开了连接，那个端点发出的所有未传输数据都会被传送给另一个端点，之后到另一个端点的连接也会被代理终止。如果还有数据要传输给关闭连接的端点，数据会被丢弃。</p>
<h3 id="8-5-3-SSL隧道"><a href="#8-5-3-SSL隧道" class="headerlink" title="8.5.3 SSL隧道"></a>8.5.3 SSL隧道</h3><p>最初Web隧道是为了通过防火墙来传输加密的SSL流量。将所有流量通过分组过滤路由器和代理服务器以隧道方式传输，以提升安全性。但有些协议如加密SSL，其信息是加密的，无法通过传统的代理服务器转发。</p>
<p>HTTP中添加一项隧道特性，可以将原始的加密数据放在HTTP报文中，通过普通的HTTP信道传送。但是，这项特性可能会被滥用，使得恶意协议通过HTTP隧道流入某个组织内部。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/LG2Qj3xtDazou1H.png"
                      alt="SdlL3tBsyFZEL7Vt__thumbnail.png"
                ></p>
<h3 id="8-5-4SSL隧道与HTTP-HTTPS网关的对比"><a href="#8-5-4SSL隧道与HTTP-HTTPS网关的对比" class="headerlink" title="8.5.4SSL隧道与HTTP/HTTPS网关的对比"></a>8.5.4SSL隧道与HTTP/HTTPS网关的对比</h3><p>HTTPS协议（SSL上的HTTP）进行网关的操作：由网关（而不是客户端）初始化与远端HTTPS服务器的SSL会话，然后代表客户端执行HTTPS事务。响应会由代理接收并解密，然后通过（不安全的）HTTP传送给客户端。这种方式有几个缺点：</p>
<ol>
<li>客户端到网关之间的连接是普通的非安全HTTP；</li>
<li>虽然代理是已认证主体，但客户端无法对远端服务器执行SSL客户端认证；</li>
<li>网关要支持完整的SSL实现。</li>
</ol>
<p>对于SSL隧道机制来说，无需在代理中实现SSL。SSL 会话是建立在产生请求的客户端和目的（安全的）Web服务器之间的，中间的代理服务器只是将加密数据经过隧道传输，并不会在安全事务中扮演其他的角色。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/mXFkvVxJdzy9qY5.png"
                      alt="cITItirpNAmBAC8F__thumbnail.png"
                ></p>
<h3 id="8-5-5-隧道认证"><a href="#8-5-5-隧道认证" class="headerlink" title="8.5.5 隧道认证"></a>8.5.5 隧道认证</h3><p>在适当的情况下，可以将HTTP的其他特性与隧道配合使用。比如将代理的认证支持与隧道配合使用，对客户端使用隧道的权利进行认证。</p>
<h3 id="8-5-6-隧道的安全性考虑"><a href="#8-5-6-隧道的安全性考虑" class="headerlink" title="8.5.6 隧道的安全性考虑"></a>8.5.6 隧道的安全性考虑</h3><p>隧道网关无法验证目前使用的协议是否是它原本打算经过隧道传输的协议。因此一些用户可能会通过本打算用于SSL的隧道，越过公司防火墙传递因特网游戏流量，甚至恶意用户可能会用隧道打开Telnet会话，或用隧道绕过公司的E-mail扫描器来发送E-mail。</p>
<p>为了降低对隧道的滥用，网关应该只为特定的知名端口，如HTTPS的端口443，打开隧道。</p>
<h2 id="8-6-中继"><a href="#8-6-中继" class="headerlink" title="8.6 中继"></a>8.6 中继</h2><p><strong>HTTP中继</strong>（relay）是没有完全遵循HTTP规范的简单HTTP代理，它负责处理HTTP中建立连接的部分，然后对字节进行盲转发。</p>
<p>盲中继不执行任何首部和方法逻辑，有时是很有用的，有时会提供简单的过滤、诊断或内容转换功能。但这种方式可能潜在严重的互操作问题。</p>
<p>某些简单盲中继实现中存在的问题是，由于它们无法正确处理Connection首部，所以有潜在的挂起keep-alive连接的可能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ENAhCpFIZGrD645.png"
                      alt="IULgh1VsZyxKgPpy__thumbnail.png"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>11-客户端识别与cookie机制</title>
    <url>/2021/01/23/note/HTTP/11-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%86%E5%88%AB%E4%B8%8Ecookie%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="11-1-个性化接触"><a href="#11-1-个性化接触" class="headerlink" title="11.1 个性化接触"></a>11.1 个性化接触</h2><p>现代的Web站点希望能够提供个性化的接触，希望对连接另一端的用户有更多的了解，并且能在用户浏览页面时对其进行跟踪。用户的识别机制：</p>
<ol>
<li><strong>HTTP首部</strong>，承载了用户身份信息。</li>
<li><strong>客户端IP地址跟踪</strong>，通过用户的IP地址对其进行识别。</li>
<li><strong>用户登录</strong>，用认证方式来识别用户。</li>
<li><strong>胖URL</strong>，在URL中嵌人识别信息的技术。</li>
<li><strong>cookie</strong>，持久身份识别技术。<h2 id="11-2-HTTP首部"><a href="#11-2-HTTP首部" class="headerlink" title="11.2 HTTP首部"></a>11.2 HTTP首部</h2></li>
</ol>
<p>七种常见的用来承载用户相关信息的HTTP请求首部，后四个首部用于更高级的识别技术。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/5L8iAcKqhvVbH4N.png"
                      alt="OGLHbPyUzYspa9X1__thumbnail.png"
                ></p>
<p>由于有些服务器会搜集E-mail地址，用于垃圾邮件的散发，所以很少有浏览器会发送From首部。实际上，From首部是由自动化的机器人或蜘蛛发送的。</p>
<p>User-Agent首部包括浏览器的名称和版本，操作系统的相关信息。用于实现定制内容与特定的浏览器及其属性间的良好互操作，但并没有为识别特定的用户提供太多帮助。</p>
<p>Referer首部提供了用户来源页面的URL。Referer首部自身并不能完全标识用户，但它说明了用户之前访问过哪个页面。通过它可以更好地理解用户的浏览行为，以及用户的兴趣所在。</p>
<p>From、User-Agent和Referer首部都不足以实现可靠的识别。</p>
<h2 id="11-3-客户端IP地址"><a href="#11-3-客户端IP地址" class="headerlink" title="11.3 客户端IP地址"></a>11.3 客户端IP地址</h2><p>通常HTTP首部并不提供客户端的IP地址（有些代理会舔加Client-IP首部），但Web服务器可以找到承载HTTP请求的TCP连接另一端的IP地址。</p>
<p>使用客户端IP地址来识别用户存在着很多缺点，限制了将其作为用户识别技术的效能：</p>
<ol>
<li>客户端IP地址描述的是所用的机器，而不是用户。如果多个用户共享同一台计算机，就无法对其进行区分。</li>
<li>很多因特网服务提供商都会在用户登录时为其动态分配IP地址。用户每次登录时，都会得到一个不同的地址。</li>
<li>为了提高安全性，并对稀缺的地址资源进行管理，很多用户通过<strong>网络地址转换</strong>（Network Address Translation，NAT）防火墙来浏览网络内容的。NAT设备将了防火墙后面的实际客户端的IP地址转换成了一个共享的防火墙IP地址（和不同的端口号）。</li>
<li>HTTP代理和网关通常会打开一些新的到原始服务器的TCP连接。Web服务器看到的将是代理服务器的IP地址，而不是客户端的。但个别代理会添加特殊的Client-IP或x-Forwarded-For扩展首部来保存原始的IP地址。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/87AXogI6KjVtWf1.png"
                      alt="UtHMnCSRoPNvPQj9__thumbnail.png"
                ></p>
<h2 id="11-4-用户登录"><a href="#11-4-用户登录" class="headerlink" title="11.4 用户登录"></a>11.4 用户登录</h2><p>Web服务器可以要求用户通过用户名和密码进行认证（登录）来显式地询问用户是谁。HTTP中包含了一种内建机制，可以用WWW-Authenticate首部和Authorization首部向Web站点传送用户的相关信息。</p>
<p>如果服务器希望在为用户提供对站点的访问之前登录，可以向浏览器回送一条HTTP响应代码401 Login Required，然后浏览器显示一个登录对话框，一旦登录，浏览器就可以不断地在每条发往这个站点的请求甚至没有要求中，向服务器发送Authorization首部作为一种身份的标识。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/8Kc5o9SdyMIVRfE.png"
                      alt="UtY4a0FC6TRmjhdo__thumbnail.png"
                ></p>
<h2 id="11-5-胖URL"><a href="#11-5-胖URL" class="headerlink" title="11.5 胖URL"></a>11.5 胖URL</h2><p>有些Web站点会为每个用户生成特定版本的URL来追踪用户的身份。通常对真正的URL路径开始或结束的地方添加一些状态信息。用户浏览站点时，Web服务器会动态生成一些超链，继续维护URL中的状态信息。改动后包含了用户状态信息的URL被称为胖URL（fat URL）。</p>
<p>但这种技术存在几个很严重的问题：</p>
<ol>
<li><strong>丑陋的URL</strong>。浏览器中显示的胖URL会给新用户带来困扰。</li>
<li><strong>无法共享URL。</strong>胖URL中包含了与特定用户和会话有关的状态信息。如果将其发送给其他人，可能就在无意中将你积累的个人信息都共享出去了。</li>
<li><strong>破坏缓存</strong>。为每个URL生成用户特有的版本意味着不再有可供公共访问的URL需要缓存。</li>
<li><strong>额外的服务器负荷</strong>。服务器需要重写HTML页面使URL变胖。</li>
<li><strong>逃逸口</strong>。用户跳转到其他站点或者请求一个特定的URL时，就很容易在无意中“逃离”胖URL会话。只有当用户严格地追随预先修改过的链接时，胖URL才能工作。如果用户逃离此链接，就会丢失其进展信息，重新开始。</li>
<li><strong>在会话间是非持久的</strong>。除非用户收藏了特定的胖URL，否则用户退出登录时，所有的信息都会丢失。<h2 id="11-6-cookie"><a href="#11-6-cookie" class="headerlink" title="11.6 cookie"></a>11.6 cookie</h2></li>
</ol>
<p>cookie是当前识别用户，实现持久会话的最好方式。它们定义了一些新的HTTP首部。cookie的存在也影响了缓存，大多数缓存和浏览器都不允许对任何cookie的内容进行缓存。</p>
<h3 id="11-6-1-cookie的类型"><a href="#11-6-1-cookie的类型" class="headerlink" title="11.6.1 cookie的类型"></a>11.6.1 cookie的类型</h3><p>cookie可以笼统地分为两类：<strong>会话cookie</strong>和<strong>持久cookie</strong>。</p>
<p>会话cookie是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除。如果设置了Discard参数，或者没有设置Expires或Max-Age参数来说明扩展的过期时间，这个cookie就是一个 会话cookie.</p>
<p>持久cookie的生存时间更长，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。</p>
<h3 id="11-6-2-cookie是如何工作的"><a href="#11-6-2-cookie是如何工作的" class="headerlink" title="11.6.2 cookie是如何工作的"></a>11.6.2 cookie是如何工作的</h3><p>用户首次访问Web站点时，Web服务器给这个用户“拍上”一个独有的cookie，这样以后就可以识别出这个用户。cookie中包含了一个由（name=value）这样的信息构成的任意列表。</p>
<p>cookie并不仅限于ID号，很多Web服务器会将信息直接保存在cookie中，并通过set-cookie或set-cookie2 HTTP响应（扩展）首部将其贴到用户身上去。浏览器会记住从服务器返回的cookie内容，并将cookie集存储在浏览器的cookie数据库中。将来用户返回同一站点时，浏览器会挑中那个服务器贴到用户上的那些cookie，并在一个cookie请求首部中将其传回去。</p>
<h3 id="11-6-3-cookie罐：客户端的状态"><a href="#11-6-3-cookie罐：客户端的状态" class="headerlink" title="11.6.3 cookie罐：客户端的状态"></a>11.6.3 cookie罐：客户端的状态</h3><p>因为浏览器负责存储cookie信息，所以系统被称为<strong>客户端侧状态</strong>（client-sidestate）。cookie规范的正式名称为<strong>HTTP状态管理机制</strong>（HTTP state management mechanism）。不同的浏览器会以不同的方式来存储cookie。</p>
<h3 id="11-6-4-不同站点使用不同的cookie"><a href="#11-6-4-不同站点使用不同的cookie" class="headerlink" title="11.6.4 不同站点使用不同的cookie"></a>11.6.4 不同站点使用不同的cookie</h3><p>浏览器内部的cookie罐中可以有很多cookie，但浏览器通常只向每个站点发送2 ~ 3个cookie，浏览器只向服务器发送服务器产生的那些cookie。原因如下：</p>
<ol>
<li>对所有cookie字节进行传输会严重降低性能。浏览器实际传输的cookie字节数要比实际的内容字节数多；</li>
<li>cookie中包含的是服务器特有的名值对，所以对大部分站点来说，大多数cookie都只是无法识别的无用数据；</li>
<li>将所有的cookie发送给所有站点会引发潜在的隐私问题。<h3 id="11-6-5-cookie成分"><a href="#11-6-5-cookie成分" class="headerlink" title="11.6.5 cookie成分"></a>11.6.5 cookie成分</h3></li>
</ol>
<p>现在使用的cookie规范有两个不同的版本：<strong>cookies版本0</strong>（也叫Netscape cookies）和<strong>cookies版本1</strong>（RFC 2965）。cookies 版本1是对cookies版本0的扩展，应用不如后者广泛。</p>
<p>cookie规范版本0和版本1都不是作为HTTP/1.1规范的一部分提供的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/CXx8REyPFs7LhUY.png"
                      alt="Jq2YLdpVHtY6PfRA__thumbnail.png"
                ></p>
<h3 id="11-6-6-cookies版本0（Netscape）"><a href="#11-6-6-cookies版本0（Netscape）" class="headerlink" title="11.6.6 cookies版本0（Netscape）"></a>11.6.6 cookies版本0（Netscape）</h3><p>最初的cookie规范是由网景公司定义的。这些“版本0”的cookie定义了Set-Coookie响应首部、cookie请求首部以及用于控制cookie的字段。</p>
<h4 id="11-6-6-1-版本0的set-Cookie首部"><a href="#11-6-6-1-版本0的set-Cookie首部" class="headerlink" title="11.6.6.1 版本0的set-Cookie首部"></a>11.6.6.1 版本0的set-Cookie首部</h4><p>set-Cookie首部有一个强制性的cookie名和cookie 值。后面跟着可选的cookie属性，中间由分号分隔。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/hZbMTLJrzs3KPuk.png"
                      alt="qdonImiSjvneeOvw__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/sIC5VgzkP8fB9Hj.png"
                      alt="GBdOJLwCMpYc0S2p__thumbnail.png"
                ></p>
<h4 id="11-6-6-2-版本0的Cookie首部"><a href="#11-6-6-2-版本0的Cookie首部" class="headerlink" title="11.6.6.2 版本0的Cookie首部"></a>11.6.6.2 版本0的Cookie首部</h4><p>客户端发送请求时，会将所有与域、路径和安全过滤器相匹配的未过期cookie都发送给这个站点。所有cookie都被组合到一个Cookie首部中。</p>
<h3 id="11-6-7-cookies版本1（RFC-2965）"><a href="#11-6-7-cookies版本1（RFC-2965）" class="headerlink" title="11.6.7 cookies版本1（RFC 2965）"></a>11.6.7 cookies版本1（RFC 2965）</h3><p>这个版本1标准引入了Set-Cookie2首部和Cookie2首部，但也能与版本0系统进行互操作。</p>
<p>RFC 2965 cookie的主要改动包括下列内容：</p>
<ol>
<li>为每个cookie关联上解释性文本，对其目的进行解释。</li>
<li>允许在浏览器退出时，不考虑过期时间，将cookie强制销毁。</li>
<li>用相对秒数，而不是绝对日期来表示cookie的Max-Age.</li>
<li>通过URL端口号，而不仅仅是域和路径来控制cookie的能力。</li>
<li>通过Cookie首部回送域、端口和路径过滤器（如果有的话）。</li>
<li>为实现互操作性使用的版本号。</li>
<li>在Cookie首部从名字中区分出附加关键字的$前缀。<h4 id="11-6-7-1-版本1的set-Cookie2首部"><a href="#11-6-7-1-版本1的set-Cookie2首部" class="headerlink" title="11.6.7.1 版本1的set-Cookie2首部"></a>11.6.7.1 版本1的set-Cookie2首部</h4></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/pVqy9eLYgvZUxda.png"
                      alt="5a2SbBmAsu83S7yy__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/rDePvSIkW4th2Mj.png"
                      alt="mtVJtcN1kr8hhsQp__thumbnail.png"
                ></p>
<h4 id="11-6-7-2-版本1的Cookie首部"><a href="#11-6-7-2-版本1的Cookie首部" class="headerlink" title="11.6.7.2 版本1的Cookie首部"></a>11.6.7.2 版本1的Cookie首部</h4><p>版本1的cookie会带回与传送的每个cookie相关的附加信息，用来描述每个cookie途径的过滤器。每个匹配的cookie都必须包含来自相应set-cookie2首部的所有Domain、Port 或Path属性。所有匹配cookie都是和它们的Set-Cookie2过滤器一同传输的，而且保留关键字都是以美元符号（$）开头的。</p>
<h4 id="11-6-7-3-版本1的Cookie2首部和版本协商"><a href="#11-6-7-3-版本1的Cookie2首部和版本协商" class="headerlink" title="11.6.7.3 版本1的Cookie2首部和版本协商"></a>11.6.7.3 版本1的Cookie2首部和版本协商</h4><p>Cookie2请求首部负责在能够理解不同cookie规范版本的客户端和服务器之间进行互操作性的协商。</p>
<p>如果服务器理解新形式的cookie，就能够识别出Cookie2首部，并在响应首部发送set-Cookie2（而不是Set-Cookie）。如果客户端从同一个响应中获得set-Cookie和Set-Cookie2首部，忽略Set-Cookie首部。</p>
<p>如果客户端既支持版本0又支持版本1的cookie，但从服务器获得的是版本0的Set-Cookie首部，就应该带着版本0的Cookie首部发送cookie。但客户端还应该发送Cookie2：$Version=“1”来告知服务器它是可以升级的。</p>
<h3 id="11-6-8-cookie与会话跟踪"><a href="#11-6-8-cookie与会话跟踪" class="headerlink" title="11.6.8 cookie与会话跟踪"></a>11.6.8 cookie与会话跟踪</h3><p>可以用cookie在用户与某个站点进行多项事务处理时对用户进行跟踪，启动一个事务链，在这些事务中Web服务器会通过一系列的重定向、URL重写以及cookie设置来附加标识信息。</p>
<h3 id="11-6-9-cookie与缓存"><a href="#11-6-9-cookie与缓存" class="headerlink" title="11.6.9 cookie与缓存"></a>11.6.9 cookie与缓存</h3><p>缓存与cookie事务有关的文档时需要注意，cookie和缓存的规则并没有很好地建立起来。下 面是处理缓存时的一些指导性规则：</p>
<ol>
<li><strong>标示无法缓存的文档</strong></li>
</ol>
<p>如果除了Set-Cookie首部之外文档是可缓存的，就使用Cache-Control：no-cache=”Set-Cookie”，或者为可缓存文档使用Cache-Control：public，这样利于节省Web中的带宽。</p>
<ol start="2">
<li><strong>缓存Set-Cookie首部</strong></li>
</ol>
<p>如果向多个用户发送了相同的Set-Cookie首部，可能会破坏用户的定位。</p>
<p>有些缓存在将响应缓存起来之前会删除set-Cookie首部，但这样由缓存提供服务的客户端就不会有cookie了。强制缓存与原始服务器重新验证每条请求，并将返回的所有Set-Cookie首部都合并到客户端的响应中去，就可以解决。原始服务器可以通过向缓存的副本中添加这个首部来要求进行这种再验证：Cache-Control：must-revalidate，max-age=0</p>
<p>即便内容实际上是可以缓存的，一些缓存可能也会拒绝缓存所有包含Set-Cookie首部的响应。有些缓存允许使用缓存Set-Cookie图片，但不缓存文本的模式。</p>
<ol start="3">
<li><strong>处理带有Cookie首部的请求</strong></li>
</ol>
<p>带有Cookie首部的请求到达时，就在提示我们，得到的结果可能是私有的。一定要将私有内容标识为不可缓存的，但有些服务器可能会犯错，没有将此内容标记为不可缓存的。</p>
<p>有些响应文档对应于携带Cookie首部的请求，一些缓存可能会不去缓存。有些缓存允许使用缓存cookie图片，而不缓存文本的模式。更广泛接受的方案是缓存带有Cookie首部的图片，将过期时间设置为零，强制每次都进行再验证。</p>
<h3 id="11-6-10-cookie-安全性和隐私"><a href="#11-6-10-cookie-安全性和隐私" class="headerlink" title="11.6.10 cookie.安全性和隐私"></a>11.6.10 cookie.安全性和隐私</h3><p>第三方Web站点使用持久cookie来跟踪用户就是一种最大的滥用。将这种做法与IP地址和Referer首部信息结合在一起，营销公司就可以构建起相当精确的用户档案和浏览模式信息。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>12-基本认证机制</title>
    <url>/2021/01/23/note/HTTP/12-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="12-1-认证"><a href="#12-1-认证" class="headerlink" title="12.1 认证"></a>12.1 认证</h2><p>服务器需要通过某种方式来了解用户身份，从而判定用户可以访问的事务和资源。认证就意味着要证明你是谁。通常是通过提供用户名和密码来进行认证的。</p>
<p>HTTP为认证提供了一种原生工具。尽管可以在HTTP的认证形式和cookie基础之上“运行自己的”认证工具，但在很多情况下，HTTP的原生认证功能就可以很好地满足要求。</p>
<p>最常见的HTTP认证形式，<strong>基本认证</strong>（basic authentication），<strong>摘要认证</strong>（digest authentication）。</p>
<h3 id="12-1-1-认证协议与首部"><a href="#12-1-1-认证协议与首部" class="headerlink" title="12.1.1  认证协议与首部"></a>12.1.1  认证协议与首部</h3><p>HTTP通过一组可定制的控制首部，为不同的认证协议提供了一个可扩展框架。认证协议也是在HTTP认证首部中指定的。可以随意设计一些使用HTTP质询/响应框架的新协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Qc3z4qZmlpSRDIF.png"
                      alt="3I1T0Sqn0vGxXzWp__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/peGioQUZ7IylC62.png"
                      alt="rkRrBdeZ0ZR0sz8V__thumbnail.png"
                ></p>
<p>Web服务器会将受保护的文档组织成一个<strong>安全域</strong>（security realm）。每个安全域都可以有不同的授权用户集，不同的用户对各个安全域的访问权限是不同的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/TBj9MzoIDHLrSFU.png"
                      alt="hOOl1LLNsJNi4Al7__thumbnail.png"
                ></p>
<h2 id="12-2-基本认证"><a href="#12-2-基本认证" class="headerlink" title="12.2 基本认证"></a>12.2 基本认证</h2><p>在基本认证中，Web服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。服务器会返回401状态码，而不是200状态码来初始化认证质询，并用WWW-Authent icate响应首部指定要访问的安全域。浏览器收到质询时，会打开一个对话框，请求用户输人这个域的用户名和密码。然后将用户名和密码稍加扰码，再用Authorization请求首部回送给服务器。基本认证协议没有使用Authentication-Info首部。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/dCwAg4KYpaTEXtW.png"
                      alt="qlzDftADKFeS3vHH__thumbnail.png"
                ></h3><h3 id="12-2-1-Base-64用户名-密码编码"><a href="#12-2-1-Base-64用户名-密码编码" class="headerlink" title="12.2.1 Base-64用户名/密码编码"></a>12.2.1 Base-64用户名/密码编码</h3><p>HTTP基本认证将（由冒号分隔的）用户名和密码打包在一起，并用Base 64编码方式对其进行编码。简单来说，Base-64 编码会将一个8位字节序列划分为一些6位的块。用每个6位的块在由64个字符组成的特殊的字母表中选择一个字符，这个字母表中包含了大部分字母和数字。</p>
<h3 id="12-2-2-代理认证"><a href="#12-2-2-代理认证" class="headerlink" title="12.2.2 代理认证"></a>12.2.2 代理认证</h3><p>中间的代理服务器也可以实现认证功能，通过代理服务器提供对某组织内部资源的统一访问控制。代理认证的步骤与Web服务器身份验证的步骤相同，但首部和状态码都有所不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/KTnjvgwAZtaYpz6.png"
                      alt="9TuJb1meuUYlSwAR__thumbnail.png"
                ></p>
<h2 id="12-3-基本认证的安全缺陷"><a href="#12-3-基本认证的安全缺陷" class="headerlink" title="12.3 基本认证的安全缺陷"></a>12.3 基本认证的安全缺陷</h2><p>基本认证只能用它来防止非恶意用户无意间进行的访问，或将其与SSL这样的加密技术配合使用。基本认证存在下列安全缺陷：</p>
<ol>
<li>虽然Base-64编码通过隐藏用户名和密码，可以很轻易地通过反向编码过程进行解码。</li>
<li>即使第三方用户可以捕获被修改过的用户名和密码，并将修改过的用户名和密码重放给原始服务器，以获得对服务器的访问权。</li>
<li>很多用户会在这些服务间使用相同的用户名和密码。可能被恶意先捕获明文形式的用户名和密码，然后访问重要的网站。</li>
<li>没有针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，但却修改了报文的其余部分。</li>
<li>假冒服务器很容易骗过基本认证。如果在用户实际连接到一台恶意服务器或网关的时候，攻击者请求用户输入密码，将其存储起来以备未来使用，然后捏造错误信息传送给用户。</li>
</ol>
<p>通常基本认证来提供便捷且不重要的文档个性化服务或访问控制保护，可以防止用户不小心对文档进行访问。更安全的方案是，将基本认证与加密数据传输（比如SSL）配合使用，向恶意用户隐藏用户名和密码，或使用摘要认证。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>14-安全HTTP</title>
    <url>/2021/01/23/note/HTTP/14-%E5%AE%89%E5%85%A8HTTP/</url>
    <content><![CDATA[<h2 id="14-1-保护HTTP的安全"><a href="#14-1-保护HTTP的安全" class="headerlink" title="14.1 保护HTTP的安全"></a>14.1 保护HTTP的安全</h2><p>HTTP安全技术能够提供下列功能:</p>
<ol>
<li><strong>服务器认证</strong>（客户端知道它们是在与真正的而不是伪造的服务器通话）。</li>
<li><strong>客户端认证</strong>（服务器知道它们是在与真的而不是伪造的客户端通话）。</li>
<li><strong>完整性</strong>（客户端和服务器的数据不会被修改）。</li>
<li><strong>加密</strong>（客户端和服务器的对话是私密的，无需担心被窃听）。</li>
<li><strong>效率</strong>（一个运行的足够快的算法，以便低端的客户端和服务器使用）。</li>
<li><strong>普适性</strong>（基本上所有的客户端和服务器都支持这些协议）。</li>
<li><strong>管理的可扩展性</strong>（在任何地方的任何人都可以立即进行安全通信）。</li>
<li><strong>适应性</strong>（能够支持当前最知名的安全方法）。</li>
<li><strong>可行性</strong>（满足社会的政治文化需要）。</li>
</ol>
<p><strong>HTTPS</strong>就是最流行的HTTP安全形式。HTTPS方案的URL以https://，而不是http://开头，据此就可以分辨某个Web页面是通过HTTPS还是HTTP访问的。</p>
<p>使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP下面提供了一个传输级的密码安全层<strong>SSL</strong>，也可以使用传输层安全（Transport Layer Security，<strong>TLS</strong>）。SSL和TLS类似，可以用SSL来表示SSL和TLS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zm3NZXxUEaTAFw2.png"
                      alt="mIJdG4CNy1xhnqon__thumbnail.png"
                ></p>
<p>大部分编码解码工作都在SSL库中完成的，Web客户端和服务器在使用安全HTTP时无需过多地修改其协议处理逻辑。在大多数情况下，只需要用SSL的输入/输出调用取代TCP的调用，再增加几个其他调用来配置和管理安全信息。</p>
<h2 id="14-2-数字加密"><a href="#14-2-数字加密" class="headerlink" title="14.2 数字加密"></a>14.2 数字加密</h2><ol>
<li><strong>密码</strong>，对文本进行编码，使偷窥者无法识别的算法。</li>
<li><strong>密钥</strong>，改变密码行为的数字化参数。</li>
<li><strong>对称密钥加密系统</strong>，编/解码使用相同密钥的算法。</li>
<li><strong>不对称密钥加密系统</strong>，编/解码使用不同密钥的算法。</li>
<li><strong>公开密钥加密系统</strong>，一种能够使数百万计算机便捷地发送机密报文的系统。</li>
<li><strong>数字签名</strong>，用来验证报文未被伪造或篡改的校验和。</li>
<li><strong>数字证书</strong>，由一个可信的组织验证和签发的识别信息。<h3 id="14-2-1-密码"><a href="#14-2-1-密码" class="headerlink" title="14.2.1 密码"></a>14.2.1 密码</h3></li>
</ol>
<p>密码学基于一种名为密码（cipher）的秘密代码。密码是一套编码方案，一种特殊的报文编码方式和一种稍后使用的相应解码方式的结合体。加密之前的原始报文通常被称为<strong>明文</strong>（plaintext 或cleartext）。使用了密码之后的编码报文通常被称作<strong>密文</strong>（ciphertext）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/xscoKFJZtgAfElr.png"
                      alt="TKPj2auk0Ick7iCq__thumbnail.png"
                ></p>
<p>起初密码是相当简单的算法。比如字符旋转密码，报文中的每个字符都由字母表中三个位置之后的字符来取代。“A”由“D”来取代，“B”由“E”来取代，以此类推。而密码机可以用复杂得多的密码来快速、精确地对报文进行编解码，使代码的破解更加困难。</p>
<h3 id="14-2-2-使用密钥的密码"><a href="#14-2-2-使用密钥的密码" class="headerlink" title="14.2.2 使用密钥的密码"></a>14.2.2 使用密钥的密码</h3><p>大部分机器上都有一些号盘，可以将其设置为大量不同的值以改变密码的工作方式。没有正确的号盘设置（密钥值），解码器无法工作。同一条输入报文通过同一台编码机进行传输，会随密钥值的不同产生不同的输出。这些密码参数被称为<strong>密钥</strong>（key）。</p>
<h3 id="14-2-3-数字密码"><a href="#14-2-3-数字密码" class="headerlink" title="14.2.3 数字密码"></a>14.2.3 数字密码</h3><p>与金属钥匙或机械设备中的号盘设置相比，数字密钥只是一些数字。数字密钥值是编/解码算法的输入。编码算法就是会读取数据的函数，函数根据算法和密钥值对其进行编/解码。</p>
<p>给定一段明文报文P、一个编码函数E和一个数字编码密钥e，就可以生成一段经过编码的密文C。通过解码函数D和解码密钥d，可以将密文C解码为原始的明文P。编/解码函数都是互为反函数的，对P的编码进行解码就会回到原始报文P上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ltw1QL6YpIAU4qR.png"
                      alt="6y06i9T1LHudkYmQ__thumbnail.png"
                ></p>
<h2 id="14-3-对称密钥加密技术"><a href="#14-3-对称密钥加密技术" class="headerlink" title="14.3 对称密钥加密技术"></a>14.3 对称密钥加密技术</h2><p>很多数字加密算法都是<strong>对称密钥</strong>（symmetric-key）加密技术，因为编码时使用的密钥值和解码时一样（e=d），统称为密钥k。</p>
<p>发送端和接收端要共享相同的密钥k才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文。流行的对称密钥加密算法有：DES、Triple-DES、RC2 、RC4。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/kJMwZKbtDqvji7a.png"
                      alt="b4QoZX7deFh2BTZr__thumbnail.png"
                ></p>
<h3 id="14-3-1-密钥长度与枚举攻击；"><a href="#14-3-1-密钥长度与枚举攻击；" class="headerlink" title="14.3.1 密钥长度与枚举攻击；"></a>14.3.1 密钥长度与枚举攻击；</h3><p>在很多情况下，编/解码算法都是众所周知的，因此密钥是唯一保密的东西。</p>
<p>用暴力去尝试所有的密钥值称为<strong>枚举攻击</strong>（enumeration attack）。好的加密算法会迫使攻击者试遍每一个可能的密钥，才能破解代码。</p>
<p>可用密钥值的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。通常对称密钥加密技术所有的密钥值都是有效的，有些加密技术只有部分秘钥值有效。</p>
<p>在传统的对称密钥加密技术中，对小型的、不太重要的事务来说，40位的密钥就足够安全了。但现在可能需要128 位的密钥。</p>
<h3 id="14-3-2-建立共享密钥"><a href="#14-3-2-建立共享密钥" class="headerlink" title="14.3.2 建立共享密钥"></a>14.3.2 建立共享密钥</h3><p>对称密钥加密技术的缺点之一就是发送者和接收者在互相对话之前，要有一个共享的保密密钥。</p>
<p>每对通信实体都需要自己的私有密钥。如果有N个节点，每个节点都要和其他所有N-1个节点进行安全对话，总共大概会有N^2个保密密钥。</p>
<h2 id="14-4-公开密钥加密技术"><a href="#14-4-公开密钥加密技术" class="headerlink" title="14.4 公开密钥加密技术"></a>14.4 公开密钥加密技术</h2><p>公开密钥加密技术使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文解码。编码密钥是公开，但解密密钥只有主机才知道。但解码密钥是保密的，因此只有接收端才能对发送给它的报文进行解码。</p>
<p>这样解决了对称秘钥技术的缺点，无须为了进行安全的通信而先交换私有密钥，使得密钥的建立变得更加简单。节点X可以将其加密密钥ex公开。任何想向节点X发送报文的人都可以使用相同的公开密钥了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/cyUZdHxANTu97tg.png"
                      alt="R3C0ZWtLpOZaLWpA__thumbnail.png"
                ></p>
<h3 id="14-4-1-RSA"><a href="#14-4-1-RSA" class="headerlink" title="14.4.1 RSA"></a>14.4.1 RSA</h3><p>所有公开密钥非对称加密系统所面临的共同挑战是，要确保即便有人拥有了下面所有的线索，也无法计算出保密的私有密钥：</p>
<ol>
<li>公开密钥（是公有的，所有人都可以获得）；</li>
<li>一小片拦截下来的密文（可通过对网络的嗅探获取）；</li>
<li>一条报文及与之相关的密文（对任意一段文本运行加密器就可以得到）。</li>
</ol>
<p>RSA算法就是一个满足了以上这些条件的流行的公开密钥加密系统，它使得破解代码找到相应的私有密钥的难度仍相当于对一个极大的数进行质因数分解的困难程度。</p>
<h3 id="14-4-2-混合加密系统和会话密钥"><a href="#14-4-2-混合加密系统和会话密钥" class="headerlink" title="14.4.2 混合加密系统和会话密钥"></a>14.4.2 混合加密系统和会话密钥</h3><p>公开密钥加密算法的计算可能会很慢，因为它混合使用了对称和非对称策略。常见的做法是在两节点间通过便捷的公开密钥加密技术建立起安全通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。</p>
<h2 id="14-5-数字签名"><a href="#14-5-数字签名" class="headerlink" title="14.5 数字签名"></a>14.5 数字签名</h2><p>除了加/解密报文之外，还可以用加密系统对报文进行签名（sign），签名是加了密的校验和，数字签名是附加在报文上的特殊加密校验码。因为只有作者保密的私有密钥才能产生校验和，收到报文后用公钥能对数字签名解密，可以证明没有被冒充，同时再次进行摘要运算进行标胶，证明报文是否被篡改过。</p>
<p>数字签名通常是用非对称公开密钥技术产生的。它解决了对私钥加密整个文件以及之后的解密的开销问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/JcRPX8nAW2KgDpo.png"
                      alt="Tke6UEV6jKnzqPSN__thumbnail.png"
                ></p>
<h2 id="14-6-数字证书"><a href="#14-6-数字证书" class="headerlink" title="14.6 数字证书"></a>14.6 数字证书</h2><h3 id="14-6-1-证书的主要内容"><a href="#14-6-1-证书的主要内容" class="headerlink" title="14.6.1 证书的主要内容"></a>14.6.1 证书的主要内容</h3><p>数字证书（certs）包含了由某个受信任组织担保的用户或公司（比如CA证书授权中心）的相关信息。CA证书中心用自己的私钥，对发送端的公钥和其他信息一起加密，生成”数字证书”。因为接受端只有用CA机构的公钥解密这份数字证书，才能拿到发送者的公钥，CA机构是绝对权威可信的，然后继续验证数字签名。这解决了发送端和接收端的公钥同时被替换的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/G3CDi1Krl2Z59qL.png"
                      alt="fFoOZEhjrhEeQgdN__thumbnail.png"
                ></p>
<h3 id="14-6-2-X-509-v3证书"><a href="#14-6-2-X-509-v3证书" class="headerlink" title="14.6.2 X.509 v3证书"></a>14.6.2 X.509 v3证书</h3><p>大多数证书都以X.509 v3标准格式来存储它们的信息。X.509 v3证书提供了一种标准的方式，将证书信息规范至一些可解析字段中。基于X.509证书的签名有：Web服务器证书、客户端电子邮件证书、软件代码签名证书和证书颁发机构证书。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/bByFuUQC7NInJ23.png"
                      alt="hspZDgv7mPLSk21u__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/eECKZzIkQaGsYHn.png"
                      alt="zPbm4kXgLajyitzJ__thumbnail.png"
                ></p>
<h3 id="14-6-3-用证书对服务器进行认证"><a href="#14-6-3-用证书对服务器进行认证" class="headerlink" title="14.6.3 用证书对服务器进行认证"></a>14.6.3 用证书对服务器进行认证</h3><p>通过HTTPS建立一个安全Web事务之后，浏览器会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。浏览器收到证书时会对签名颁发机构进行检查。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zxqIrC6iV1wbLZs.png"
                      alt="SD8nb5zOtht8Okfl__thumbnail.png"
                ></p>
<h2 id="14-7-HTTPS细节介绍"><a href="#14-7-HTTPS细节介绍" class="headerlink" title="14.7 HTTPS细节介绍"></a>14.7 HTTPS细节介绍</h2><p>HTTPS是最常见的HTTP安全版本。HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起。</p>
<h3 id="14-7-1-HTTPS概述"><a href="#14-7-1-HTTPS概述" class="headerlink" title="14.7.1 HTTPS概述"></a>14.7.1 HTTPS概述</h3><p>HTTPS就是在安全的传输层上发送的HTTP。HTTPS没有将未加密的HTTP报文发送给TCP，而是先将其发送给了一个安全层，对其进行加密。HTTP安全层是通过SSL及其现代替代协议TLS来实现的。术语SSL同时来表示SSL或者TLS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/XlTijkFArSQERvw.png"
                      alt="Dcf7PaKFNvsZgcjI__thumbnail.png"
                ></p>
<h3 id="14-7-2-HTTPS方案"><a href="#14-7-2-HTTPS方案" class="headerlink" title="14.7.2 HTTPS方案"></a>14.7.2 HTTPS方案</h3><p>安全HTTP是可选的。因此，对Web服务器发起请求时，会去检查URL的方案前缀。因为SSL是个二进制协议，与HTTP完全不同， 如果SSL从端口80到达，Web服务器会将二进制SSL流量理解为错误的HTTP并关闭连接。</p>
<h3 id="14-7-3-建立安全传输"><a href="#14-7-3-建立安全传输" class="headerlink" title="14.7.3 建立安全传输"></a>14.7.3 建立安全传输</h3><p>在HTTPS中，客户端首先打开一条到Web服务器端口443的连接。一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥。握手完成之后，客户端就将请求报文发送给安全层。在将这些报文发送给TCP之前，都要先对其进行加密。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/NMiYZGj785gxROW.png"
                      alt="wELgIlWVSdCcZivr__thumbnail.png"
                ></p>
<h4 id="14-7-3-1-SSL握手"><a href="#14-7-3-1-SSL握手" class="headerlink" title="14.7.3.1 SSL握手"></a>14.7.3.1 SSL握手</h4><p>在发送已加密的HTTP报文前，客户端和服务器进行一次SSL握手，它们要完成以下工作：</p>
<ol>
<li>交换协议版本号；</li>
<li>选择一个两端都了解的密码；</li>
<li>对两端的身份进行认证；</li>
<li>生成临时的会话密钥，以便加密信道。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/kaDtWuZFMd1ciGw.png"
                      alt="GzOgAMKnHN1Dx72w__thumbnail.png"
                ></p>
<h3 id="14-7-4-服务器证书"><a href="#14-7-4-服务器证书" class="headerlink" title="14.7.4 服务器证书"></a>14.7.4 服务器证书</h3><p>SSL支持双向认证，将服务器证书承载回客户端，再将客户端的证书回送给服务器。但实际中很少出现服务器要求使用客户端证书，安全HTTPS事务总是要求使用服务器证书的。</p>
<h4 id="14-7-4-1-站点证书的有效性"><a href="#14-7-4-1-站点证书的有效性" class="headerlink" title="14.7.4 .1 站点证书的有效性"></a>14.7.4 .1 站点证书的有效性</h4><p>SSL自身不要求用户检查Web服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进行进一步彻查的手段。验证步骤如下所述：</p>
<ol>
<li><strong>日期检测</strong></li>
</ol>
<p>首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果过期，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息。</p>
<ol start="2">
<li><strong>签名颁发者可信度检测</strong></li>
</ol>
<p>每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。浏览器会附带一个签名颁发机构的受信列表。如果浏览器收到了某未知甚至恶意的颁发机构签发的证书，那它通常会显示一条警告信息。</p>
<ol start="3">
<li><strong>签名检测</strong></li>
</ol>
<p>一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性。</p>
<ol start="4">
<li><strong>站点身份检测</strong></li>
</ol>
<p>为防止服务器复制其他人的证书，或拦截其他人的流量，浏览器会验证证书中的域名与所对话的服务器的域名是否匹配，有些CA会为一组服务器创建包含服务器名称列表或通配域名的证书。如果主机名与证书中的标识符不匹配，客户端要么通知用户，要么就以表示证书不正确的差错报文来终止连接。</p>
<h4 id="14-7-4-2-虚拟主机与证书"><a href="#14-7-4-2-虚拟主机与证书" class="headerlink" title="14.7.4 .2 虚拟主机与证书"></a>14.7.4 .2 虚拟主机与证书</h4><p>有些流行的Web服务器程序只支持一个证书。如果用户请求的是虚拟主机名（一台服务器上有多个主机名），与证书名称并不严格匹配，浏览器就会显示警告框。可以在开始处理安全事务时，通过重定向解决。</p>
<h2 id="14-8-通过代理以隧道形式传输安全流量"><a href="#14-8-通过代理以隧道形式传输安全流量" class="headerlink" title="14.8 通过代理以隧道形式传输安全流量"></a>14.8 通过代理以隧道形式传输安全流量</h2><p>客户端通常会用Web代理服务器代表它们来访问Web服务器。代理是防火墙路由器唯一允许 进行HTTP流量交换的设备，它可能会进行病毒检测或其他的内容控制工作。但只要客户端用服务器的公钥对发往服务器的数据进行加密，代理就不能读取HTTP首部，也就无法知道应该将请求转向何处。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/e4EUHGJDPcs6MXZ.png"
                      alt="ioF0MOUNikHKQnIO__thumbnail.png"
                ></p>
<p>解决方案：<strong>HTTPS SSL 隧道协议</strong>。客户端在开始加密之前，通过CONNECT的扩展方法发送以明文形式的要连接的安全主机和端口信息，告知给代理，客户端会等待来自代理的响应。e.g.  CONNECT home.netscape.com:443   HTTP/1. 0</p>
<p>代理会对请求进行评估，确保它有效且用户有权请求这样一条连接。如果正常，代理会建立到目标服务器的连接。如果成功，就向客户端发送条200 Connection Established响应。之后直接在客户端和服务器之间以隧道形式传输数据。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>16-国际化</title>
    <url>/2021/03/05/note/HTTP/16-%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<p>HTTP应用程序使用字符集编码请求和显示不同字母表中的文本，它们使用语言标记根据用户所理解的语言来说明并限制内容。</p>
<h2 id="16-1-HTTP对国际性内容的支持"><a href="#16-1-HTTP对国际性内容的支持" class="headerlink" title="16.1 HTTP对国际性内容的支持"></a>16.1 HTTP对国际性内容的支持</h2><p>服务器通过Content-Type首部中的charset参数和content-Language首部告知客户端文档的字母表和语言。</p>
<p>客户端发送Accept-Charset首部和Accept-Language首部，告知服务器它理解哪些字符集编码算法和语言以及其中的优先顺序。</p>
<h2 id="16-2-字符集与HTTP"><a href="#16-2-字符集与HTTP" class="headerlink" title="16.2 字符集与HTTP"></a>16.2 字符集与HTTP</h2><h3 id="16-2-1-字符集是把字符转换为二进制码的编码"><a href="#16-2-1-字符集是把字符转换为二进制码的编码" class="headerlink" title="16.2.1 字符集是把字符转换为二进制码的编码"></a>16.2.1 字符集是把字符转换为二进制码的编码</h3><p>HTTP字符集的值说明如何把实体内容的二进制码转换为特定字母表中的字符。每个字符集标记都命名了一种把二进制码转换为字符的算法（反之亦然）。</p>
<h3 id="16-2-2-字符集和编码如何工作"><a href="#16-2-2-字符集和编码如何工作" class="headerlink" title="16.2.2 字符集和编码如何工作"></a>16.2.2 字符集和编码如何工作</h3><p>在图16-2a中，文档中的二进制码被转换成字符代码，它表示了特定编码字符集中某个特定编号的字符。在这个例子里，解码后的字符代码是数字编号225.</p>
<p>在图16-2b中，字符代码用于从编码的字符集中选择特定的元素。在iso-8859-6中，值225对应阿拉伯字母”FEH”。在步骤a和b中使用的算法取决于MIME的charset标记。</p>
<p>国际化字符系统的关键目标是把语义和表示隔离开来。HTTP只关心字符数据和相关语言及字符集标签的传输。字符形状的显示是由用户的图形显示软件完成的，如图16-2c所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/YQCaD1G28o5Swdz.png"
                      alt="image.png"
                ></p>
<h2 id="16-3-多语言字符编码入门"><a href="#16-3-多语言字符编码入门" class="headerlink" title="16.3 多语言字符编码入门"></a>16.3 多语言字符编码入门</h2><h3 id="16-3-1-字符集术语"><a href="#16-3-1-字符集术语" class="headerlink" title="16.3.1 字符集术语"></a>16.3.1 字符集术语</h3><p>以下是应当了解的电子化字符系统的8个术语。</p>
<ol>
<li><strong>字符。</strong>字符是指字母、数字、标点、表意文字、符号，或其他文本形式的唯一书写“原子”。由统一字符集（Universal Character Set，UCS，非正式名字Unicode）首创。</li>
<li><strong>字形。</strong>描述字符的笔画图案或唯一的图形化形状，每个字符可以有很多不同的字形。</li>
<li><strong>编码后的字符。</strong>分配给字符的唯一数字编号。</li>
<li><strong>代码空间。</strong>计划用于字符代码值的整数范围。</li>
<li><strong>代码宽度。</strong>每个（固定大小的）字符代码所用的位数。</li>
<li><strong>字符库。</strong>特定的工作字符集（全体字符的一个子集）。</li>
<li><strong>编码后的字符集。</strong>组成字符库的已编码字符集，并为每个字符分配代码空间中的一个代码。</li>
<li><strong>字符编码方案。</strong>把数字化的字符代码编码成一系列二进制码（并能相应地反向解码）的算法。字符编码方案可用来减少识别字符所需要的数据总量（压缩）、解决传输限制、统一重叠編码字符集。<h3 id="16-3-2-字符集的命名很糟糕"><a href="#16-3-2-字符集的命名很糟糕" class="headerlink" title="16.3.2 字符集的命名很糟糕"></a>16.3.2 字符集的命名很糟糕</h3></li>
</ol>
<p>从技术上说，MIME中的charset标记描述的是把数据位映射为唯一的字符的一整套算法。它是字符编码方案（character encoding scheme）和编码后的字符集（coded character set）这两种概念的组合。</p>
<h3 id="16-3-3-编码后的字符集"><a href="#16-3-3-编码后的字符集" class="headerlink" title="16.3.3 编码后的字符集"></a>16.3.3 编码后的字符集</h3><p>码后的字符集把整数映射到字符。编码后的字符集经常用数组来实现，通过代码数值来索引，数组的元素就是字符。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/9CWXzZRbD7iJGdN.png"
                      alt="image _1_.png"
                ></p>
<h3 id="16-3-4-字符编码方案"><a href="#16-3-4-字符编码方案" class="headerlink" title="16.3.4 字符编码方案"></a>16.3.4 字符编码方案</h3><p>字符编码方案规定如何把字符的代码数字打包装入内容比特，以及在另一端如何将其解包回字符代码（参见图16-7）。字符编码方案有以下3种主要类型。</p>
<ol>
<li><strong>固定宽度。</strong>固定宽度方式的编码用固定数量的比特表示每个编码后的字符。它们能被快速处理，但可能会浪费空间。如8位。</li>
<li><strong>可变宽度（无模态）。</strong>可变宽度方式的编码对不同的字符代码数字采用不同数量的比特。对于常用字符，这样可以减少需要的位数，而且还能在允许使用多字节来表示国际性字符的同时，保持对传统8位字符集的兼容性。如UTF-8。</li>
<li><strong>可变宽度（有模态）。</strong>有模态的编码使用特殊的“转义”模式在不同的模态之间切换。例如，可以用有模态的编码在文本中使用多个互相有重叠的字符集。有模态的编码处理起来比较复杂，但它们可以有效地支持复杂的书写系统。如iso-2022-jp。<h2 id="16-4-语言标记与HTTP"><a href="#16-4-语言标记与HTTP" class="headerlink" title="16.4 语言标记与HTTP"></a>16.4 语言标记与HTTP</h2></li>
</ol>
<p>语言标记有一个或多个部分，用连字号分隔，称为子标记：第一个子标记称为主子标记，其值是标准化的en、zh，第二个子标记是可选的，遵循它的命名标准；其他尾随的子标记都是未注册的。主子标记中只能含有字母（A-z），其后的子标记可以含有字母和数字，长度最多8个字符。</p>
<h2 id="16-5-国际的URI"><a href="#16-5-国际的URI" class="headerlink" title="16.5 国际的URI"></a>16.5 国际的URI</h2><h3 id="16-5-1-URI字符集合"><a href="#16-5-1-URI字符集合" class="headerlink" title="16.5.1 URI字符集合"></a>16.5.1 URI字符集合</h3><p>URI中允许出现的US-ASCI字符的子集，可以被分成<strong>保留</strong>、<strong>未保留</strong>以及<strong>转义字符</strong>这几类。未保留的字符可用于URI允许其出现的任何部分。保留的字符在很多URI中都有特殊的含义，因此一般来说不能使用它们。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/gNGEMCxcHwLW9sy.png"
                      alt="image _2_.png"
                ></p>
<h3 id="16-5-3-转义和反转义"><a href="#16-5-3-转义和反转义" class="headerlink" title="16.5.3 转义和反转义"></a>16.5.3 转义和反转义</h3><p>可以在URI内部插入保留字符以及原本不支持的字符，每个转义是一组3字符序列，由百分号（%）后面跟上两个十六进制数字的字符。这两个十六进制数字就表示一个US-ASCI字符的代码。例如，要在URL中插入一个空白（ASCII 32），可以用转义%20，</p>
<p>在内部处理时，HTTP应用程序应当在传输和转发URI的时候保持转义不变,HTTP应用程序应该仅在需要数据的时候才对URI进行转义。需要注意，要转义的值本身应该在US-ASCI代码值的范围内（0~127）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>18-Web主机托管</title>
    <url>/2021/03/05/note/HTTP/18-Web%E4%B8%BB%E6%9C%BA%E6%89%98%E7%AE%A1/</url>
    <content><![CDATA[<h2 id="18-1-主机托管服务"><a href="#18-1-主机托管服务" class="headerlink" title="18.1 主机托管服务"></a>18.1 主机托管服务</h2><p>对内容资源的存储、协调以及管理的职责统称为Web主机托管。如果不想自行管理服务器所需的软硬件，就需要主机托管服务。</p>
<h2 id="18-2-虚拟主机托管"><a href="#18-2-虚拟主机托管" class="headerlink" title="18.2 虚拟主机托管"></a>18.2 虚拟主机托管</h2><p>Web托管者通过让一些顾客共享一台计算机来提供便宜的Web主机托管服务。这称为共享主机托管或虚拟主机托管。每个网站看起来是托管在不同的服务器上，但实际上是托管在同一个物理服务器上。但这不一定意味着上千个网站是用一台PC机来提供服务的。托管者可以创建同样的服务器，称为服务器集群（server farm），把负载分摊在群里的服务器上。</p>
<h3 id="18-2-1-虚拟服务器请求缺乏主机信息"><a href="#18-2-1-虚拟服务器请求缺乏主机信息" class="headerlink" title="18.2.1 虚拟服务器请求缺乏主机信息"></a>18.2.1 虚拟服务器请求缺乏主机信息</h3><p>HTTP/1.0请求没有包含主机名信息，因此不能支持托管了多个网站的Web服务器。HTТP/1.1支持Host首部解决了这个问题.</p>
<h3 id="18-2-2-设法让虚拟主机托管正常工作"><a href="#18-2-2-设法让虚拟主机托管正常工作" class="headerlink" title="18.2.2 设法让虚拟主机托管正常工作"></a>18.2.2 设法让虚拟主机托管正常工作</h3><p>原始HTTP规范错误地假设了每个Web服务器上只托管了一个网站，正因为如此，URL中的主机名信息被当作冗余信息剥离了，只要求发送路径部分。但将现存的应用程序都升级到HTTP/1.1规范还需要很长时间。在此期间，涌现了以下4种技术。</p>
<ol>
<li><strong>通过URL路径进行虚拟主机托管</strong></li>
</ol>
<p>在URL中增添专门的路径部分，以便服务器判断是哪个网站，但这不是一个好办法。</p>
<ol start="2">
<li><strong>通过端口号进行主机托管</strong></li>
</ol>
<p>为每个站点分配不同的端口号，这样请求就由Web服务器的单独实例来处理。但终端用户不乐意在URL中指定非标准的端口号。</p>
<ol start="3">
<li><strong>通过IP地址进行主机托管</strong></li>
</ol>
<p>为不同的虚拟站点分配专门的IP地址，把这些地址都绑定到一台单独的机器上。</p>
<ol start="4">
<li><strong>通过Host首部进行主机托管</strong></li>
</ol>
<p>HTTP/1.0的增强版和HTTP/1.1的正式版定义了Host请求首部来携带网站名称。</p>
<h3 id="18-2-3-HTТP-1-1的нost首部"><a href="#18-2-3-HTТP-1-1的нost首部" class="headerlink" title="18.2.3 HTТP/1.1的нost首部"></a>18.2.3 HTТP/1.1的нost首部</h3><p>对于没有进行虚拟主机托管，且不允许资源随请求主机的不同而变化的原始服务器来说，可以忽略Host首部字段的值，否则都必须判断其所请求的资源时使用下列规则。</p>
<p>（1）如果HTTP请求报文中的URL是绝对的（包含方案和主机部分），就忽略Host首部的值。</p>
<p>（2）如果HTTP请求报文中的URL没有主机部分，而请求带有Host首部，则主机/端口的值就从Host首部中取。</p>
<p>（3）如果前两部都无法获得有效的主机，就向客户端返回400 Bad Request响应。</p>
<p>如果客户端显式地使用代理服务器，客户端必须把原始服务器，而非代理服务器的名字和端口放在Host首部中。</p>
<h2 id="18-3-使网站更可靠和更快"><a href="#18-3-使网站更可靠和更快" class="headerlink" title="18.3 使网站更可靠和更快"></a>18.3 使网站更可靠和更快</h2><p>服务器集群和分布式代理缓存或反向代理服务器分散网络流量，避免拥塞。分发内容使之更靠近终端用户，传输时间更短。客户端和服务器间传输的方式是影响资源访问速度最主要的因素。加速网站访问的另一种方法是对内容进行编码以便更快地传输。</p>
<h3 id="18-3-1镜像的服务器集群"><a href="#18-3-1镜像的服务器集群" class="headerlink" title="18.3.1镜像的服务器集群"></a>18.3.1镜像的服务器集群</h3><p>服务器集群是一排配置相同的Web服务器，互相可以替换。每个服务器上的内容可以通过镜像复制，这样当某个服务器出问题的时候，其他的可以顶上。</p>
<p>镜像的服务器常常组成层次化的关系。某个服务器它含有原始内容，这个服务器称为<strong>主原始服务器</strong>（master origin server），从主原始服务器接收内容的镜像服务器称为<strong>复制原始服务器</strong>（replica origin server）。镜像Web服务器可以在不同的地点包含同样内容的副本。</p>
<p>一种简单的部署服务器集群的方法是用网络交换机把请求分发给服务器。托管在服务器上的每个网站的IP地址就设置为交换机的IP地址。</p>
<p>在图18-6显示的镜像服务器集群中，主原始服务器负责把内容发送给复制原始服务器。对集群外部来说，内容所在的IP地址就是交换机的IP地址。交换机负责把请求发送到服务器上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/iPrAHfGDqR8Mesd.png"
                      alt="image _2_.png"
                ></p>
<p>有以下两种方法把客户端的请求导向特定的服务器。</p>
<ol>
<li><strong>HTTP重定向</strong></li>
</ol>
<p>该内容的URL会解析到主服务器的IP地址，然后它会发送重定向到复制服务器。</p>
<ol start="2">
<li><strong>DNS重定向</strong></li>
</ol>
<p>该内容的URL会解析到4个IP地址，DNS服务器可以选择发送给客户端的IP地址。</p>
<h3 id="18-3-2-内容分发网络"><a href="#18-3-2-内容分发网络" class="headerlink" title="18.3.2 内容分发网络"></a>18.3.2 内容分发网络</h3><p>内容分发网络（CDN）就是对特定内容进行分发的专门网络。这个网络中的节点可以是Web服务器、反向代理或缓存。</p>
<h3 id="18-3-3-CDN中的反向代理缓存"><a href="#18-3-3-CDN中的反向代理缓存" class="headerlink" title="18.3.3 CDN中的反向代理缓存"></a>18.3.3 CDN中的反向代理缓存</h3><p>上图中，复制原始服务器可以用反向代理（也称为替代物）缓存来代替。反向代理缓存可以像镜像服务器一样接受服务器请求。它们代表原始服务器中的一个特定集合来接收服务器请求。</p>
<p>反向代理和镜像服务器之间的区别在于反向代理通常是需求驱动的。它们不保存原始服务器的全部内容副本，而是客户端请求的那部分内容。为了更容易地访问就是高请求率的内容，有些反向代理可以在用户请求之前就从服务器上载入内容。</p>
<h3 id="18-3-4-CDN中的代理缓存"><a href="#18-3-4-CDN中的代理缓存" class="headerlink" title="18.3.4 CDN中的代理缓存"></a>18.3.4 CDN中的代理缓存</h3><p>与反向代理不同，传统的代理缓存能收到发往任何Web服务器的请求。（代理缓存与原始服务器之间不需要有任何工作关系或IP地址约定。）。某些代理缓存也可以预先载入热点内容。</p>
<p>按需驱动的代理缓存也可以部署在拦截环境，在这种情况下，交换机或路由器会拦截Web流量并将其发送给代理缓存。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>20-重定向与负载均衡</title>
    <url>/2021/03/05/note/HTTP/20-%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="20-1-为什么要重定向"><a href="#20-1-为什么要重定向" class="headerlink" title="20.1 为什么要重定向"></a>20.1 为什么要重定向</h2><p>由于HTTP应用程序需要可靠地执行HTTP事务、最小化时延、节约网络带宽，Web内容通常分布在很多地方。可以将重定向当作一组有助于找到“最佳”分布式内容的技术。</p>
<p>多数重定向部署都包含了某些形式的负载均衡。也就是它们可以将输入报文的负载分摊到一组服务器中去。反之，因为输入报文一定会在分担负荷的服务器之间进行某种分布，所以任意形式的负载均衡中都包含了重定向。</p>
<h2 id="20-2-重定向到何地"><a href="#20-2-重定向到何地" class="headerlink" title="20.2 重定向到何地"></a>20.2 重定向到何地</h2><p>从很多重定向技术都可用于服务器、代理、缓存和网关。一些重定向技术是专门为特定类型的端点设计的，没有通用性。</p>
<p>Web服务器会根据每个IP来处理请求，把对某特定URL的每条请求都发送到最佳的Web服务器上去（最靠近客户端的、或负载最轻的或采用其他优化策略选择的服务器）。</p>
<h2 id="20-3-重定向协议概览"><a href="#20-3-重定向协议概览" class="headerlink" title="20.3 重定向协议概览"></a>20.3 重定向协议概览</h2><p>重定向的目标是尽快地将HTTP报文发送到最佳的Web服务器上去。HTTP报文传输的方向会受到HTTP应用程序和报文经由的路由设备的影响，浏览器配置、DNS，TCP/P路由以及HTTP都提供了重定向报文的机制。比如。</p>
<ol>
<li>配置创建客户端报文的浏览器应用程序，使其将报文发送给代理服务器。</li>
<li>DNS解析程序会选择用于报文寻址的IP地址。</li>
<li>报文经过网络传输时，会被划分为一些带有地址的分组，交换机和路由器会检查分组中的TCP/IP地址，并据此来确定分组的发送路线。</li>
<li>Web服务器可以通过HTTP重定向将请求反弹给不同的Web服务器。</li>
</ol>
<p>20.4 通用的重定向方法</p>
<h3 id="20-4-1-HTTP重定向"><a href="#20-4-1-HTTP重定向" class="headerlink" title="20.4.1 HTTP重定向"></a>20.4.1 HTTP重定向</h3><p>处理重定向的服务器（重定向服务器）找到可用的负载最小的内容服务器，并将浏览器重定向到那台服务器上去。HTTP重定向的优点之一就是重定向服务器知道客户端的IP地址；理论上来讲，它可以做出更合理的选择。</p>
<p>HTTP重定向可以在服务器间导引请求，但它有以下几个缺点。</p>
<ol>
<li>需要原始服务器进行大量处理来判断要重定向到哪台服务器上去。</li>
<li>增加了用户时延，因为访问页面时要进行两次往返。</li>
<li>如果重定向服务器出故障，站点就会瘫痪。</li>
</ol>
<p>由于存在这些弱点，HTTP重定向通常都会与其他一种或多种重定向技术结合使用。</p>
<h3 id="20-4-2-DNS重定向"><a href="#20-4-2-DNS重定向" class="headerlink" title="20.4.2 DNS重定向"></a>20.4.2 DNS重定向</h3><p>DNS允许将几个IP地址关联到一个域中，可以配置DNS解析程序，以返回可变的IP地址。</p>
<p><strong>DNS轮转</strong>:DNS服务器都会在每次完成查询之后对地址进行轮转。由于大多数DNS客户端只会使用多地址集中的第一个地址，所以DNS轮转可以在多台服务器间提供负载均衡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Al9KaUwCZBNSx7G.png"
                      alt="image.png"
                ></p>
<p>DNS局限性：没有考虑任何与客户端和服务器的相对位置，或者服务器当前负载有关的因素。其次很多Web浏览器或操作系统都会进行DNS缓存，以减少DNS查找的开销。DNS轮转通常都不会平衡单个客户端的负载。</p>
<p>因此有些增强的DNS服务器会使用其他一些技术来选择地址的顺序。</p>
<ol>
<li><strong>负载均衡算法。</strong>使DNS服务器跟踪服务器上的负载，将最佳Web服务器放在列表最前面。</li>
<li><strong>邻接路由算法。</strong>使DNS服务器尝试着将用户导向最近的服务器。</li>
<li><strong>故障屏蔽算法。</strong>使DNS服务器监视网络状况，将请求绕过出现服务中断或其他故障的地方。</li>
</ol>
<p>通常，运行复杂服务器跟踪算法的DNS服务器就是在内容提供者控制之下的一个权威服务器。</p>
<p>但是，对于那些要查找附近服务器的服务来说，缺点就是权威DNS服务器只能用本地DNS服务器的IP地址决定，而非客户端的IP地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/2Il5cpGM38WotJH.png"
                      alt="image _1_.png"
                ></p>
<h3 id="20-4-3-任播寻址"><a href="#20-4-3-任播寻址" class="headerlink" title="20.4.3 任播寻址"></a>20.4.3 任播寻址</h3><p>在任播寻址中，几个地理上分散的服务器拥有完全相同的IP地址，而且会通过骨干路由器的“最短路径”路由功能将客户端的请求发送给离它最近的服务器。这种方法需要，每台服务器都要向邻近的骨干路由器广告，服务器会通过路由器通信协议与其邻近的骨干路由器通信。骨干路由器收到发送给任播地址的分组时，会像平常一样寻找接受那个IP地址的最近的“路由器”。由于服务器是将自己作为那个地址的路由器广告出去的，所以骨干路由器会将分组发送给服务器。</p>
<p>任播寻址仍是项实验性技术。要使用分布式任播技术，服务器须使用“路由器语言”，且路由器必须能够处理可能出现的地址冲突，因为因特网地址基本都是假定一台服务器只有一个地址的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Nrh85dgCUJTPGFI.png"
                      alt="image _2_.png"
                ></p>
<h3 id="20-4-4IP-MAC转发"><a href="#20-4-4IP-MAC转发" class="headerlink" title="20.4.4IP MAC转发"></a>20.4.4IP MAC转发</h3><p>在以太网中，HTTP报文都是以携带地址的数据分组的形式发送的。每个分组有一个的MAC地址，这是第二层设备（通常是交换机和HUB）会接收具有特定输入MAC地址的分组，然后将其转发到特定的输出MAC地址上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/VEoGWqiDmRNaLZB.png"
                      alt="image _3_.png"
                ></p>
<p>通常，如果缓存中没有请求需要的HTTP内容，代理缓存就会代表客户端向此内容的原始服务器发送一条HTTP请求。交换机会将端口80的请求从代理（MAC6）发送给因特网网关（MAC5）</p>
<p>支持MAC转发的第四层交换机通常会将请求转发给几个代理缓存，并在它们之间平衡负载。因为MAC地址转发只是点对点的，所以服务器或代理只能位于离交换机一跳远的地方。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/2TdyikbQZLY1IWJ.png"
                      alt="QQ截图20210304204846.png"
                ></p>
<h3 id="20-4-5-IP地址转发"><a href="#20-4-5-IP地址转发" class="headerlink" title="20.4.5 IP地址转发"></a>20.4.5 IP地址转发</h3><p>在IP地址转发中，交换机或其他第四层设备会检测输入分组中的TCP/IP地址，并通过修改目的IP地址，对分组进行相应的转发。与MAC转发相比，优点是目标服务器只要位于交换机的上游就行，而非一跳远的地方，而且通常第三层的端到端因特网路由都会将分组传送到正确的地方。</p>
<p>这种类型的转发也称为NAT（Network Address Translation，网络地址转换）。</p>
<p>缺点在于，因为从客户端接受输入TCP连接的交换机管理着连接，交换机必须通过那条TCP连接将响应回送给客户端。这样，所有来自目标服务器或代理的响应都必须返回给交换机。服务器或代理可能看不到真正的客户端IP地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/pyioQk2YVaBXsEc.png"
                      alt="image _4_.png"
                ></p>
<p>有以下两种方式可以控制响应的返回路径。</p>
<ol>
<li>将分组的源IP地址改成交换机的IP地址。这种方式被称为完全NAT（full NAT），其中的IP转发设备会对目的IP地址和源IP地址都进行转换。缺点是服务器不知道客户端的IP地址（当涉及到认证和计费），因为从客户端接受输入TCP连接的交换机管理着连接，交换机必须通过那条TCP连接将响应回送给客户端，所有来自目标服务器或代理的响应都必须返回给交换机。</li>
<li>如果源IP地址仍然是客户端的IP地址，就要确保没有从服务器到客户端的直接路由（绕过交换机的）。这种方式被称为半NAT（half NAT），这种方法的优点是服务器知道客户端的IP地址，但缺点是要对客户端和服务器之间的整个网络都有某种程度的控制。<h3 id="20-4-6-网元控制协议"><a href="#20-4-6-网元控制协议" class="headerlink" title="20.4.6 网元控制协议"></a>20.4.6 网元控制协议</h3></li>
</ol>
<p>NECP（Network Element Control Protocol，网元控制协议）允许网元（NE，路由器和交换机等负责转发IP分组的设备）与服务器元素（SE，web服务器和代理缓存等提供应用层请求的设备）进行交互。NECP并未显式提供对负载均衡的支持；它只是为SE提供了一种发送负载均衡信息给NE的方式，这样NE就可以在它认为合适的情况下进行负载均衡了。与WCCP一样，NECP也提供了几种转发分组的方式：MAC转发、GRE封装和NAT.</p>
<p>NECP支持例外。SE可以决定它不能为某些特定的源IP地址提供服务，并将这些地址发送给NE，然后，NE可以将来自这些IP地址的请求转发给原始服务器。</p>
<h2 id="20-5-代理的重定向方法"><a href="#20-5-代理的重定向方法" class="headerlink" title="20.5 代理的重定向方法"></a>20.5 代理的重定向方法</h2><p>客户端如何知道要连接到某个代理，可以用3种方法来判断：显式的浏览器配置，动态自动配置以及透明拦截。</p>
<h3 id="20-5-1-显式浏览器配置"><a href="#20-5-1-显式浏览器配置" class="headerlink" title="20.5.1 显式浏览器配置"></a>20.5.1 显式浏览器配置</h3><p>用户可以在大多数浏览器中输入代理的名字或IP地址以及端口号。但有些服务提供商不允许用户配置普通浏览器来使用代理，它们会要求用户下载事先配置好的浏览器。</p>
<p>显式浏览器配置有以下两个主要的缺点。</p>
<ol>
<li>在代理无法响应的情况下或浏览器配置代理错误，也不会去联系原始服务器。</li>
<li>如果代理出现网络架构方面的变动，用户都要修改浏览器代理设置。<h3 id="20-5-2-代理自动配置"><a href="#20-5-2-代理自动配置" class="headerlink" title="20.5.2 代理自动配置"></a>20.5.2 代理自动配置</h3></li>
</ol>
<p>代理自动配置（PAC）协议：自动的动态配置浏览器，连接到正确的代理服务器，可以解决上面提出的问题。PAC的基本思想是让浏览器去获取一个称为PAC的特殊文件，这个文件说明了每个URL所关联的代理。缺点是必须要对浏览器进行配置，让它知道要从哪个服务器获取PAC文件。</p>
<h2 id="20-5-3-Web代理自动发现协议（略）"><a href="#20-5-3-Web代理自动发现协议（略）" class="headerlink" title="20.5.3 Web代理自动发现协议（略）"></a>20.5.3 Web代理自动发现协议（略）</h2><p>WPAD（Web代理自动发现协议）的目标是在不要求终端用户手工配置代理设置，而且不依赖透明流量拦截的情况下，为Web浏览器提供一种发现并使用附近代理的方式。</p>
<p>实现WPAD协议的HTTP客户端：用WPAD找到PAC文件的配置URL（CURL），根据这个CURL获取PAC文件，执行PAC文件来确定代理服务器，向那个代理服务器发送HTTP请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/FOXqjtdfATC1lBo.png"
                      alt="image _5_.png"
                ></p>
<h2 id="20-6-缓存重定向方法"><a href="#20-6-缓存重定向方法" class="headerlink" title="20.6 缓存重定向方法"></a>20.6 缓存重定向方法</h2><p>WCCP协议可以使路由器将Web流量重定向到代理缓存中去。WCCP负责路由器和缓存服务器之间的通信，这样路由器就可以对缓存进行验证（确保启动且运行），在缓存之间进行负载均衡，并将特定类型的流量发送给特定的缓存了。</p>
<p>下面是WCCP重定向在HTTP上工作过程的概述。</p>
<ol>
<li>启动包含了一些支持WCCP的路由器和缓存的网络，这些路由器和缓存之间可以相互通信。</li>
<li>一组路由器及其目标缓存构成一个WCCP服务组。服务组的配置说明了要将何种流量发往何处、流量是如何发送的以及如何在服务组的缓存之间进行负载均衡。</li>
<li>若服务组配置为重定向HTTP流量，服务组中路由器就将HTTP请求发送给服务组中的缓存。</li>
<li>HTTP请求抵达服务组中的路由器时，路由器会（根据对请求IP地址的散列，或者“掩码/值”的配对策略）选择服务组中的某个缓存为请求提供服务。</li>
<li>路由器向缓存发送请求分组，可以用缓存的IP地址来封装分组，也可通过IP MAC转发实现。</li>
<li>如果缓存无法为请求提供服务，就将分组返回给路由器进行普通的转发。</li>
<li>服务组中的成员会互相交换心跳报文，不断验证对方的可用性。<h2 id="20-7-因特网缓存协议"><a href="#20-7-因特网缓存协议" class="headerlink" title="20.7 因特网缓存协议"></a>20.7 因特网缓存协议</h2></li>
</ol>
<p>ICP（因特网缓存协议）允许缓存在自身没有请求的内容的情况下，在其兄弟缓存中查找命中内容，以避免查询原始服务器而带来的更多开销。</p>
<p>ICP会同时去询问附近的多个缓存，看看它们的缓存中是否有特定的URL，附近的缓存如果有就会返回一个简短的报文HIT，否则返回MISS。缓存就可以打开一条到拥有此对象的邻居缓存的HTTP连接。但ICP请求内容时只使用了URL，所以会降低缓存命中率。</p>
<p>ICP报文是一个以网络字节序表示的32位封装结构，为提高效率，可由UDP数据报承载其报文。但UDP是一种不可靠的因特网协议，因此使用ICP的程序要具有超时功能，以检测丢失的数据报。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/54XhGHIWUtJS1cz.png"
                      alt="image _6_.png"
                ></p>
<h2 id="20-8-缓存阵列路由协议"><a href="#20-8-缓存阵列路由协议" class="headerlink" title="20.8 缓存阵列路由协议"></a>20.8 缓存阵列路由协议</h2><p>通过CARP（缓存阵列路由协议）协议来管理一组代理服务器，多个代理服务器的负载分散到一组服务器上。CARP是ICP的一个替代品。它们都允许管理者通过使用多个代理服务器来提高性能。</p>
<p>通过ICP协议连接起来的每个代理服务器都是将内容进行了冗余镜像的独立缓存服务器，在不同的代理服务器之间复制Web对象条目是可行的。相反，用CARP连接起来的一组服务器会被当作一个大型的缓存服务器，其中每个组件服务器都只包含全部缓存文档中的一部分。</p>
<p>通过对某个Web对象的URL应用散列函数，CARP就可以将此对象映射到特定的代理服务器上去，所以可以通过单次查找确定对象的位置，无须去查询集合中配置的每个代理服务器。</p>
<p>但CARP的缺点是，如果某个代理服务器不可用了，就要重新修改散列表，而且必须重新配置现存代理服务器上的内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/GYDefJaBXAbCdS4.png"
                      alt="image _7_.png"
                ></p>
<h2 id="20-9-超文本缓存协议（略）"><a href="#20-9-超文本缓存协议（略）" class="headerlink" title="20.9 超文本缓存协议（略）"></a>20.9 超文本缓存协议（略）</h2><p>HTCP（超文本缓存协议）允许兄弟缓存之间通过URL和所有的请求及响应首部来相互查询文档是否存在，以降低错误命中的可能。而且HTCP允许兄弟缓存监视或请求在对方的缓存中添加或删除所选中的文档，并修改对方已缓存文档的缓存策略。ICP和HTCP事务之间的区别体现在请求和响应细节上。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>17-内容协商与转码</title>
    <url>/2021/03/05/note/HTTP/17-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E8%BD%AC%E7%A0%81/</url>
    <content><![CDATA[<h2 id="17-1-内容协商技术"><a href="#17-1-内容协商技术" class="headerlink" title="17.1 内容协商技术"></a>17.1 内容协商技术</h2><p>有3种方法可以决定服务器上哪个页面最适合客户端：让客户端来选择、服务器自动判定，或让中间代理来选。这3种技术分别称为客户端驱动的协商、服务器驱动的协商以及透明协商。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/5zJXLQxF7H2j8Em.png"
                      alt="image.png"
                ></p>
<h2 id="17-2-客户端驱动的协商"><a href="#17-2-客户端驱动的协商" class="headerlink" title="17.2 客户端驱动的协商"></a>17.2 客户端驱动的协商</h2><p>从实现原理上来说，服务器实际上有两种方法为客户端提供选项：一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息，另一种方法是发送回HTTP/1.1响应时，使用300 Multiple Choices响应代码。</p>
<p>除了增加时延且对每个页面都要进行繁琐的多次请求之外，这种方法还有一个缺点：它需要多个URL：公共页面要一个，其他每种特殊页面也都要一个。</p>
<h2 id="17-3-服务器驱动的协商"><a href="#17-3-服务器驱动的协商" class="headerlink" title="17.3 服务器驱动的协商"></a>17.3 服务器驱动的协商</h2><p>有两种机制可供HTTP服务器评估发送什么响应给客户端比较合适。</p>
<ol>
<li><strong>检查内容协商首部集</strong>。服务器察看客户端发送的Accept首部集，设法用相应的响应首部与之匹配。</li>
<li><strong>根据其他（非内容协商）首部进行变通</strong>。例如，服务器根据客户端发送的User-Agent首部来发送响应。<h3 id="17-3-1-内容协商首部集"><a href="#17-3-1-内容协商首部集" class="headerlink" title="17.3.1 内容协商首部集"></a>17.3.1 内容协商首部集</h3></li>
</ol>
<p>服务器用表17-3中列出的实体首部集来匹配客户端的Accept首部集。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/wDq85RTpac23ZUE.png"
                      alt="image _1_.png"
                ></p>
<p>注意，由于HTTP是无状态的协议（表示服务器不会在不同的请求之间追踪客户端的偏好），所以客户端必须在每个请求中都发送其偏好信息。</p>
<h3 id="17-3-2-内容协商首部中的质量值"><a href="#17-3-2-内容协商首部中的质量值" class="headerlink" title="17.3.2 内容协商首部中的质量值"></a>17.3.2 内容协商首部中的质量值</h3><p>HTTP协议中定义了质量值q，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。如果服务器依旧匹配客户端的任何偏好的情况下，服务器可以修改文档，也就是对文档进行转码，以匹配客户端的偏好。</p>
<h3 id="17-3-3-随其他首部集而变化"><a href="#17-3-3-随其他首部集而变化" class="headerlink" title="17.3.3 随其他首部集而变化"></a>17.3.3 随其他首部集而变化</h3><p>比如User-Agent首部。侈如，服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p>
<p>由于缓存需要尽力提供所缓存文档中正确的“最佳”版本，HTTP协议定义了服务器在响应中发送的Vary首部。这个首部告知缓存（还有客户端和所有下游的代理）服务器根据哪些首部来决定发送响应的最佳版本。</p>
<h2 id="17-4-透明协商"><a href="#17-4-透明协商" class="headerlink" title="17.4 透明协商"></a>17.4 透明协商</h2><p>HTTP/1.1规范中没有定义任何透明协商机制，但定义了vary首部。服务器在响应中发送了vary首部，以告知中间节点需要使用哪些请求首部进行内容协商。</p>
<p>代理缓存可以为通过单个URL访问的文档保存不同的副本。如果服务器把它们的决策过程传给缓存，这些代理就能代表服务器与客户端进行协商。同时缓存也是进行内容转码的地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码。</p>
<h3 id="17-4-1-进行缓存与备用候选"><a href="#17-4-1-进行缓存与备用候选" class="headerlink" title="17.4.1 进行缓存与备用候选"></a>17.4.1 进行缓存与备用候选</h3><p>服务器使用的与这些首部集匹配的相应实体首部集。缓存也必须使用相同的首部集来决定回送哪个版本的已缓存的响应，从而确保对客户端请求回送的是正确的已缓存响应。</p>
<p>若缓存保存了同一个URL的两份不同的文档，与服务器一样。这些不同的版本称为<strong>变体</strong>（variant）或<strong>备用候选</strong>（alternate）。</p>
<p>当新的请求到达时，缓存会根据内容协商首部集来寻找最佳匹配。但在把文档提供给客户端之前，须检查在已缓存响应中有无发送vary首部。如果有，那么新请求中那些首部的值必须与旧的已缓存请求里相应的首部相同，如果无法匹配，缓存就从原始服务器获取文档。因此为实现透明协商，缓存必须为每个已缓存变体保存客户端请求首部和相应的服务器响应首部。</p>
<h2 id="17-5-转码"><a href="#17-5-转码" class="headerlink" title="17.5 转码"></a>17.5 转码</h2><p>如果服务器没有能满足客户端需求的文档，可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档。这种选项称为<strong>转码</strong>。有3种类别的转码：<strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong>。</p>
<h3 id="17-5-1-格式转换"><a href="#17-5-1-格式转换" class="headerlink" title="17.5.1 格式转换"></a>17.5.1 格式转换</h3><p>格式转换是指将数据从一种格式转换成另一种格式，使之可以被客户端查看。注意，内容转换或转码与内容编码或传输编码不同，后两者一般用于更高效或安全地传输内容，而前两者则为访问设备能够查看内容。</p>
<h3 id="17-5-2-信息综合"><a href="#17-5-2-信息综合" class="headerlink" title="17.5.2 信息综合"></a>17.5.2 信息综合</h3><p>从文档中提取关键的信息片段称为信息综合（information synthesis）。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标。</p>
<h3 id="17-5-3-内容注入"><a href="#17-5-3-内容注入" class="headerlink" title="17.5.3 内容注入"></a>17.5.3 内容注入</h3><p>前面描述的两类转码通常会减少Web文档的内容，而内容注入转码会增加文档的内容。例子有自动广告生成器和用户追踪系统。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>21-日志记录与使用情况跟踪</title>
    <url>/2021/03/08/note/HTTP/21-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<h2 id="21-1-记录内容"><a href="#21-1-记录内容" class="headerlink" title="21.1 记录内容"></a>21.1 记录内容</h2><p>日志的记录出于两种原因：查找服务器或代理中存在的问题，生成Web站点访问方式的统计信息,统计数据用于市场营销、计费和容量规划等。</p>
<h2 id="21-2-日志格式"><a href="#21-2-日志格式" class="headerlink" title="21.2 日志格式"></a>21.2 日志格式</h2><h3 id="21-2-1-常见日志格式"><a href="#21-2-1-常见日志格式" class="headerlink" title="21.2.1 常见日志格式"></a>21.2.1 常见日志格式</h3><p>很多服务器在默认情况下都会使用这种日志格式。表21-1按序列出了常用日志格式中的字段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/xukbWo6RMaAL3fg.png"
                      alt="image.png"
                ></p>
<h3 id="21-2-2-组合日志格式"><a href="#21-2-2-组合日志格式" class="headerlink" title="21.2.2 组合日志格式"></a>21.2.2 组合日志格式</h3><p>另一种常用日志格式为组合日志格式（Combined Log Format）。实际上，它就是常用日志格式的基础上添加了两个字段。</p>
<ol>
<li><strong>User-Agent字段</strong>，用于说明是哪个HTTP客户端应用程序在发起已被记录的请求。</li>
<li><strong>Referer字段</strong>，则提供了更多与请求端在何处找到这个URL的有关信息。<h2 id="21-3-命中率测量"><a href="#21-3-命中率测量" class="headerlink" title="21.3 命中率测量"></a>21.3 命中率测量</h2></li>
</ol>
<p>由于缓存服务器的存在，在不访问原始服务器的情况下就能满足客户端的请求，服务器中没有客户端访问其内容的记录，导致日志文件中出现遗漏。</p>
<p>因此，内容提供者会对其最重要的页面进行缓存清除（cache bust），将某些内容设置为无法缓存，这样所有对此内容的请求都会被导向原始服务器。</p>
<p>由于代理缓存（以及一些客户端）都会保留自己的日志，所以如果服务器能够访问这些日志，就可以避免使用缓存清除。命中率测量协议是对HTTP的一种扩展，命中率测量协议要求缓存周期性地向原始服务器汇报缓存访问的统计数据。</p>
<h3 id="21-3-2-Meter首部"><a href="#21-3-2-Meter首部" class="headerlink" title="21.3.2 Meter首部"></a>21.3.2 Meter首部</h3><p>命中率测量扩展建议使用新增加的首部Meter，缓存和服务器可以通过它在相互间传输与用法和报告有关的指令，这与用来进行缓存指令交换的Cache-Control首部很类似。</p>
<p>表21-10列出了定义的各种指令和谁可以在Meter首部传输这些指令。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/aj7EQXtpW3odUwf.png"
                      alt="image _1_.png"
                ></h2><p>事务的第一部分就是客户端和代理缓存之间一个普通的HTTP事务，但在代理请求中，要注意有插入的Meter首部和来自服务器的响应。这里，代理正在通知服务器它可以进行命中率测量，作为回应，服务器则请求代理报告它的命中次数。</p>
<p>从客户端的角度看，请求正常结束了，代理开始代表服务器跟踪该请求资源的命中次数。稍后代理尝试与服务器再次验证资源，代理会在发送给服务器的条件请求中嵌入它跟踪记录的计量信息。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/TV3AS9Gt5NdgCkD.png"
                      alt="image _2_.png"
                ></h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Common infrastructure</title>
    <url>/2021/03/08/note/HTML%20Standard/Common%20infrastructure/</url>
    <content><![CDATA[<p><strong>Parallelism</strong>并行性，指不同的进程可以同时进行，同时为了避免对相同的数据进行不同的操作，这里使用队列(先进先出)来解决。但所举的例子，没怎么懂。。</p>
<p><strong>Resources</strong>资源，资源能否被支持，取决于资源的格式，是否为critical资源由资源格式的规范来定义，对于CSS样式表，关键子资源是通过@import 规则导入的样式表及其间接导入的样式表。</p>
<p><strong>element type 元素类型，</strong>有local name 和 namespace命名空间，如果属性名称与XML中Name定义的生产匹配，且不包含：，则该属性名称能与XML兼容。</p>
<p><strong>DOM trees</strong>，当有些element和 attribute没有指定值时，会有默认值，比如div标签的display属性默认值就是block，有时呢格局需要我们又会设置为none。当一个node作为插入时的参数时，将连接 browsing-context，remove时，断开 browsing-context连接。<strong>browsing context</strong>是指呈现给用户的document对象内的一个环境。shadowroot 这个概念目前没怎么能理解到，查询得知是 DOM 子树的根节点</p>
<p><strong>Scripting</strong>，foo 更为精确的说应该是interface object</p>
<p><strong>Plugins</strong>，是content handlers 的 implementation-defined set</p>
<p><strong>Character encodings</strong>，字符编码， 是 byte streams 和 Unicode strings之间转换的方式，其中utf-16不兼容ASCII.</p>
<p><strong>Conformance classes</strong>，<strong>Conforming documents</strong>是指遵守 conformance criteria的文档，user agent 无权处理不符合标准的文档。用户代理可以分为Web browsers and other interactive 用户代理、Non-interactive presentation 用户代理、support the suggested default rendering 的Visual 用户代理、不支持 scripting 的用户代理，<strong>UA</strong>使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等</p>
<p><strong>Conformance checkers，</strong>在进行检查时，没有 browsing context和脚本的运行，<strong>conformance criteria</strong>分为三种：通过DTD，通过machine，通过人检查，conformance checker必须满足检查前两种。</p>
<p><strong>Data mining tools，</strong>处理HTML和XML文档的工具和程序<strong>，</strong>除了渲染文档和检查其符合性以外，还要根据其处理的文档语义进行处理。</p>
<p><strong>Authoring tools and markup generators，</strong>Authoring tools 分为两类。一种是 tools that work from structure or semantic data，还有一种tools that work on a WYSIWYG（所见即所得） media-specific editing basis，创作工具 应该能让用户能够创建结构良好，语义丰富，独立于媒体的内容， 规范描述了两种 authoring formats，一种基于XML,另一种， custom format inspired by SGML(标准通用标记语言)，也就是HTML。一些 conformance requirements是对元素、属性、方法、对象的要求，分为两类，一种是内容模型限制的要求（ documents and authoring tools），一种是实现行为的要求（UA） 。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML standard</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Semantics, structure, and APIs of HTML documents</title>
    <url>/2021/03/08/note/HTML%20Standard/Semantics_%20structure_%20and%20APIs%20of%20HTML%20documents/</url>
    <content><![CDATA[<p><strong>Document object</strong>:包含<strong>HTTPS state，</strong>代表传输数据的网络信道的安全属性，<strong>referrer policy、module ma、feature policy、CSP list</strong>包含了内容安全策略</p>
<p>Semantics ，元素、属性、属性值规范都定义了语义，不能用于定义语义以外的目的，不得使用规范以外的元素、属性、属性值。html具有描述进度条的progresss元素。</p>
<p><strong>Elements in the DOM，</strong>HTML元素必须实现规范列出的接口，并将这些接口expose to 脚本。</p>
<p><strong>Element definitions</strong>，每一个元素包含以下信息的定义：类别、Contexts in which this element can be used、内容模型、Tag omission in text/html、内容属性、Accessibility considerations、DOM 接口。</p>
<p><strong>Content models，</strong>每一个元素都内容模型，即对元素预期内容的描述，元素的内容是其dom中的子元素。元素之间允许有空格，元素之间的字符表示为Text，DOM节点，空Text节点和 Text仅由这些字符的序列组成的节点被视为 元素间空格。 在确定元素的内容是否与元素的内容模型匹配时，以及遵循定义文档和元素语义的算法时，必须忽略元素间空格，注释节点和处理指令节点（处理指令节点没懂）。HTML元素可以没有父节点。当元素的内容模型为空，该元素不包含任何Text节点（元素间空格除外）且不包含元素节点。</p>
<p><strong>Kinds of content，</strong>元素可以属于一个或者多个类别，甚至有些元素不属于任何特定类别，</p>
<ol>
<li><strong>Metadata content：</strong>设置其余内容的表示形式或行为、是指文档与其他文档的关系、传达其他 “out of band” 信息的内容。</li>
<li><strong>Flow content：</strong>大多元素都属于这个类别，常见的a、div、table……。</li>
<li><strong>Sectioning content：</strong>用于定义内容标题和页脚，比如article、aside、nav、section。</li>
<li><strong>Heading content：</strong>h1、h2…。</li>
<li><strong>Phrasing content：</strong>分类为Phrasing content的大多元素只能包含Phrasing content的元素。3.2.5.2.5后面一节暂未理解。</li>
<li><strong>Embedded content，</strong>将另一个资源导入文档中的内容，或来自插入到文档中的另一个词汇表中的内容，如audio、video,有些有 fallback content，比如外部资源的格式不支持所显示的内容</li>
<li><strong>Interactive content，</strong>a、button、input。。。。</li>
<li><strong>Palpable content，</strong>没理解</li>
<li><strong>Script-supporting elements，</strong>script、template</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML standard</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>The elements of HTML（三）</title>
    <url>/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="area元素"><a href="#area元素" class="headerlink" title="area元素"></a><strong>area元素</strong></h2><p>图像映射上文本和对应区域的超链接或图像映射上的dead area</p>
<p><strong>Categories</strong>:Flow content、Phrasing content.</p>
<p><strong>Contexts in which this element can be used</strong>:仅当有一个map祖先，phrasing content</p>
<p><strong>Content model</strong>:无</p>
<p><strong>Tag omission in text/html</strong>:没有结束标签</p>
<p><strong>Content attributes:</strong></p>
<p><strong>Global attributes：</strong></p>
<ol>
<li><p>alt —定义此区域的替换文本。</p>
</li>
<li><p>coords — 可点击区域的坐标</p>
</li>
<li><p>shape —定义区域的形状</p>
</li>
<li><p>href — 超链接地址</p>
</li>
<li><p>target — 在何处打开 href 属性指定的目标 URL</p>
</li>
<li><p>download — 是否下载资源后不是导航</p>
</li>
<li><p>ping — URLs to ping</p>
</li>
<li><p>rel —超链接的文档中的位置与目标资源之间的关系</p>
</li>
<li><p>referrerpolicy — Referrer policy</p>
</li>
</ol>
<p>1、area的父元素一定是map</p>
<p>2、area有href属性，代表超链接，这种情况下，必须有alt属性。如果没有href属性，alt属性可以省略，target, download, ping, rel, referrerpolicy 必须省略。</p>
<p>3、shape</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Keywords</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Circle state</td>
<td>circle/circ</td>
<td>必须有 coords 属性（3个整数，最后一个非负）</td>
</tr>
<tr>
<td>Default state</td>
<td>default</td>
<td>不能有 coords 属性</td>
</tr>
<tr>
<td>Polygon state</td>
<td>poly/polygon</td>
<td>必须有 coords 属性（至少6个整数，且是偶数）</td>
</tr>
<tr>
<td>Rectangle state</td>
<td>rect/rectangle</td>
<td>必须有 coords 属性（4个整数，第一个小于第三个，第二个小于第四个）</td>
</tr>
</tbody></table>
<p>4、如果area有itemprop属性，则也必须设置href属性</p>
<h2 id="MathML"><a href="#MathML" class="headerlink" title="MathML"></a><strong>MathML</strong></h2><p>MathML 是数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;math&gt;</span><br><span class="line"></span><br><span class="line">&lt;mi&gt;x&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo&gt;&#x3D;&lt;&#x2F;mo&gt;</span><br><span class="line"></span><br><span class="line">&lt;mfrac&gt;</span><br><span class="line"></span><br><span class="line">&lt;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo form&#x3D;&quot;prefix&quot;&gt;−&lt;&#x2F;mo&gt; &lt;mi&gt;b&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo&gt;±&lt;&#x2F;mo&gt;</span><br><span class="line"></span><br><span class="line">&lt;msqrt&gt;</span><br><span class="line"></span><br><span class="line">&lt;msup&gt; &lt;mi&gt;b&lt;&#x2F;mi&gt; &lt;mn&gt;2&lt;&#x2F;mn&gt; &lt;&#x2F;msup&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo&gt;−&lt;&#x2F;mo&gt;</span><br><span class="line"></span><br><span class="line">&lt;mn&gt;4&lt;&#x2F;mn&gt; &lt;mo&gt;⁢&lt;&#x2F;mo&gt; &lt;mi&gt;a&lt;&#x2F;mi&gt; &lt;mo&gt;⁢&lt;&#x2F;mo&gt; &lt;mi&gt;c&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;msqrt&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;mn&gt;2&lt;&#x2F;mn&gt; &lt;mo&gt;⁢&lt;&#x2F;mo&gt; &lt;mi&gt;a&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mfrac&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;math&gt;</span><br></pre></td></tr></table></figure>
<h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a><strong>SVG</strong></h2><p>是一种用于描述二维的矢量图形，基于 XML 的标记语言。SVG 相对于图像，就好比 HTML 相对于文本。</p>
<p>doc = iframe . getSVGDocument()</p>
<p>doc = embed . getSVGDocument()</p>
<p>doc = object . getSVGDocument()</p>
<p>如果iframe、embed或object元素用于嵌入SVG，则返回Document对象。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML standard</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>The elements of HTML（四）</title>
    <url>/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>表单</strong>是一种网页组件，可以包含表单控件如文本，按钮，复选框，范围或颜色选择器控件。 用户可以与这样的表单进行交互并提供数据，随后这些数据被发送到服务器用于进一步处理 （例如返回搜索或计算结果）。</p>
<p>编写表单的步骤（没有顺序）：编写用户界面、实现服务器端的处理、用户界面与服务器端通信的配置。</p>
<h1 id="用户界面的编写"><a href="#用户界面的编写" class="headerlink" title="用户界面的编写"></a>用户界面的编写</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;  </span><br><span class="line"> &lt;p&gt;&lt;label&gt;Customer name: &lt;input&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;Telephone: &lt;input type&#x3D;tel&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;E-mail address: &lt;input type&#x3D;email&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;fieldset&gt;</span><br><span class="line">  &lt;legend&gt; Pizza Size &lt;&#x2F;legend&gt;   </span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size&gt; Small &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size&gt; Medium &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size&gt; Large &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;&#x2F;fieldset&gt;</span><br><span class="line"> &lt;fieldset&gt;</span><br><span class="line">  &lt;legend&gt; Pizza Toppings &lt;&#x2F;legend&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Bacon &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Extra Cheese &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Onion &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Mushroom &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;&#x2F;fieldset&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;Preferred delivery time: &lt;input type&#x3D;time min&#x3D;&quot;11:00&quot; max&#x3D;&quot;21:00&quot; step&#x3D;&quot;900&quot;&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;Delivery instructions: &lt;textarea&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;button&gt;Submit order&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">**简要说明：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>表单都以form元素开始。多数控件都由 input 元素表示，它默认提供一个文本控件。</li>
<li>使用 label 元素来描述控件，标签文本和控件自己都会进入 label 元素内。</li>
<li>表单的每一部分都是一个段落，一般用 p 元素来与其他部分分隔。</li>
<li>单选按钮用 input 元素，设置 type 属性，值为 radio。 name属性值一样让单选按钮成组。</li>
<li>fieldset 元素让一批控件成为一组，控件组的标题由 fieldset 中的 legend 表示。</li>
<li>这些复选框使用 input 元素， type 属性值为 checkbox：。</li>
<li>电话号码的表单控件（type 属性设为 tel 的 input 元素）， e-mail 地址（type 属性设为 email 的 input 元素）：</li>
<li>type 属性设为 time 的 input 元素来询问配送时间。 很多控件都可以设置可选值的范围；这个例子中的属性是 min, max 和step。这些属性分别用来设置最小时间，最大时间， 以及允许的值之间的间隔（单位为秒）。</li>
<li>textarea 元素可以用来提供多行文本。</li>
<li>为了让表单可以提交，用一个 button 元素。<h1 id="用户界面与服务器端通信的配置"><a href="#用户界面与服务器端通信的配置" class="headerlink" title="用户界面与服务器端通信的配置"></a>用户界面与服务器端通信的配置</h1></li>
</ol>
<p>表单提交通常是GET 或 POST 请求。在 form 元素上使用 method 属性来指定使用哪种方法。 指定编码方式要使用 enctype 属性。action 属性来指定处理提交的数据服务的 URL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">enctype</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;https://pizza.example.com/order.cgi&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每个需要提交的表单控件都要有一个名字来对应提交的数据。属性name指定了提交的名字。他们之间可以通过 value 属性给它们不同的值来区分。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span> <span class="attr">value</span>=<span class="string">&quot;small&quot;</span>&gt;</span> Small <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span> <span class="attr">value</span>=<span class="string">&quot;medium&quot;</span>&gt;</span> Medium <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span> <span class="attr">value</span>=<span class="string">&quot;large&quot;</span>&gt;</span> Large <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="客户端表单验证"><a href="#客户端表单验证" class="headerlink" title="客户端表单验证"></a>客户端表单验证</h1><p>通过表单标记使得用户代理可以在表单提交之前检查用户输入，但服务器仍然必须校验输入是有效的（因为恶意用户可以很容易绕过表单验证）， 但这使我们可以避免因为只能在服务器上检查而造成用户等待。input 元素上的required 属性，表示只有给出值之后表单才可以提交。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Customer name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;custname&quot;</span> <span class="attr">required</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 maxlength 属性来限制输入的长度。 把这个属性添加到 textarea 元素上，我们可以限制用户输入到 1000 字符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Delivery instructions: <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">maxlength</span>=<span class="string">1000</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提交表单时，每个不合法的表单控件上，以及 form 元素上都会触发 invalid 事件， 这个事件可以用来显示表单存在哪些问题的一个描述。</p>
<h1 id="启用表单控件的客户端自动填充"><a href="#启用表单控件的客户端自动填充" class="headerlink" title="启用表单控件的客户端自动填充"></a>启用表单控件的客户端自动填充</h1><p>浏览器可以帮助用户自动填充表单控件，避免让用户每次重新输入。为了帮助用户代理做自动填充，可以使用 autocomplete 属性来描述字段的用途。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Customer name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;custname&quot;</span> <span class="attr">required</span> <span class="attr">autocomplete</span>=<span class="string">&quot;shipping name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="提高用户手机端体验"><a href="#提高用户手机端体验" class="headerlink" title="提高用户手机端体验"></a>提高用户手机端体验</h1><p>有些设备使用inputmode属性为用户提供多种输入方式。例如，在输入信用卡号码时，用户可能希望只看到0-9数字键，而在输入姓名时，用户可能希望看到每个单词默认大写的表单字段。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Buzzer code: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;custbuzz&quot;</span> <span class="attr">inputmode</span>=<span class="string">&quot;number&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="type-autocomplete-inputmode之间的区别"><a href="#type-autocomplete-inputmode之间的区别" class="headerlink" title="type, autocomplete, inputmode之间的区别"></a>type, autocomplete, inputmode之间的区别</h1><p>input元素上的type属性决定用户代理将使用哪种控件来公开字段。</p>
<p>autocomplete属性描述了用户将输入的值实际表示的内容。</p>
<p>当控件是文本控件时，inputmode属性决定使用哪种输入方式。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><table>
<thead>
<tr>
<th><strong>element</strong></th>
<th><strong>meaning</strong></th>
<th><strong>Categories</strong></th>
<th><strong>Contexts in which this element can be used</strong></th>
<th><strong>Content model</strong></th>
<th><strong>Tag omission in text/html</strong></th>
<th><strong>Content attributes</strong></th>
<th><strong>remark</strong></th>
</tr>
</thead>
<tbody><tr>
<td>form</td>
<td>表单</td>
<td>Flow content、Palpable content</td>
<td>flow content</td>
<td>Flow content,但没有form元素后代</td>
<td>不可省略</td>
<td>accept-charset—服务器处理表单数据的字符集action — 表单提交的urlautocomplete—form内控件设置自动填充enctype—发送表单数据之前如何对其进行编码method —表单提交使用的HTTP方法name — 用于使用API时的名称novalidate —表单提交时不用进行验证target —表单提交的上下文rel</td>
<td></td>
</tr>
<tr>
<td>label</td>
<td>为 input 元素定义标注</td>
<td>Flow content、Phrasing content、Interactive content、Palpable content</td>
<td>phrasing content</td>
<td>Phrasing content，但没有后代labelable元素，除非它是元素的 labeled control且没有后代label</td>
<td>不可省略</td>
<td>for — 绑定到哪个表单元素</td>
<td>1.要么通过for属性（属性值和需要绑定控件id一样），要么将控件放在label元素内。</td>
</tr>
</tbody></table>
<h1 id="Input-type"><a href="#Input-type" class="headerlink" title="Input type"></a>Input type</h1><table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>button</td>
<td>定义可单击的按钮（主要与JavaScript一起使用以激活脚本）</td>
<td></td>
</tr>
<tr>
<td>checkbox</td>
<td>定义一个复选框</td>
<td></td>
</tr>
<tr>
<td>color</td>
<td>定义颜色选择器</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>定义日期控件（年，月，日（无时间））</td>
<td></td>
</tr>
<tr>
<td>datetime-local</td>
<td>定义日期和时间控件（年，月，日，时间（无时区））</td>
<td></td>
</tr>
<tr>
<td>file</td>
<td>定义文件选择字段和“浏览”按钮（用于文件上载）</td>
<td></td>
</tr>
<tr>
<td>image</td>
<td>将图像定义为提交按</td>
<td></td>
</tr>
<tr>
<td>month</td>
<td>定义月份和年份控件（无时区）</td>
<td></td>
</tr>
<tr>
<td>number</td>
<td>定义用于输入数字的字段</td>
<td></td>
</tr>
<tr>
<td>password</td>
<td>定义密码字段</td>
<td></td>
</tr>
<tr>
<td>radio</td>
<td>定义单选按钮</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>定义范围控件（如滑块控件）</td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>定义重置按钮</td>
<td></td>
</tr>
<tr>
<td>submit</td>
<td>定义提交按钮</td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>定义用于输入时间的控件（无时区）</td>
<td></td>
</tr>
<tr>
<td>week</td>
<td>定义周和年控制（无时区）</td>
<td></td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏的输入字段</td>
<td>禁止进行约束验证；如果那么name和 <em>charset</em> 值相同，必须省略value属性。</td>
</tr>
<tr>
<td>text</td>
<td>定义单行文本字段</td>
<td>没有指定type值或无效，默认为文本控件。输入值和value值禁止使用回车符或换行符。</td>
</tr>
<tr>
<td>search</td>
<td>定义用于输入搜索字符串的文本字段</td>
<td>没有指定type值或无效，默认为文本控件。输入值和value值禁止使用回车符或换行符。</td>
</tr>
<tr>
<td>tel</td>
<td>定义用于输入电话号码的字段</td>
<td>输入值和value值禁止使用回车符或换行符。不强制使用特定规则</td>
</tr>
<tr>
<td>url</td>
<td>定义用于输入URL的字段</td>
<td>可以为空字符串，但不能使用回车符或换行符。当元素的值既不是空字符串，也不是有效的绝对URL，元素的类型不匹配</td>
</tr>
<tr>
<td>email</td>
<td>定义电子邮件地址的字段</td>
<td>定义电子邮件地址的字段当设置了multiple属性：</td>
</tr>
</tbody></table>
<h1 id="定义电子邮件地址的字段当设置了multiple属性：Input-attribute"><a href="#定义电子邮件地址的字段当设置了multiple属性：Input-attribute" class="headerlink" title="定义电子邮件地址的字段当设置了multiple属性：Input attribute"></a>定义电子邮件地址的字段当设置了multiple属性：Input attribute</h1><table>
<thead>
<tr>
<th align="left">accept</th>
<th align="left">规定通过文件上传来提交</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alt</td>
<td align="left">图像不可用的替代文本</td>
</tr>
<tr>
<td align="left">autocomplete</td>
<td align="left">是否使用输入字段的自动</td>
</tr>
<tr>
<td align="left">checked</td>
<td align="left">首次加载时是否被选中</td>
</tr>
<tr>
<td align="left">dirname</td>
<td align="left">输入字段的文本方向</td>
</tr>
<tr>
<td align="left">disabled</td>
<td align="left">是否禁用此元素</td>
</tr>
<tr>
<td align="left">form</td>
<td align="left">规定输入字段所属的一个</td>
</tr>
<tr>
<td align="left">formaction</td>
<td align="left">覆盖表单的 action 属性</td>
</tr>
<tr>
<td align="left">formenctype</td>
<td align="left">覆盖表单的 enctype 属性</td>
</tr>
<tr>
<td align="left">formmethod</td>
<td align="left">覆盖表单的 method 属性</td>
</tr>
<tr>
<td align="left">formnovalidate</td>
<td align="left">覆盖表单的 novalidate</td>
</tr>
<tr>
<td align="left">formtarget</td>
<td align="left">覆盖表单的 target 属性n</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">预定义的选项列表</td>
</tr>
<tr>
<td align="left">max</td>
<td align="left">输入字段的最大值</td>
</tr>
<tr>
<td align="left">maxlength</td>
<td align="left">输入字段的最大长度</td>
</tr>
<tr>
<td align="left">min</td>
<td align="left">输入字段的最小值</td>
</tr>
<tr>
<td align="left">minlength</td>
<td align="left">输入字段的最小长度</td>
</tr>
<tr>
<td align="left">multiple</td>
<td align="left">是否允许多个值</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">元素名称</td>
</tr>
<tr>
<td align="left">pattern</td>
<td align="left">输入字段的值的格式</td>
</tr>
<tr>
<td align="left">placeholder</td>
<td align="left">用户填写输入字段的提示</td>
</tr>
<tr>
<td align="left">readonly</td>
<td align="left">是否允许用户修改</td>
</tr>
<tr>
<td align="left">required</td>
<td align="left">是否必须填写</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">控件尺寸</td>
</tr>
<tr>
<td align="left">src</td>
<td align="left">资源地址</td>
</tr>
<tr>
<td align="left">step</td>
<td align="left">输入的间隔</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">控件类型</td>
</tr>
<tr>
<td align="left">value</td>
<td align="left">元素的值</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">宽</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">pattern的描述</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML standard</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>01-计算机网络和因特网</title>
    <url>/2021/05/09/note/Computer%20Networking/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1   什么是因特网"></a>1.1   什么是因特网</h2><p>互联网中所有设备都称为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）。可以进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起。</p>
<p>通信链路由不同类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱。当端系统要发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为**<code>分组</code>**（packet），这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p>
<p>分组交换机接收并转发分组，著名的类型有<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>（route或path）。</p>
<p>端系统通过因特网服务提供商<code>（ISP）</code>接入因特网，每个<code>ISP</code>就是一个由多台分组交换机和多段通信链路组成的网络。<code>ISP</code>为端系统和内容提供者提供了各种不同类型的网络接入。因特网就是将端系统彼此互联，因此为端系统提供接入的<code>ISP</code>也必须互联。</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>（protocol），定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。<code>TCP</code>（Transmission Control Protocol，传输控制协议）和<code>IP</code>（Internet Protocol，网际协议）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为<code>TCP/IP</code>。</p>
<p>与因特网相连的端系统提供了一个<strong>套接字接口</strong>（socket interface），是一套发送程序必须遵循的规则集合。该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p>
<h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2   网络边缘"></a>1.2   网络边缘</h2><p><strong>接入网</strong>，是指将端系统物理连接到其边缘路由器（edge router）的网络。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。不同的接入方式如下：    </p>
<ol>
<li><p>DSL</p>
</li>
<li><p>电缆</p>
</li>
<li><p>拨号</p>
</li>
<li><p>卫星</p>
</li>
<li><p>FTTH</p>
</li>
<li><p>以太网</p>
</li>
<li><p>WiFi</p>
</li>
<li><p>蜂窝</p>
</li>
</ol>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3   网络核心"></a>1.3   网络核心</h2><p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>和<strong>分组交换</strong>。</p>
<h3 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1   分组交换"></a>1.3.1   分组交换</h3><p>端系统彼此交换<strong>报文</strong>（message）。报文可以执行一种控制功能，或者包含数据。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为<strong>分组</strong>（packet）。在源和目的地之间，每个分组都通过通信链路和分组交换机（packet switch）传送。</p>
<h4 id="1-3-1-1-存储转发传输"><a href="#1-3-1-1-存储转发传输" class="headerlink" title="1.3.1.1   存储转发传输"></a>1.3.1.1   存储转发传输</h4><p>多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制,是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/07/UAIxaBy4rboWwN3.png"
                      alt="image-20210507152330699"
                ></p>
<h4 id="1-3-1-2-排队时延和分组丢失"><a href="#1-3-1-2-排队时延和分组丢失" class="headerlink" title="1.3.1.2   排队时延和分组丢失"></a>1.3.1.2   排队时延和分组丢失</h4><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>，也称为输出队列，如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延。这些时延变化的程度取决于网络的拥塞程度。</p>
<p>因为缓存空间的大小是有限的，当一个到达的分组发现该缓存已被其他等待传输的分组完全充满了，将出现分组丢失（<strong>丢包</strong>），到达的分组或已经排队的分组之一将被丢弃。    </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/07/5f1gaZ94nuvE8oU.png"
                      alt="image-20210507153107447"
                ></p>
<h4 id="1-2-1-3-转发表和路由选择协议"><a href="#1-2-1-3-转发表和路由选择协议" class="headerlink" title="1.2.1.3   转发表和路由选择协议"></a>1.2.1.3   转发表和路由选择协议</h4><p>在因特网中，每个端系统都具有一个IP地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。</p>
<p>每台路由器具有一个由<strong>路由选择协议</strong>自动地设置的转发表，用于将目的地址或目的地址的一部分映射成为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。路由器则将分组导向该出链路。</p>
<h3 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2   电路交换"></a>1.3.2   电路交换</h3><p>在电路交换网络中，端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。</p>
<p>在发送方能够发送信息之前，电路交换网络必须在发送方和接收方之间建立一条连接，该连接被称为一条<strong>电路</strong>，同时在连接期间在该网络链路上预留了恒定的传输速率。</p>
<p>与此相反，一台主机要经过分组交换网络向另一台主机发送分组，该分组被发送进网络，而不预留任何链路资源之类的东西。如果因为此时其他分组也需要经该链路进行传输而使链路之一出现拥塞，则该分组将不得不在传输链路发送侧的缓存中等待而产生时延。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/07/VJATDQ527tz4YmW.png"
                      alt="image-20210507155332872"
                ></p>
<h4 id="1-3-2-1-电路交换网络中的复用"><a href="#1-3-2-1-电路交换网络中的复用" class="headerlink" title="1.3.2.1   电路交换网络中的复用"></a>1.3.2.1   电路交换网络中的复用</h4><p>链路中的电路是通过频分复用（FDM）或时分复用（TDM）来实现的。</p>
<p>对于FDM链路，链路的频谱由跨越链路创建的所有连接共享。在连接期间链路为每条连接专用一个频段。比如在电话网络中，这个频段的宽度通常为4kHz。调频无线电台也使用FDM来共享88MHz~108MHz的频谱，其中每个电台被分配一个特定的频段。</p>
<p>对于TDM链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/07/pAEQVjugsSnGJex.png"
                      alt="image-20210507160841531"
                ></p>
<h4 id="1-3-2-2-分组交换与电路交换的对比"><a href="#1-3-2-2-分组交换与电路交换的对比" class="headerlink" title="1.3.2.2   分组交换与电路交换的对比"></a>1.3.2.2   分组交换与电路交换的对比</h4><p>电路交换不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用。另一方面，分组交换按需分配链路使用。链路传输能力将在所有需要在链路上传输分组的用户之间逐分组地被共享。<br>如今趋势无疑是朝着分组交换方向发展。</p>
<h3 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3   网络的网络"></a>1.3.3   网络的网络</h3><p>接入ISP自身必须互联。有不同的网络结构实现：</p>
<ul>
<li><p>网络结构1</p>
<p>每个接入ISP直接与每个其他接入ISP连接。当然，这样的网状设计对于接入ISP费用太高，因为这将要求每个接入ISP要与世界上数十万个其他接入ISP有一条单独的通信链路。</p>
</li>
<li><p>网络结构2</p>
<p>一种两层的等级结构，不同的全球传输提供商位于顶层，而接入ISP位于底层，但必须保证全球传输ISP之间必须是互联的。</p>
</li>
<li><p>网络结构3</p>
<p>不仅有多个竞争的第一层ISP，而且在一个区域可能有多个竞争的区域ISP，因此在这个等级结构的每一层，都有客户-提供商关系。</p>
</li>
<li><p>网络结构4</p>
<p>由接入ISP、区域ISP、第一层ISP，PoP，多宿、对等和IXP组成。</p>
<p>一个PoP只是提供商网络中的一台或多台路由器（在相同位置）群组，其中客户ISP能够与提供商ISP连接。PoP存在于等级结构的所有层次，但底层（接入ISP）等级除外。对于要与提供商PoP连接的客户网络，它能从第三方电信提供商租用高速链路将它的路由器之一直接连接到位于该PoP的一台路由器。任何ISP（除了第一层ISP）可以选择多宿，即可以与多个提供商ISP连接。</p>
<p>位于相同等级结构层次的邻近一对ISP能够对等（peer），也就是能够直接将它们的网络连到一起，使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输。当两个ISP对等时，通常不进行结算，即任一个ISP不向其对等付费。沿着这些相同路线，第三方公司能创建一个因特网交换点（IXP），IXP是一个汇合点，多个ISP能够在这里一起对等。</p>
</li>
<li><p>网络结构5</p>
<p>在网络结构4顶部增加内容提供商网络构建而成。通过创建自己的网络，内容提供商不仅减少了向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。比如谷歌专用网络可以通过与较低层ISP对等，或者在IXP处与它们连接。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/07/37lahxgMJqUr8dR.png"
                      alt="image-20210507162728777"
                ></p>
<h2 id="1-4-分组交换网中的时延、丢包和吞吐量"><a href="#1-4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="1.4   分组交换网中的时延、丢包和吞吐量"></a>1.4   分组交换网中的时延、丢包和吞吐量</h2><h3 id="1-4-1-分组交换网中的时延概述"><a href="#1-4-1-分组交换网中的时延概述" class="headerlink" title="1.4.1   分组交换网中的时延概述"></a>1.4.1   分组交换网中的时延概述</h3><p>时延最为重要的是<strong>节点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>和<strong>传播时延</strong>，这些时延总体累加起来是节点总时延。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/08/fDruvzeBnZFTjKa.png"
                      alt="image-20210508100453905"
                ></p>
<ol>
<li><p>节点处理时延<br>包括了检查分组首部、决定将该分组导向何处，检查比特级别的差错间。处理之后，路由器将该分组引向通往路由器B链路之前的队列。</p>
</li>
<li><p>排队时延<br>取决于先期到达的正在排队等待向链路传输的分组数量。</p>
</li>
<li><p>传输时延<br>路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。</p>
</li>
<li><p>传播时延<br>等于两台路由器之间的距离除以传播速率。</p>
</li>
</ol>
<h3 id="1-4-2-丢包"><a href="#1-4-2-丢包" class="headerlink" title="1.4.2   丢包"></a>1.4.2   丢包</h3><p>一条链路前的队列只有有限的容量，当到达的分组将发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，即该分组将会丢失。<br>分组丢失的比例随着流量强度增加而增加。因此，一个节点的性能常常不仅根据时延来度量，而且根据丢包的概率来度量。丢失的分组可能基于端到端的原则重传，以确保所有的数据最终从源传送到了目的地。</p>
<h3 id="1-4-3-计算机网络中的吞吐量"><a href="#1-4-3-计算机网络中的吞吐量" class="headerlink" title="1.4.3   计算机网络中的吞吐量"></a>1.4.3   计算机网络中的吞吐量</h3><p>为了定义吞吐量，考虑从主机A到主机B跨越计算机网络传送一个大文件。在任何时间瞬间的<strong>瞬时吞吐量</strong>是主机B接收到该文件的速率（以bps计）。如果该文件由F比特组成，主机B接收到所有F比特用去T秒，则文件传送的<strong>平均吞吐量</strong>是F/T bps。对于某些应用程序，希望具有低时延和在某个阈值之上的一致的瞬时吞吐量。而对于其他应用程序，时延不是决定性的，但是希望具有尽可能高的吞吐量。</p>
<p>当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率。但如果许多其他的数据流也通过这条链路流动，一条具有高传输路仍然可能成为文件传输的瓶颈链路。</p>
<h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5   协议层次及其服务模型"></a>1.5   协议层次及其服务模型</h2><h3 id="1-5-1-分层的体系结构"><a href="#1-5-1-分层的体系结构" class="headerlink" title="1.5.1   分层的体系结构"></a>1.5.1   分层的体系结构</h3><p>利用分层的体系结构，使某层所提供的服务实现易于改变。只要该层对其上面的层提供相同的服务，并且使用来自下面层次的相同服务，当某层的实现变化时，该系统的其余部分保持不变。</p>
<p>分层的一个潜在缺点是一层可能冗余较低层的功能。例如，许多协议栈在基于每段链路和基于端到端两种情况下，都提供了差错恢复。第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息（如时间戳值），这违反了层次分离的目标。</p>
<p>各层的所有协议被称为<strong>协议栈</strong>。因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/08/dHOXRLnIkPEg8fJ.png"
                      alt="image-20210508110737337"
                ></p>
<ol>
<li><p>应用层<br>应用层是网络应用程序及它们的应用层协议存留的地方。包括HTTP（提供Web文档的请求和传送）、SMTP（提供电子邮件报文的传输）和FTP（提供两个端系统之间的文件传送）。域名解析也是借助于应用层协议即域名系统（DNS）完成的。应用层协议分布在多个端系统上，两个端系统中的应用程序使用协议相互交换信息分组，位于应用层的信息分组称为报文。</p>
</li>
<li><p>运输层<br>运输层在应用程序端点之间传送应用层报文。有两种运输协议，即TCP和UDP，其中的任一个都能运输应用层报文。TCP向它的应用程序提供了面向连接的服务，包括应用层报文向目的地的确保传递和流量控制，TCP也将长报文划分为短报文，并提供拥塞控制机制。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制，运输层的分组称为报文段。</p>
</li>
<li><p>网络层<br>网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。在一台源主机中的运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。<br>网络层包括网际协议IP，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段，IP仅有一个，所有具有网络层的因特网组件必须运行IP。网络层也包括决定路由的路由选择协议，它根据该路由将数据报从源传输到目的地。</p>
</li>
<li><p>链路层<br>网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个节点移动到路径上的下一个节点，网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据报上传给网络层。由链路层提供的服务取决于应用于该链路的特定链路层协议。链路层分组称为帧。</p>
</li>
<li><p>物理层<br>物理层将帧中的一个个比特从一个节点移动到下一个节点。在这层中的协议与该链路的实际传输媒体相关</p>
</li>
</ol>
<p>OSI参考模型的7层是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。OSI参考模型中附加的两个层，即表示层和会话层。<br>表示层的作用是使通信的应用程序能够解释交换数据的含义，包括数据压缩和数据加密以及数据描述。会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<h3 id="1-5-2封装"><a href="#1-5-2封装" class="headerlink" title="1.5.2封装"></a>1.5.2封装</h3><p>在发送主机端，一个应用层报文被传送给运输层，运输层收取到报文并附上附加信息，比如允许接收端运输层向上向适当的应用程序交付报文的信息、差错检测位信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段，运输层报文段因此封装了应用层报文。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，链路层增加链路层首部信息并生成链路层帧。所以在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段。有效载荷通常是来自上一层的分组。</p>
<p>封装的过程能够比前面描述的更为复杂。例如，一个大报文可能被划分为多个运输层的报文段（这些报文段每个可能被划分为多个网络层数据报）。在接收端，则必须从其连续的数据报中重构这样一个报文段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/05/09/mzjIy1qAh6pNbZ2.png"
                      alt="image-20210509201001252"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络：自顶向下方法</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>04-变量、作用域与内存</title>
    <url>/2021/01/23/note/JavaScript/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1　原始值与引用值"></a>4.1　原始值与引用值</h2><p>ECMAScript变量可以包含两种不同类型的数据：把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。</p>
<p>保存<strong>原始值</strong>的变量是按值访问的，我们操作的就是存储在变量中的实际值。</p>
<p><strong>引用值</strong>是保存在内存中的对象。JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，操作的是对该对象的引用而非实际的对象本身。为此，保存引用值的变量是按引用访问的。</p>
<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1　动态属性"></a>4.1.1　动态属性</h3><p>对于引用值而言，可以随时添加、修改和删除其属性和方法，直到对象被销毁或属性被显式地删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>原始类型的初始化可以只使用原始字面量形式。但如果使用的是<code>new</code>关键字，则JavaScript会创建一个<code>Object</code>类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"></span><br><span class="line">name2.age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name2.age);    <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2　复制值"></a>4.1.2　复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure>
<p><code>num2</code>跟存储在<code>num1</code>中的5是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/26/543JBFVTbLgqXDZ.png"
                      alt="image-20210426144006095"
                ></p>
<p>但在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/26/D1lHbqn3dO9Nmge.png"
                      alt="image-20210426144130945"
                ></p>
<h3 id="4-1-3-传递参数"><a href="#4-1-3-传递参数" class="headerlink" title="4.1.3　传递参数"></a>4.1.3　传递参数</h3><p>ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p>
<p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，是<code>arguments</code>对象中的一个槽位）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>如果<code>num</code>是按引用传递的，那么<code>count</code>的值也会被修改为30。但是如果变量中传递的是对象，就没那么清楚了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>在函数内部，<code>obj</code>和<code>person</code>都指向同一个对象。结果就是，即使对象是按值传进函数的，<code>obj</code>也会通过引用访问对象。当函数内部给<code>obj</code>设置了<code>name</code>属性时，函数外部的对象也会反映这个变化，因为<code>obj</code>指向的对象保存在全局作用域的堆内存上。</p>
<p>但这不意味着参数是按引用传递的。为证明对象也是按值传递的，我们再来看看下面这个修改后的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子将<code>obj</code>重新定义为一个有着不同<code>name</code>的新对象。当<code>person</code>传入<code>setName()</code>时，其<code>name</code>属性被设置为<code>&quot;Nicholas&quot;</code>。然后变量<code>obj</code>被设置为一个新对象且<code>name</code>属性被设置为<code>&quot;Greg&quot;</code>。如果<code>person</code>是按引用传递的，那么<code>person</code>应该自动将指针改为指向<code>name</code>为<code>&quot;Greg&quot;</code>的对象。可是，当我们再次访问<code>person.name</code>时，它的值还是<code>&quot;Nicholas&quot;</code>，这表明函数中参数的值改变之后，原始的引用仍然没变。当<code>obj</code>在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p>
<h3 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4　确定类型"></a>4.1.4　确定类型</h3><p><code>typeof</code>操作符最适合用来判断一个变量是否为原始类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">let</span> u;</span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为此提供了<code>instanceof</code>操作符，如果变量是给定引用类型（由其原型链决定）的实例，则<code>instanceof</code>操作符返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量pattern是RegExp吗？</span></span><br></pre></td></tr></table></figure>
<p>因为按照定义，所有引用值都是<code>Object</code>的实例，因此通过<code>instanceof</code>操作符检测任何引用值和<code>Object</code>构造函数都会返回<code>true</code>。如果用<code>instanceof</code>检测原始值，则始终会返回<code>false</code>，因为原始值不是对象。</p>
<blockquote>
<p>**注意 **ECMA-262规定，任何实现内部<code>[[Call]]</code>方法的对象都应该在<code>typeof</code>检测时返回<code>&quot;function&quot;</code>，所以<code>typeof</code>对正则表达式也返回<code>&quot;function&quot;</code>。但在IE和Firefox中，<code>typeof</code>对正则表达式返回<code>&quot;object&quot;</code>。</p>
</blockquote>
<h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2　执行上下文与作用域"></a>4.2　执行上下文与作用域</h2><p>执行上下文规定了当前代码执行的环境(当前执行代码片段中的变量、函数、作用域链等)，决定了变量或函数可以访问哪些数据，以及它们的行为。每个上下文都包含有一个关联的<strong>变量对象</strong>（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/26/W4PyMzv8OngRsUd.png"
                      alt="img"
                ></p>
<p>只有一段代码块开始执行时才会创建执行上下文。执行上下文分为：</p>
<ul>
<li>全局上下文(整个js文件被加载执行建立的上下文，必有且唯一)</li>
<li>函数上下文(函数被调用执行时建立的上下文，每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。)</li>
</ul>
<p>全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，就是<code>window</code>对象，因此所有通过<code>var</code>定义的全局变量和函数都会成为<code>window</code>对象的属性和方法。使用<code>let</code>和<code>const</code>的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。</p>
<p>函数上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数，但全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器。</p>
<p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p>
<h3 id="4-2-1-标识符查找"><a href="#4-2-1-标识符查找" class="headerlink" title="4.2.1　标识符查找"></a>4.2.1　标识符查找</h3><p>上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其<strong>活动对象</strong>（activation object）用作变量对象。活动对象最初只有一个定义变量：<code>arguments</code>（全局上下文中没有这个变量）。作用域链中的下一个变量对象来自包含上下文，以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p>
<p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
<p>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">    <span class="comment">// 这里可以访问color、anotherColor、tempColor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以访问color和anotherColor，但访问不到tempColor</span></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>以上代码涉及3个上下文：全局上下文、<code>changeColor()</code>和<code>swapColors()</code>的局部上下文。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/26/oLpJd2kq7RZX8nF.png"
                      alt="image-20210426160430875"
                ></p>
<p>上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。</p>
<blockquote>
<p><strong>注意</strong>　函数参数是局部变量，被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。标识符查找有一定代价。访问局部变量比访问全局变量要快，因为不用切换作用域。</p>
</blockquote>
<h3 id="4-2-2-作用域链增强"><a href="#4-2-2-作用域链增强" class="headerlink" title="4.2.2　作用域链增强"></a>4.2.2　作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种（<code>eval()</code>调用内部存在第三种上下文），但有其他方式来增强作用域链。下面的语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。</p>
<ul>
<li><code>try</code>/<code>catch</code>语句的<code>catch</code>块</li>
<li><code>with</code>语句</li>
</ul>
<p>这两种情况下，都会在作用域链前端添加一个变量对象。对<code>with</code>语句来说，会向作用域链前端添加指定的对象；对<code>catch</code>语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;<span class="comment">//未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>with</code>语句将<code>location</code>对象作为上下文，因此<code>location</code>会被添加到作用域链前端。<code>buildUrl()</code>函数中定义了一个变量<code>qs</code>。当<code>with</code>语句中的代码引用变量<code>href</code>时，实际上引用的是<code>location.href</code>，也就是自己变量对象的属性。在引用<code>qs</code>时，引用的则是定义在<code>buildUrl()</code>中的那个变量，它定义在函数上下文的变量对象上。而在<code>with</code>语句中使用<code>var</code>声明的变量<code>url</code>会成为函数上下文的一部分，可以作为函数的值被返回；但因为实际这里使用<code>let</code>声明的变量<code>url</code>，被限制在块级作用域，所以在<code>with</code>块之外没有定义。</p>
<h3 id="4-2-3-变量声明"><a href="#4-2-3-变量声明" class="headerlink" title="4.2.3　变量声明"></a>4.2.3　变量声明</h3><h4 id="4-2-2-1-使用var的函数作用域声明"><a href="#4-2-2-1-使用var的函数作用域声明" class="headerlink" title="4.2.2.1   使用var的函数作用域声明"></a><strong>4.2.2.1   使用</strong><code>var</code>的函数作用域声明</h4><p>在使用<code>var</code>声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在<code>with</code>语句中，最接近的上下文也是函数上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);  <span class="comment">// 报错：sum在这里不是有效变量，但省略上面var，sum会被添加到了全局上下文，就可以访问，但不推荐</span></span><br></pre></td></tr></table></figure>
<p><code>var</code>声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br></pre></td></tr></table></figure>
<p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出<code>undefined</code>而不是<code>Reference Error</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-2-使用let的块级作用域声明"><a href="#4-2-2-2-使用let的块级作用域声明" class="headerlink" title="4.2.2.2   使用let的块级作用域声明"></a><strong>4.2.2.2   使用</strong><code>let</code>的块级作用域声明</h4><p><code>let</code>关键字的作用域是块级的。块级作用域由最近的一对包含花括号<code>&#123;&#125;</code>界定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError，这里即便var声明也会导致报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-3-使用const的常量声明"><a href="#4-2-2-3-使用const的常量声明" class="headerlink" title="4.2.2.3   使用const的常量声明"></a><strong>4.2.2.3   使用</strong><code>const</code>的常量声明</h4><p>使用<code>const</code>声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。其他方面与<code>let</code>声明是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure>
<p>赋值为对象的<code>const</code>变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果想让整个对象都不能修改，可以使用<code>Object.freeze()</code>，当再给属性赋值时虽然不会报错，但会静默失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    prop: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.prop = <span class="number">33</span>; <span class="comment">// 在严格模式下会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.prop); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3　垃圾回收"></a>4.3　垃圾回收</h2><p>JavaScript通过自动内存管理实现内存分配和闲置资源回收。基本思路：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，靠算法是解决不了的。</p>
<p>以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了。</p>
<p>但并不是所有时候都会这么明显。垃圾回收程序须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量有不同的实现方式，主要有两种标记策略：标记清理和引用计数。</p>
<h3 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1　标记清理"></a>4.3.1　标记清理</h3><p>JavaScript最常用的垃圾回收策略是<strong>标记清理</strong>（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p>
<p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次<strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2　引用计数"></a>4.3.2　引用计数</h3><p>另一种不常用的垃圾回收策略是<strong>引用计数</strong>（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
<p>引用计数会遇到严重的问题：<strong>循环引用</strong>。就是对象A有一个指针指向对象B，而对象B也引用了对象A。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  objectA.someOtherObject = objectB;</span><br><span class="line">  objectB.anotherObject = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>objectA</code>和<code>objectB</code>通过各自的属性相互引用，意味着它们的引用数都是2。在标记清理策略下，函数结束后，这两个对象都不在作用域中，不会遇到问题。</p>
<p>但在引用计数策略下，<code>objectA</code>和<code>objectB</code>在函数结束后还会存在，因为它们的引用数永远不会变成0。如果函数被多次调用，则会导致大量内存永远不会被释放。<br>在IE8及更早版本的IE中，BOM和DOM中的对象是C++实现的组件对象模型（COM，Component Object Model）对象，而COM对象使用引用计数实现垃圾回收，如果制造了循环引用，这样DOM元素的内存永远不会被回收，即使它已经被从页面上删除了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br></pre></td></tr></table></figure>
<p>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>现在IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。</p>
<h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3　性能"></a>4.3.3　性能</h3><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。</p>
<p>现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。</p>
<p>由于调度垃圾回收程序方面的问题会导致性能下降，IE的策略是根据一个确定的分配数，这样实现的问题在于，分配那么多变量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就会导致垃圾回收程序过于频繁地运行。</p>
<p>IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。如果垃圾回收程序回收的内存不到已分配的15%，这些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存达到已分配的85%，则阈值重置为默认值。</p>
<blockquote>
<p><strong>警告</strong> 在某些浏览器中可以但不推荐主动触发垃圾回收的。在IE中，<code>window.CollectGarbage()</code>方法会立即触发垃圾回收。在Opera 7及更高版本中，调用<code>window.opera.collect()</code>也会启动垃圾回收程序。</p>
</blockquote>
<h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4　内存管理"></a>4.3.4　内存管理</h3><p>在使用垃圾回收的编程环境中，分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑，为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。</p>
<p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为<code>null</code>，从而释放其引用，这也可以叫作<strong>解除引用</strong>。这个建议最适合全局变量和全局对象的属性，因为局部变量在超出作用域后会被自动解除引用，当然这并不代表立刻被回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  localPerson.name = name;</span><br><span class="line">  <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> globalPerson = createPerson(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="comment">// 解除globalPerson对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p>
<h4 id="4-3-4-1-通过const和let声明提升性能"><a href="#4-3-4-1-通过const和let声明提升性能" class="headerlink" title="4.3.4.1   通过const和let声明提升性能"></a><strong>4.3.4.1   通过</strong><code>const</code>和<code>let</code>声明提升性能</h4><p>因为<code>const</code>和<code>let</code>都以块（而非函数）为作用域，所以相比于使用<code>var</code>，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。</p>
<h4 id="4-3-4-2-隐藏类和删除操作"><a href="#4-3-4-2-隐藏类和删除操作" class="headerlink" title="4.3.4.2   隐藏类和删除操作"></a><strong>4.3.4.2   隐藏类和删除操作</strong></h4><p>有时候需要根据浏览器使用的JavaScript引擎来采取对应的性能优化策略。V8 JavaScript引擎在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。</p>
<p>运行期间，V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这种情况进行优化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure>
<p>V8会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a2.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>此时两个<code>Article</code>实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。解决方案就是避免JavaScript的“先创建再补充”（ready-fire-aim）式的动态属性赋值，尽量在构造函数中就一次性声明所有属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>delete</code>关键字会导致生成相同的隐藏类片段。即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。</p>
<p>最佳实践是把不想要的属性设置为<code>null</code>。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author;</span><br><span class="line"><span class="comment">// 改为a1.author = null;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-3-内存泄漏"><a href="#4-3-4-3-内存泄漏" class="headerlink" title="4.3.4.3   内存泄漏"></a><strong>4.3.4.3   内存泄漏</strong></h4><p>JavaScript中的内存泄漏大部分是由不合理的引用导致的。意外声明全局变量是最常见但也最容易修复的内存泄漏问题。此时解释器会把变量当作<code>window</code>的属性来创建。只要在变量声明前头加上<code>var</code>、<code>let</code>或<code>const</code>关键字即可解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器也可能会导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：只要定时器一直运行，回调函数中引用的<code>name</code>就会一直占用内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>使用JavaScript闭包也很容易造成内存泄漏。只要<code>outer</code>函数存在就不能清理<code>name</code>，因为闭包一直在引用着它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">outer = <span class="literal">null</span>; <span class="comment">// 解除对函数的引用</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-4-静态分配与对象池-review"><a href="#4-3-4-4-静态分配与对象池-review" class="headerlink" title="4.3.4.4   静态分配与对象池 review"></a><strong>4.3.4.4   静态分配与对象池</strong> review</h4><p>为了提升JavaScript性能，最后要考虑的就是浏览器。关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。</p>
<p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resultant = <span class="keyword">new</span> Vector();</span><br><span class="line">  resultant.x = a.x + b.x;</span><br><span class="line">  resultant.y = a.y + b.y;</span><br><span class="line">  <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。再加上这个矢量加法函数如果频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。<br>该问题的解决方案是不要动态创建矢量对象，让它使用一个已有的矢量对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b, resultant</span>) </span>&#123;</span><br><span class="line">  resultant.x = a.x + b.x;</span><br><span class="line">  resultant.y = a.y + b.y;</span><br><span class="line">  <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这需要在其他地方实例化矢量参数<code>resultant</code>，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？<br>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vectorPool是已有的对象池</span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.allocate();</span><br><span class="line">v1.x = <span class="number">10</span>;</span><br><span class="line">v1.y = <span class="number">5</span>;</span><br><span class="line">v2.x = -<span class="number">3</span>;</span><br><span class="line">v2.y = -<span class="number">6</span>;</span><br><span class="line">addVector(v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log([v3.x, v3.y]); <span class="comment">// [7, -1]</span></span><br><span class="line">vectorPool.free(v1);</span><br><span class="line">vectorPool.free(v2);</span><br><span class="line">vectorPool.free(v3);</span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象,则这里也需要把这些属性设置为null</span></span><br><span class="line">v1 = <span class="literal">null</span>;</span><br><span class="line">v2 = <span class="literal">null</span>;</span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vectorList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> vector = <span class="keyword">new</span> Vector();</span><br><span class="line">vectorList.push(vector);</span><br></pre></td></tr></table></figure>
<p>由于JavaScript数组的大小是动态可变的，引擎会删除大小为100的数组，再创建一个新的大小为200的数组。垃圾回收程序看到这个删除操作，说不定因此很快就回收垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。</p>
<blockquote>
<p>**注意 **静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能，但并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Backgrounds and Borders Level 3</title>
    <url>/2021/03/07/note/W3C%20CSS/Backgrounds%20and%20Borders%20Level%203/</url>
    <content><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>每一个盒有一个背景层，可以是透明的（默认）也可以以某个颜色或一个以上的图像填满。背景属性可以用来指定背景使用的颜色（background-color）与图像（background-image）及图像如何伸缩、定位、铺设等等。背景属性不继承。</p>
<h3 id="1-1-多个背景图像的层叠"><a href="#1-1-多个背景图像的层叠" class="headerlink" title="1.1 多个背景图像的层叠"></a>1.1 多个背景图像的层叠</h3><p>盒的背景可以有多个背景图像层，数目由 background-image 属性逗号分隔的取值数目而定。取值 none 也产生一个层。</p>
<p>每一个图像依照其他背景属性里相应的值伸缩、定位、层迭。各属性的列从第一个取值开始配对 ，不使用结尾多余的取值。若属性用逗号分隔的取值比背景图像层的数目还少，UA 必须以重复列里面的取值直到取值数足够的方式计算使用值。</p>
<h3 id="1-2-背景颜色-―-background-color-属性"><a href="#1-2-背景颜色-―-background-color-属性" class="headerlink" title="1.2 背景颜色 ― background-color 属性"></a>1.2 背景颜色 ― background-color 属性</h3><p>本属性决定元素的背景色。背景色在任何背景图像之下。初始值为transparent。</p>
<p>底色层依照最底层的背景图像层对应的 background-clip 值剪裁。</p>
<p>Example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">background-color</span>: <span class="number">#F00</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-图像源-―-background-image-属性"><a href="#1-3-图像源-―-background-image-属性" class="headerlink" title="1.3 图像源 ― background-image 属性"></a>1.3 图像源 ― background-image 属性</h3><p>为一个元素设置一个或者多个背景图像</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123; background-image: url(&quot;marble.svg&quot;) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-图像铺成-―-background-repeat-属性"><a href="#1-4-图像铺成-―-background-repeat-属性" class="headerlink" title="1.4 图像铺成 ― background-repeat 属性"></a>1.4 图像铺成 ― background-repeat 属性</h3><p>在双值语法中, 第一个值表示水平重复行为, 第二个值表示垂直重复行为.</p>
<p>|单值|等价于双值|<br>|:—-:|:—-|:—-:|:—-|<br>|repeat-x（水平方向重复）|repeat no-repeat|<br>|repeat-y（垂直方向重复）|no-repeat repeat|<br>|repeat（图像会按需重复来覆盖整个背景图片所在的区域. 最后一个图像会被裁剪, 如果它的大小不合适的话）|repeat repeat|<br>|space（图像会尽可能得重复, 但是不会裁剪. 第一个和最后一个图像会被固定在元素(element)的相应的边上, 同时空白会均匀地分布在图像之间）|space space|<br>|round（随着允许的空间在尺寸上的增长, 被重复的图像将会伸展(没有空隙), 直到有足够的空间来添加一个图像.）|round round|<br>|no-repeat（图像不会被重复）|no-repeat no-repeat|</p>
<h3 id="1-5-图像固定-―-background-attachment-属性"><a href="#1-5-图像固定-―-background-attachment-属性" class="headerlink" title="1.5 图像固定 ― background-attachment 属性"></a>1.5 图像固定 ― background-attachment 属性</h3><p>决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p>
<table>
<thead>
<tr>
<th align="left">fixed</th>
<th align="left">背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">local</td>
<td align="left">背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。</td>
</tr>
<tr>
<td align="left">scroll</td>
<td align="left">表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）</td>
</tr>
</tbody></table>
<h3 id="1-6-图像定位-―-background-position-属性"><a href="#1-6-图像定位-―-background-position-属性" class="headerlink" title="1.6 图像定位 ― background-position 属性"></a>1.6 图像定位 ― background-position 属性</h3><p>若指定了背景图像，本属性可以用来指定图像（伸缩之后）在对应的背景定位区域的初始位置。</p>
<p>|center|居中背景图片|<br>|:—-:|:—-|:—-:|:—-|<br>|top, left, bottom, right|如果是单个值，图片在指定边缘的中间位置，|<br>|百分比|(容器宽 - 图片宽) * (position x%) = x方向偏移值<br>(容器高 - 图片高) * (position y%) = y方向偏移值|<br>|长度值|长度值是元素向指定边缘偏移|</p>
<p>Example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">top</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">left</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: 25% 75%;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">bottom</span> 50<span class="selector-tag">px</span> <span class="selector-tag">right</span> 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">right</span> 35% <span class="selector-tag">bottom</span> 45%;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-描绘区域-―-background-clip-属性"><a href="#1-7-描绘区域-―-background-clip-属性" class="headerlink" title="1.7 描绘区域 ― background-clip 属性"></a>1.7 描绘区域 ― background-clip 属性</h3><p>元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。</p>
<p>|border-box<br>|背景延伸至边框外沿（但是在边框下层）|<br>|:—-:|:—-|:—-:|:—-|<br>|padding-box|背景延伸至内边距（padding）外沿。不会绘制到边框处|<br>|content-box|背景被裁剪至内容区（content box）外沿|</p>
<h3 id="1-8-定位区域-―-background-origin-属性"><a href="#1-8-定位区域-―-background-origin-属性" class="headerlink" title="1.8 定位区域 ― background-origin 属性"></a>1.8 定位区域 ― background-origin 属性</h3><p>指定背景图片background-image 属性的原点位置的背景相对区域。</p>
<p>|border-box|背景图片的摆放以border区域为参考|<br>|:—-:|:—-|:—-:|:—-|<br>|padding-box（默认值）|背景图片的摆放以padding区域为参考|<br>|content-box|背景图片的摆放以content区域为参考|</p>
<h3 id="1-9-图像伸缩-―-background-sizing-属性"><a href="#1-9-图像伸缩-―-background-sizing-属性" class="headerlink" title="1.9 图像伸缩 ― background-sizing 属性"></a>1.9 图像伸缩 ― background-sizing 属性</h3><p>设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。</p>
<p>|length|设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。|<br>|:—-:|:—-|:—-:|:—-|<br>|百分比|以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。|<br>|cover|把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。|<br>|contain|把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。|</p>
<h3 id="1-10-背景缩写-―-background-属性"><a href="#1-10-背景缩写-―-background-属性" class="headerlink" title="1.10 背景缩写 ― background 属性"></a>1.10 背景缩写 ― background 属性</h3><p>一次性集中定义各种背景属性，包括 color, image, origin 与 size, repeat 方式等等。对于所有简写属性，任何没有被指定的值都会被设定为它们的 初始值。</p>
<p>background-color 只能在background的最后一个属性上定义。background-size 必须紧跟在 background-position后面，并用“/”分隔。</p>
<h3 id="1-11-特殊元素的背景"><a href="#1-11-特殊元素的背景" class="headerlink" title="1.11 特殊元素的背景"></a>1.11 特殊元素的背景</h3><p>当html标签没有设置背景色时，我们看见的是作用在浏览器画布上的背景色，不是body上的；</p>
<p>当html标签被设置了背景色时，我们看见的是真正作用在body上的背景色。</p>
<p>CSS根据根元素（html/body）给文档画布渲染背景颜色，同时背景色的定位区域就是根元素的区域；</p>
<p>根元素不再绘制该背景色，即根元素背景的使用值是透明的</p>
<h2 id="2-边框"><a href="#2-边框" class="headerlink" title="2 边框"></a>2 边框</h2><h3 id="2-1-边框颜色-―-border-color-属性"><a href="#2-1-边框颜色-―-border-color-属性" class="headerlink" title="2.1 边框颜色 ― border-color 属性"></a>2.1 边框颜色 ― border-color 属性</h3><p>border-color 是一个用于设置元素四个边框颜色的快捷属性： border-top-color, border-right-color, border-bottom-color, border-left-color</p>
<h3 id="2-2-边框样式-―-border-style-属性"><a href="#2-2-边框样式-―-border-style-属性" class="headerlink" title="2.2 边框样式 ―  border-style 属性"></a>2.2 边框样式 ―  border-style 属性</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/q9he18OyK3IpLMf.png"
                      alt="ChxDSvz4EdQEY2sF__thumbnail.png"
                ></p>
<h3 id="2-3-边框宽度-―-border-width-属性"><a href="#2-3-边框宽度-―-border-width-属性" class="headerlink" title="2.3 边框宽度 ― border-width 属性"></a>2.3 边框宽度 ― border-width 属性</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 当给定一个宽度时，该宽度作用于选定元素的所有边框 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line"><span class="comment">/* 当给定两个宽度时，该宽度分别依次作用于选定元素的横边与纵边 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 2<span class="selector-tag">px</span> 1.5<span class="selector-tag">em</span>;</span><br><span class="line"><span class="comment">/* 当给定三个宽度时，该宽度分别依次作用于选定元素的上横边、纵边、下横边 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span> 2<span class="selector-tag">em</span> 1.5<span class="selector-tag">cm</span>;</span><br><span class="line"><span class="comment">/* 当给定四个宽度时，该宽度分别依次作用于选定元素的上横边、右纵边、下横边、左纵边 （即按顺时针依次作用） */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span> 2<span class="selector-tag">em</span> 0 4<span class="selector-tag">rem</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用的全局关键字有：inherit(继承),initial（初始值）,unset（不设置） */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="comment">/* 使用作用于 border-width 的关键字 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">thin</span>;</span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">medium</span>;</span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">thick</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-边框缩写属性"><a href="#2-4-边框缩写属性" class="headerlink" title="2.4 边框缩写属性"></a>2.4 边框缩写属性</h3><p>用于设置各种单独的边界属性的简写属性。border可以用于设置一个或多个以下属性的值： border-width, border-style, border-color ,无顺序，只接受三个参数，分别是宽度、风格和颜色，所以这样会使得四条边的边框相同。</p>
<h2 id="3-圆角"><a href="#3-圆角" class="headerlink" title="3 圆角"></a>3 圆角</h2><h3 id="3-1-曲线半径-―-border-radius-属性"><a href="#3-1-曲线半径-―-border-radius-属性" class="headerlink" title="3.1 曲线半径 ― border-radius 属性"></a>3.1 曲线半径 ― border-radius 属性</h3><p>border-*-radius 属性的两个长度或百分比值决定了作为边框外边形状的四分之一椭圆的半径。第一个取值是水平半径，第二个是垂直半径。若没有第二个取值，和第一个值相同。若其中一个长度为零，则角落垂直，不是圆角。</p>
<p>作为水平半径的百分比值，取值相对于边框盒的宽度，作为垂直半径的百分比值，取值相对于边框盒的高度。</p>
<p>border-radius’缩写可以用来设定四个 ‘border-*-radius’。若指定的值包含斜线，则斜线前面的取值会设定水平半径，斜线后面的取值会设定垂直半径，若没有斜线，则取值同时用来设定两个半径。</p>
<p>每个半径的四个值按照左上、右上、右下、左下的顺序，若没有左下取值则使用右上取值，若没有右下取值则使用左上取值，若没有右上取值则使用左上取值。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/rMPEAo5hlJaORH3.png"
                      alt="frIxaJtah6iUhkL6__thumbnail.png"
                ></p>
<h3 id="3-2-Corner-Shaping"><a href="#3-2-Corner-Shaping" class="headerlink" title="3.2 Corner Shaping"></a>3.2 Corner Shaping</h3><p>边距边（内边框）的半径是外边框半径减掉对应的边框粗细的结果。若这个结果是负值，内半径为零。（在这种情况下边距边的圆心可能不与外边框曲线的圆心重叠。）同样地，内容边半径是边距边半径减掉对应边距，或是零（前面结果为负值的情形）。使用者代理透过插值计算在曲线区域中边框与边距的粗细，也因此当相邻边框的粗细不同的时候，角落会是粗细边框之间的平滑转场。</p>
<p>如果外曲线超过了相邻角落的边距边，内曲线可能不是完整的四分之一椭圆。</p>
<p>所有边框样式（‘solid’ 、‘dotted’ 、‘inset’ 等等）跟者边框的曲线走。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/YF2eBGnv1amVl9A.png"
                      alt="wne9FIO17lzvrUbe__thumbnail.png"
                ></p>
<p>当圆角连接的两个边框的粗细不同时圆角的效果（左）与边框宽度比角落半径还粗的时候的圆角效果（右）</p>
<h3 id="3-3-Corner-Clipping"><a href="#3-3-Corner-Clipping" class="headerlink" title="3.3 Corner Clipping"></a>3.3 Corner Clipping</h3><p>使用者代理使用适当的曲线（以 ‘background-clip’ 决定）剪裁一个盒的背景（但不剪裁边框图像）。其他使用边框边或边距边（像是 ‘overflow’ 属性 ‘visible’ 以外的值）剪裁达到的效果也必须改用曲线剪裁。使用者代理总是用内容边曲线修剪置换元素。</p>
<p>边框边的曲线外的区域不接受以该元素为目标的pointer事件。</p>
<h3 id="3-4-Color-and-Style-Transitions"><a href="#3-4-Color-and-Style-Transitions" class="headerlink" title="3.4 Color and Style Transitions"></a>3.4 Color and Style Transitions</h3><p>颜色与样式变化必须发生在同时包含边框半径与内曲线中心（如果边框半径小于边框宽度，这是指边距边角落的点）的最小长方形与边框相交的片段。</p>
<p>若其中一个边框的宽度为零，则另一个边框的颜色与样式会佔满整个变化区域。不然，相邻边框间的颜色与样式转场的中心点必须正比于边框宽度的比例，使得中心点的位置函数是这个比例的连续函数。然而，本规范没有定义转场的长相或是「正比」如何对应到曲线上的点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/fwurvComZgIl5jL.png"
                      alt="mVbdbNd2w1ZiqJNy__thumbnail.png"
                ></p>
<p>在这些角落的图形中，颜色与样式转场必须发生在绿色的区域。D 例中边框半径决定的长方形不包括内曲线（是个直角）的中心，因此转场范围扩张到角落之处。转场可发生在整个转场区域之中，但是本规范没有这样的要求：举例来说，两个实心边框之间的渐层颜色转场可能只发生在由外半径的尖端内半径的尖端包源的区域（在 D 例中以深绿色表示）。</p>
<h3 id="3-5-Overlapping-Curves"><a href="#3-5-Overlapping-Curves" class="headerlink" title="3.5 Overlapping Curves"></a>3.5 Overlapping Curves</h3><p>圆角曲线不能重叠：当任两个相邻边的半径和超过边框合的大小时，UA 必须以同样比例收缩所有边框半径直到曲线彼此不重叠。半径的收缩演算法如下：</p>
<p>设 f = min(Li/Si)，其中 i ∈ {顶, 右, 底, 左}，Si 是在 i 边的两个角的对应的两个半径的和，L顶 = L底 = 盒的宽度，L左 = L右 = 盒的高度。若 f &lt; 1，则所有角落半径同乘 f。</p>
<p>这个公式确保在收缩之后，四分之一圆形还是四分之一圆形、大的半径还是比小的大。但是这个作法可能收缩本来就很小的角落，让附近应该看起来一样的元素看起来不一样。</p>
<p>若曲线干扰到捲轴等等的 UI 元素，UA 在有必要的限度内（不得超过）可再缩小受影响的边框半径（只限受影响的边框半径）。</p>
<p>盒的渲染结果必须和以缩小的圆角值当作指定值一样。</p>
<h3 id="3-6-表格上的效果"><a href="#3-6-表格上的效果" class="headerlink" title="3.6 表格上的效果"></a>3.6 表格上的效果</h3><p>‘border-radius’ 属性适用于 ‘table’ 与 ‘inline-table’ 元素。当 ‘border-collapse’ 为 ‘collapse’，border-radius 属性不会被应用到表格。</p>
<h2 id="4-图像边框"><a href="#4-图像边框" class="headerlink" title="4 图像边框"></a>4 图像边框</h2><h3 id="4-1-图像源-―-border-image-source-属性"><a href="#4-1-图像源-―-border-image-source-属性" class="headerlink" title="4.1 图像源 ― border-image-source 属性"></a>4.1 图像源 ― border-image-source 属性</h3><p>元素的边框图片（border-image）的资源</p>
<p>Example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border-image-source: url(&#x27;/media/examples/border-diamonds.png&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-图像分割-―-border-image-slice-属性"><a href="#4-2-图像分割-―-border-image-slice-属性" class="headerlink" title="4.2 图像分割 ― border-image-slice 属性"></a>4.2 图像分割 ― border-image-slice 属性</h3><p>border-image-slice属性会将图片分割为9个区域：图像被分割为九个区域：四个角、四条边以及一个中间区域。除非使用了关键词 fill，否则中间的图像部分会被丢弃。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/T9UILsbuPq276f5.png"
                      alt="XV72AIIGYEUs0q2Y__thumbnail.png"
                ></p>
<p>|number|数字值，代表图像中像素）或矢量坐标|<br>|:—-:|:—-|:—-:|:—-|<br>|%|相对于图像尺寸的百分比值：图像的宽度影响水平偏移，高度影响垂直偏移|<br>|fill|保留边框图像的中间部分|</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 所有的边 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 30%; </span><br><span class="line"><span class="comment">/* 垂直方向 | 水平方向 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 10% 30%;</span><br><span class="line"><span class="comment">/* 顶部 | 水平方向 | 底部 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 30 30% 45;</span><br><span class="line"><span class="comment">/* 上 右 下 左 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 7 12 14 5; </span><br><span class="line"><span class="comment">/* 使用fill（fill可以放在任意位置） */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 10% <span class="selector-tag">fill</span> 7 12;</span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">border-image-slice</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">border-image-slice</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-绘制区域-―-border-image-width-属性"><a href="#4-3-绘制区域-―-border-image-width-属性" class="headerlink" title="4.3 绘制区域 ― border-image-width 属性"></a>4.3 绘制区域 ― border-image-width 属性</h3><p>规定图像边框的宽度</p>
<p>|<em>length</em>|    |<br>|:—-:|:—-|:—-:|:—-|<br>|number|代表对应的 border-width 倍数|<br>|%|区域的高度影响水平偏移，宽度影响垂直偏移|<br>|auto|如果规定该属性，则宽度为对应的图像切片的固有宽度|</p>
<h3 id="4-4-边扩展-―-border-image-outset-属性"><a href="#4-4-边扩展-―-border-image-outset-属性" class="headerlink" title="4.4 边扩展 ― border-image-outset 属性"></a>4.4 边扩展 ― border-image-outset 属性</h3><p>规定边框图像超出边框盒的量。在上、右、下、左侧。如果忽略第四个值，则与第二个值相同。如果省略第三个值，则与第一个值相同。如果省略第二个值，则与第一个值相同。不允许任何负值作为 border-image-outset 值。</p>
<p>|length|    |<br>|:—-:|:—-|:—-:|:—-|<br>|number|代表对应的 border-width 的倍数|</p>
<h3 id="4-5-图像铺成-―-background-image-repeat-属性"><a href="#4-5-图像铺成-―-background-image-repeat-属性" class="headerlink" title="4.5 图像铺成 ― background-image-repeat 属性"></a>4.5 图像铺成 ― background-image-repeat 属性</h3><p>定图像边框是否应该被重复（repeated）、拉伸（stretched）或铺满（rounded）。</p>
<p>|stretch|拉伸图像来填充区域|<br>|:—-:|:—-|:—-:|:—-|<br>|repeat|平铺（重复）图像来填充区域|<br>|round|类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域|</p>
<h3 id="4-6-图像边框缩写-―-border-image-属性"><a href="#4-6-图像边框缩写-―-border-image-属性" class="headerlink" title="4.6 图像边框缩写 ― border-image 属性"></a>4.6 图像边框缩写 ― border-image 属性</h3><p>border-image 属性是一个简写属性，用于设置以下属性：</p>
<p>|border-image-source|用在边框的图片的路径。|<br>|:—-:|:—-|:—-:|:—-|<br>|border-image-slice|图片边框向内偏移。|<br>|border-image-width|图片边框的宽度。|<br>|border-image-outset|边框图像区域超出边框的量。|<br>|border-image-repeat|图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。|</p>
<h2 id="5-Drop-Shadows-the-box-shadow-property"><a href="#5-Drop-Shadows-the-box-shadow-property" class="headerlink" title="5 Drop Shadows: the box-shadow property"></a>5 Drop Shadows: the box-shadow property</h2><p>在元素的框架上添加阴影效果，可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括阴影的X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色。</p>
<p>如果只给出两个值, 那么这两个值将会被当作 <offset-x><offset-y> 来解释。</p>
<p>如果给出了第三个值, 那么第三个值将会被当作<blur-radius>解释。</p>
<p>如果给出了第四个值, 那么第四个值将会被当作<spread-radius>来解释。</p>
<p>|<em>h-shadow</em>|必需。水平阴影的位置。允许负值。|<br>|:—-:|:—-|:—-:|:—-|<br>|<em>v-shadow</em>|必需。垂直阴影的位置。允许负值。|<br>|<em>blur</em>|可选。模糊距离。|<br>|<em>spread</em>|可选。阴影的尺寸。|<br>|<em>color</em>|可选。阴影的颜色。|<br>|inset|可选。将外部阴影 (outset) 改为内部阴影。|</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/vWIH2DkhayP94Lq.png"
                      alt="iGP0Sj73DZ5MyOkG__thumbnail.png"
                ></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 60<span class="selector-tag">px</span> <span class="selector-tag">-16px</span> <span class="selector-tag">teal</span>;</span><br><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</span><br><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0.2);</span><br><span class="line"><span class="comment">/* 插页(阴影向内) | x偏移量 | y偏移量 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inset</span> 5<span class="selector-tag">em</span> 1<span class="selector-tag">em</span> <span class="selector-tag">gold</span>;</span><br><span class="line"><span class="comment">/* 任意数量的阴影，以逗号分隔 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> <span class="selector-tag">red</span>, <span class="selector-tag">-1em</span> 0 0.4<span class="selector-tag">em</span> <span class="selector-tag">olive</span>;</span><br><span class="line"><span class="comment">/* 全局关键字 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>W3C CSS</category>
      </categories>
      <tags>
        <tag>W3C</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Flexible Box Layout Module Level 1</title>
    <url>/2021/03/07/note/W3C%20CSS/Flexible%20Box%20Layout%20Module%20Level%201/</url>
    <content><![CDATA[<h2 id="1-伸缩布局盒模型和术语"><a href="#1-伸缩布局盒模型和术语" class="headerlink" title="1 伸缩布局盒模型和术语"></a>1 伸缩布局盒模型和术语</h2><p>一个设有display:flex或display:inline-flex的元素是叫做flex容器 ，flex容器的子元素被称为 flex items，这些子元素使用伸缩布局模型来排版。</p>
<p>块布局与行内布局的布局计算偏向使用书写模式方向，伸缩布局偏向使用flex directions。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/KfP81wsm5OzxFrL.png"
                      alt="4uiZCCmxjzPvhtDD__thumbnail.png"
                ></p>
<p><strong>main axis（主轴）main dimension（主轴方向）</strong></p>
<p><strong>main-start（主轴起点）main-end（主轴终点）</strong></p>
<p><strong>main size（主轴长度）main size property（主轴长度属性）</strong></p>
<p><strong>cross axis（侧轴）cross dimension（侧轴方向）</strong></p>
<p><strong>cross-start（侧轴起点）cross-end（侧轴长度）</strong></p>
<p><strong>cross size（侧轴长度）cross size property（侧轴长度属性）</strong></p>
<h2 id="2-flex容器-―display的flex、inline-flex值"><a href="#2-flex容器-―display的flex、inline-flex值" class="headerlink" title="2 flex容器 ―display的flex、inline-flex值"></a>2 flex容器 ―display的flex、inline-flex值</h2><p>flex   元素产生块级flex容器盒。inline-flex  元素产生行内级flex容器盒。</p>
<p>flex容器会为其内容建立新的<strong>伸缩格式化上下文</strong>(flex formatting context)。 浮动不会闯入flex容器，且flex容器的边界不与其内容的边界叠加。flex容器不是block容器，因此有些用来控制block布局的属性，在伸缩布局中不适用。如：</p>
<ol>
<li>多栏(column)的所有column-*属性；</li>
<li>float与clear；（“float”属性仍然会影响flex容器子容器上的“display”的计算值)</li>
<li>vertical-align。</li>
<li>::first-line 和::first-letter，且flex container元素也不会成为它祖先的::first-line和::first-letter。</li>
</ol>
<p>若元素display的值是inline-flex且元素是一个浮动或绝对定位元素，则display的计算值是flex。</p>
<h2 id="3-flex-item"><a href="#3-flex-item" class="headerlink" title="3 flex item"></a>3 flex item</h2><p>一个flex容器的内容具有零个以上的flex item ，flex容器的每一个子元素都会成为一个flex item，且在flex容器里的连续文字块会被包起来成为匿名的block container flex item，若匿名flex item仅包含空白，则该flex item不会渲染，如同视为display: none。</p>
<p>匿名的item box是不能设置style的，因为没有元素去设置，它只能从flex container继承styles。</p>
<p>一个flex item为它的内容建立了一个独立的格式化上下文。然而flex items它本身是一个flex-level盒子，而不是block-level盒子：它们参与的是flex格式化上下文，而不是块级格式化上下文。</p>
<p>一些display值通常会在原始盒子周围创建匿名的盒子，但对于flex item来说，它首先被块级化，所以不会创建匿名盒子，例如两个连续的flex items的display值被设置为table-cell将会创建两个分开的块级flex items,而不是被包装为一个单独的匿名table。</p>
<p>对于display值被指定为table的flex item，表格包装盒子成为一个flex item，order和align-self适用于它，任何标题框的内容都有助于计算表格盒子的最小和最大宽度。</p>
<p>对于width和height采用以下规则计算：flex items的最终尺寸是在执行布局的时候计算的，就好像表格盒子和表格内容的间隔是表格盒子的border+padding区域一样。</p>
<h3 id="3-1-绝对定位的伸缩子元素"><a href="#3-1-绝对定位的伸缩子元素" class="headerlink" title="3.1 绝对定位的伸缩子元素"></a>3.1 绝对定位的伸缩子元素</h3><p>因为它脱离了文档流，所以绝对定位的child不参与flex布局。</p>
<p>flex container中的绝对定位元素的位置被计算就好像它是flex container中仅有的唯一元素一样，并且假设flexcontainer和flex item都是固定大小的尺寸。所以为了此目的，automargin被视为0。换句话说，flex容器中的定位元素是相对于flex容器的contentbox定位的。</p>
<p>如果对flex container中的绝对定位的元素设置align-self: center;,自动offset将会让它在flex容器的cross axis居中。然而因为一个绝对定位的flex item是固定尺寸的，stretch属性被视为和flex start相同。</p>
<h3 id="3-2-Flex-itemMargins-and-Paddings"><a href="#3-2-Flex-itemMargins-and-Paddings" class="headerlink" title="3.2 Flex itemMargins and Paddings"></a>3.2 Flex itemMargins and Paddings</h3><p>相邻flex items的margins不会合并。</p>
<p>百分比的margins和paddings和block boxes一样，相对于它们的containing block计算。</p>
<p>auto margins会扩展去吸收相应区域额外的空间，它们被用于对齐或者使相邻的flex items分离。</p>
<h3 id="3-3-Flex-Item-Z-Ordering"><a href="#3-3-Flex-Item-Z-Ordering" class="headerlink" title="3.3 Flex Item Z-Ordering"></a>3.3 Flex Item Z-Ordering</h3><p>flex items的渲染和inline block类似，除了order属性会改变源文档的顺序，不是auto值的z-index会创建一个堆叠上下文，甚至是position被设置static的时候也一样（表现的好像是position是relative一样）。</p>
<p>位于flex item外部的后代仍然参与flex item建立的的任何堆叠上下文。</p>
<h3 id="3-4-Collapsed-Items"><a href="#3-4-Collapsed-Items" class="headerlink" title="3.4 Collapsed Items"></a>3.4 Collapsed Items</h3><p>在flex item上指定visibility:collapse会引发它成为一个折叠flex item，产生一种类似在table-row或table-column上设置visibility:collapse的效果：折叠的flex item完全从渲染中移除，但是留下一个桩来保持flex line的cross size的稳定。因此，如果一个flex容器只有一个flex line，动态折叠或者不折叠items可能会改变flex容器的main size，但是不会对它的cross size产生影响，也不会导致页面其余部分“摇晃”，然而flex line的换行是折叠之后重做的，所以具有多line的flex容器的cross size可能会也可能不会改变。</p>
<p>尽管折叠flex item没有被渲染，但它确实出现在formatting structure，因此不像设置了display: none的items。依赖于formatting structure的盒子的效果（例如递增计数器，运行动画或者过渡）仍然对折叠items产生作用。</p>
<h3 id="3-5-flex-item的自动最小尺寸"><a href="#3-5-flex-item的自动最小尺寸" class="headerlink" title="3.5 flex item的自动最小尺寸"></a>3.5 flex item的自动最小尺寸</h3><p>为了为flex items提供一个更加合理的默认最小尺寸，对于一个不是滚动容器的主轴中的flex items的最小尺寸的值就是它的基于内容的最小尺寸，对于滚动容器，自动最小尺寸通常是0。</p>
<p>通常来说，flex items的基于内容的最小尺寸是content size suggestion和specified size suggestion中的较小值。然而，如果一个盒子具有宽高比但是没有specified size，它的基于内容的最小尺寸就是content size suggestion和transferred size suggestion中的较小值。如果盒子既没有specified size suggestion也没有宽高比，它的基于内容的最小尺寸就是content size suggestion。</p>
<p><strong>specified size suggestion</strong></p>
<p>如果item的计算main size property是有定义的，specified size suggestion就是该大小（如果它是被定义的，则由其最大main size property限制），否则是undefined。</p>
<p><strong>transferred size suggestion</strong></p>
<p>如果item具有固有的宽高比并且它的计算的cross size property是有定义的，transferred size suggestion就是那个大小（如果它们是有定义的，则由其最小和最大cross size properties限制），通过宽高比转化，否则是undefined。</p>
<p><strong>content size suggestion</strong></p>
<p>content size suggestion就是主轴上的最小内容大小，如果它具有宽高比，通过任何定义的min and max cross peoperties转化宽高比，那么它是受限制的，然后进一步受限制如果它定义了max main size property.</p>
<p>为了计算盒子的固有大小（例如盒子的最小内容大小），基于内容的最小大小使得该轴中盒子的大小变得不确定（即使例如其宽度属性指定了确定的大小），这意味着根据此大小计算的百分比将表现为auto。</p>
<h2 id="4-顺序与方向"><a href="#4-顺序与方向" class="headerlink" title="4 顺序与方向"></a>4 顺序与方向</h2><p>flex container的内容可以沿着任意方向和任意顺序布局，这个功能通过使用flex-direction,flex-wrap和order属性实现。</p>
<h3 id="4-1-flex流的方向：flex-direction属性"><a href="#4-1-flex流的方向：flex-direction属性" class="headerlink" title="4.1 flex流的方向：flex-direction属性"></a>4.1 flex流的方向：flex-direction属性</h3><p>|flex-direction属性值|flex-direction决定了flex items在主轴上沿着什么方向布局|<br>|:—-:|:—-|:—-:|:—-|<br>|row（默认）|主轴的方向和inline axis相同，main-start和main-end分别和inline-start和inline-end方向相同|<br>|row-reverse|和row相似，但main-start和main-end调转过来|<br>|column|主轴的方向和block axis一致，main-start和main-end分别和block-start和block-end方向相同|<br>|column-reverse|和column相似，但main-start和main-end调转过来|</p>
<h3 id="4-2-flex行换行-：flex-wrap属性"><a href="#4-2-flex行换行-：flex-wrap属性" class="headerlink" title="4.2 flex行换行 ：flex-wrap属性"></a>4.2 flex行换行 ：flex-wrap属性</h3><p>|flex-wrap属性值|flex wrap属性控制flex containers是单行的还是多行的，以及侧轴的方向。侧轴的方向决定了新行被叠加的方向。|<br>|:—-:|:—-|:—-:|:—-|<br>|nowrap（默认）|flex containers是单行的|<br>|wrap|flex containers是多行的。|<br>|wrap-reverse|和wrap一样，不过方向相反。|</p>
<h3 id="4-3-flex方向与换行-：flex-flow缩写"><a href="#4-3-flex方向与换行-：flex-flow缩写" class="headerlink" title="4.3 flex方向与换行 ：flex-flow缩写"></a>4.3 flex方向与换行 ：flex-flow缩写</h3><p>flex-flow是flex-directive和flex-wrap的简写形式，定义了flex container的主轴和侧轴。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/G87MglOH1UqaeSr.png"
                      alt="7w6xAn53Yd7j7pwQ__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/IY4lrixyNtMsP89.png"
                      alt="HdIWBm2MS37XVzeN__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/JPRzlABt3qQxY8g.png"
                      alt="oOMZpxlmZTIx2Vn3__thumbnail.png"
                ></p>
<p>flex-flow是和writing mode相关的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/7zfqoyTVSUYLA9R.png"
                      alt="d7uQWKnXZubXdt5O__thumbnail.png"
                ></p>
<h3 id="4-4-display顺序-order属性"><a href="#4-4-display顺序-order属性" class="headerlink" title="4.4 display顺序 :order属性"></a>4.4 display顺序 :order属性</h3><p>flex item默认的展示顺序和源文档一样，order属性可以改变这种顺序。</p>
<p>order接受一个整数值，从最低的值开始排列，值相同的按源文档的顺序排序，绝对布局的flex items被视为order: 0。</p>
<p>order仅仅影响视觉上的顺序，而不会影响逻辑源代码的顺序和非视觉媒体或者不支持css的设备的顺序。</p>
<h2 id="5-FlexLines"><a href="#5-FlexLines" class="headerlink" title="5 FlexLines"></a>5 FlexLines</h2><p>flex items在flex容器中排列在flex lines中。一个flex container可以是单行的或者多行的，这取决于flex-wrap属性。</p>
<p>single-line flex容器：（设置了flex-wrap: nowrap），所有的item布局在一个单行，即使会引起内容溢出。</p>
<p>multi-line flex容器：（设置了flex-wrap: wrap或者flex-wrap: wrap-reverse），分割它的flex items成为多line。当额外的line被创建，它们在容器的侧轴上按照flex-wrap属性的值堆叠，每一个line至少包含一个item，除非容器是空的。</p>
<p>一旦内容被分割为多行，每一行就是独立布局的，弹性长度和justify-content,align-self属性一次只考虑在一行中的items。</p>
<p>在一个多行的flex container中（甚至只有一行），每行的侧轴尺寸就是能够包含下该行的items的最小尺寸（通过align-self属性排列后），行在flex container中的排列使用align-content属性设置。在单行的flex container中，行的侧轴尺寸就是flex container的侧轴尺寸，align-content没有效果。每一行的主轴的尺寸总是和flex container内容盒子的主轴尺寸相同的。</p>
<h2 id="6-伸缩性"><a href="#6-伸缩性" class="headerlink" title="6 伸缩性"></a>6 伸缩性</h2><p>flex布局的定义方面是能够使flex items弹性，改变它们的宽度/高度去填充main dimension剩余的空间，这可以通过flex属性实现。flex container分配剩余空间给它的items（通过设置flex-grow ）来填充填充容器，或者收缩它们（通过设置flex-shrink）来阻止溢出。</p>
<p>如果flex item的flex-grow和flex-shrink都是0，是完全没有弹性的，否则是伸缩的。</p>
<h3 id="6-1-flex缩写"><a href="#6-1-flex缩写" class="headerlink" title="6.1 flex缩写"></a>6.1 flex缩写</h3><p>flex属性规定了flex元素如何伸长或缩短以适应flex容器中的可用空间。这是一个简写属性，用来设置 flex-grow, flex-shrink 与 flex-basis。</p>
<ol>
<li><strong>flex-grow</strong></li>
</ol>
<p>指定了flex的增长因子，当有正的剩余空间的时候，增长因子决定了flex item相对于容器中其他的flex items的增长程度，默认值为1。当line上的flex值之和小于1时，它们将占用小于100％的可用空间。</p>
<ol start="2">
<li><strong>flex-shrink</strong></li>
</ol>
<p>决定了flex item相对于容器中其他的flex items的收缩程度，默认值为1，不能为负数。仅在默认宽度之和大于容器的时候才会发生收缩。</p>
<ol start="3">
<li><strong>flex-basis</strong></li>
</ol>
<p>指定了 flex 元素在主轴方向上的初始大小。flex-basis接受和width,height一样的值（除了auto被视为不同的），以及content关键字。</p>
<pre><code>1. auto</code></pre>
<p>当在flex item使用该值时，auto关键字将item的main size property设为它的flex-basis。若那个值是也是auto，就使用值就是content。<br>    2. content<br>表示基于flex item内容的自动尺寸</p>
<h3 id="6-2-flex的常见值"><a href="#6-2-flex的常见值" class="headerlink" title="6.2 flex的常见值"></a>6.2 flex的常见值</h3><ol>
<li><strong>flex: initial</strong></li>
</ol>
<p>等效于flex: 0 1 auto，基于它的width/height来设置它的尺寸（若item的main size property被设置为auto,它的尺寸将会基于它的内容），在正的剩余空间的时候flex item没有弹性，但是没有充足空间的时候会收缩到它的最小尺寸，alignment abilities或者auto margin在主轴上排列flex items。</p>
<ol start="2">
<li><strong>flex: auto</strong></li>
</ol>
<p>等效于flex: 1 1 auto,基于它的width/height来设置它的尺寸，并且使它完全弹性的，它会吸收任何多余的空间。</p>
<ol start="3">
<li><strong>flex: none</strong></li>
</ol>
<p>等效于flex: 0 0 auto, 基于它的width/height来设置它的尺寸，并且使它完全不可弹性的。甚至在溢出的情况也不会收缩。</p>
<ol start="4">
<li><strong>flex: positive-number</strong></li>
</ol>
<p>等效于flex: <positive-number> 1 0，使flex item弹性的，并且设置flex basis为0。</p>
<p>默认情况下flex items并不会缩减到它的最小尺寸以下（最大的text长度或者固定尺寸的元素），改变这个可以通过设置min-width或者min-height属性</p>
<h2 id="7-对齐"><a href="#7-对齐" class="headerlink" title="7 对齐"></a>7 对齐</h2><h3 id="7-1-auto-margin对齐"><a href="#7-1-auto-margin对齐" class="headerlink" title="7.1 auto margin对齐"></a>7.1 auto margin对齐</h3><p>flex item 和 block流的auto margin非常类似：</p>
<ol>
<li>在计算flex bases和伸缩长度的时候，auto margin被视为0</li>
<li>优先于通过justify-content和align-self设置的对齐属性，在那个区域的任何正的空间的都被分配给auto margin。</li>
<li>溢出的盒子会忽略它们的auto margin，并且在end方向溢出<h3 id="7-2-主轴对齐-justify-content属性"><a href="#7-2-主轴对齐-justify-content属性" class="headerlink" title="7.2 主轴对齐 :justify-content属性"></a>7.2 主轴对齐 :justify-content属性</h3></li>
</ol>
<table>
<thead>
<tr>
<th align="left">justify-content属性值</th>
<th align="left">定义了项目在主轴上的对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">flex-start（默认）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">flex-end</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">center</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">space-between</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">space-around</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Q6k15IzBNuJGbvn.png"
                      alt="HGyMlU07TRUL0xu2__thumbnail.png"
                ></p>
<h3 id="7-3-侧轴对齐-align-items与align-self属性"><a href="#7-3-侧轴对齐-align-items与align-self属性" class="headerlink" title="7.3 侧轴对齐 :align-items与align-self属性"></a>7.3 侧轴对齐 :align-items与align-self属性</h3><p>flex items可以在当前容器的当前行的侧轴上对齐，align-items设置flex容器中所有项的默认对齐方式，包括匿名flex items，align-self为单个flex items设置对齐方式，会覆盖它的默认对齐方式，对于匿名的flex items，align-self始终匹配它们相关联的flex容器的align-items值。</p>
<p>如果任何flex-items的margin的值为auto。则align-self无效。</p>
<p>如果flex容器的高度受到约束，stretch值可能导致flex item的内容溢出item</p>
<table>
<thead>
<tr>
<th align="left">align-items和align-self属性值</th>
<th align="left">定义了项目在主轴上的对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto（align-self的属性值，且默认）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">flex-start</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">flex-end</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">center</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">baseline</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">stretch</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/FRKW1quDNZtfUzM.png"
                      alt="kmOo5IYgu9TesAUd__thumbnail.png"
                ></p>
<h3 id="7-4-堆栈伸缩行-：align-content属性"><a href="#7-4-堆栈伸缩行-：align-content属性" class="headerlink" title="7.4 堆栈伸缩行 ：align-content属性"></a>7.4 堆栈伸缩行 ：align-content属性</h3><p>当cross-axis有额外空间的时候，align-content排列flex容器中的lines，类似justity-content在主轴排列单独的item，这个属性对于单行的flex容器没有效果。单行flex容器的line会自动拉伸填充空间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/oGZzPy8RMfkYTtC.png"
                      alt="H98ydaeN2I2CiLn8__thumbnail.png"
                ></p>
<h2 id="8-Flex容器基线"><a href="#8-Flex容器基线" class="headerlink" title="8 Flex容器基线"></a>8 Flex容器基线</h2><p>为了使flex容器本身参与基线对齐（例如，当flex容器本身是外部flex容器的flex item时），它需要提交最能代表其内容的基线位置。为此，flex容器基线的位置被决定如下（使用order重排后并将flex-direction考虑在内）：</p>
<p><strong>first/last 主轴基线集</strong></p>
<p>当flex容器的inline axis匹配它的main axis，它的基线被决定如下：</p>
<ol>
<li>如果flex容器的最开始/最末尾的flex line中的任何flex items参与基线对齐，flex容器的first/last主轴基线集则从那些flex items的共享对齐基线生成。</li>
<li>否则，如果flex容器至少有一个flex item，则flex容器的first/last基线集是从最开始/最末尾的flex item的对齐基线生成。（如果该item没有与flex容器主轴平行的对齐基线，则首先从其边界边缘合成一个）。</li>
<li>否则，flex容器没有first/last主轴基线集，并且根据其对齐上下文规则在需要时合成一个。</li>
</ol>
<p><strong>first/last侧轴基线集</strong></p>
<p>当flex容器的inline axis匹配它的cross axis，它的基线被决定如下：</p>
<ol>
<li>如果flex容器至少有一个flex item，则flex容器的first/last基线集是从最开始/最末尾的flex item的对齐基线生成。（如果该item没有与flex容器交叉轴平行的对齐基线，则首先从其边界边缘合成一个）。</li>
<li>否则，flex容器没有first/last主轴基线集，并且根据其对齐上下文规则在需要时合成一个。</li>
</ol>
<p>根据上述规则计算基线时，如果贡献基线的框具有允许滚动的overflow值，</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>W3C CSS</category>
      </categories>
      <tags>
        <tag>W3C</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Selectors Level 3</title>
    <url>/2021/03/07/note/W3C%20CSS/Selectors%20Level%203/</url>
    <content><![CDATA[<p>**CSS(层叠样式表)**是一个描述HTML和XML文档在屏幕等上呈现的语言。CSS使用选择器将样式属性绑定到文档中的元素，选择器是与树中的元素相匹配的模式，在语法上不区分大小写，</p>
<h2 id="1-选择器介绍"><a href="#1-选择器介绍" class="headerlink" title="1 选择器介绍"></a>1 选择器介绍</h2><table>
<thead>
<tr>
<th align="center">Pattern</th>
<th align="left">Represents</th>
<th align="center">Description</th>
<th align="left">Level</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="left">所有元素</td>
<td align="center">通用选择器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E</td>
<td align="left">所有E元素</td>
<td align="center">类型选择器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center">E[foo]</td>
<td align="left">定义了 “foo”属性的E元素</td>
<td align="center">属性选择器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E[foo=”bar”]</td>
<td align="left">定义了”foo”属性且值为”bar”的E元素</td>
<td align="center">属性选择器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E[foo~=”bar”]</td>
<td align="left">定义了”foo”属性且属性值是一个以空格分隔的列表，其中一个列表的值为”bar”。</td>
<td align="center">属性选择器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E[foo^=”bar”]</td>
<td align="left">定义了“foo”属性且值以“bar”开头的E元素</td>
<td align="center">属性选择器</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E[foo$=”bar”]</td>
<td align="left">定义了“foo”属性且值以“bar”结尾的E元素</td>
<td align="center">属性选择器</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E[foo*=”bar”]</td>
<td align="left">定义了“foo”属性且值包含“bar”的E元素</td>
<td align="center">属性选择器</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E[foo|=”en”]</td>
<td align="left">定义了“foo”属性且属性值是用连字符（-）分隔的列表，值开头的字符为”en”的E元素</td>
<td align="center">属性选择器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E:root</td>
<td align="left">文档的根元素，对于HTML文档就是HTML元素</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:nth-child(n)</td>
<td align="left">E元素的父元素中的第n个子元素</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:nth-last-child(n)</td>
<td align="left">E元素的父元素中的倒数第n个子元素（只匹配同种的E元素）</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:nth-of-type(n)</td>
<td align="left">E元素的父元素中的第n个子代E元素</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:nth-last-of-type(n)</td>
<td align="left">E元素的父元素中的倒数第n个子元素（只匹配同种的E元素）</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:first-child</td>
<td align="left">E元素的父元素中的第一个子代E元素</td>
<td align="center">结构伪类</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E:last-child</td>
<td align="left">E元素的父元素中的最后一个子代E元素</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:first-of-type</td>
<td align="left">E元素的父元素中的第一个子代E元素（只匹配相同的E元素）</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:last-of-type</td>
<td align="left">E元素的父元素中的最后一个子代E元素（只匹配相同的E元素）</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:only-child</td>
<td align="left">匹配父元素仅有的这个E元素</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:only-of-type</td>
<td align="left">匹配父元素仅有一个的E元素（只匹配相同的E元素）</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:empty</td>
<td align="left">匹配一个不包含任何元素的元素（文本结点也被看做子元素）</td>
<td align="center">结构伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:link<br>E:visited</td>
<td align="left">作为超链接的E元素，其目标尚未访问（：link）或已访问（：visited）</td>
<td align="center">链接伪类</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">E:active<br>E:hover<br>E:focus</td>
<td align="left">在某些用户操作期间的E元素</td>
<td align="center">用户操作伪类</td>
<td align="left">1 and 2</td>
</tr>
<tr>
<td align="center">E:target</td>
<td align="left">相关URL指向的E元素</td>
<td align="center">目标伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E:lang(fr)</td>
<td align="left">语言为”fr”的E元素</td>
<td align="center">:lang() 伪类</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E:enabled<br>E:disabled</td>
<td align="left">用户界面上处于可用或禁用状态的E元素</td>
<td align="center">UI元素声明伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">E:checked</td>
<td align="left">用户界面上处于选中状态的E元素(用于input type为radio与checkbox时)</td>
<td align="center">UI元素声明伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E::first-line</td>
<td align="left">设置E元素内的第一行样式</td>
<td align="center">::first-line伪元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center">E::first-letter</td>
<td align="left">设置E元素内的第一个字符</td>
<td align="center">::first-letter伪元素</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center">E::before</td>
<td align="left">设置在对象前发生的内容</td>
<td align="center">::before伪元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E::after</td>
<td align="left">设置在对象后发生的内容</td>
<td align="center">after伪元素</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E.warning</td>
<td align="left">class属性值为warning的E元素</td>
<td align="center">类选择器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center">E#myid</td>
<td align="left">ID为”myid”的E元素</td>
<td align="center">ID选择器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center">E:not(s)</td>
<td align="left">不含有S选择器的元素</td>
<td align="center">相反伪类</td>
<td align="left">3</td>
</tr>
<tr>
<td align="center">E F</td>
<td align="left">所有属于E元素后代F元素</td>
<td align="center">后代组合器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="center">E &gt; F</td>
<td align="left">所有属于E元素的子代F元素</td>
<td align="center">子代组合器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E + F</td>
<td align="left">紧贴在E元素之后的F元素</td>
<td align="center">相邻兄弟组合器</td>
<td align="left">2</td>
</tr>
<tr>
<td align="center">E ~ F</td>
<td align="left">在E元素之后的F元素</td>
<td align="center">兄弟组合器</td>
<td align="left">3</td>
</tr>
</tbody></table>
<h2 id="2-选择器语法"><a href="#2-选择器语法" class="headerlink" title="2 选择器语法"></a><strong>2 选择器语法</strong></h2><p><strong>选择器</strong>是由一个或多个简单选择器序列组成并由组合器分隔的链。一个伪元素可以附加到选择器中的最后一个简单选择器序。</p>
<p><strong>简单选择器序列</strong>是不被组合器分割的简单选择器链，它总是以类型选择器或通用选择器开始，序列中不允许使用其他类型选择器或通用选择器。</p>
<p><strong>简单选择器</strong>：类型选择器，通用选择器、属性选择器、类选择器、ID选择器、伪类选择器。</p>
<p><strong>组合器</strong>有：空格、“&gt;”（greater-than sign）、“+”（plus sign）和“~”（tilde）。组合器和它周围的简单选择器之间可以出现空白。空白中只能出现“空格”、“制表符”、“换行符”、“回车符”和“换页符”。其他类似空格的字符，例如“em space”（全角空格）和“ideographic space”（表意空格），都不是空白的一部分。</p>
<p>由选择器表示的文档树的元素是选择器的主题。由单个简单选择器序列组成的选择器表示满足其要求的任何元素。将另一个简单选择器序列和一个组合器添加到一个简单选择器序列前，会产生额外的匹配约束，因此选择器的主题始终是最后一个简单选择器序列所表示的元素的子集。</p>
<p><strong>空选择器</strong>（不包含简单选择器序列和伪元素）是无效的选择器。</p>
<p>选择器中的字符可以用反斜杠转义。</p>
<p>某些选择器支持命名空间前缀。声明命名空间前缀的机制应该由使用选择器的语言指定。如果没有指定，则不声明前缀。在CSS中，命名空间前缀使用@namespace规则声明。</p>
<h2 id="3-选择器组"><a href="#3-选择器组" class="headerlink" title="3 选择器组"></a>3 选择器组</h2><p>一个由逗号分隔的选择器列表表示列表中每个单独的选择器所选择的所有元素的联合，它们共享相同的声明。注意：如果其中一个选择器无效，则整个选择器组都将无效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1, h2, h3 &#123; font-family: sans-serif &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-类型选择器"><a href="#4-类型选择器" class="headerlink" title="4 类型选择器"></a>4 类型选择器</h2><p>类型选择器匹配文档语言元素类型的名称。类型选择器匹配文档树中该元素类型的每一个实例。如果命名空间前缀没有提前声明，此类型选择器是无效的。</p>
<p>|<strong>ns|E</strong>|表示命名空间 ns 中的 E 元素|<br>|:—-:|:—-|:—-:|:—-|<br>|*<strong>|E</strong>|表示任何命名空间中的 E 元素(包括没有命名空间的元素)|<br>|<strong>|E</strong>|若有默认命名空间，表示默认命名空间中的 E 元素，否则表示没有命名空间的 E 元素|<br>|<strong>E</strong>|如果没有默认命名空间的情况下，等同于<strong>|E</strong>，否则等同于 ns|E|</p>
<p>CSS examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> foo url(<span class="attribute">http:</span>//www.example.com);</span><br><span class="line"> </span><br><span class="line">foo|h1 &#123;color: blue&#125;/* 只匹配在命名空间&quot;http://www.example.com&quot;中的 h1 元素 */</span><br><span class="line">foo|* &#123;color: yellow&#125;/* 匹配在命名空间&quot;http://www.example.com&quot;中的所有元素 */</span><br><span class="line">|h1 &#123; color: red &#125; /* 匹配没有命名空间的 h1 元素 */</span><br><span class="line">*|h1 &#123; color: green &#125;/* 匹配所有命名空间（包括没有命名空间）的 h1 元素 */ </span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: green &#125;<span class="comment">/* 因为没有默认命名空间，所以同上 */</span></span><br></pre></td></tr></table></figure>
<h2 id="5-通用选择器"><a href="#5-通用选择器" class="headerlink" title="5 通用选择器"></a>5 通用选择器</h2><p>如果没有为选择器指定默认名称空间，则它表示文档树中任何名称空间(包括没有名称空间的元素)中的任何元素。如果命名空间前缀没有提前声明，此通用选择器是无效的</p>
<p>如果通用选择器后面还有其他简单选择器，或者紧跟着一个伪元素，那么*可能被省略，并且暗示了通用选择器的存在。</p>
<p>不要省略 *，因为可以减少两者之间的混淆，比如 div  :first-child 和 div:first-child，在这里，div *:first-child 更具可读性。</p>
<p>Examples:</p>
<ul>
<li><code>*[hreflang|=en]</code>and<code>[hreflang|=en]</code>are equivalent,</li>
<li><code>*.warning</code>and<code>.warning</code>are equivalent,</li>
<li><code>*#myid</code>and<code>#myid</code>are equivalent.</li>
</ul>
<p>通用选择器允许有命名空间。使用如下:</p>
<p>|<strong>ns|**<em>|表示命名空间 ns 中的所有元素|<br>|:—-:|:—-|:—-:|:—-|<br>|</em></strong>|<strong><em>|任何元素|<br>|**|</em></strong>|如果有默认命名空间，表示默认命名空间中的任何元素，如果有，则表示没有命名空间的任何元素|<br>|<strong>**<em>|如果没有默认命名空间的情况下，等同于</em></strong>|**<em>，否则等同于 ns|</em>|</p>
<h2 id="6-属性选择器"><a href="#6-属性选择器" class="headerlink" title="6 属性选择器"></a>6 属性选择器</h2><p>根据元素的属性和属性值来匹配元素。通用语法由方括号[ ] 组成，其中包含属性名称，后跟可选条件以匹配属性的值。</p>
<p>|<strong>[att]</strong>|表示定义了att属性的元素，无论属性值是什么|<br>|:—-:|:—-|:—-:|:—-|<br>|<strong>[att=val]</strong>|表示定义了att属性且属性值是val的元素|<br>|<strong>[att~=val]</strong>|表示定义了att属性且属性值在一个以空格分隔的列表中的值为val的元素,如果val中有空格或为空字符串，则不代表任何元素|<br>|<strong>[att|=val]</strong>|表示定义了att属性且值在以连字符（-）分隔的列表中以val开头或就是val|<br>|<strong>[att^=val]</strong>|表示定义了att属性且值以val开头的元素,如果val为空字符串，则不代表任何元素|<br>|<strong>[att$=val]</strong>|表示定义了att属性且值以val结尾的元素,如果val为空字符串，则不代表任何元素|<br>|*<em>[att</em>=val]**|表示定义了att属性且值含有val的元素,如果val为空字符串，则不代表任何元素|</p>
<p>属性选择器中的属性名是一个CSS限定名:之前声明的命名空间前缀可以被前置到属性名前，默认名称空间不适用于属性，因此没有名称空间组件的属性选择器只适用于没有名称空间的属性(相当于“|attr”)。如果命名空间前缀没有提前声明，此属性选择器是无效的</p>
<p>CSS examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> foo <span class="string">&quot;http://www.example.com&quot;</span>;</span><br><span class="line"><span class="selector-attr">[foo|att=val]</span>&#123;<span class="attribute">color</span>:blue&#125;<span class="comment">/* 匹配定义的att属性在&quot;http://www.example.</span></span><br><span class="line"><span class="comment">com&quot;命名空间值中，且其值为val的元素 */</span></span><br><span class="line"><span class="selector-attr">[*|att]</span> &#123;<span class="attribute">color</span>: yellow&#125;<span class="comment">/* 只匹配定义了att属性的元素 */</span></span><br><span class="line"><span class="selector-attr">[|att]</span> &#123;<span class="attribute">color</span>: green&#125;<span class="comment">/* 匹配属性没有命名空间的元素 */</span></span><br><span class="line"><span class="selector-attr">[att]</span> &#123;<span class="attribute">color</span>: green&#125;<span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure>
<h3 id="6-1-DTD文档中属性默认值"><a href="#6-1-DTD文档中属性默认值" class="headerlink" title="6.1 DTD文档中属性默认值"></a>6.1 DTD文档中属性默认值</h3><p>在某些文档格式中，默认属性值可以在DTD或其他地方定义，如果他们存在于文档树中，只能被属性选择器选中。</p>
<p>例如，XML UA需要在文档的“内部子集”中查找默认属性值。根据UA的不同，在DTD的外部子集中定义的默认属性值可能会也可能不会出现在文档树中。</p>
<p>Example:</p>
<p>一个定义了radix属性，且默认属性值为”decimal”的EXAMPLE元素，DTD片段如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ATTLIST <span class="meta-keyword">EXAMPLE</span> <span class="meta-keyword">radix</span> (<span class="meta-keyword">decimal</span>,<span class="meta-keyword">octal</span>) <span class="meta-string">&quot;decimal&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果样式表包含规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">EXAMPLE</span><span class="selector-attr">[radix=decimal]</span> &#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span><br><span class="line"><span class="selector-tag">EXAMPLE</span><span class="selector-attr">[radix=octal]</span>   &#123; <span class="comment">/*... other settings...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>第一条规则可能不会匹配radix属性为默认值的元素，也就是没有被明确设置。为了应对所有情形，对默认属性的属性选择器必须被取消掉：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">EXAMPLE</span>                &#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span><br><span class="line"><span class="selector-tag">EXAMPLE</span><span class="selector-attr">[radix=octal]</span>   &#123; <span class="comment">/*... other settings...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这里，因为选择器EXAMPLE[radix=octal]更加具体，第二条规则的样式声明会覆盖第一条规则。注意所有针对默认情况的属性声明都会被非默认情况下的样式规则覆盖。</p>
<h2 id="7-类选择器"><a href="#7-类选择器" class="headerlink" title="7 类选择器"></a>7 类选择器</h2><p>类选择器允许以一种独立于文档元素的方式来指定样式。通过，可以代替“~=”  符号来表示，    该属性值必须紧跟在“.”符号后面。</p>
<p>CSS examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*<span class="selector-class">.pastoral</span> &#123; <span class="attribute">color</span>: green  &#125;<span class="comment">/* all elements with class~=pastoral */</span></span><br><span class="line"><span class="selector-class">.pastoral</span> &#123; <span class="attribute">color</span>: green &#125;  <span class="comment">/* all elements with class~=pastoral */</span></span><br><span class="line"><span class="selector-tag">H1</span><span class="selector-class">.pastoral</span> &#123; <span class="attribute">color</span>: green &#125;  <span class="comment">/* H1 elements with class~=pastoral */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.pastoral</span><span class="selector-class">.marine</span> &#123; <span class="attribute">color</span>: green &#125; <span class="selector-tag">l</span><span class="comment">/* class属性值同时有pastoral和marine且以空格隔开 */</span></span><br></pre></td></tr></table></figure>
<h2 id="8-ID选择器"><a href="#8-ID选择器" class="headerlink" title="8 ID选择器"></a>8 ID选择器</h2><p>ID选择器表示具有与ID选择器中的标识符匹配的标识符的元素实例。选择器不会指定UA如何知道元素的ID类型属性。ID属性在同一文档中是唯一的</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-id">#chapter1</span> <span class="comment">/* 表示一个h1元素，其ID类型属性值为“chapter1” */</span></span><br><span class="line"><span class="selector-id">#chapter1</span> <span class="comment">/* 表示ID类型属性值为“chapter1”的任何元素 */</span></span><br><span class="line">*<span class="selector-id">#z98y</span> <span class="comment">/* 表示其ID类型属性值为“z98y”的任何元 */</span></span><br></pre></td></tr></table></figure>
<h2 id="9-伪类"><a href="#9-伪类" class="headerlink" title="9 伪类"></a>9 伪类</h2><p>伪类的概念被引入以允许选择位于该文档树以外或者使用其他简单选择器不能表达的信息。</p>
<p>伪类允许出现在选择器中的所有简单选择器序列中。伪类可以出现在简单选择器序列的任何地方。伪类的名字是不区分大小写的。一些伪类是互相排斥的，伪类可能是动态的，当用户操作文档时一个元素可能获得或失去一个伪类。</p>
<h3 id="9-1-动态伪类"><a href="#9-1-动态伪类" class="headerlink" title="9.1 动态伪类"></a>9.1 动态伪类</h3><p>动态伪类根据元素特征分类，不同于他们的名称、属性和内容，原则上特征不能从文档树得出，动态伪类不会出现在文档源或文档树中。</p>
<h4 id="9-1-1-链接伪类-link-和-visited"><a href="#9-1-1-链接伪类-link-和-visited" class="headerlink" title="9.1.1 链接伪类*:link 和:visited*"></a>9.1.1 链接伪类*:link 和:visited*</h4><p>用户代理一般将已访问过的链接和未访问的链接分开表示。选择器提供伪类:link 和 :visited来区分他们。</p>
<p><strong>:link</strong>伪类表示还没有访问过的链接</p>
<p><strong>:visited</strong>伪类表示已经访问过的链接</p>
<p>经过一定的时间，用户代理可能选择返回一个访问过的链接为:link状态。这两种状态是互斥的 。</p>
<p>这可能让样式表开发者在未经用户同意的情况下探测用户已经访问过哪些网站。UA可能因此将所有链接设置为未访问，或实现其他策略去避免用户隐私泄露。</p>
<h4 id="9-1-2-用户动作伪类-hover-active-focus"><a href="#9-1-2-用户动作伪类-hover-active-focus" class="headerlink" title="9.1.2 用户动作伪类 :hover, :active,:focus"></a>9.1.2 用户动作伪类 :hover, :active,:focus</h4><p>交互性用户代理时有会改变渲染以响应用户操作。选择器提供三个伪类来响应用户操作。</p>
<p><strong>:hover伪类</strong>：当用户通过指针设备指定一个元素，但不一定激活它。例如，当光标（鼠标指针）停在元素上方时可视化用户代理可以激活这个伪类。不支持交互式媒体的用户代理不必支持这个伪类。</p>
<p><strong>:active伪类</strong>：用户激活元素时激活这个伪类。例如用户在元素上单击鼠标。</p>
<p><strong>:focus伪类</strong>：当元素获取焦点时这个伪类被激活（从键盘或鼠标或其他设备获取输入）。</p>
<p>文档语言或特殊实现会限制某些元素能够捕获:active或:focus。这些伪类不是互相排斥的。一个元素可能同时匹配到多个伪类。</p>
<p>当一个元素处于:active或:hover时，选择器没有定义其父元素是否也处于同样的状态。如果一个元素处于:hover作用是因为它的子元素被指针设备所指向，这时这个父元素可能并没有被指针元素所指向。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>    <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> <span class="comment">/* 已访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>   <span class="comment">/* 用户悬停 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>  <span class="comment">/* 活动中的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>   <span class="comment">/* 获取焦点 */</span> </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:hover</span> <span class="comment">/* 动态伪类的组合 */</span></span><br><span class="line"><span class="comment">/* 一个元素可以同时处在:visited和:active（或 :link 和 :active) */</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-目标伪类-target"><a href="#9-2-目标伪类-target" class="headerlink" title="9.2 目标伪类:target"></a>9.2 目标伪类:target</h3><p>有些URI引用一个资源中的一个地址。这类URI以井号（#）结束并跟着一个锚标识符（被称作片段标识符 fragment identifier）。</p>
<p>具有片段标识符的URI链接到文档内的某一个元素，就是目标元素。例如这个URI指向HTML文档内叫做section_2的锚点：<a href="http://example.com/html/top.html#section_2">http://example.com/html/top.html#section_2</a></p>
<p>一个目标元素可以被:target伪类表示。如果文档的URI没有片段标识符，那么文档不存在目标元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.note</span><span class="selector-pseudo">:target</span> <span class="comment">/* 一个做为文档目标元素且class为note的p元素 */</span></span><br><span class="line"><span class="comment">/* 下面，:target伪类用来将目标元素变成红色并且在它之前放置一个图像： */</span></span><br><span class="line">*<span class="selector-pseudo">:target</span> &#123; <span class="attribute">color </span>: red &#125;</span><br><span class="line">*<span class="selector-pseudo">:target</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content </span>: <span class="built_in">url</span>(target.png) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-语言伪类-lang"><a href="#9-3-语言伪类-lang" class="headerlink" title="9.3 语言伪类:lang"></a>9.3 语言伪类:lang</h3><p>如果文档语言描述了如何确定一个元素的自然语言，那么将有可能实现一个表示特定语言的元素的选择器。例如，在HTML中语言可以被lang属性和meta元素中的可能存在的一些信息组合表示或在协议中（例如HTTP头部）表示。XML使用叫做xml:lang的属性，并且其他文档语言可能使用其他方法来确定语言。</p>
<p>伪类**:lang(C)**表示一个使用语言C的元素。无论元素的语言值等于C，或是以C开头跟随“ - ”都将被匹配。    对C和元素语言值的匹配是不区分大小写的。C不必是一个有效的语言名。</p>
<p>C必须是一个有效的CSS标识符并且不可以为空，否则，选择器是无效的。</p>
<p>Examples:</p>
<p>前两个选择器表示一个应用Belgian French 或 German语言的HTML文档。后两个选择器表示任意Belgian French 或 German语言元素中的q元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html:lang(fr-be)</span><br><span class="line">html:lang(de)</span><br><span class="line">:lang(fr-be) &gt; q</span><br><span class="line">:lang(de) &gt; </span><br></pre></td></tr></table></figure>
<p>:lang(C)与 |= 操作符的区别在于： |= 操作符仅仅表示对元素指定属性的比较，而:lang(C)伪类使用UA的知识在文档语义上进行比较。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/*仅仅body匹配[lang|=fr]（因为它具有LANG属性）但是body和P都匹配:lang(fr)（因为他们都使用法语）。P不匹配[lang|=fr]因为它没有LANG属性：*/</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">lang</span>=<span class="string">fr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Je suis français.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-4-UI元素状态伪类"><a href="#9-4-UI元素状态伪类" class="headerlink" title="9.4 UI元素状态伪类"></a>9.4 UI元素状态伪类</h3><h4 id="9-4-1-enabled和-disabled伪类"><a href="#9-4-1-enabled和-disabled伪类" class="headerlink" title="9.4.1 :enabled和:disabled伪类"></a>9.4.1 :enabled和:disabled伪类</h4><p><strong>:enabled</strong>伪类表示处在可用状态下的用户接口元素。这些元素具有与不可用相对的状态。</p>
<p>:<strong>disabled</strong>伪类表示用户接口元素在不可用状态。这些元素具有与可用相对的状态。</p>
<p>用户接口元素、可用与不可用的状态是依赖于语言的。在一个典型的文档中大多数元素既不是:enabled也不是:disabled的。（常用于input、textarea）</p>
<p>CSS中可能影响用户与UI元素交互的属性不会影响:enabled或:disabled的匹配。例如display和visibility属性不会影响元素的enabled/disabled状态。</p>
<h4 id="9-4-2-checked伪类"><a href="#9-4-2-checked伪类" class="headerlink" title="9.4.2 :checked伪类"></a>9.4.2 :checked伪类</h4><p>单选和多选元素可以被用户开关。一些菜单项目在用户选择他们时会处在选中状态。例如:checked伪类最初匹配HTML4中具有selected和checked的元素。:checked伪类本质上是动态的，他们随着用户操作而改，。因为它可以以文档中存在的语义属性作为依据，所以它可以匹配所有的媒体。用户可以关闭(toggle “off”)这些元素，这将使:checked伪类不再匹配。（常用于    checkbox    、radio、option ）</p>
<h4 id="9-4-3-indeterminate伪类"><a href="#9-4-3-indeterminate伪类" class="headerlink" title="9.4.3 :indeterminate伪类"></a>9.4.3 :indeterminate伪类</h4><p>单选和多选元素可以被用户开关，但一些时候它们处在不确定状态，既不是选中也不是非选中。元素属性和DOM操作可能导致这种情况。</p>
<h3 id="9-5-结构伪类"><a href="#9-5-结构伪类" class="headerlink" title="9.5 结构伪类"></a>9.5 结构伪类</h3><p>选择器通过结构化伪类的概念来进行基于文档中额外信息的不能被其他简单选择器或组合器表示的匹配。</p>
<p>在计算元素位于其父元素的子元素列表中的位置时，独立的文字或其他非元素节点是不被计算的且索引是从1开始的。</p>
<h4 id="9-5-1-root伪类"><a href="#9-5-1-root伪类" class="headerlink" title="9.5.1 :root伪类"></a>9.5.1 :root伪类</h4><p>:root伪类表示作为文档根的元素。在HTML 4中总是HTML元素。</p>
<h4 id="9-5-2-nth-child-伪类"><a href="#9-5-2-nth-child-伪类" class="headerlink" title="9.5.2 :nth-child()伪类"></a>9.5.2 :nth-child()伪类</h4><p>:nth-child(an+b)伪类表示一个元素它在文档树中有an+b-1个前兄弟节点，n可以为任何正数或0，并且有一个父元素。a和b要大于0。这有效的将子元素按a个元素进行分组（最后一组包含余数个元素），并且选择每一组的第b个元素。a和b必须为整数（正数，负数或0）。第一个子元素的索引是1。</p>
<p>:nth-child()可以用odd和even作为参数。odd相当于2n+1，even相当于2n。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n+1)</span> <span class="comment">/* 表示HTML中table的奇数行 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(odd)</span>  <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n+0)</span> <span class="comment">/* 表示HTML中table的偶数行 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(even)</span> <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="comment">/* 通过CSS修改段落颜色 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+1)</span> &#123; <span class="attribute">color</span>: navy; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+2)</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+3)</span> &#123; <span class="attribute">color</span>: maroon; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+4)</span> &#123; <span class="attribute">color</span>: purple; &#125;</span><br></pre></td></tr></table></figure>
<p>当b前面存在负号，那么正号必须被移除，也就是说被负号替代以表示b是个负数。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child(10n-1)</span>  <span class="comment">/* 表示第9，第19，第29以此类推的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-child(10n+9)</span>  <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-child(10n+-1)</span> <span class="comment">/* 无效的语法，会被忽略 */</span></span><br></pre></td></tr></table></figure>
<p>当a=0时ab部分应被忽略（除非b部分已经被忽略了）。当an不存在并且b是非负数，b前的正号（当存在时）可以被忽略。这类似于:nth-child(b)。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">foo</span><span class="selector-pseudo">:nth-child(0n+5)</span>   <span class="comment">/* 表示一个处在第五个的foo元素 */</span></span><br><span class="line"><span class="selector-tag">foo</span><span class="selector-pseudo">:nth-child(5)</span>      <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure>
<p>当a=1或a=-1，这个数字可以被省略。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 下面的选择器等价: */</span></span><br><span class="line"><span class="selector-tag">bar</span><span class="selector-pseudo">:nth-child(1n+0)</span>   <span class="comment">/* 选择所有bar元素, 优先级 (0,1,1) */</span></span><br><span class="line"><span class="selector-tag">bar</span><span class="selector-pseudo">:nth-child(n+0)</span>    <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-tag">bar</span><span class="selector-pseudo">:nth-child(n)</span>      <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-tag">bar</span>                   <span class="comment">/* 同上，但是优先级更低 (0,0,1) */</span></span><br></pre></td></tr></table></figure>
<p>如果b=0，那么每一个第a个元素被选取。这种情况下，+b(或-b)部分可能被省略除非a部分已经被省略了。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n+0)</span> <span class="comment">/* 示HTML中table的每一个偶数行 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n)</span> <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure>
<p>空白符被允许出现在 左括号“(” 后和右括号 “)” 前，并且当an和b同时出现时空白符可以出现在“+”或“-”的两边。</p>
<p>Valid Examples with white space:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child(</span> 3<span class="selector-tag">n</span> + 1 )</span><br><span class="line"><span class="selector-pseudo">:nth-child(</span> +3<span class="selector-tag">n</span> <span class="selector-tag">-</span> 2 )</span><br><span class="line"><span class="selector-pseudo">:nth-child(</span> <span class="selector-tag">-n</span>+ 6)</span><br><span class="line"><span class="selector-pseudo">:nth-child(</span> +6 )</span><br></pre></td></tr></table></figure>
<p>Invalid Examples with white space:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child(3</span> <span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-pseudo">:nth-child(+</span> 2<span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-pseudo">:nth-child(+</span> 2)</span><br></pre></td></tr></table></figure>
<p>a和b都为0时，这个伪类不表示文档树中的任何元素。</p>
<p>a可以是负数，但是an+b只能是正数，对于n&gt;=0，可能表示文档树中的一个元素。</p>
<p>Example:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">html|tr:nth-child(-n+6)  /* 表示XHTML中table的前6行 */</span><br></pre></td></tr></table></figure>
<h4 id="9-5-3-nth-last-child-伪类"><a href="#9-5-3-nth-last-child-伪类" class="headerlink" title="9.5.3 :nth-last-child() 伪类"></a>9.5.3 :nth-last-child() 伪类</h4><p>:nth-of-type(an+b)伪类表示一个元素在文档树中在这个元素之前具有an+b-1个和此元素相同元素名的兄弟元素，n可以为任何正数或0，并且具有父元素。 参数的定义参照:nth-child()。同样可以接受odd和even作为参数。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-last-child(-n+2)</span>  <span class="comment">/* 表示HTML中table的最后2行 */</span></span><br><span class="line"><span class="selector-tag">foo</span><span class="selector-pseudo">:nth-last-child(odd)</span>  <span class="comment">/* 表示父元素中的所有奇数元素，从后往前计算 */</span></span><br></pre></td></tr></table></figure>
<h4 id="9-5-4-nth-of-type-伪类"><a href="#9-5-4-nth-of-type-伪类" class="headerlink" title="9.5.4 :nth-of-type() 伪类"></a>9.5.4 :nth-of-type() 伪类</h4><p>:nth-of-type(an+b)伪类表示一个元素在文档树中在这个元素之前具有an+b-1个和此元素相同元素名的兄弟元素，n可以为任何正数或0，并且具有父元素。 参数的定义参照:nth-child()。同样可以接受odd和even作为参数。</p>
<p>CSS example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:nth-of-type(2n+1)</span> &#123; <span class="attribute">float</span>: right; &#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:nth-of-type(2n)</span> &#123; <span class="attribute">float</span>: left; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-5-nth-last-of-type-伪类"><a href="#9-5-5-nth-last-of-type-伪类" class="headerlink" title="9.5.5 :nth-last-of-type()伪类"></a>9.5.5 :nth-last-of-type()伪类</h4><p>:nth-last-of-type(an+b)伪类表示一个元素在文档树中在这个元素之后具有an+b-1个和此元素相同元素名的兄弟元素，n可以为任何正数或0，并且具有父元素。 参数的定义参照:nth-child()。同样可以接受odd和even作为参数。</p>
<p>Example:</p>
<p>表示body中所有h2元素，除了第一个和最后一个</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(n+2)</span><span class="selector-pseudo">:nth-last-of-type(n+2)</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，用样可以使用:not(),虽然选择器是一样长的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">h2</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-of-type)</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-of-type)</span></span><br></pre></td></tr></table></figure>
<h4 id="9-5-6-first-child伪类"><a href="#9-5-6-first-child伪类" class="headerlink" title="9.5.6 :first-child伪类"></a>9.5.6 :first-child伪类</h4><p>与:nth-child(1)相同。:first-child表示第一个子元素。</p>
<p>Examples:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span><span class="comment">/*表示div元素中的p元素，且这个p元素是第一个子元素 */</span></span><br></pre></td></tr></table></figure>
<p>这个选择器表示下面片段中div中的p元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">last</span> <span class="selector-tag">P</span> <span class="selector-tag">before</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;div class=&quot;note&quot;&gt;</span><br><span class="line">   &lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">first</span> <span class="selector-tag">P</span> <span class="selector-tag">inside</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>但是不表示下面片段中的第二个p元素：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">last</span> <span class="selector-tag">P</span> <span class="selector-tag">before</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;div class=&quot;note&quot;&gt;</span><br><span class="line">   &lt;<span class="selector-tag">h2</span>&gt; <span class="selector-tag">Note</span> &lt;/<span class="selector-tag">h2</span>&gt;</span><br><span class="line">   &lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">first</span> <span class="selector-tag">P</span> <span class="selector-tag">inside</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>下面的两个选择器一般是等价的:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:first-child</span> <span class="comment">/* a是任何元素的第一个子元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:first-child</span> <span class="comment">/* 当a不是根元素时同上 */</span></span><br></pre></td></tr></table></figure>
<h4 id="9-5-7-last-child伪类"><a href="#9-5-7-last-child伪类" class="headerlink" title="9.5.7 :last-child伪类"></a>9.5.7 :last-child伪类</h4><p>同:nth-last-child(1)。:last-child表示一个元素中的最后一个子元素。</p>
<p>Example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> <span class="comment">/* 表示一个有序列表ol中的最后一个条目li */</span> </span><br></pre></td></tr></table></figure>
<h4 id="9-5-8-first-of-type-伪类"><a href="#9-5-8-first-of-type-伪类" class="headerlink" title="9.5.8 :first-of-type 伪类"></a>9.5.8 :first-of-type 伪类</h4><p>同:nth-of-type(1)。:first-of-type伪类表示具有相同元素类型的兄弟节点中的第一个节点。</p>
<p>Example:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 表示一个在列表dl中的标题dt，这个dt是与它相同类型的兄弟节点中的第一个节点： */</span></span><br><span class="line"><span class="selector-tag">dl</span> <span class="selector-tag">dt</span><span class="selector-pseudo">:first-of-type</span></span><br></pre></td></tr></table></figure>
<p>这表示了下面的头两个dt元素，但不能表示第三个dt元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dt</span>&gt;</span>gigogne<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>fusée<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>multistage rocket<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>table<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>   /* 不能被表示到 */</span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>nest of tables<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="9-5-9-last-of-type"><a href="#9-5-9-last-of-type" class="headerlink" title="9.5.9 :last-of-type"></a>9.5.9 :last-of-type</h4><p>同:nth-last-of-type(1)。:last-of-type伪类表示具有相同元素类型的兄弟节点中的最后一个节点。</p>
<p>Example:</p>
<p>下面的选择器表示table行tr中的最后一个数据单元td：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> &gt; <span class="selector-tag">td</span><span class="selector-pseudo">:last-of-type</span></span><br></pre></td></tr></table></figure>
<h4 id="9-5-10-only-child伪类"><a href="#9-5-10-only-child伪类" class="headerlink" title="9.5.10 :only-child伪类"></a>9.5.10 :only-child伪类</h4><p>表示某个是其父元素中的唯一元素的元素。同:first-child:last-child 或 :nth-child(1):nth-last-child(1), 但是具有更低的优先级。</p>
<h4 id="9-5-11-only-of-type伪类"><a href="#9-5-11-only-of-type伪类" class="headerlink" title="9.5.11 :only-of-type伪类"></a>9.5.11 :only-of-type伪类</h4><p>表示某个父元素中子元素，父元素不存在与此子元素同类的子元素。同:first-of-type:last-of-type 或 :nth-of-type(1):nth-last-of-type(1)，但是具有更低的优先级。</p>
<h4 id="9-5-12-empty伪类"><a href="#9-5-12-empty伪类" class="headerlink" title="9.5.12 :empty伪类"></a>9.5.12 :empty伪类</h4><p>:empty伪类表示一个元素根本没有子元素。在文档树中，仅仅元素节点和内容节点具有非0长度的数据时，会影响是否为空。注释，处理指令和其他节点不会产生影响。</p>
<p>Examples:</p>
<p>p:empty 对下面的片段是有效的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>foo:empty 对下面的片段是无效的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="tag">&lt;<span class="name">bar</span>&gt;</span>bla<span class="tag">&lt;/<span class="name">bar</span>&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>this is not <span class="tag">&lt;<span class="name">bar</span>&gt;</span>:empty<span class="tag">&lt;/<span class="name">bar</span>&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-6-空白"><a href="#9-6-空白" class="headerlink" title="9.6 空白"></a>9.6 空白</h3><p>这一节是故意留白的，之前是:contains()伪类。</p>
<h3 id="9-7-否定伪类"><a href="#9-7-否定伪类" class="headerlink" title="9.7 否定伪类"></a>9.7 否定伪类</h3><p>否定伪类:not(X)是一个将简单选择器作为参数的功能符。它表示不是它的参数所表示的元素。</p>
<p>否定伪类不可嵌套，:not(:not(…))是无效的。注意因为伪元素不是简单选择器，所以他们不可以作为:not()的参数。</p>
<p>Examples:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[DISABLED]</span>) <span class="comment">/* 表示不是disabled状态以外的所有button */</span></span><br><span class="line">*<span class="selector-pseudo">:not(FOO)</span><span class="comment">/* 表示不是FOO元素以外的所有元素 */</span></span><br><span class="line">html|*:not(:link):not(:visited) /* 表示除了链接以外所有HTML元素 */</span><br></pre></td></tr></table></figure>
<p>默认命名空间声明不会影响否定伪类的参数，除非参数是个全局选择器或一个类型选择器。<br>Examples:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果默认命名空间是&quot;http://example.com/&quot;，下面的选择器表示所有不在这个命名空间中的元素 */</span></span><br><span class="line">*|*:not(*)</span><br><span class="line"><span class="comment">/* 下面的选择器匹配任何没有被指向的元素，不管它的命名空间是什么 */</span></span><br><span class="line">*|*:not(:hover)</span><br></pre></td></tr></table></figure>
<p>:not()伪类允许表示没有价值的选择器，例如:not(<em>|</em>)，这不表示任何元素，或者foo:not(bar)，这等价于foo但是具有更高优先级。</p>
<h2 id="10-伪元素"><a href="#10-伪元素" class="headerlink" title="10 伪元素"></a>10 伪元素</h2><p>伪元素创建超越文档语言定义的文档树的抽象概念。伪元素允许开发者访问这些原本难以访问的信息，以及访问源文档中不存在内容。</p>
<p>伪元素由两个冒号::及紧跟伪元素的名字组成。 为了兼容性，单冒号也被允许。伪元素必须在简单选择器序列的最后。</p>
<h3 id="10-1-first-line伪元素"><a href="#10-1-first-line伪元素" class="headerlink" title="10.1 ::first-line伪元素"></a>10.1 ::first-line伪元素</h3><p><strong>::first-line</strong>伪元素表示元素中的第一个格式化行 .</p>
<p>选择器P::first-line不匹配任何真正的文档元素。用户代理会添加虚拟标签序列（fictional tag sequence）到文档中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;P&gt;&lt;P::first-line&gt; This is a somewhat long HTML paragraph that &lt;&#x2F;P::first-line&gt; will be broken into several lines. The first line will be identified by a fictional tag sequence.&lt;&#x2F;P&gt;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-1-CSS中定义的第一个格式化行"><a href="#10-1-1-CSS中定义的第一个格式化行" class="headerlink" title="10.1.1 CSS中定义的第一个格式化行"></a>10.1.1 CSS中定义的第一个格式化行</h4><p>在CSS中，::first-line伪元素在块容器时才有效。元素的第一个格式化行可能出现在块级后代中。例如，<DIV><P>This line…</P></DIV>中DIV的第一行就是P的第一行（假定P和DIV都是块级）。</p>
<p>table-cell或 inline-block不能作为祖先元素的第一个格式化行。因此，<DIV><P STYLE="display: inline-block">Hello<BR>Goodbye</P> etcetera</DIV>中DIV的第一个格式化行不是“Hello”，而是 etcetera。</p>
<p>在片段<p><br>First…中p的第一个格式化行不包含任何字母（假定使用HTML4中br的默认样式），因为由br的存在。</p>
<p>UA应该将::first-line的虚拟开始标签嵌套于最内部的闭合块级元素中。 （只是应该而已，因为css1和css2没有要求）</p>
<p>例如，下面段落</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">  &lt;P&gt;First paragraph&lt;&#x2F;P&gt;</span><br><span class="line">  &lt;P&gt;Second paragraph&lt;&#x2F;P&gt;</span><br><span class="line">&lt;&#x2F;DIV&gt;</span><br></pre></td></tr></table></figure>
<p>虚拟标签序列是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">  &lt;P&gt;&lt;DIV::first-line&gt;&lt;P::first-line&gt;First paragraph&lt;&#x2F;P::first-line&gt;&lt;&#x2F;DIV::first-line&gt;&lt;&#x2F;P&gt;</span><br><span class="line">  &lt;P&gt;&lt;P::first-line&gt;Second paragraph&lt;&#x2F;P::first-line&gt;&lt;&#x2F;P&gt;</span><br><span class="line">&lt;&#x2F;DIV&gt;</span><br></pre></td></tr></table></figure>
<p>::first-line伪元素类似于一个 inline-level元素，但是具有一些约束。下面的CSS属性可以作用于一个::first-line伪元素：字体属性，颜色属性，背景属性，word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, line-height。UA可能实现其他属性。<br>在CSS继承中，出现在第一行的子元素的某些部分仅从::first-line伪元素继承适用于::first-line伪元素的属性。其他属性继承于第一行伪元素的非伪元素父元素。（子元素的不出现在第一行的部分总是继承于父元素）。这里太绕了。。。</p>
<h3 id="10-2-first-letter伪元素"><a href="#10-2-first-letter伪元素" class="headerlink" title="10.2 :first-letter伪元素"></a>10.2 :first-letter伪元素</h3><p>::first-letter伪元素，如果在这行上它前面没有任何其他内容（例如图片和 inline tables），表示元素的第一个字母，::first-letter伪元素通常被用于开头字母大写和首字下沉这些通用的印刷效果。</p>
<p>如果标点符号出现在在首字母之前或之后也应该被包括进去，数字也同样生效。</p>
<p>如果组成::first-letter的字母不在一个元素中，例如<p>‘<em>T…中的“’T”，UA可能为其中一个或两个字母创建::first-letter伪元素，或都不创建。</p>
<p>首字母必须出现在第一个格式化行上。例如，在<p><br>First…第一行不包含任何字母并且::first-letter不匹配任何东西。</p>
<h4 id="10-2-1-CSS中的应用"><a href="#10-2-1-CSS中的应用" class="headerlink" title="10.2.1 CSS中的应用"></a>10.2.1 CSS中的应用</h4><p>在CSS中，::first-letter伪元素在 block-like 容器中生效，例如block，list-item，table-cell，table-caption和inline-block元素。</p>
<p>在CSS中t，able-cell或inline-block的第一个字母不能作为祖先元素的第一个字母。</p>
<p>如果元素是list item (‘display: list-item’), ::first-letter 应用在主体盒子标记后的第一个字母。    用户代理将忽略该列表项的    ::first-letter。如果元素有::b=efore和::after内容，::first-letter应用的时候应该包含它们的内容。比如，在p::before {content: “Note: “}生效时， p::first-letter 匹配“Note”中的“N”。</p>
<p>在CSS中,当float属性是none时::first-line伪元素相当于一个inline-level元素 ,否则它是浮动元素。</p>
<h3 id="10-3-before-和-after伪类"><a href="#10-3-before-和-after伪类" class="headerlink" title="10.3 ::before 和 ::after伪类"></a>10.3 ::before 和 ::after伪类</h3><p><strong>::before</strong>和**::after**伪类用来描述在元素内容之前或之后生成内容。</p>
<p>当::first-letter和::first-line被用在包含::before或::after生成元素的对象时，第一个字母或第一行包含这些生成内容。</p>
<h2 id="11-组合器"><a href="#11-组合器" class="headerlink" title="11 组合器"></a>11 组合器</h2><h3 id="11-1-后代组合器"><a href="#11-1-后代组合器" class="headerlink" title="11.1 后代组合器"></a>11.1 后代组合器</h3><p>选择器“A B”表示一个元素B是祖先A的任意后代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div * p</span><br></pre></td></tr></table></figure>
<p>表示了p元素是div元素之后的第二代或更多代元素。*两侧的空白符不属于全局选择器。空白符是一个组合器表示div是某个元素的祖先，并且这个元素是p的祖先。<br>表示一个元素具有href属性并且是p的后代，p在div之中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div p *[href]</span><br></pre></td></tr></table></figure>
<h3 id="11-2-子代组合器"><a href="#11-2-子代组合器" class="headerlink" title="11.2 子代组合器"></a>11.2 子代组合器</h3><p>子代组合器描述了两个元素间的父子关系。</p>
<h3 id="11-3-兄弟选择器"><a href="#11-3-兄弟选择器" class="headerlink" title="11.3 兄弟选择器"></a>11.3 兄弟选择器</h3><p>有两个兄弟组合器：next-sibling combinator和subsequent-sibling combinator。他们都会忽略非元素节点（例如元素间的文字）。</p>
<h4 id="11-4-相邻兄弟组合器"><a href="#11-4-相邻兄弟组合器" class="headerlink" title="11.4 相邻兄弟组合器"></a>11.4 相邻兄弟组合器</h4><p>相邻兄弟组合器用“+”表示，它分割两个简单选择器序列。在文档树中这两个序列具有相同的父节点并且第一个序列表示的元素紧紧在第二个序列表示的元素前。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">math</span> + <span class="selector-tag">p</span>  <span class="comment">/* 表示跟在一个math元素后的p元素 */</span></span><br></pre></td></tr></table></figure>
<h4 id="11-5-一般兄弟选择器"><a href="#11-5-一般兄弟选择器" class="headerlink" title="11.5 一般兄弟选择器"></a>11.5 一般兄弟选择器</h4><p>一般兄弟选择器通过“~”表示，它分割两个简单选择器序列。两个序列表示的元素要在同一个父元素下并且第一个序列表示的元素要在第二个序列表示的元素前（但不必是紧紧挨着）。</p>
<h2 id="12-选择器优先级计算"><a href="#12-选择器优先级计算" class="headerlink" title="12 选择器优先级计算"></a>12 选择器优先级计算</h2><p>规则如下：</p>
<pre><code>    1. ID选择器的数量 (= a)
    2. 类选择器、属性选择器和伪类的数量 (= b)
    3. 类型选择器和伪元素的数量(= c)</code></pre>
<p>忽略通用选择器，否定伪类参与计算，但不当做伪类计算。把三个数字连起来a-b-c（在具有大基数的数字系统中）作为优先级。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>W3C CSS</category>
      </categories>
      <tags>
        <tag>W3C</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>03-WebKit架构和模块</title>
    <url>/2021/01/21/note/Webkit/03-WebKit%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="3-1-WebKit-架构及模块"><a href="#3-1-WebKit-架构及模块" class="headerlink" title="3.1 WebKit 架构及模块"></a>3.1 WebKit 架构及模块</h2><h3 id="3-1-1-获取WebKit"><a href="#3-1-1-获取WebKit" class="headerlink" title="3.1.1 获取WebKit"></a>3.1.1 获取WebKit</h3><p>WebKit是一个开源项目，可以从<a class="link"   href="http://www.webkit.org官方网站下载源代码./" >www.webkit.org官方网站下载源代码。<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="3-1-2-WebKit-架构"><a href="#3-1-2-WebKit-架构" class="headerlink" title="3.1.2 WebKit 架构"></a>3.1.2 WebKit 架构</h3><p>WebKit支持不同的浏览器，因为不同浏览器的需求不同，所以在WebKit中，一些代码可以共享，另外一部分不同的被称为WebKit的移植（Ports）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/a3fWkhvNVFGbXUM.png"
                      alt="3NEAHZuv3WuglE3I__thumbnail.png"
                ></p>
<p>图中的WebKit架构，虚线框表示该部分模块在不同浏览器使用的WebKit内核中的实现不是普遍共享的，实线框标记的模块表示它们基本上是共享的，但是否共享可以通过不同的编译配置改变它们的行为。</p>
<p>图中最下面的是“<strong>操作系统</strong>”，WebKit可以在不同的操作系统上工作。不同浏览器可能会依赖不同的操作系统，同一个浏览器使用的WebKit也可能依赖不同的操作系统。</p>
<p>在“操作系统”层之上的就是WebKit赖以工作的<strong>第三方库</strong>，这些库是WebKit运行的基础。通常来讲，它们包括<strong>图形库</strong>、<strong>网络库</strong>、<strong>视频库</strong>等。</p>
<p>在它们二者之上的就是WebKit项目，图中把它细分为两层，每层包含很多模块，由于图的大小限制，略去了其中一些次要模块。这些模块支撑网页加载和渲染过程。</p>
<p><strong>WebCore</strong>是加载和渲染网页的基础部分，包括<strong>HTML解释器</strong>、<strong>CSS解释器</strong>、<strong>SVG</strong>、<strong>DOM</strong>、<strong>渲染树</strong>（RenderObject树、RenderLayer树等），以及<strong>Inspector</strong>（Web Inspector、调试网页）。这些共享部分有些是基础框架，其背后的支持也需要各个平台的不同实现。WebCore这些部分主要被加载和渲染过程的第一、二阶段所使用。</p>
<p><strong>JavaScriptCore引擎</strong>是WebKit中的默认JavaScript 引擎，WebKit 中对JavaScript 引擎的调用是独立于引擎的。</p>
<p><strong>WebKit Ports</strong>指的是WebKit中的非共享部分，包括<strong>硬件加速架构</strong>、<strong>网络栈</strong>、<strong>视频解码</strong>、<strong>图片解码</strong>等。这些模块由于平台差异、依赖的第三方库和需求不同等方面原因，就产生了移植部分，导致众多WebKit版本的行为并非一致。</p>
<p>在WebCore和WebKit Ports之上的层主要是提供嵌入式编程接口，是提供给浏览器调用的。图中左右两个部分分别是<strong>狭义WebKit的接口</strong>和<strong>WebKit2的接口</strong>。因为接口与具体的移植有关，所以有一个与浏览器相关的<strong>绑定层，</strong>绑定层上面就是WebKit项目对外暴露的接口层。接口层的定义也是与移植密切相关的。</p>
<p>WebKit还有一个部分<strong>测试用例</strong>在图中没有展现出来，包括<strong>布局测试用例</strong>（Layout Tests）和<strong>性能测试用例</strong>（Performance Tests），这两类测试包含了大量的测试用例和期望结果。总体上来讲WebKit移植还是共享大量的用例。这些用例被用来验证渲染结果的正确性。每个浏览器所用的WebKit必须保证能够编译出来一个可执行程序，称为DumpRenderTree，它被用来运行测试用例并将渲染结果同期望结果对比。</p>
<h2 id="3-2-基于Blink的Chromium浏览器结构"><a href="#3-2-基于Blink的Chromium浏览器结构" class="headerlink" title="3.2 基于Blink的Chromium浏览器结构"></a>3.2 基于Blink的Chromium浏览器结构</h2><h3 id="3-2-1-Chromium浏览器的架构及模块"><a href="#3-2-1-Chromium浏览器的架构及模块" class="headerlink" title="3.2.1 Chromium浏览器的架构及模块"></a>3.2.1 Chromium浏览器的架构及模块</h3><p>Chromium也是基于WebKit（Blink）的。</p>
<h4 id="3-2-1-1-架构和模块"><a href="#3-2-1-1-架构和模块" class="headerlink" title="3.2.1.1 架构和模块"></a>3.2.1.1 架构和模块</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/c1kLXiOthd6oas5.png"
                      alt="IinKReweDux5nZou__thumbnail.png"
                ></p>
<p>Chromium的架构和主要的模块中，Blink 只是其中的一块，和它并列的还有众多的Chromium模块，包括<strong>GPU/CommandBuffer</strong>（硬件加速架构）、<strong>V8 JavaScript引擎</strong>、<strong>沙箱模型</strong>、<strong>CC</strong>（Chromium Compositor）、<strong>IPC</strong>、<strong>UI</strong>等。</p>
<p><strong>Content 模块</strong>和<strong>Content API</strong>（接口）是Chromium对渲染网页功能的抽象。Content这里是指用来渲染网页内容的模块，没有Content模块，浏览器的开发者也可以在WebKit的Chromium移植上渲染网页内容，但是却没有办法获得沙箱模型、跨进程的GPU硬件加速机制、众多的HTML5功能，因为这些功能很多是在Content层里实现的。</p>
<p>Content模块和Content API将下面的渲染机制、安全机制和插件机制等隐藏起来，提供一个接口层。该接口目前被上层模块或者其他项目使用，内部调用者包括Chromium浏览器、Content Shell 等，外部包括<strong>CEF</strong>（Chromium Embedded Framework）、Opera 浏览器等。</p>
<p><strong>Chromium浏览器</strong>和<strong>Content Shell</strong>是构建在Content API之上的两个“浏览器”，Chromium具有浏览器完整的功能，而Content Shell是使用Content API来包装的一层简单的“壳”，但也是一个简单的“浏览器”，用户可以使用Content模块来渲染和显示网页内容。Content Shell的作用，其一可以用来测试Content模块很多功能的正确性，例如渲染、硬件加速等；其二是一个参考，可以被很多外部的项目参考来开发基于Content API的浏览器或者各种类型的项目。</p>
<p>在Android系统上，ContentShell的作用更大，这是因为同它并排的左侧的Chromium浏览器的代码没有开源，导致开发者只能依赖Content Shell。</p>
<p><strong>Android WebView</strong>是为了满足Android系统上的WebView而设计的，其思想是利用Chromium的实现来替换原来Android系统默认的WebView。</p>
<h4 id="3-2-1-2-多进程模型"><a href="#3-2-1-2-多进程模型" class="headerlink" title="3.2.1.2 多进程模型"></a>3.2.1.2 多进程模型</h4><p>多进程模型的好处：</p>
<ol>
<li>避免因单个页面的不响应或者崩溃而影响整个浏览器的稳定性，特别是对用户界面的影响；</li>
<li>当第三方插件崩溃时不会影响页面或者浏览器的稳定性，因为第三方插件也被使用单独的进程来运行；</li>
<li>方便了安全模型的实施，也就是沙箱模型是基于多进程架构的。这很大程度上也是WebKit2 产生的原因。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Ijui9pOAPyVHFwU.png"
                      alt="qT1uN6gND8xF5hwh__thumbnail.png"
                ></p>
<p>Chromium架构设计的灵活性，使用者还可以通过设置来改变它的进程模型方式。图中方框代表进程，连接线代表IPC进程间通信。</p>
<p><strong>Browser进程</strong>：浏览器的主进程，负责浏览器界面的显示、各个页面的管理，是所有其他类型进程的祖先，负责它们的创建和销毁等工作，它有且仅有一个。</p>
<p><strong>Renderer进程</strong>：网页的渲染进程，负责页面的渲染工作，Blink/WebKit 的渲染工作主要在这个进程中完成，可能有多个，但是Renderer 进程的数量与用户打开的网页数量不一定一致。因为Chromium允许用户配置，此外在沙箱模型启动的情况下，该进程可能会发生一些改变。</p>
<p><strong>NPAPI插件进程</strong>：该进程是为NPAPI 类型的插件而创建的。其创建的基本原则是每种类型的插件只会被创建一次，而且仅当使用时才被创建。当多个网页使用同一种类型的插件的时候，进程会为每个使用者创建一个实例，所以插件进程是被共享的。</p>
<p><strong>GPU进程</strong>：最多只有一个，当且仅当GPU硬件加速打开的时候才会被创建，主要用于对3D图形加速调用的实现。</p>
<p><strong>Pepper插件进程</strong>：同NPAPI插件进程，不同的是为Pepper 插件而创建的进程。</p>
<p><strong>其他类型的进程</strong>：图中还有一些其他类型的进程在之后介绍。</p>
<p>对于桌面系统（Windows、Linux、Mac OS）中的Chromium浏览器，它们的进程模型总结后包括以下一些特征：</p>
<ol>
<li>Browser进程和页面的渲染是分开的，页面渲染导致的崩溃不会导致浏览器主界面的崩溃。</li>
<li>每个网页是独立的进程，这保证了页面之间相互不影响。</li>
<li>插件进程也是独立的，插件本身的问题不会影响浏览器主界面和网页。</li>
<li>GPU 硬件加速进程也是独立的。</li>
</ol>
<p>对于Chromium的Android版，主体进程模型大致相同，不同主要指：</p>
<ol>
<li><strong>GPU进程，</strong>GPU进程演变成Browser进程的一个线程，目的之一是节省资源。</li>
<li><strong>Renderer进程，</strong>Android版不支持插件，所以没有插件进程，Renderer也是独立的进程，但是会演变成Android上的服务（service）进程。而且由于Android系统的局限性，Renderer进程的数目会被严格限制，这就涉及到了影子（Phantom）标签的议题。影子标签就是浏览器会将后台的网页所使用的渲染设施都清除，只是原来的一个影子，当用户再次切换的时候，网页需要重新加载和渲染。</li>
</ol>
<p>Chromium允许用户配置Renderer 进程被创建的方式，模型的类型有：</p>
<ol>
<li><strong>Process-per-site-instance</strong>：该类型的含义是为每一个页面都创建一个独立的Render进程，不管这些页面是否来自于同一域。好处是每个页面互不影响，坏处是资源的浪费。</li>
<li><strong>Process-per-site</strong>：该类型的含义是属于同一个域的页面共享同一个进程，而不同属一个域的页面则分属不同的进程。好处是对于相同的域，进程可以共享，内存消耗相对较小，坏处是可能会有特别大的Renderer 进程。</li>
<li><strong>Process-per-tab</strong>：该类型的含义是为每个标签页都创建一个独立的进程，而不管它们是否是不同域不同实例，这也是Chromium的默认行为，但会浪费资源。</li>
<li><strong>Single process</strong>：该类型的含义是不为页面创建任何独立的进程，所有渲染工作都在Browser进程中进行，它们是Browser进程中的多个线程。这个类型在桌面系统上一般不推荐使用，只有在比较单进程和多进程时相对有用，但在Chromium的Android版本上，在Android WebView中，该模式被采用。<h4 id="3-2-1-3-Browser进程和Renderer进程"><a href="#3-2-1-3-Browser进程和Renderer进程" class="headerlink" title="3.2.1.3 Browser进程和Renderer进程"></a>3.2.1.3 Browser进程和Renderer进程</h4></li>
</ol>
<p>Browser进程和Renderer进程都是在WebKit的接口之外由Chromium引入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/YLSJcDgjMZpdmOy.png"
                      alt="CTnRBqgG4ElY7uhV__thumbnail.png"
                ></p>
<p><strong>WebKit接口层</strong>，一般基于WebKit接口层的浏览器直接在上面构建，而没有引入复杂的多进程架构。</p>
<p><strong>WebKit黏附层</strong>，因为Chromium中一些类型和WebKit内部不一致，所以需要一个桥接层。</p>
<p><strong>Renderer</strong>，主要处理进程间通信，接受来自Browser进程的请求，并调用相应的WebKit接口层。同时将WebKit的处理结果发送回去。上面这些层都是在Renderer进程中工作的。</p>
<p><strong>RendererHost</strong>，目的也是处理同Renderer进程之间的通信，不过RendererHost是给Renderer进程发送请求并接收来自Renderer进程的结果。</p>
<p><strong>Web Contents</strong>表示的是网页的内容，它同时包括显示网页内容的子窗口，子窗口最后被嵌入浏览器的用户界面，作为它的一个标签页。</p>
<h4 id="3-2-1-4-多线程模型"><a href="#3-2-1-4-多线程模型" class="headerlink" title="3.2.1.4 多线程模型"></a>3.2.1.4 多线程模型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/6WhXVSPUxQrOz9C.png"
                      alt="vbkdMTBjTVYMog53__thumbnail.png"
                ></p>
<p>网页的加载和渲染过程在图中模型下的基本工作方式如以下步骤：</p>
<ol>
<li>Browser进程收到用户的请求，首先由UI线程处理，而且将相应的任务转给IO线程，它随即将该任务传递给Renderer进程。</li>
<li>Renderer进程的IO线程经过解释后交给渲染线程。渲染线程接受请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。最后Renderer进程将结果由IO线程传递给Browser进程。</li>
<li>最后，Browser进程接收到结果并将结果绘制出来。</li>
</ol>
<p>Chromium为了保持线程间通信和同步，同时避免造成死锁或者资源的竞争冲突等问题，在绝大多数的场景，使用事件和一种Chromium新创建的任务传递机制，仅在非用不可的情况下才使用锁或者线程安全对象。</p>
<h4 id="3-2-1-5-Content接口"><a href="#3-2-1-5-Content接口" class="headerlink" title="3.2.1.5 Content接口"></a>3.2.1.5 Content接口</h4><p>Content接口不仅提供了一层对多进程进行渲染的抽象接口，而且它支持所有的HTML5功能、GPU硬件加速功能和沙箱机制。Content接口按照功能分成六个部分，每个部分的接口一般也可以分成两类，第一类是嵌入者（可以是Chromium浏览器、CEF3和Content Shell）调用的接口，另一类是嵌入者应该实现的回调接口，被Content接口的内部实现所调用，用来参与具体实现的逻辑或者事件的监听等。</p>
<ol>
<li><strong>App</strong>。这部分主要与应用程序或者进程的创建和初始化相关，它被所有的进程使用，用来处理一些进程的公共操作。包括两种类型，第一类主要包括进程创建的初始化函数，也就是Content模块的初始化和关闭动作；第二类主要是各种回调函数，用来告诉嵌入者启动完成，进程启动、退出，沙盒模型初始化开始和结束等。</li>
<li><strong>Browser</strong>。第一类包括对一些HTML5功能和其他高级功能实现的参与。第二类主要是实现部分的逻辑，被Browser进程调用，还有就是一些事件的函数回调。</li>
<li><strong>Common</strong>。主要定义一些公共的接口，这些被Renderer和Browser共享，例如一些进程相关、参数、GPU相关等。</li>
<li><strong>Plugin</strong>。仅有一个接口类，通知嵌入者Plugin进程何时被创建。</li>
<li><strong>Renderer</strong>。第一类包含获取RenderThread的消息循环、注册V8Extension、计算JavaScript表达式等。第二类包括ContentRendererClient，主要是实现部分逻辑，被Browser端（或者进程）调用，还有就是一些事件的函数回调。</li>
<li><strong>Utility</strong>。工具类接口，主要包括让嵌入者参与Content接口中的线程创建和消息的过滤。<h2 id="3-3-WebKit2"><a href="#3-3-WebKit2" class="headerlink" title="3.3 WebKit2"></a>3.3 WebKit2</h2></li>
</ol>
<h3 id="3-3-1-WebKit2架构及模块"><a href="#3-3-1-WebKit2架构及模块" class="headerlink" title="3.3.1 WebKit2架构及模块"></a>3.3.1 WebKit2架构及模块</h3><p>相比于狭义的WebKit，WebKit2是一套全新的结构和接口。它主要目的和思想同Chromium类似，就是将渲染过程放在单独的进程中来完成，独立于用户界面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/BNDilROn5je1LJd.png"
                      alt="DcFsDgQUQEzoXb3W__thumbnail.png"
                ></p>
<p>WebKit2中也引入了插件进程和网络进程。Web进程对应于Chromium中的Renderer进程，主要是渲染网页。UI进程对应于Chromium中的Browser进程。接口就暴露在该进程中，应用程序只需调用该接口即可。应用程序指的是浏览器或者任何使用该接口的程序。</p>
<h3 id="3-3-2-WebKit-和WebKit2嵌入式接口"><a href="#3-3-2-WebKit-和WebKit2嵌入式接口" class="headerlink" title="3.3.2 WebKit 和WebKit2嵌入式接口"></a>3.3.2 WebKit 和WebKit2嵌入式接口</h3><p>WebKit提供嵌入式接口，该接口表示其他程序可以将网页渲染嵌入在程序中作为其中的一部分，或用户界面的一部分。对于WebKit的Chromium移植来说，它的接口主要用于Chromium浏览器，而不是嵌入式的使用方式。</p>
<p>在WebKit项目中，狭义WebKit的接口主要思想是将网页的渲染结果作为用户界面中的一个窗口部件，它用来显示网页的内容。按功能大致可以把所有接口分成六种类型：</p>
<ol>
<li>设置加载网页、获取加载进度、停止加载、重新加载等；</li>
<li>遍历前后浏览记录类，可以前进、后退等；</li>
<li>网页的很多设置，例如缩放、主题、背景、模式、编码等；</li>
<li>查找网页的内容、高亮等；</li>
<li>触控事件、鼠标事件处理；</li>
<li>查看网页源代码、显示调试窗口等与开发者相关的接口，是通常的嵌入式接口提供的功能。</li>
</ol>
<p>WebKit2接口不同于WebKit的接口，它们是不兼容的，但目的都是提供嵌入式的应用接口。WebKit2接口大致可以分为两个大的部分，</p>
<ol>
<li><strong>WebView相关的接口</strong>，表示渲染的设置、渲染过程、界面等，其中大多数跟各个移植紧密相关。有三个主要的类，它们被各个移植所共享。<ol>
<li>WKView[Ref]：表示的是一个与平台相关的视图，例如在Windows上它表示的就是一个窗口的句柄。</li>
<li>WKContextRef：所有页面的上下文，这些被共享的信息包括local storage、设置等。</li>
<li>WKPageRef：表示网页，也就是浏览的基本单位。</li>
</ol>
</li>
<li>上面<strong>接口依赖的基础类</strong>，它们被各个移植所共享，既包括容器、字符串等基础类，也包括跟网页相关的基础类，例如URL、请求、网页设置等。</li>
</ol>
<p>WebKit2还有WebBundle接口，在Web进程里，其目的是让某些移植访问DOM，目前还没有明确的需求。</p>
<h3 id="3-3-3-比较WebKit2和Chromium的多进程模型以及接口"><a href="#3-3-3-比较WebKit2和Chromium的多进程模型以及接口" class="headerlink" title="3.3.3 比较WebKit2和Chromium的多进程模型以及接口"></a>3.3.3 比较WebKit2和Chromium的多进程模型以及接口</h3><p>下图详细描述了WebKit 接口和Chromium的多进程的关系，以及和Content接口的关系。前面笔者也介绍了一些，例如Renderer进程直接调用WebKit接口，以及和Content接口允许应用程序注入并参与Content之下各个进程的内部逻辑。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ljF2cJTVagvwpei.png"
                      alt="IZ9qB9RUHmSwUfSc__thumbnail.png"
                ></p>
<p>首先，Chromium使用的仍然是WebKit接口，而不是WebKit2接口，也就是说Chromium是在WebKit接口之上构建的多进程架构。</p>
<p>其次，WebKit2 的接口希望尽量将多进程结构隐藏起来，但对Chromium来说，它的主要目的是给Chromium提供Content接口以便构建浏览器，其本身目标不是提供嵌入式接口，虽然有CEF项目基于它构建了嵌入式接口。</p>
<p>最后，Chromium中每个进程都是从相同的二进制可执行文件启动，而基于WebKit2的进程则未必如此。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Web服务器</title>
    <url>/2021/01/23/note/HTTP/05-Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Web服务器会对HTTP请求进行处理并提供响应。“<strong>Web服务器</strong>”可以用来表示Web服务器的软件，也可以用来表示提供Web页面的特定设备或计算机。</p>
<p>Web服务器有着不同的风格、形状和尺寸。有普通的10行Perl脚本的Web服务器、50MB的安全商用引擎以及极小的卡上服务器。</p>
<h1 id="5-1-Web服务器的实现"><a href="#5-1-Web服务器的实现" class="headerlink" title="5.1 Web服务器的实现"></a>5.1 Web服务器的实现</h1><p>Web服务器逻辑实现了HTTP协议、管理着Web资源，并负责提供Web服务器的管理功能。Web服务器逻辑和操作系统共同负责管理TCP连接。底层操作系统负责管理底层计算机系统的硬件细节，并提供了TCP/IP网络支持、负责装载Web资源的文件系统以及控制当前计算活动的进程管理功能。</p>
<p>Web服务器的不同的形式：通用软件Web服务器；Web服务器设备；嵌入式Web服务器。</p>
<h1 id="5-2-通用软件Web服务器"><a href="#5-2-通用软件Web服务器" class="headerlink" title="5.2 通用软件Web服务器"></a>5.2 通用软件Web服务器</h1><p>通用软件Web服务器都运行在标准的、有网络功能的计算机系统上。可以选择开源软件（比如Apache或W3C的Jigsaw）或者商业软件（比如微软和iPlanet的Web服务器）。基本上所有的计算机和操作系统中都有可用的Web服务器软件。</p>
<h1 id="5-3-Web服务器设备"><a href="#5-3-Web服务器设备" class="headerlink" title="5.3 Web服务器设备"></a>5.3 Web服务器设备</h1><p>Web服务器设备（Web server appliance）是预先打包好的软硬件解决方案。厂商会在他们选择的计算机平台上预先安装好软件服务器，并将软件配置好。</p>
<p>这样不再需要安装及配置软件，可以极大地简化管理工作。但Web服务器通常不太灵活，特性不太丰富，而且服务器硬件也不太容易重用或升级。</p>
<h1 id="5-4-嵌入式Web服务器"><a href="#5-4-嵌入式Web服务器" class="headerlink" title="5.4 嵌入式Web服务器"></a>5.4 嵌入式Web服务器</h1><p>嵌入式服务器（embededserver）是嵌入到消费类产品（比如打印机或家用设备中去的小型Web服务器。嵌入式Web服务器允许用户通过便捷的Web浏览器接口来管理其消费者设备。嵌入式Web服务器通常只能提供最小特性功能集。</p>
<h1 id="5-5-Web服务器操作"><a href="#5-5-Web服务器操作" class="headerlink" title="5.5 Web服务器操作"></a>5.5 Web服务器操作</h1><p>（1）建立连接——接受一个客户端连接，如果不希望与这个客户端建立连接，就将其关闭。</p>
<p>（2）接收请求——从网络中读取一条HTTP请求报文。</p>
<p>（3）处理请求——对请求报文进行解释，并采取行动。</p>
<p>（4）访问资源——访问报文中指定的资源。</p>
<p>（5）构建响应——创建带有正确首部的HTTP响应报文。</p>
<p>（6）发送响应——将响应回送给客户端。</p>
<p>（7）记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/zrlwpHmco57i2PW.png"
                      alt="pzJLam8z7mPDhlLa__original.png"
                ></p>
<h2 id="5-5-1-第一步——接受客户端连接"><a href="#5-5-1-第一步——接受客户端连接" class="headerlink" title="5.5.1 第一步——接受客户端连接"></a>5.5.1 第一步——接受客户端连接</h2><p>如果客户端已经打开了一条到服务器的持久连接，可以使用那条连接来发送它的请求。否则，客户端需要打开一条新的到服务器的连接。</p>
<h3 id="5-5-1-1-处理新连接"><a href="#5-5-1-1-处理新连接" class="headerlink" title="5.5.1.1 处理新连接"></a>5.5.1.1 处理新连接</h3><p>客户端请求一条到Web服务器的TCP连接时，Web服务器会建立连接，判断连接的另一端是哪个客户端，从TCP连接中将IP地址解析出来。一旦新连接建立起来并被接受，服务器就会将新连接添加到其现存Web服务器连接列表中，做好监视连接上数据传输的准备。</p>
<p>Web服务器可以随意拒绝或立即关闭任意一条连接。有些Web服务器会因为客户端IP地址或主机名是未认证的，或者因为它是已知的恶意客户端而关闭连接。</p>
<h3 id="5-5-1-2-客户端主机名识别"><a href="#5-5-1-2-客户端主机名识别" class="headerlink" title="5.5.1.2 客户端主机名识别"></a>5.5.1.2 客户端主机名识别</h3><p>可以用“反向DNS”对大部分Web服务器进行配置，以便将客户端IP地址转换成客户端主机名。Web服务器可以将客户端主机名用于详细的访问控制和日志记录。但主机名查找会花费很长时间，降低Web事务处理的速度。大容量Web服务器要么会禁止主机名解析，要么只允许对特定内容进行解析。</p>
<h3 id="5-5-1-3-通过ident确定客户端用户"><a href="#5-5-1-3-通过ident确定客户端用户" class="headerlink" title="5.5.1.3 通过ident确定客户端用户"></a>5.5.1.3 通过ident确定客户端用户</h3><p>有些Web服务器支持IETF的ident协议，通过ident协议找到发起HTTP连接的用户名。<strong>通用日志格式</strong>（Common Log Format）的第二个字段中就包含了每条HTTP请求的ident用户名。如果客户端支持ident协议，就在TCP端口113上监听ident请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/BSiXQd2bOTuN53a.png"
                      alt="HnlHkh82fRKut68j__original.png"
                ></p>
<p>ident在公共因特网上并不能很好地工作，原因包括：</p>
<pre><code>1. 很多客户端PC没有运行ident识别协议守护进程软件；
2. ident协议会使HTTP事务处理产生严重的时延；
3. 很多防火墙不允许ident流量进入；
4. ident协议不安全，容易被伪造；
5. ident协议不支持虚拟IP地址；
6. 暴露客户端的用户名涉及隐私问题。</code></pre>
<p>告知ApacheWeb服务器通过<strong>IdentityCheck  on</strong>指令使用ident查找功能。如果没有ident信息，用连字符（-）来填充ident日志字段。由于通常没有ident信息，在使用通用日志格式的日志文件中，第二个字段通常都是连字符。</p>
<h2 id="5-5-2-第二步——接收请求报文"><a href="#5-5-2-第二步——接收请求报文" class="headerlink" title="5.5.2 第二步——接收请求报文"></a>5.5.2 第二步——接收请求报文</h2><p>连接上有数据到达时，Web服务器会从网络连接中读取数据，并将请求报文中的内容解析出来。</p>
<p>解析请求报文时，Web服务器操作：</p>
<pre><code>1. 解析请求行，查找请求方法、指定的资源标识符（URI）以及版本号，各项之间由一个空格分隔，并以CRLF作为行的结束；
2. 读取以CRLF结尾的报文首部；
3. 检测到以CRLF结尾的、标识首部结束的空行（如果有的话）；
4. 如果有的话（长度由Content-Length首部指定），读取请求主体。</code></pre>
<p>解析请求报文时，Web服务器会不定期地从网络上接收输入数据。网络连接可能出现延迟，所以将部分报文数据临时存储在内存中，直到收到足以进行解析的数据并理解其意义为止。</p>
<h3 id="5-5-2-1-报文的内部表示法"><a href="#5-5-2-1-报文的内部表示法" class="headerlink" title="5.5.2.1 报文的内部表示法"></a>5.5.2.1 报文的内部表示法</h3><p>有些Web服务器会用，便于进行报文操作的内部数据结构来存储请求报文。比如，数据结构中可能包含有指向请求报文中各个片段的指针及其长度，将这些首部存放在一个快速查询表中，以便快速访问特定首部的具体值了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/JL5lRyhHMOqg4xd.png"
                      alt="6J2aJFF37Qfi51H7.png"
                ></p>
<h3 id="5-5-2-2-连接的输入-输出处理结构"><a href="#5-5-2-2-连接的输入-输出处理结构" class="headerlink" title="5.5.2.2 连接的输入/输出处理结构"></a>5.5.2.2 连接的输入/输出处理结构</h3><p>高性能的Web服务器能够同时支持数千条连接。连接可能在快速地或者慢速向Web服务器发送请求甚至空闲着。因为请求可能会在任意时刻到达，所以Web服务器会不停地观察有无新的Web请求。不同的Web服务器结构会以不同的方式为请求服务。</p>
<ol>
<li>单线程Web服务器（参见a）</li>
</ol>
<p>一次只处理一个请求，直到完成为止。这种结构易于实现，但所有其他连接都会被忽略。这样会造成严重的性能问题，只适用于低负荷的服务器，以及type-o-serve这样的诊断工具。</p>
<ol start="2">
<li>多进程及多线程Web服务器（参见b）</li>
</ol>
<p>用多个进程，或更高效的线程同时对请求进行处理。可以根据需要或预先创建线程/进程。有些服务器会为每条连接分配一个线程/进程，但当同时处理过多连接时，会消耗太多的内存或系统资源，因此通常都会对线程/进程的最大数量进行限制。</p>
<ol start="3">
<li>复用I/O的服务器（参见c）</li>
</ol>
<p>在复用结构中，同时监视所有连接上的活动。当连接的状态发生变化时（有数据可用，或出现错误时），就对那条连接进行少量的处理；处理结束之后，将连接返回到开放连接列表中，等待下一次状态变化。</p>
<ol start="4">
<li>复用的多线程Web服务器（参见d）</li>
</ol>
<p>多个线程中的每一个都在观察打开的连接，并对每条连接执行少量的任务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/QzpRsmfEyFrSeuM.png"
                      alt="2mA4SsoOK7nSD7FP.png"
                ></p>
<h2 id="5-5-3-第三步——处理请求"><a href="#5-5-3-第三步——处理请求" class="headerlink" title="5.5.3 第三步——处理请求"></a>5.5.3 第三步——处理请求</h2><p>一旦Web服务器收到了请求，就可以根据方法、资源、首部和可选的主体部分来对请求进行处理了。比如POST要求请求报文中必须带有实体主体部分的数据；比如OPTIONS允许有也可以没有请求的主体部分。比如GET禁止在请求报文中包含实体的主体数据。</p>
<h2 id="5-5-4-第四步——对资源的映射及访问"><a href="#5-5-4-第四步——对资源的映射及访问" class="headerlink" title="5.5.4 第四步——对资源的映射及访问"></a>5.5.4 第四步——对资源的映射及访问</h2><p>Web服务器是资源服务器。它们负责发送预先创建好的内容，比如HTML页面或图片，以及运行在服务器上的资源生成程序所产生的动态内容。将内容传送给客户端之前，要将请求报文中的URI映射为Web服务器上适当的内容或内容生成器，以识别出内容的源头。</p>
<h3 id="5-5-4-1-docroot"><a href="#5-5-4-1-docroot" class="headerlink" title="5.5.4.1 docroot"></a>5.5.4.1 docroot</h3><p>Web服务器支持各种不同类型的资源映射，最简单的形式就是用请求URI作为名字来访问Web服务器文件系统中的文件。通常，Web服务器的文件系统中会有特殊的文件夹专门用于存放Web内容。这个文件夹被称为文档的根目录（documentroot或docroot）。Web服务器从请求报文中获取URI，并将其附加在文档根目录的后面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/NfA8CvY7cpJeb9Z.png"
                      alt="YjRu2XQ3AOUZMPxL.png"
                ></p>
<p>在配置文件httpd.conf中添加<strong>DocumentRoot行</strong>为Apache Web服务器设置文档的根目录：DocumentRoot/usr/local/httpd/files</p>
<p>服务器不能让相对URL退到docroot之外，将文件系统的其余部分暴露出来。</p>
<h4 id="5-5-4-1-1-虚拟托管的docroot"><a href="#5-5-4-1-1-虚拟托管的docroot" class="headerlink" title="5.5.4.1.1 虚拟托管的docroot"></a>5.5.4.1.1 虚拟托管的docroot</h4><p>虚拟托管的Web服务器会在同一台Web服务器上提供多个Web站点，每个站点都有自己独有的文档根目录。虚拟托管Web服务器会根据URI或Host首部的IP地址或主机名来识别要使用的正确文档根目录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/ohlBFpvjKqM5RVD.png"
                      alt="h2lrUmLfCt6WWhJe__thumbnail.png"
                ></p>
<p>对ApacheWeb服务器来说，为每个虛拟Web站点配置一个VirtualHost块，每个虚拟服务器都要包含DocumentRoot。</p>
<h4 id="5-5-4-1-2-用户的主目录docroot"><a href="#5-5-4-1-2-用户的主目录docroot" class="headerlink" title="5.5.4.1.2 用户的主目录docroot"></a>5.5.4.1.2 用户的主目录docroot</h4><p>Docroot的另一种常见应用是在Web服务器上为人们提供私有的Web站点。通常把以斜杠和波浪号（/~）开始，后面跟着用户名的URI映射为此用户的私有文档根目录。私有docroot通常是用户主目录下那个名为public_html 的目录，也可将其配置为其他值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/XRS34sTM8odOjJc.png"
                      alt="mzxmQqltivIgO2q9__thumbnail.png"
                ></p>
<h3 id="5-5-4-2-目录列表"><a href="#5-5-4-2-目录列表" class="headerlink" title="5.5.4.2 目录列表"></a>5.5.4.2 目录列表</h3><p>Web服务器可以接收对目录URL的请求，其路径可以解析为一个目录，而不是文件。对大多数Web服务器对目录URL的请求采取不同的动作：</p>
<ol>
<li>返回一个错误。</li>
<li>不返回目录，返回一个特殊的默认‘索引文件”。多数Web服务器会去查找目录中名为index.html或index.htm的文件来代表此目录，并返回这个文件的内容。在Apache Web服务器上，可以用配置指令<strong>DirectoryIndex</strong>配置要作为默认目录文件使用的文件名集合，指令按照优先顺序列出所有可以作为目录索引文件使用的文件名。</li>
</ol>
<p>例如：    DirectoryIndex  index.html  index.htm  home.html  home.htm  index.cgi</p>
<ol>
<li>扫描目录，返回一个包含目录内容的HTML页面。如果用户请求目录URI时，没有提供默认的索引文件，且没有禁止使用目录索引，很多Web服务器都会自动返回一个HTML文件，文件中会列出目录里的文件名和每个文件的大小和修改日期，还包括到每个文件的URI链接。</li>
</ol>
<p>可以通过以下Apache指令禁止自动生成目录索引文件：Options-Indexes</p>
<h3 id="5-5-4-3-动态内容资源的映射"><a href="#5-5-4-3-动态内容资源的映射" class="headerlink" title="5.5.4.3 动态内容资源的映射"></a>5.5.4.3 动态内容资源的映射</h3><p>Web服务器可以将URI映射为动态资源，也就是映射到按需动态生成内容的程序上。多数Web服务器都提供了一些机制以识别和映射动态资源，能够分辨资源什么时候是动态的，动态内容生成程序位于何处，以及如何运行那个程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/AfQbyTgORts29kv.png"
                      alt="QX5bpDmH8lbf0JpV__thumbnail.png"
                ></p>
<p>Apache允许用户将URI路径名组件映射为可执行文件目录，服务器会试着去执行目录中的程序。</p>
<p>Apache允许用户用一个特殊的文件扩展名来标识可执行文件。这种方式就可以将可执行脚本放在任意目录中了。e.g.  AddHandler cgi-script.cgi （执行所有以.cgi结尾的Web资源）。</p>
<h3 id="5-5-4-4-服务器端包含项"><a href="#5-5-4-4-服务器端包含项" class="headerlink" title="5.5.4.4 服务器端包含项"></a>5.5.4.4 服务器端包含项</h3><p>很多Web服务器提供了对<strong>服务器端包含项</strong>（SSI）的支持，这是创建动态内容的一种方式。如果资源被标识为存在服务器端包含项，服务器就会发送前对资源内容进行扫描，以查找特定的模板（可以是变量名或嵌入式脚本）。可以用变量的值或可执行脚本的输出来取代特定的模板。</p>
<h3 id="5-5-4-5-访问控制"><a href="#5-5-4-5-访问控制" class="headerlink" title="5.5.4.5 访问控制"></a>5.5.4.5 访问控制</h3><p>Web服务器还可以为特定资源进行访问控制。Web服务器可以根据客户端的IP地址进行访问控制，也可以要求输入密码来访问资源。</p>
<h2 id="5-5-5-第五步——构建响应"><a href="#5-5-5-第五步——构建响应" class="headerlink" title="5.5.5 第五步——构建响应"></a>5.5.5 第五步——构建响应</h2><p>Web服务器识别出了资源，就执行请求方法中描述的动作，并返回响应报文，包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体。</p>
<h3 id="5-5-5-1-响应实体"><a href="#5-5-5-1-响应实体" class="headerlink" title="5.5.5.1 响应实体"></a>5.5.5.1 响应实体</h3><p>如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。如果有响应主体的话，响应报文中通常包括：</p>
<ol>
<li>描述响应主体MIME类型的Content-Type首部；</li>
<li>描述响应主体长度的Content-Length首部；</li>
<li>实际报文的主体内容。<h3 id="5-5-5-2-MIME类型"><a href="#5-5-5-2-MIME类型" class="headerlink" title="5.5.5.2 MIME类型"></a>5.5.5.2 MIME类型</h3></li>
</ol>
<p>Web服务器要确定响应主体的MIME类型。</p>
<ol>
<li><strong>MIME 类型</strong>（mime.types）</li>
</ol>
<p>Web服务器可用文件的扩展名来说明MIME类型。Web服务器会为每个资源扫描一个包含了所有扩展名的MIME类型的文件，以确定其MIME类型。这种最常见。</p>
<ol start="2">
<li><strong>魔法分类</strong>（Magic typing）</li>
</ol>
<p>ApacheWeb服务器可以扫描每个资源的内容，并将其与一个已知模式表（魔法文件）进行匹配，以决定每个文件的MIME类型。适用于文件没有标准扩展名的时候。</p>
<ol start="3">
<li><strong>显式分类</strong>（Explicit typing）</li>
</ol>
<p>可对Web服务器进行配置，不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型。</p>
<ol start="4">
<li><strong>类型协商</strong></li>
</ol>
<p>有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式（及相关的MIME类型）“最好”。</p>
<p>还可以通过配置Web服务器，将特定的文件与MIME类型相关联。</p>
<h3 id="5-5-5-3-重定向"><a href="#5-5-5-3-重定向" class="headerlink" title="5.5.5.3 重定向"></a>5.5.5.3 重定向</h3><p>Web服务器有时会返回重定向响应而不是成功的报文，将浏览器重定向到其他地方来执行请求。Location响应首部包含了内容的新地址或优选地址的URI。重定向可用于下列情况：</p>
<ol>
<li><strong>永久删除的资源</strong></li>
</ol>
<p>资源被移动到了新的位置，或被重新命名，有了新的URL。Web服务器可以告诉客户端资源已经被重命名了，让其可以在从新地址获取资源之前，更新书签之类的信息。状态码301 Moved Permanently就用于此类重定向。</p>
<ol start="2">
<li><strong>临时删除的资源</strong></li>
</ol>
<p>如果资源被临时移走或重命名了，服务器将客户端重定向到新的位置上去。由于重命名是临时的，所以服务器希望客户端不必对书签进行更新。状态码303 See Other以及状态码307 Temporary Redirect用于此类重定向。</p>
<ol start="3">
<li><strong>URL增强</strong></li>
</ol>
<p>服务器通常用重定向来重写URL，常用于嵌入上下文。服务器会生成一个新的包含了嵌入式状态信息的URL，并将用户重定向到这个新的URL上。客户端会跟随这个重定向信息，重新发起请求。状态码303 See Other和307 Temporary Redirect用于此类重定向。</p>
<ol start="4">
<li><strong>负载均衡</strong></li>
</ol>
<p>如果一个超载的服务器收到一条请求，可以将客户端重定向到一个负载不重的服务器上去。状态码303 See Other和307 Temporary Redirect可用于此类重定向。</p>
<ol start="5">
<li><strong>服务器关联</strong></li>
</ol>
<p>Web服务器上可能有某些用户的本地信息，可以将客户端重定向到包含了那个客户端信息的服务器上去。状态码303 See Other和307 Temporary Redirect可用于此类重定向。</p>
<ol start="6">
<li><strong>规范目录名称</strong></li>
</ol>
<p>客户端请求的URI是一个不带尾部斜线的目录名时，多数Web服务器都会将客户端重定向到一个加了斜线的URI上，这样相对链接就可以正常工作。</p>
<h2 id="5-5-6-第六步——发送响应"><a href="#5-5-6-第六步——发送响应" class="headerlink" title="5.5.6 第六步——发送响应"></a>5.5.6 第六步——发送响应</h2><p>服务器可能有很多条到各个客户端的连接，有空闲的，有向服务器发送数据，还有正在向客户端回送响应数据。</p>
<p>服务器要记录连接的状态，<strong>对非持久连接而言</strong>，服务器应该在发送了整条报文之后，关闭自己这一端的连接；<strong>对持久连接来说</strong>，连接可能仍保持打开状态，服务器要正确地计算Content-Length首部，客户端才会知道响应什么时候结束。</p>
<h2 id="5-5-7-第七步——记录日志"><a href="#5-5-7-第七步——记录日志" class="headerlink" title="5.5.7 第七步——记录日志"></a>5.5.7 第七步——记录日志</h2><p>最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务。大多数Web服务器都提供了几种日志配置格式。更多细节请参见第21章。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>04-链接管理</title>
    <url>/2021/01/23/note/HTTP/04-%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="4-1-TCP链接"><a href="#4-1-TCP链接" class="headerlink" title="4.1 TCP链接"></a>4.1 TCP链接</h2><h3 id="4-1-1-TCP的可靠数据管道"><a href="#4-1-1-TCP的可靠数据管道" class="headerlink" title="4.1.1 TCP的可靠数据管道"></a>4.1.1 TCP的可靠数据管道</h3><p>HTTP连接实际，上就是TCP连接和一些使用连接的规则，TCP为HTTP提供了一条可靠的比特传输管道。</p>
<h3 id="4-1-2-TCP流、IP分组"><a href="#4-1-2-TCP流、IP分组" class="headerlink" title="4.1.2 TCP流、IP分组"></a>4.1.2 TCP流、IP分组</h3><p>TCP的数据是通过IP分组（IP 数据报）的小数据块来发送的。安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/BcYmKZklw5pDSIs.png"
                      alt="EcJv4cg2UJABtNpp__thumbnail.png"
                ></p>
<p>TCP段是由IP分组承载。每个IP分组中包括：</p>
<pre><code>    1. 一个IP分组首部，包含源和目的IP地址、长度和其他一些标记（通常为20字节）；
    2. 一个TCP段首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值。（通常为20字节）；
    3. 一个TCP数据块（0个或多个字节）。</code></pre>
<h3 id="4-1-3-TCP连接的正确运行"><a href="#4-1-3-TCP连接的正确运行" class="headerlink" title="4.1.3 TCP连接的正确运行"></a>4.1.3 TCP连接的正确运行</h3><p>计算机随时都有几条TCP连接处于打开状态，TCP 通过端口号来保持连接的正确运行。</p>
<p>TCP连接通过4个值来识别：&lt;<strong>源IP地址、源端口号、目的IP地址、目的端口号</strong>&gt;。这4个值唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/B6FQoYxgDh1sqbG.png"
                      alt="46GDogLOzoqcLen7__thumbnail.png"
                ></p>
<h3 id="4-1-4-TCP套接字编程"><a href="#4-1-4-TCP套接字编程" class="headerlink" title="4.1.4 TCP套接字编程"></a>4.1.4 TCP套接字编程</h3><p>操作系统提供了一些操纵其TCP连接的工具。我们来看一个TCP编程接口。这个套接字API向HTTP程序员隐藏了TCP和IP的所有细节。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/o1AtgCIRBbeWjDF.png"
                      alt="qv4I1NjxFUOC6xh8__thumbnail.png"
                ></p>
<p>套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间的分段和重装细节。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/3h56inwBySqHbtE.png"
                      alt="vAn3ica3x7NtExWZ__thumbnail.png"
                ></p>
<p>从Web服务器等待连接（S4）开始。客户端根据URL判定出IP地址和端口号，并建立一条到服务器的TCP连接（C3）。</p>
<p>建立连接后，客户端就会发送HTTP请求（C5），服务器读取请求（S6）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（S7），并将数据写回客户端。客户端读取数据（C6），并对响应数据进行处理（C7）。</p>
<h2 id="4-2-TCP性能"><a href="#4-2-TCP性能" class="headerlink" title="4.2 TCP性能"></a>4.2 TCP性能</h2><h3 id="4-2-1-HTTP事务的时延"><a href="#4-2-1-HTTP事务的时延" class="headerlink" title="4.2.1 HTTP事务的时延"></a>4.2.1 HTTP事务的时延</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/Kyjzs8YnHod3DqX.png"
                      alt="N1zHevdCojb7owBy__thumbnail.png"
                ></p>
<p>与建立TCP连接、传输请求、响应报文的时间相比，事务处理可能是很短的，除非客户端或服务器超载，或正处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的。</p>
<p>HTTP事务的时延原因：</p>
<p>（1）<strong>DNS解析</strong>，但大多数HTTP客户端都有一个小的DNS缓存，用来保存近期所访问站点的IP地址，可以很快地将主机名解析出来。</p>
<p>（2）客户端会向服务器发送一条TCP连接请求，并等待服务器回送请求接受应答。每条新的<strong>TCP连接的连接建立时延</strong>，最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会很高。</p>
<p>（3）连接建立后，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器从TCP连接中<strong>读取请求报文</strong>，并<strong>处理请求报文</strong>，因特网<strong>传输请求报文</strong>、服务器处理请求报文都需要时间。</p>
<p>（4）Web服务器会<strong>回送HTTP响应</strong>，这些TCP网络时延的大小取决于<strong>硬件速度</strong>、<strong>网络和服务器的负载</strong>，<strong>请求和响应报文的尺寸</strong>，以及客户端和服务器之间的<strong>距离</strong>。<strong>TCP协议的技术复杂性</strong>也会对时延产生巨大的影响。</p>
<h3 id="4-2-2-TCP相关时延"><a href="#4-2-2-TCP相关时延" class="headerlink" title="4.2.2 TCP相关时延"></a>4.2.2 TCP相关时延</h3><pre><code>1. TCP连接建立握手，
2. 用于捎带确认的TCP延迟确认算法
3. TCP慢启动拥塞控制；
4. 数据聚集的Nagle算法；
5. TIME_WAIT时延和端口耗尽。</code></pre>
<h4 id="4-2-2-1-TCP连接的握手时延"><a href="#4-2-2-1-TCP连接的握手时延" class="headerlink" title="4.2.2.1 TCP连接的握手时延"></a>4.2.2.1 TCP连接的握手时延</h4><p>建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接用来传送少量数据，这些交换过程就会降低HTTP的性能。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/pcMj5YAJitqbS6o.png"
                      alt="McjEXqUcLmE8y4Qe__thumbnail.png"
                ></p>
<p><strong>TCP连接握手步骤:</strong></p>
<pre><code>1. 请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40 ~60个字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求（参见a）。
2. 如果服务器接受连接，会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受（参见b）。
3. 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图c）。现代的TCP栈都允许客户端在这个确认分组中发送数据。</code></pre>
<p>通常HTTP事务不会交换太多数据，SYN/SYN+ACK握手会产生一个可测量的时延。TCP连接的ACK分组通常都足够承载整个HTTP请求报文，而且很多HTTP服务器响应报文都可以放人一个IP分组中去。最后导致小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。</p>
<h4 id="4-2-2-2-延迟确认"><a href="#4-2-2-2-延迟确认" class="headerlink" title="4.2.2.2 延迟确认"></a>4.2.2.2 延迟确认</h4><p>每个TCP段有一个序列号和数据完整性校验和，来确保数据的成功传输。接收者收到完好的段时，会向发送者回送确认分组。如果发送者没有在指定时间内收到确认信息，发送者就认为分组已破坏或损毁，会重发数据。</p>
<p>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“<strong>捎带</strong>”。TCP将返回的确认信息与输出的数据分组结合在一起。</p>
<p>为增加确认报文找到同向传输数据分组的可能，TCP栈实现了一种<strong>“延迟确认”算法，</strong>会在一个特定的窗口时间（通常100 ~ 200毫秒）内将输出确认存放在缓冲区中，以寻找能捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求-应答行为，导致当希望有相反方向回传分组的时候，偏偏没有那么多。</p>
<p>延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<h4 id="4-2-2-3-TCP慢启动"><a href="#4-2-2-3-TCP慢启动" class="headerlink" title="4.2.2.3 TCP慢启动"></a>4.2.2.3 TCP慢启动</h4><p>TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动（slow start），防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。HTTP事务不能一次将所有分组都发送出去，必须发送一个分组，等待确认，才可以发送两个分组，再次被确认，就可以发送四个分组，以此类推。这种方式被称为“打开拥塞窗口”。</p>
<p>由于这种拥塞控制特性，新连接的传输速度会比已经交换过数据的“已调谐”连接慢。</p>
<h4 id="4-2-2-4-Nagle算法与TCP-NODELAY"><a href="#4-2-2-4-Nagle算法与TCP-NODELAY" class="headerlink" title="4.2.2.4 Nagle算法与TCP_NODELAY"></a>4.2.2.4 Nagle算法与TCP_NODELAY</h4><p>TCP有数据流接口，每个TCP段中都至少装载了40个字节的标记和首部，所以如果TCP发送了大量包含少量数据的分组，网络的性能会下降。</p>
<p><strong>Nagle算法</strong>：试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。Nagle算法鼓励发送全尺寸的段，只有当所有其他分组都被确认之后，才发送非全尺寸的分组。如果其他分组仍在传输中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p>
<p><strong>Nagle算法缺陷</strong>：首先，小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题，Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100 ~ 200毫秒。</p>
<p>HTTP应用程序通常设置参数TCP_NODELAY，禁用Nagle算法，这样须确保会向TCP写入大块的数据，不会产生一堆小分组。</p>
<h4 id="4-2-2-5-TIME-WAIT累积与端口耗尽"><a href="#4-2-2-5-TIME-WAIT累积与端口耗尽" class="headerlink" title="4.2.2.5 TIME__WAIT累积与端口耗尽"></a>4.2.2.5 TIME__WAIT累积与端口耗尽</h4><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，维持的时间，是最大分段使用期的两倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。这也防止之前连接的复制分组插入了具有相同连接值的新TCP流，会破坏TCP数据。</p>
<p>但在性能基准测试时，TIME__WAIT 也限制了可用的连接值组合。因为在只有一个客户端和一台Web服务器的情况下，构建一条TCP连接的4个值，只有源端口号可以随意改变，客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限，而且在2MSL秒内连接是无法重用的，连接率就被限制了。</p>
<p>可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</p>
<p>即使没有遇到端口耗尽问题，也要小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会减缓。</p>
<h2 id="4-3-HTTP链接的处理"><a href="#4-3-HTTP链接的处理" class="headerlink" title="4.3 HTTP链接的处理"></a>4.3 HTTP链接的处理</h2><h3 id="4-3-1-connection首部"><a href="#4-3-1-connection首部" class="headerlink" title="4.3.1 connection首部"></a>4.3.1 connection首部</h3><p>Connection首部有3种类型的标签：</p>
<pre><code>1. HTTP 首部字段名，列出了只与此连接有关的首部；
2. 任意标签值，用于描述此连接的非标准选项；
3. 值close，说明操作完成之后需关闭这条持久连接。</code></pre>
<p>如果连接标签中包含了HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发，在将报文转发出去之前，删除Connection所列出的首部字段以及自身。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/d6Kyks1VMU3bLYA.png"
                      alt="MWKLFwHwkjmuqWQY__original.png"
                ></p>
<h3 id="4-3-2-串行事务处理时延"><a href="#4-3-2-串行事务处理时延" class="headerlink" title="4.3.2 串行事务处理时延"></a>4.3.2 串行事务处理时延</h3><p>串行加载缺点：1、叠加链接时延和慢启动时延。2、有些浏览器需要完全加载后才显示。</p>
<p>新的链接方法：</p>
<pre><code>1. 并行连接：通过多条TCP连接发起并发的HTTP请求。
2. 持久连接：重用TCP连接，以消除连接及关闭时延。
3. 管道化连接：通过共享的TCP连接发起并发的HTTP请求。
4. 复用的连接：交替传送请求和响应报文（实验阶段）。</code></pre>
<h2 id="4-4-并行链接"><a href="#4-4-并行链接" class="headerlink" title="4.4 并行链接"></a>4.4 并行链接</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/A6ETjvVg29zX3rw.png"
                      alt="E02QnUnHmeOPbogJ__original.png"
                ></h2><p>并行链接的优点：</p>
<pre><code>1. 每个事务都有自己的连接，装载是并行的，连接的时延也是重叠的。（嵌入的组件不一定都在同一台Web服务器上，可以同多台服务器建立并行的连接）。
2. 可以让用户感觉更快。</code></pre>
<p>并行链接的缺点：</p>
<pre><code>1. 如果并行加载多个对象，每个对象竞争有限的带宽，都会以较慢的速度按比例加载。
2. 打开大量连接会消耗很多内存资源，从造成服务器、代理性能的下降。
3. 由于TCP慢启动特性，每条新连接的性能都会有所降低。</code></pre>
<p>浏览器一般会将并行连接的总数限制为4个。服务器可以随意关闭来自特定客户端的超量连接。</p>
<h2 id="4-5-持久链接"><a href="#4-5-持久链接" class="headerlink" title="4.5 持久链接"></a>4.5 持久链接</h2><p><strong>站点本地性</strong>（site locality）：Web客户端经常打开到同一个站点的连接。因此，初始化了对某服务器HTTP请求的应用程序可能会对那台服务器不久发起更多的请求。</p>
<p><strong>持久连接</strong>：HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接，直到客户端或服务器决定将其关闭为止。</p>
<p>优点：避开缓慢的连接建立阶段；避免慢启动的拥塞适应阶段。</p>
<p>缺点：累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/XpykQEHGe4K1Rfm.png"
                      alt="RUOT3rgreZZqeDQ5__original.png"
                ></p>
<p>持久连接与并行连接配合使用是高效的方式。通常，Web应用程序打开少量的并行连接，其中的每一个都是持久连接。</p>
<p>持久连接有两种类型：比较老的**”keep-alive”连接<strong>，现代的</strong>“persistent”连接**</p>
<h3 id="4-5-1-HTTP-1-0-keep-alive连接"><a href="#4-5-1-HTTP-1-0-keep-alive连接" class="headerlink" title="4.5.1 HTTP/1.0+   keep-alive连接"></a>4.5.1 HTTP/1.0+   keep-alive连接</h3><p>客户端通过包含Connection：Keep-Alive首部请求，将一条连接保持在打开状态。如果服务器可以，就在响应中包含相同的首部，否则说明服务器不支keep-alive，会在发回响应报文之后关闭连接。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，有多部件媒体类型，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>Keep-Alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的行为：</p>
<pre><code>1. 参数**timeout**在Keep-Alive响应首部发送，服务器希望将连接保持在活跃状态的时间。
2. 参数**max**在Keep-Alive响应首部发送，服务器希望为多少个事务保持此连接的活跃状态。
3. Keep-Alive首部支持任意未经处理的属性，用于诊断和调试。语法为name[=value]。</code></pre>
<h4 id="4-5-1-1-哑代理"><a href="#4-5-1-1-哑代理" class="headerlink" title="4.5.1.1 哑代理"></a>4.5.1.1 哑代理</h4><p>老的或简单的代理都是<strong>盲中继</strong>（blind relay），只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/szK69eWZDEVytLj.png"
                      alt="EBTdTrTeWy3Jfd15__original.png"
                ></p>
<p>后果：客户端和服务器都认为它们在进行keep-alive对话，但代理等待源端服务器关闭连接，源端服务器认为连接保持在打开状态，所以不会去关闭连接，反而立即转向下一条请求。而代理并不认为同一条连接上会有其他请求，<strong>请求被忽略</strong>。这会使浏览器<strong>一直处于挂起状态</strong>，直到客户端或服务器将连接超时，并将其关闭为止。</p>
<p>有几个不能作为Connection首部值列出，包括Proxy-Authenticate、Proxy-Connection、</p>
<p>Transfer-Encoding和Upgrade。</p>
<h4 id="4-5-1-2-插入Proxy-Connection解决哑代理"><a href="#4-5-1-2-插入Proxy-Connection解决哑代理" class="headerlink" title="4.5.1.2 插入Proxy-Connection解决哑代理"></a>4.5.1.2 插入Proxy-Connection解决哑代理</h4><p>浏览器向代理发送非标准的Proxy-Connection扩展首部，而不是官方支持的Connection首部。如果代理是盲中继，将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部，否则就用Connection首部取代Proxy-Connection首部，然后将其发送给服务器。</p>
<p>对有多层次代理的情况，Proxy-Connection 仍然无法解决问题。</p>
<h3 id="4-5-2-HTTP-1-1-持久连接"><a href="#4-5-2-HTTP-1-1-持久连接" class="headerlink" title="4.5.2 HTTP/1.1  持久连接"></a>4.5.2 HTTP/1.1  持久连接</h3><p><strong>持久连接（</strong>persistent connection），在默认情况下是激活的。除非向报文中显式地添加一个Connection：close首部。但客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。</p>
<h2 id="4-6-管道化连接"><a href="#4-6-管道化连接" class="headerlink" title="4.6 管道化连接"></a>4.6 管道化连接</h2><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>。在响应到达之前，可以将多条请求放入队列。当第一条请求流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/rBgSFhCpoTQbLdw.png"
                      alt="SmB3DWYPPxzXolFI__original.png"
                ></p>
<p>管道化连接的限制：</p>
<ol>
<li>HTTP客户端确认是持久连接，才能使用管道。</li>
<li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li>
<li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。<h2 id="4-7-关闭连接"><a href="#4-7-关闭连接" class="headerlink" title="4.7 关闭连接"></a>4.7 关闭连接</h2></li>
</ol>
<h3 id="4-7-1-任意解除连接"><a href="#4-7-1-任意解除连接" class="headerlink" title="4.7.1 任意解除连接"></a>4.7.1 任意解除连接</h3><p>所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接，但也有可能出错，对管道化持久连接来说，这种情形是很常见的。</p>
<h3 id="4-7-2-Content-Length及截尾操作"><a href="#4-7-2-Content-Length及截尾操作" class="headerlink" title="4.7.2 Content-Length及截尾操作"></a>4.7.2 Content-Length及截尾操作</h3><p>每条HTTP响应都应该有Content-Length首部。一些老的HTTP服务器会省略或者包含错误的长度指示，这就要依赖服务器发出的连接关闭来说明数据的真实末尾。</p>
<p>客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与Content-Length并不匹配或没有Content-Length时，接收端应该质疑长度的正确性。</p>
<p>如果接收端是个缓存代理，不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能），而是原封不动地转发出去，以维护语义的透明性。</p>
<h3 id="4-7-3-连接关闭容限、重试、幂等性"><a href="#4-7-3-连接关闭容限、重试、幂等性" class="headerlink" title="4.7.3 连接关闭容限、重试、幂等性"></a>4.7.3 连接关闭容限、重试、幂等性</h3><p>如果在客户端执行事务的过程中，传输连接关闭了，除非事务处理会带来副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，源端服务器关闭连接，就会留下大量未处理的请求，需要重新调度。</p>
<p>如果一个事务，不管是执行几次，得到的结果都相同，这个事务就是<strong>幂等</strong>的。要发送一条非幂等请求，需要等待来自前一条请求的响应状态。</p>
<p>用户Agent代理一定不能自动重试非幂等方法或序列。比如post订单，大多数浏览器都会提供一个对话框，询问用户是否希望再次发起事务处理。</p>
<h3 id="4-7-4-正常关闭连接"><a href="#4-7-4-正常关闭连接" class="headerlink" title="4.7.4 正常关闭连接"></a>4.7.4 正常关闭连接</h3><h4 id="4-7-4-1-完全关闭与半关闭"><a href="#4-7-4-1-完全关闭与半关闭" class="headerlink" title="4.7.4.1 完全关闭与半关闭"></a>4.7.4.1 完全关闭与半关闭</h4><p>应用程序可以关闭TCP输入和输出信道中的任意一个或两者。</p>
<p>套接字调用<strong>close（）</strong>将TCP连接的输入输出信道都关闭了，称作“<strong>完全关闭</strong>”，如图a所示。</p>
<p>套接字调用<strong>shutdown（）</strong>单独关闭输入或输出信道，这被称为<strong>“半关闭”</strong>，如图b所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/XaR3DEm9GuULlNs.png"
                      alt="HqfJNF2eliisLFNQ__original.png"
                ></p>
<h4 id="4-7-4-2-TCP关闭及重置错误"><a href="#4-7-4-2-TCP关闭及重置错误" class="headerlink" title="4.7.4.2 TCP关闭及重置错误"></a>4.7.4.2 TCP关闭及重置错误</h4><p>当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误。</p>
<p>关闭连接的输出信道总是安全的。连接另一端的对等实体会在从其缓冲区中读出所有数据之后收到一条通知，说明流结束了，知道连接关闭了。</p>
<p>关闭连接的输入信道比较危险，除非知道另一端不再发送数据。如果向已关闭的输入信道发送数据，操作系统会回送一条TCP“<strong>连接被对端重置</strong>”报文，删除对端还未读取的所有缓存数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/QfXG1hNrvmxoDLB.png"
                      alt="DZvhKCeOgaAwmwKW__original.png"
                ></p>
<h4 id="4-7-4-3-正常关闭"><a href="#4-7-4-3-正常关闭" class="headerlink" title="4.7.4.3 正常关闭"></a>4.7.4.3 正常关闭</h4><p>应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都知道不再发送数据（比如关闭输出信道）后，连接就会被完全关闭，不会有重置的危险。</p>
<p>但不无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>06-代理</title>
    <url>/2021/01/23/note/HTTP/06-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="6-1-Web的-中间实体"><a href="#6-1-Web的-中间实体" class="headerlink" title="6.1 Web的 中间实体"></a>6.1 Web的 中间实体</h1><p>Web上的代理服务器是代表客户端完成事务处理的中间人。HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h1 id="6-2-私有和共享代理"><a href="#6-2-私有和共享代理" class="headerlink" title="6.2 私有和共享代理"></a>6.2 私有和共享代理</h1><ol>
<li><strong>公共代理</strong></li>
</ol>
<p>多数代理都是公共的共享代理。集中式代理的费效比更高，容易管理。某些代理应用，如高速缓存代理服务器，会利用用户间共同的请求，汇入同一个代理服务器的用户越多，就越有用。</p>
<ol start="2">
<li><strong>私有代理</strong></li>
</ol>
<p>单个客户端专用的代理被称为私有代理。并不常见，常用于直接运行在客户端计算机上的时候。有些浏览器辅助产品或一些ISP服务，会在用户的PC上直接运行一些小型的代理，以便扩展浏览器特性，提高性能，或为免费ISP服务提供主机广告。</p>
<h1 id="6-3-代理与网关的对比"><a href="#6-3-代理与网关的对比" class="headerlink" title="6.3 代理与网关的对比"></a>6.3 代理与网关的对比</h1><p>代理连接的是两个或多个使用相同协议的应用程序，而网关连接的则是两个或多个使用不同协议的端点，客户端同样可以通过它完成与服务器之间的事务处理。</p>
<p>实际上，代理和网关之间的区别很模糊。由于浏览器和服务器实现的是不同版本的HTTP，代理也经常要做一些协议转换工作。而商业化的代理服务器也会实现网关的功能来支持SSL安全协议、SOCKS防火墙、FTP访问，以及基于Web的应用程序。</p>
<h1 id="6-4-代理的作用"><a href="#6-4-代理的作用" class="headerlink" title="6.4 代理的作用"></a>6.4 代理的作用</h1><p>代理服务器可以改善安全性，提高性能，节省费用，可以看到并接触到所有流过的HTTP流量，所以代理可以监视流量并对其进行修改，以实现很多有用的增值Web服务。比如：</p>
<ol>
<li><strong>儿童过滤器</strong></li>
</ol>
<p>可以利用过滤器代理来阻止学生访问成人内容。</p>
<ol start="2">
<li><strong>文档访问控制</strong></li>
</ol>
<p>可以用代理服务器在大量Web服务器和Web资源之间实现统一的访问控制策略，创建审核跟踪机制。这在大型企业环境或其他分布式机构中是很有用的。</p>
<p>在集中式代理服务器上可以对所有访问控制功能进行配置，而无需在众多由不同组织管理、不同厂商制造、使用不同模式的Web服务器上进行经常性的访问控制升级。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/d8KC24sWEakyeZq.png"
                      alt="pqBy6kmLeBWZV7aG.png"
                ></p>
<ol start="3">
<li><strong>安全防火墙</strong></li>
</ol>
<p>使用代理服务器来提高安全性。代理服务器会在网络中的单一安全节点上限制应用层协议的数据流入或流出一个组织，还可以提供用来消除病毒的Web和E-mail代理使用的那种挂钩程序，以便对流量进行详细的检查。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/2EYom5XjtMRKcW6.png"
                      alt="tDT5ij0kvoywHIjQ__thumbnail.png"
                ></p>
<ol start="4">
<li><strong>Web缓存</strong></li>
</ol>
<p>Web代理缓存维护了常用文档的本地副本，并按需提供，以减少慢且贵的因特网通信。</p>
<ol start="5">
<li><strong>反向代理</strong></li>
</ol>
<p>被称为替代物（surrogate）或反向代理（re-verseproxy）的代理接收发给Web服务器的真实请求，但不同的是，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。</p>
<p>反向代理能提高访问慢速Web服务器上公共内容时的性能。在这种配置中，反向代理称为服务器加速器（server accelerator）。还可以将替代物与内容路由功能配合使用，以创建按需复制内容的分布式网络。</p>
<ol start="6">
<li><strong>内容路由器</strong></li>
</ol>
<p>内容路由器可以根据因特网流量状况以及内容类型将请求导向特定的Web服务器。也可以用来实现各种服务级的请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/FTsdtzrCXflucPY.png"
                      alt="MavD3X6KgAr6iSp7__thumbnail.png"
                ></p>
<ol start="7">
<li><strong>转码器</strong></li>
</ol>
<p>代理服务器在将内容发送给客户端之前，可以修改内容的主体格式。在这些数据表示法之间进行的透明转换被称为<strong>转码</strong>（transcoding）。</p>
<ol start="8">
<li><strong>匿名者</strong></li>
</ol>
<p>匿名者代理会主动从HTTP报文中删除身份特性（比如客户端IP地址、From首部、Referer首部、cookie、URI的会话ID），从而提供高度的私密性和匿名性。</p>
<h1 id="6-5-代理会去往何处"><a href="#6-5-代理会去往何处" class="headerlink" title="6.5 代理会去往何处"></a>6.5 代理会去往何处</h1><h2 id="6-5-1-代理服务器的部署"><a href="#6-5-1-代理服务器的部署" class="headerlink" title="6.5.1 代理服务器的部署"></a>6.5.1 代理服务器的部署</h2><p>根据其目标用途，将代理放在任意位置。部署代理服务器的几种方式：</p>
<ol>
<li><strong>出口代理</strong></li>
</ol>
<p>将代理固定在本地网络的出口点，以便控制本地网络与大型因特网之间的流量。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/jdWInHAMKaqyD72.png"
                      alt="C514fsJkpTUSr3Mj__thumbnail.png"
                ></p>
<ol start="2">
<li><strong>访问（入口）代理</strong></li>
</ol>
<p>常被放在ISP访问点上，用以处理来自客户的聚合请求。ISP 使用缓存代理来存储常用文档的副本，以提高用户的下载速度，降低因特网带宽耗费。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/PnJCv7LoE2GhFK6.png"
                      alt="FkNHex993CoqIdQy__thumbnail.png"
                ></p>
<ol start="3">
<li><strong>反向代理</strong></li>
</ol>
<p>通常被部署在网络边缘，在Web服务器之前，在那里可以处理所有传送给Web服务器的请求，并只在必要时向Web服务器请求资源。可以提高Web服务器的安全特性，或者将快速的Web服务器缓存放在较慢的服务器之前，以提高性能。反向代理通常会直接冒用Web服务器的名字和IP地址，请求就会被发送给代理而不是服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/rsQ3Ujy68klButd.png"
                      alt="gaArfFB4Cn2B7FQL__thumbnail.png"
                ></p>
<ol start="4">
<li><strong>网络交换代理</strong></li>
</ol>
<p>可以将具有足够处理能力的代理放在网络之间的因特网对等交换点上，通过缓存来减轻因特网节点的拥塞，并对流量进行监视。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/xonWmKcysiPkf2Q.png"
                      alt="pXAesc94BLzDz3HV__thumbnail.png"
                ></p>
<h2 id="6-5-2-代理的层次结构"><a href="#6-5-2-代理的层次结构" class="headerlink" title="6.5.2 代理的层次结构"></a>6.5.2 代理的层次结构</h2><p>通过<strong>代理层次结构</strong>（proxy hierarchy）将代理级联起来。在代理的层次结构中，会将报文从一个代理传给另一个代理，直到最终抵达原始服务器为止（然后通过代理传回给客户端）。</p>
<p>下一个入口（inbound）代理（靠近服务器）被称为父代理，下一个出口（outbound）代理（靠近客户端）被称为子代理。</p>
<h4 id="6-5-2-1-代理层次结构的内容路由"><a href="#6-5-2-1-代理层次结构的内容路由" class="headerlink" title="6.5.2.1 代理层次结构的内容路由"></a>6.5.2.1 代理层次结构的内容路由</h4><p>层次不一定是静态的。代理服务器可以根据众多因素，将报文转发给一个不断变化的代理服务器和原始服务器集。</p>
<ol>
<li><strong>负载均衡</strong></li>
</ol>
<p>子代理可能会根据当前父代理上的工作负载级别来决定如何选择一个父代理，以均衡负载。</p>
<ol start="2">
<li><strong>地理位置附近的路由</strong></li>
</ol>
<p>子代理可能会选择负责原始服务器所在物理区域的父代理。</p>
<ol start="3">
<li><strong>协议/类型路由</strong></li>
</ol>
<p>子代理可能会根据URI将报文转发到不同的父代理和原始服务器上去。某些特定类型的URI可能要通过一些特殊的代理服务器转发请求，以便进行特殊的协议处理。</p>
<ol start="4">
<li><strong>基于订购的路由</strong></li>
</ol>
<p>如果发布者为高性能服务额外付费了，它们的URI就会被转发到大型缓存或压缩引擎上去，以提高性能。</p>
<h2 id="6-5-3-代理是如何获取流量的"><a href="#6-5-3-代理是如何获取流量的" class="headerlink" title="6.5.3 代理是如何获取流量的"></a>6.5.3 代理是如何获取流量的</h2><p>客户端通常会直接与Web服务器进行通信，有四种常见方式可以使客户端流量流向代理：</p>
<ol>
<li><strong>修改客户端（下一节）</strong></li>
</ol>
<p>很多Web客户端，都支持手工和自动的代理配置。如果将客户端配置为使用代理服务器，客户端就会将HTTP请求有意地直接发送给代理，而不是原始服务器。</p>
<ol start="2">
<li><strong>修改网络</strong></li>
</ol>
<p>在客户端不知道或没有参与的情况下，拦截网络流量并将其导人代理。这种拦截通常都依赖于监视HTTP流量的交换设备及路由设备。这种代理被称为拦截（intercepting）代理。</p>
<ol start="3">
<li><strong>修改DNS的命名空间</strong></li>
</ol>
<p>放在Web服务器之前的代理服务器替代物，会直接假扮Web服务器的名字和IP地址。通过手工编辑DNS名称列表，或用特殊的动态DNS服务器根据需要来确定适当的代理或服务器。有时在安装过程中，真实服务器的IP地址和名称被修改了，替代物得到的会是之前的地址和名称。</p>
<ol start="4">
<li><strong>修改Web服务器</strong></li>
</ol>
<p>将某些Web服务器配置为向客户端发送一条HTTP重定向命令（响应码305），将客户端请求重定向到一个代理上去。收到重定向命令后，客户端会与代理进行通信。</p>
<h1 id="6-6-客户端的代理设置"><a href="#6-6-客户端的代理设置" class="headerlink" title="6.6 客户端的代理设置"></a>6.6 客户端的代理设置</h1><p>所有现代的Web浏览器都允许用户对代理的使用进行配置，其中包括以下几种：</p>
<ol>
<li><strong>手工配置</strong></li>
</ol>
<p>显式地设置要使用的代理。不同浏览器都有不同的方式来进行手工配置的修改，但其思想是一样的：为代理指定主机和端口。</p>
<p>手工代理配置很简单但有些死板。只能为所有内容指定唯一一个代理服务器，且不支持故障转移，还会给大型组织带来管理问题。如果配置过的浏览器基数很大，那么需要进行修改的时候，重新配置每个浏览器是非常困难，甚至不可能。</p>
<ol start="2">
<li><strong>预先配置浏览器</strong></li>
</ol>
<p>浏览器厂商或发行商会在将浏览器发送给其客户之前预先对浏览器（或所有其他Web客户端）的代理设置进行手工配置。</p>
<ol start="3">
<li><strong>代理的自动配置</strong>（Proxy Auto-Configuration，PAC）</li>
</ol>
<p>提供一个 URI，指向一个代理自动配置文件（PAC），客户端取回这个JavaScript文件，文件都必须定义一个名为FindProxyForURL（url，host）的函数，用来计算访问URI时使用的适当的代理服务器。函数的返回值可以是表6-1列出的任意值。</p>
<p>PAC文件的后缀通常是.pac，MIME类型通常是application/x-ns-proxy-autoconfig。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/kQnzKs4qbBeV8Rl.png"
                      alt="AAivIeKbOTQBj2Rk__thumbnail.png"
                ></p>
<ol start="4">
<li><strong>WPAD的代理发现</strong></li>
</ol>
<p>有些浏览器支持<strong>Web代理自动发现协议</strong>（Web Proxy Autodiscovery Protocol，WPAD），WPAD协议的算法会使用发现机制的逐级上升策略自动地为浏览器查找合适的PAC文件。</p>
<p>WPAD会使用一系列的资源发现技术来判定适当的PAC文件。WPAD会一个接一个地对每种技术进行尝试，直到成功为止。当前的WPAD协议规范按顺序定义了下列技术：</p>
<ol>
<li>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）；</li>
<li>服务定位协议（Service Location Protocol，SLP）；</li>
<li>DNS知名主机名；</li>
<li>DNS SRV记录；</li>
<li>TXT记录中的DNS服务URI。<h1 id="6-7-代理请求的问题"><a href="#6-7-代理请求的问题" class="headerlink" title="6.7 代理请求的问题"></a>6.7 代理请求的问题</h1></li>
</ol>
<h2 id="6-7-1-代理URI与服务器URI的不同"><a href="#6-7-1-代理URI与服务器URI的不同" class="headerlink" title="6.7.1 代理URI与服务器URI的不同"></a>6.7.1 代理URI与服务器URI的不同</h2><p>客户端向Web服务器发送请求时，请求行中只包含部分URI（没有方案、主机或端口），向代理发送请求时，请求行中则包含完整的URI。</p>
<p>因为在原始的HTTP设计中，客户端直接与单个服务器进行对话，不存在虚拟主机，也没有为代理制定什么规则，服务器知道自己的主机名和端口，从而为了避免发送冗余信息。</p>
<p>代理出现之后，需要知道目标服务器的名称。基于代理的网关要知道URI的方案才能连接到FTP资源和其他方案上。因此HTTP/1.0要求代理请求发送完整的URI，但它为服务器请求保留部分URI的形式。</p>
<p>在显式地配置客户端代理设置的情况下，客户端知道将部分URI发送给服务器，将完整URI发送给代理。</p>
<h2 id="6-7-2-虚拟主机的问题"><a href="#6-7-2-虚拟主机的问题" class="headerlink" title="6.7.2 虚拟主机的问题"></a>6.7.2 虚拟主机的问题</h2><p>虚拟主机Web服务器会在很多Web站点间共享同一个物理Web服务器。和代理缺少方案/主机/端口出现的问题相似，但解决方法却有所不同：</p>
<ol>
<li>显式的代理要求在请求报文中使用完整URI来解决题；</li>
<li>虚拟主机Web服务器要求使用Host首部来承载主机和端口信息。<h2 id="6-7-3-拦截代理会收到部分URI"><a href="#6-7-3-拦截代理会收到部分URI" class="headerlink" title="6.7.3 拦截代理会收到部分URI"></a>6.7.3 拦截代理会收到部分URI</h2></li>
</ol>
<p>只要客户端正确地实现了HTTP，它们就会在请求中包含完整的URI，发送给经过显式配置的代理。这样解决了部分问题，</p>
<p>但客户端并不总是知道它是在和代理进行对话，因为有些代理对客户端可能是不可见的。在这两种情况下，客户端都会认为它在与Web服务器进行对话，不会发送完整的URI:</p>
<ol>
<li><strong>反向代理</strong>。通过假扮服务器的主机名或IP地址来做到这一点,客户端无法区分反向代理和Web服务器，因此它会发送部分URI。</li>
<li><strong>拦截代理</strong>。它会拦截从客户端发往服务器的请求，并提供一个缓存响应，或对其进行转发。拦截代理拦截了从客户端到服务器的流量，所以它会收到发送给Web服务器的部分URI。拦截代理可能也会拦截客户端到代理的流量，在这种情况下，可能会收到完整URI，需要对其进行处理。由于显式代理的通信端口通常与HTTP使用的端口有所不同（通常是8080而不是80），而且拦截代理通常只对端口80进行拦截，所以这种情况并不会经常发生。<h2 id="6-7-4-代理既可以处理代理请求，也可以处理服务器请求"><a href="#6-7-4-代理既可以处理代理请求，也可以处理服务器请求" class="headerlink" title="6.7.4 代理既可以处理代理请求，也可以处理服务器请求"></a>6.7.4 代理既可以处理代理请求，也可以处理服务器请求</h2></li>
</ol>
<p>由于将流量重定向到代理服务器的方式有所不同，通用的代理服务器既应该支持请求报文中的完整URI，也应该支持部分URI。如果是显式的代理请求，代理就应该使用完整URI，如果是Web服务器请求，就应该使用部分URI和虚拟Host首部。使用完整和部分URI的规则如下所示:</p>
<ol>
<li>如果提供的是完整URI，代理就应该使用这个完整URI。</li>
<li>如果提供的是部分URI，但有Host首部，就用Host首部来确定原始服务器的名字和端口号。</li>
<li>如果提供的是部分URI，且没有Host首部，就要用其他方法来确定原始服务器：<ol>
<li>如果代理是代表原始服务器的替代物，用真实服务器的地址和端口号来配置代理；</li>
<li>如果流量被拦截了，且拦截者也可以提供原始的IP地址和端口，就用拦截技术提供的；</li>
<li>如果所有方法都失败了，就必须返回一条错误报文（通常是建议用户升级到支持Host首部的现代浏览器）。<h2 id="6-7-5-转发过程中对URI的修改"><a href="#6-7-5-转发过程中对URI的修改" class="headerlink" title="6.7.5 转发过程中对URI的修改"></a>6.7.5 转发过程中对URI的修改</h2></li>
</ol>
</li>
</ol>
<p>代理服务器要在转发报文时修改请求URI，可能造成互操作性问题。代理服务器不能强制实现严格协议一致性，HTTP规范禁止一般的拦截代理在转发URI时重写其绝对路径部分。唯一的例外是可以用“/”来取代空路径。</p>
<h2 id="6-7-6-没有显式代理时URI的解析"><a href="#6-7-6-没有显式代理时URI的解析" class="headerlink" title="6.7.6 没有显式代理时URI的解析"></a>6.7.6 没有显式代理时URI的解析</h2><p>没有代理时，浏览器会获取输入的URI，尝试着寻找相应的IP地址。</p>
<p>如果找到主机名，浏览器会尝试相应的IP地址直到获得成功的连接为止。如果没有找到主机，很多浏览器会尝试着提供某种主机名自动“扩展”机制：</p>
<ol>
<li>很多浏览器尝试加入前缀www.和后缀.com，以防用户只输入了Web站点名的中间部分。</li>
<li>有些浏览器甚至会将未解析出来的URI传递给第三方站点，让其尝试着校正拼写错误，并给出一些用户可能希望访问的URI建议。</li>
<li>大多数系统中的DNS配置允许用户只输入主机名的前缀，然后DNS会自动搜索域名。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ASP6klb0KO6R2sNA__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="6-7-7-有显式代理时URI的解析"><a href="#6-7-7-有显式代理时URI的解析" class="headerlink" title="6.7.7 有显式代理时URI的解析"></a>6.7.7 有显式代理时URI的解析</h2><p>使用显式代理时，用户的URI会被直接发送给代理，浏览器对不完整的主机名不会进行自动扩展。（浏览器会添加了默认方案和路径，但主机名和输入的一样）。有些代理会尽力尝试着去模仿浏览器的便捷服务，包括www..com自动扩展，以及添加本地域名后缀。</p>
<h2 id="6-7-8-有拦截代理时URI的解析"><a href="#6-7-8-有拦截代理时URI的解析" class="headerlink" title="6.7.8 有拦截代理时URI的解析"></a>6.7.8 有拦截代理时URI的解析</h2><p>使用拦截代理时，对客户端来说，是没有代理的。这种情况下与使用服务器的情形类似，浏览器会自动扩展主机名，直到DNS成功为止。但建立到服务器的连接时，有一个重要的区别。</p>
<p>客户端在尝试着连接每个IP地址时，对拦截代理来说，第一次连接请求就会被代理服务器拦截成功，不会连接到原始服务器上去。客户端认为它在与Web服务器进行成功的对话，但那个Web服务器可能不活跃或停用。</p>
<p>所以提供了与浏览器相同级别的容错机制，代理可以通过解析Host首部的主机名，也可以通过对IP地址的反向DNS查找来尝试其他IP地址。</p>
<h1 id="6-8-追踪报文"><a href="#6-8-追踪报文" class="headerlink" title="6.8 追踪报文"></a>6.8 追踪报文</h1><p>在将Web请求从客户端传送到服务器的路径上，经过多个代理很常见，所以需要追踪经过代理的报文流，以检测出各种问题。</p>
<h2 id="6-8-1-Via首部"><a href="#6-8-1-Via首部" class="headerlink" title="6.8.1 Via首部"></a>6.8.1 Via首部</h2><p>Via首部字段列出了与报文途经的每个中间节点（代理或网关）有关的信息。报文每经过一个节点，都必须将这个中间节点添加到Via列表的末尾。</p>
<p>Via首部字段记录报文的转发，诊断报文循环，标识请求/响应链上所有发送者的协议能力。</p>
<p>代理也可以用Via首部检测网络中的路由循环。代理在发送请求之前，在Via首部插入与其自身有关的独特字符串，并在输入的请求中查找这个字符串，以检测网络中是否存在路由循环。</p>
<h3 id="6-8-1-1-Via的语法"><a href="#6-8-1-1-Via的语法" class="headerlink" title="6.8.1.1 Via的语法"></a>6.8.1.1 Via的语法</h3><p>Via首部字段包含一个由逗号分隔的路标（waypoint）。每个路标都表示一个独立的代理服务器或网关，且包含与那个中间节点的协议和地址有关的信息。Via首部的正规语法如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/npObsZldR1gjBiK.png"
                      alt="FVuc9ckHkakOalBe__thumbnail.png"
                ></p>
<p>注每个Via路标中最多包含4个组件：一个可选的协议名（默认为HTTP）、一个必选的协议版本、一个必选的节点名和一个可选的描述性注释。</p>
<ol>
<li><strong>协议名</strong></li>
</ol>
<p>如果协议为HTTP的话，协议名是可选的。否则要在版本之前加上协议名，中间用“/”分隔。</p>
<ol start="2">
<li><strong>协议版本</strong></li>
</ol>
<p>HTTP使用的是（1.0、1.1等），之后的应用程序就能知道前面所有中间节点的协议能力。</p>
<ol start="3">
<li><strong>节点名</strong></li>
</ol>
<p>中间节点的主机和可选端口号（如果没有，可以假定使用协议的默认端口号）。在某些情况下，出于隐私方面的考虑，可以用一个假名来代替。</p>
<ol start="4">
<li><strong>节点注释</strong></li>
</ol>
<p>进一步描述这个中间节点的可选注释。通常会在这里包含厂商和版本信息，有些代理服务器还会在注释字段中包含一些与此设备上所发生事件有关的诊断信息。</p>
<h3 id="6-8-1-2-Via的请求和响应路径"><a href="#6-8-1-2-Via的请求和响应路径" class="headerlink" title="6.8.1.2 Via的请求和响应路径"></a>6.8.1.2 Via的请求和响应路径</h3><p>请求和响应通常都是通过同一条TCP连接传送的，所以响应报文会沿着与请求报文相同的路径回传。因此，响应的via首部基本上总是与请求的via首部相反。</p>
<h3 id="6-8-1-3-Via与网关"><a href="#6-8-1-3-Via与网关" class="headerlink" title="6.8.1.3 Via与网关"></a>6.8.1.3 Via与网关</h3><p>有些代理会为不使用HTTP协议的服务器提供网关的功能。Via首部记录这些协议转换，HTTP应用程序就会了解代理链上各点的协议处理能力以及所做的协议转换。</p>
<h3 id="6-8-1-4-Server和Via首部"><a href="#6-8-1-4-Server和Via首部" class="headerlink" title="6.8.1.4 Server和Via首部"></a>6.8.1.4 Server和Via首部</h3><p>Server响应首部字段对原始服务器使用的软件进行描述。如果响应报文是通过代理转发的，要确保代理没有修改server首部。server首部是用于原始服务器的，代理应该添加的是Via条目。</p>
<h3 id="6-8-1-5-Via的隐私和安全问题"><a href="#6-8-1-5-Via的隐私和安全问题" class="headerlink" title="6.8.1.5 Via的隐私和安全问题"></a>6.8.1.5 Via的隐私和安全问题</h3><p>如果不允许进行Via节点名转发，比如作为安全防线的一部分使用的代理就应该用适当的假名来取代。（恶意用户可以通过计算机名字和版本号来了解安全防线之后的网络结构。）</p>
<p>一般来说，即使隐藏真实名称，代理也应该尝试为每台代理服务器保留一个Via路标条目。</p>
<p>对需要隐藏内部网络设计和拓扑结构的组织，代理应该将一个（接收协议值相同的）有序Via路标条目序列合并成一个联合条目。除非这些条目都在同一个组织的控制之下，而且已经用假名取代了主机名，否则就不能将其合并起来。接收协议值不同的条目也不能合并起来。</p>
<h2 id="6-8-2-TRACE方法"><a href="#6-8-2-TRACE方法" class="headerlink" title="6.8.2 TRACE方法"></a>6.8.2 TRACE方法</h2><p>代理服务器可以在转发报文时对其进行修改。可以添加、修改或删除首部，也可以将主体部分转换成不同的格式。</p>
<p>通过HTTP/1.1的TRACE方法，用户可以跟踪经代理链传输的请求报文，观察报文经过了哪些代理，以及每个代理是如何对请求报文进行修改的。TRACE对代理流的调试非常有用。</p>
<p>当TRACE请求到达目的服务器时（也可以是第一个收到了Max-Forwards值为零的请求的代理或网关），整条请求报文都会被封装在一条HTTP响应的主体中回送给发送端。当TRACE响应到达时，客户端可以检查服务器收到的确切报文，以及它所经过的代理列表（在Via首部）。TRACE响应的Content-Type为message/http，状态为200 OK。</p>
<h3 id="6-8-2-1-Max-Forwards"><a href="#6-8-2-1-Max-Forwards" class="headerlink" title="6.8.2.1 Max-Forwards"></a>6.8.2.1 Max-Forwards</h3><p>可以使用Max-Forwards（最大转发次数）首部来限制TRACE和OPTIONS请求所经过的代理跳数，在测试代理链是否是在无限循环中转发报文，或查看链中特定代理服务器的效果。</p>
<p>如果Max-Forwards的值为零（Max-Forwards：0），那么即使接收者不是原始服务器，它也必须将TRACE报文回送给客户端，而不应该继续转发。</p>
<h1 id="6-9-代理认证"><a href="#6-9-代理认证" class="headerlink" title="6.9 代理认证"></a>6.9 代理认证</h1><p>代理可以作为访问控制设备使用。HTTP定义了一种名为代理认证（proxy authentication</p>
<p>）的机制，这种机制可以阻止对内容的请求，直到用户向代理提供了有效的访问权限证书为止。</p>
<p>对受限内容的请求到达一台代理服务器时，代理服务器可以返回要求使用访问证书的<strong>407</strong>Proxy Authorization Required状态码，以及用于描述怎样提供这些证书的<strong>Proxy-Authenticate</strong>首部字段。客户端收到407响应时，会尝试从本地数据库中，或通过提示用户来搜集所需要的证书。获得了证书，客户端就会重新发送请求，在Proxy-Authorization首部字段中提供所要求的证书。如果证书有效，代理就会将原始请求沿着传输链路向下传送，否则就发送另一条407应答。</p>
<p>若传输链路中有多个代理，且每个代理都要进行认证时，代理认证通常无法很好地工作。</p>
<h1 id="6-10-代理的互操作性"><a href="#6-10-代理的互操作性" class="headerlink" title="6.10 代理的互操作性"></a>6.10 代理的互操作性</h1><p>客户端、服务器和代理是由不同厂商构建的，实现的是不同版本的HTTP规范。它们支持的特性各不相同，也存在着不同的问题。代理服务器位于客户端和服务器设备之间，这些设备实现的协议可能有所不同，可能存在着很棘手的问题。</p>
<h2 id="6-10-1-处理代理不支持的首部和方法"><a href="#6-10-1-处理代理不支持的首部和方法" class="headerlink" title="6.10.1 处理代理不支持的首部和方法"></a>6.10.1 处理代理不支持的首部和方法</h2><p>代理服务器可能无法理解所有经其传输的首部字段，有些可能是特定应用程序独有的定制首部。代理必须对不认识的首部字段进行转发，将其等价地合并为由逗号分隔的列表，且必须维持同名首部字段的相对顺序。如果代理不熟悉某个方法，应该尝试将报文转发到下一跳节点上去。</p>
<h2 id="6-10-2-OPTIONS与Allow首部"><a href="#6-10-2-OPTIONS与Allow首部" class="headerlink" title="6.10.2 OPTIONS与Allow首部"></a>6.10.2 OPTIONS与Allow首部</h2><p>通过HTTP OPTIONS方法，客户端（或代理）可以发现Web服务器或者其上某个特定资源所支持的功能。在进行交互之前，确定服务器的能力，这样它就可以更方便地与具备不同特性的代理和服务器进行互操作了。</p>
<p>如果OPTIONS请求的URI是个星号（*），请求的就是整个服务器所支持的功能。</p>
<p>如果URI是个实际资源地址，OPTIONS请求就是在查询那个特定资源的可用特性。</p>
<p>Allow实体首部字段列出了请求URI标识的资源所支持的方法列表，可以将Allow首部作为请求首部，建议在新的资源上支持某些方法，并不要求服务器支持这些方法，但应该在相应的响应中包含一个Allow首部，列出它实际支持的方法。</p>
<p>即使代理无法理解指定的所有方法，也不能对Allow首部字段进行修改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/NkzjaLQrhTvPnU3.png"
                      alt="hgRKHELPa0FxVZOO__thumbnail.png"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>07-缓存</title>
    <url>/2021/01/23/note/HTTP/07-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Web缓存是可以自动保存常见文档副本的HTTP设备。优点如下：</p>
<ol>
<li><strong>减少冗余的数据传输，节省网络费用。</strong></li>
<li><strong>缓解网络瓶颈问题。</strong>很多网络为本地网络客户端提供的带宽比远程服务器提供的带宽要宽。</li>
<li><strong>降低对原始服务器的要求。</strong>服务器可以更快地响应，避免过载的出现。</li>
<li><strong>减少距离时延</strong>。<h2 id="7-1-命中和未命中的"><a href="#7-1-命中和未命中的" class="headerlink" title="7.1 命中和未命中的"></a>7.1 命中和未命中的</h2></li>
</ol>
<p><strong>缓存命中</strong>（cache hit）：已有的副本为某些到达缓存的请求提供服务。</p>
<p><strong>缓存未命中</strong>（cache miss）：到达缓存的请求由于没有副本可用，被转发给原始服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/RV3X8revzWNhbOu.png"
                      alt="JqEmbyfnLqujDvh3__thumbnail.png"
                ></p>
<h3 id="7-1-1-再验证"><a href="#7-1-1-再验证" class="headerlink" title="7.1.1 再验证"></a>7.1.1 再验证</h3><p><strong>HTTP再验证</strong>（revalidation）：原始服务器的内容可能会发生变化，缓存要对其进行检测，查看保存的副本是否仍是服务器上最新的副本。</p>
<p>大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。常用的<strong>If-Modified-since</strong>首部来对已缓存对象进行再验证。将其添加到GET请求中去，服务器就会只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。</p>
<p>服务器收到GET If-Modified-Since请求时会发生的情况：</p>
<ol>
<li><strong>再验证命中</strong>（revalidate hit）或<strong>缓慢命中</strong>（slow hit）：缓存对副本进行再验证时，会向原始服务器发送再验证请求。如果内容没有变化，服务器会以304 NotModified进行响应，只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端。这种方式比缓存命中要慢，但比缓存未命中快，因为它没有从服务器中获取对象数据。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/NYMHsQIoBiq94Cg.png"
                      alt="cY8dGPCXn8wtoLKV__thumbnail.png"
                ></p>
<ol start="2">
<li><strong>再验证未命中</strong></li>
</ol>
<p>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/4dlYMFLh5HIjAqR.png"
                      alt="yIucryfnFQtd0k4c__thumbnail.png"
                ></p>
<ol start="3">
<li><strong>对象被删除</strong></li>
</ol>
<p>如果服务器对象已经被删除了，服务器就回送404 Not Found响应，缓存也会将其副本删除。</p>
<h3 id="7-1-2-命中率"><a href="#7-1-2-命中率" class="headerlink" title="7.1.2 命中率"></a>7.1.2 命中率</h3><p><strong>缓存命中率</strong>（cache hit rate，或<strong>缓存命中比例</strong>），或<strong>文档命中率</strong>（document hit rate）：由缓存提供服务的请求所占的比例被称为。</p>
<p>实际的命中率与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。对中等规模的Web缓存来说，40%的命中率是合理的。</p>
<h3 id="7-1-3-字节命中率"><a href="#7-1-3-字节命中率" class="headerlink" title="7.1.3 字节命中率"></a>7.1.3 字节命中率</h3><p><strong>字节命中率</strong>（byte hit rate）：缓存提供的字节在传输的所有字节中所占的比例。通过这种度量方式，可以得知节省流量的程度。</p>
<p>文档命中率说明阻止了多少通往外部网络的Web事务。事务有一一个通常都很大的固定时间成分，提高文档命中率利于降低整体时延。</p>
<p>字节命中率说明阻止了多少字节传向因特网。提高字节命中率利于节省带宽。</p>
<h3 id="7-1-4-区分命中和未命中的情况"><a href="#7-1-4-区分命中和未命中的情况" class="headerlink" title="7.1.4 区分命中和未命中的情况"></a>7.1.4 区分命中和未命中的情况</h3><p>缓存命中和访问原始服务器得到的响应，响应码都是200 OK，说明响应有主体部分。区分方法：</p>
<ol>
<li>有些商业代理缓存会在Via首部附加一些额外信息，以描述缓存中发生的情况。</li>
<li>客户端使用Date首部。将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，就可以认为这是一条缓存的响应。</li>
<li>客户端通过Age首部可以分辨出这条响应的使用期。<h2 id="7-2-缓存的拓扑结构"><a href="#7-2-缓存的拓扑结构" class="headerlink" title="7.2 缓存的拓扑结构"></a>7.2 缓存的拓扑结构</h2></li>
</ol>
<p><strong>私有缓存</strong>（private cache）：个人的缓存，包含了单个用户最常用的页面。</p>
<p><strong>公有缓存</strong>（public cache）：共享的缓存，包含了某个用户团体的常用页面。</p>
<h3 id="7-2-1-私有缓存"><a href="#7-2-1-私有缓存" class="headerlink" title="7.2.1 私有缓存"></a>7.2.1 私有缓存</h3><p>私有缓存不需要很大的动力或存储空间，这样就可以将其做的很小，很便宜。多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置，还可以去看看浏览器的缓存中有些什么内容。</p>
<h3 id="7-2-2-公有缓存"><a href="#7-2-2-公有缓存" class="headerlink" title="7.2.2 公有缓存"></a>7.2.2 公有缓存</h3><p>公有缓存是特殊的共享代理服务器，被称为<strong>缓存代理服务器</strong>（caching proxy server）或者<strong>代理缓存</strong>（proxy cache）。代理缓存可以通过指定手工代理，或者通过代理自动配置文件，将浏览器配置为使用代理缓存，还可以在不配置浏览器的情况下，通过使用拦截代理，强制HTTP请求经过缓存传输。</p>
<h3 id="7-2-3-代理缓存的层次结构"><a href="#7-2-3-代理缓存的层次结构" class="headerlink" title="7.2.3 代理缓存的层次结构"></a>7.2.3 代理缓存的层次结构</h3><h4 id="7-2-3-1-层次化缓存结构"><a href="#7-2-3-1-层次化缓存结构" class="headerlink" title="7.2.3.1 层次化缓存结构"></a>7.2.3.1 层次化缓存结构</h4><p>较小缓存中未命中的请求会被导向较大的<strong>父缓存</strong>（parent cache），由它来为剩下的那些流量提供服务。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/2Fvtnc8ADEpigaO.png"
                      alt="Co7dnjntrFDvuHrm__thumbnail.png"
                ></p>
<h4 id="7-2-3-2-网状缓存结构"><a href="#7-2-3-2-网状缓存结构" class="headerlink" title="7.2.3.2 网状缓存结构"></a>7.2.3.2 网状缓存结构</h4><p>网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为<strong>内容路由器</strong>（content router）。</p>
<p>网状缓存中为内容路由设计的缓存要完成的功能：</p>
<ol>
<li>根据URL在父缓存或原始服务器之间进行动态选择。</li>
<li>根据URL动态地选择一个特定的父缓存。</li>
<li>前往父缓存之前，在本地缓存中搜索已缓存的副本。</li>
<li>允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。</li>
</ol>
<p>缓存之间更为复杂的关系允许不同的组织互为对等（peer）实体，将它们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存（sibling cache）。HTTP并不支持兄弟缓存，所以通过一些协议对HTTP进行了扩展，比如<strong>因特网缓存协议</strong>（Internet Cache Protocol，ICP）和<strong>超文本缓存协议</strong>（HyperText Caching Protocol，HTCP）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/rsigfvB136ZuEYM.png"
                      alt="iKZZ0KjuHsCngdjY__thumbnail.png"
                ></p>
<h2 id="7-3-缓存的处理步骤"><a href="#7-3-缓存的处理步骤" class="headerlink" title="7.3 缓存的处理步骤"></a>7.3 缓存的处理步骤</h2><p>对一条HTTP GET报文的基本缓存处理过程包括7个步骤。</p>
<ol>
<li>接收——缓存从网络中读取抵达的请求报文。</li>
<li>解析——缓存对报文进行解析，提取出URL和各种首部。</li>
<li>查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本并将其保存在本地。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象中还包含了一些元数据（metadata）。</li>
<li>新鲜度检测——缓存查看已缓存副本是否新鲜，如果不是，就询问服务器是否有任何更新。</li>
<li>创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。缓存负责对这些首部进行改造，以便与客户端的要求相匹配。缓存会插入新鲜度信息（Cache-Control、Age以及Expires首部），通常会包含一个Via首部。缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对象的日期。.</li>
<li>发送——缓存通过网络将响应发回给客户端。</li>
<li>日志——缓存可选地创建一个日志文件条目来描述这个事务。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/sVqzw9j2HmtbMpN.png"
                      alt="sPL9fez6Q5GM0Kew__thumbnail.png"
                ></p>
<h2 id="7-4-保持副本的新鲜"><a href="#7-4-保持副本的新鲜" class="headerlink" title="7.4 保持副本的新鲜"></a>7.4 保持副本的新鲜</h2><p>HTTP有一些机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些机制称为<strong>文档过期</strong>（document expiration）和<strong>服务器再验证</strong>（server revalidation）。</p>
<h3 id="7-4-1-文档过期"><a href="#7-4-1-文档过期" class="headerlink" title="7.4.1 文档过期"></a>7.4.1 文档过期</h3><p>通过HTTP Cache-Control和Expires首部，让原始服务器向每个文档附加了一个“过期日期”，这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p>
<p>在过期之前，缓存可以任意使用这些副本，无需与服务器联系，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。</p>
<p>一旦文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜（带有新的过期日期）的副本。</p>
<p>很多发布者都不会使用很长的过期日期。而且，很多发布者甚至都不使用过期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/yHViZqd6JFonrt1.png"
                      alt="mvA0UnLjL6rYmQLQ__thumbnail.png"
                ></p>
<h3 id="7-4-2-服务器再验证"><a href="#7-4-2-服务器再验证" class="headerlink" title="7.4.2 服务器再验证"></a>7.4.2 服务器再验证</h3><p>缓存并不一定要为每条请求验证文档的有效性，只有在文档过期时才需要与服务器进行再验证。缓存文档过期了并不一定和原始服务器上的文档有实际的区别：只是意味着到了要进行核对的时间。这种情况被称为“<strong>服务器再验证</strong>”，说明缓存需要询问原始服务器文档是否发生了变化。</p>
<ol>
<li>如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。</li>
<li>如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新。</li>
</ol>
<p>缓存返回的内容有以下几种情况：</p>
<ol>
<li>“足够新鲜”的已缓存副本；</li>
<li>与服务器进行过再验证，确认其仍然新鲜的已缓存副本；</li>
<li>如果需要与之进行再验证的原始服务器出故障了，就返回一条错误报文；</li>
<li>附有警告信息说明内容可能不正确的已缓存副本。<h3 id="7-4-3-用条件方法进行再验证"><a href="#7-4-3-用条件方法进行再验证" class="headerlink" title="7.4.3 用条件方法进行再验证"></a>7.4.3 用条件方法进行再验证</h3></li>
</ol>
<p>缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。对缓存再验证来说最有用是<strong>If-Modi fied-Since</strong>和<strong>If-None-Match</strong>首部<strong>。</strong></p>
<h4 id="7-4-3-1-If-Modified-Since-Date再验证"><a href="#7-4-3-1-If-Modified-Since-Date再验证" class="headerlink" title="7.4.3.1 If-Modified-Since:Date再验证"></a>7.4.3.1 If-Modified-Since:Date再验证</h4><p>If-Modified-since再验证请求通常被称为<strong>IMS请求</strong>。只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求：</p>
<ol>
<li>如果自指定日期后，文档被修改了，通常GET就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</li>
<li>如果自指定日期后，文档没被修改过，会向客户端返回一个小的304 Not Modified响应报文，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。一般会发送一个新的过期日期。</li>
</ol>
<p>If-Modified-Since首部可以与Last-Modified服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行再验证时，就会包含一个If-Modified-Since首部，其中携带有最后修改已缓存副本的日期：</p>
<p>If-Modified-Since：&lt;cached last-modified date&gt;</p>
<p>如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送新的文档。否则，最后修改日期相符，会返回一个304 Not Modified响应。</p>
<h4 id="7-4-3-2-If-None-Match：实体标签再验证"><a href="#7-4-3-2-If-None-Match：实体标签再验证" class="headerlink" title="7.4.3.2 If-None-Match：实体标签再验证"></a>7.4.3.2 If-None-Match：实体标签再验证</h4><p>有些情况下仅使用最后修改日期进行再验证是不够的。比如：</p>
<ol>
<li>有些文档被周期性地重写，但数据是一样的。即便内容没有变化，但修改日期会发生变化。</li>
<li>有些文档被修改了，但所做修改并不重要，不需要让缓存都重装数据。</li>
<li>有些服务器无法准确地判定其页面的最后修改日期。</li>
<li>有些服务器提供的文档会在亚秒间隙发生变化（比如实时监视器），以一秒为粒度的修改日期就不够用。</li>
</ol>
<p>因此HTTP允许用户对被称为<strong>实体标签</strong>（ETag）的“版本标识符”进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。</p>
<p>当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。如果服务器上的实体标签已经发生了变化，服务器会在一个200 OK响应中返回新的内容以及相应的新Etag.</p>
<p>可以在If-None-Match首部包含几个实体标签，告诉服务器，带有这些实体标签的对象副本在缓存上都有。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/gWolIJmiQEnwkXM.png"
                      alt="erfxAVVZ74Xb8xhr__thumbnail.png"
                ></p>
<h3 id="7-4-4-强弱验证器"><a href="#7-4-4-强弱验证器" class="headerlink" title="7.4.4 强弱验证器"></a>7.4.4 强弱验证器</h3><p>实体标签和最近修改日期都是<strong>缓存验证器</strong>（cache validator）。有时，服务器希望在对文档进行不重要的修改时，不使所有的已缓存副本都失效。HTTP/1.1 支持“<strong>弱验证器</strong>”，如果只对内容进行了少量修改，就允许服务器声明那是“足够好”的等价体。</p>
<p>有些操作不能用弱验证器来实现（比如有条件地获取部分内容），所以服务器用前缀“WI”来标识弱验证器。ETag: W/“v2.6”    If- None-Match: W/ “v2.6”</p>
<p>原始服务器不能为两个不同的实体重用一个强实体标签值，或为两个语义不同的实体重用一个弱实体标签值。</p>
<h2 id="7-5-控制缓存的能力"><a href="#7-5-控制缓存的能力" class="headerlink" title="7.5 控制缓存的能力"></a>7.5 控制缓存的能力</h2><p>服务器可以指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序：</p>
<ol>
<li>附加<strong>Cache-Control：no-store</strong>首部到响应中，禁止缓存对响应进行复制，缓存通常会向客户端转发一条no-store响应，然后删除对象。</li>
<li>附加<strong>Cache-Control：no-cache</strong>首部到响应中。可以存储在本地缓存区，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。</li>
<li>附加<strong>Cache-Control：must-revalidate</strong>首部到响应中。缓存可以通过配置，提供一些过期的对象，以提高性能，因此通过Cache-Control：must-revalidate首部让缓存严格遵守过期信息，在没有进行再验证的情况下，不能提供这个对象的陈旧副本。如果缓存在进行must-revalidate新鲜度检查时，服务器不可用，缓存就返回一条504 Gateway Timeout错误。</li>
<li>附加<strong>Cache-Control：max-age</strong>首部到响应中。还有一个s-maxage首部仅适用公有缓存。</li>
<li>附加<strong>Expires</strong>日期首部到响应中。不推荐使用Expires首部，因为服务器的时钟可能不同步，或不正确。其中Expires:0响应首部，试图将文档置于永远过期的状态，但这种语法是非法的，可能给某些软件带来问题。</li>
<li>不附加过期信息，让缓存确定自己的过期日期。<h3 id="7-5-1-试探性过期"><a href="#7-5-1-试探性过期" class="headerlink" title="7.5.1 试探性过期"></a>7.5.1 试探性过期</h3></li>
</ol>
<p>缓存通过算法计算出一个试探性最大使用期。但如果最大使用期大于24小时，就向响应首部添加Heuristic Expiration Warning（试探性过期警告，警告13）首部，但很少有浏览器提供。</p>
<p>如果文档中包含了最后修改日期，就可以使用LM-Factor算法，通过计算缓存与服务器对话的时间跟服务器声明文档最后被修改的时间之间的差值，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。通常会为试探性新鲜周期设置上限，一般设置为一周。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/rQ3UBMxVOJvqwaP.png"
                      alt="bT1QqO3hyhVyT1Rm__thumbnail.png"
                ></p>
<p>如果最后修改日期也没有，缓存通常会为文档分配一个默认的新鲜周期（通常是一个小时或一天）。</p>
<h3 id="7-5-2-客户端的新鲜度限制"><a href="#7-5-2-客户端的新鲜度限制" class="headerlink" title="7.5.2 客户端的新鲜度限制"></a>7.5.2 客户端的新鲜度限制</h3><p>Web浏览器都有Refresh（刷新）或Reload（重载）按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。</p>
<p>Refresh按钮会发布附加了Cache-Control请求首部的GET请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。Refresh 的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。客户端可以用Cache-Control请求首部来强化或放松对过期时间的限制。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/07/67RPxWeDKVmUBL3.png"
                      alt="c66vSOYHG3viCCN0__thumbnail.png"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>15-实体和编码</title>
    <url>/2021/01/23/note/HTTP/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="15-1-报文是箱子，实体是货物"><a href="#15-1-报文是箱子，实体是货物" class="headerlink" title="15.1 报文是箱子，实体是货物"></a>15.1 报文是箱子，实体是货物</h2><p>报文实体由实体首部和实体主体组成的。首部字段以一个空白的CRLF行结束，随后就是实体主体的原始内容。任何其他描述性的信息都包含在实体首部中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/cnoa3xepd6bS4Nf.png"
                      alt="YuTjZHTRjDigxdVP__thumbnail.png"
                ></p>
<h2 id="15-2-Content-Length：实体的大小"><a href="#15-2-Content-Length：实体的大小" class="headerlink" title="15.2 Content-Length：实体的大小"></a>15.2 Content-Length：实体的大小</h2><p>Content-Length首部指示出报文中实体主体的字节大小，包含了所有内容编码的。Content-Length首部就是带有实体主体的报文必须使用的，除非使用了分块编码。使用Content-Length首部能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段。</p>
<h3 id="15-2-1-检测截尾"><a href="#15-2-1-检测截尾" class="headerlink" title="15.2.1 检测截尾"></a>15.2.1 检测截尾</h3><p>HTTP的早期版本采用关闭连接的办法来划定报文的结束。但客户端无法区分是正常的连接关闭，还是由于服务器崩溃而导致的连接关闭。</p>
<p>客户端需要通过Content-Length来检测报文截尾。尤其对缓存代理服务器来说，如果收到被截尾的报文却没有识别出截尾的话，它可能会存储不完整的内容并多次使用它来提供服务。</p>
<p>缓存代理服务器通常不会为没有显式Content-Length首部的HTTP主体做缓存，以此来减小缓存已截尾报文的风险。</p>
<h3 id="15-2-2-错误的Content-Length"><a href="#15-2-2-错误的Content-Length" class="headerlink" title="15.2.2 错误的Content-Length"></a>15.2.2 错误的Content-Length</h3><p>错误的Content-Length比缺少Content-Length还要糟糕。因此有些客户端、服务器以及代理中就包含特别的算法，用来检测和纠正与有缺陷服务器的交互过程。HTTP/1.1规定用户Agent代理应该在接收且检测到无效长度时通知用户。</p>
<h3 id="15-2-3-Content-Length与持久连接"><a href="#15-2-3-Content-Length与持久连接" class="headerlink" title="15.2.3 Content-Length与持久连接"></a>15.2.3 Content-Length与持久连接</h3><p>因为如果响应通过持久连接传送，客户端无法依赖连接关闭来判别报文的结束，因此客户端通过Content-Length首部知道报文在何处结束，下一 条报文从何处开始。</p>
<p>采用<strong>分块编码</strong>（chunked encoding），使用持久连接时可以没有Content-Length首部。在分块编码的情况下，数据是分为一系列的块来发送的，每块都有大小说明。</p>
<h3 id="15-2-4-内容编码"><a href="#15-2-4-内容编码" class="headerlink" title="15.2.4 内容编码"></a>15.2.4 内容编码</h3><p>HTTP允许对实体主体的内容进行编码，可以使之更安全或进行压缩以节省空间。如果主体进行了内容编码，Content-Length说明的就是编码后主体的字节长度，而不是原始主体的长度。</p>
<h3 id="15-2-5-确定实体主体长度的规则"><a href="#15-2-5-确定实体主体长度的规则" class="headerlink" title="15.2.5 确定实体主体长度的规则"></a>15.2.5 确定实体主体长度的规则</h3><p>下面列出的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置，规则按顺序应用，谁先匹配就用谁：</p>
<ol>
<li>如果特定的HTTP报文类型中不允许带有主体，就忽略Content-Length首部，它是对实际上没有发送出来的主体进行计算的。这种情况下，Content-Length首部是提示性的，并不说明实际的主体长度。</li>
<li>如果报文中有描述传输编码的Transfer-Encoding首部（不采用默认的HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）的特殊模式结束，除非报文已经因连接关闭而结束。</li>
<li>如果报文中有Content-Length首部且报文类型允许有实体主体，而且没有非恒等的Transfer-Encoding首部字段，那么Content-Length的值就是主体的长度。如果收到的报文中Content-Length和Transfer-Encoding首部字段都有，就必须忽略Content-Length，因为传输编码会改变实体主体的表示和传输方式。从而可能就会改变传输的字节数。</li>
<li>如果报文使用了multipart/byteranges（多部分/字节范围）媒体类型，并且没有用Content-Length首部指出实体主体的长度，那么多部分报文中的每个部分都要说明自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。</li>
<li>如果上面的规则都不匹配，实体就在连接关闭的时候结束。只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应。</li>
</ol>
<p>为了和使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的Content-Length首部字段，除非知道服务器兼容HTTP/1.1。对于带有主体但没有Content-Length首部的请求，服务器就应当发送400 Bad Request响应或411 Length Required响应。.</p>
<h2 id="15-3-实体摘要"><a href="#15-3-实体摘要" class="headerlink" title="15.3 实体摘要"></a>15.3 实体摘要</h2><p>发送方可以在生成初始的主体时，生成一个数据的校验和，接收方就可以通过检查这个校验和来检测实体主体的数据是否被修改。</p>
<p>Content-MD5首部是发送对实体主体运行MD5算法的结果，只有产生响应的原始服务器可以计算并发送。中间代理和缓存不应当修改或添加这个首部，否则就会与验证端到端完整性的这个最终目的相冲突。</p>
<p>Content-MD5首部是在对内容做了所有需要的内容编码之后，还没有做传输编码前，计算出来的。为了验证报文的完整性，客户端必须先进行传输编码的解码，然后计算所得到的未进行传输编码的实体主体的MD5。</p>
<p>除了检查报文的完整性之外，MD5还可以当作散列表的关键字，用来快速定位文档并消除不必要的重复内容存储。</p>
<p>作为对HTTP的扩展，增加新的Want-Digest首部，它允许客户端说明期望响应中使用的摘要类型，并使用质量值来建议多种摘要算法并说明优先顺序。</p>
<h2 id="15-4-媒体类型和字符集"><a href="#15-4-媒体类型和字符集" class="headerlink" title="15.4 媒体类型和字符集"></a>15.4 媒体类型和字符集</h2><p>Content-Type首部字段说明实体主体的MIME类型。MIME类型是标准化的名字，用以说明运载实体的基本媒体类型。客户端应用程序使用MIME类型来解释和处理其内容。Content-Type的值是标准化的MIME类型，在互联网号码分配机构（Internet Assigned Numbers Authority，简称IANA）中注册。</p>
<p>MIME类型由一个主媒体类型后面跟一条斜线以及一个子类型组成，子类型用于进一步描述媒体类型。</p>
<p>Content-Type首部说明的是原始实体主体的媒体类型。实体经过内容编码的话，Content-Type首部说明的仍是编码之前的实体主体的类型。，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/jnyXQHRc4t2gT3U.png"
                      alt="Hgvet3LTBs7pzFpx__thumbnail.png"
                ></p>
<h3 id="15-4-1-文本的字符编码"><a href="#15-4-1-文本的字符编码" class="headerlink" title="15.4.1 文本的字符编码"></a>15.4.1 文本的字符编码</h3><p>Content-Type首部还支持可选的参数来进一步说明内容的类型。比如charset（字符集）参数，说明把实体中的比特转换为文本文件中的字符的方法：Content-Type：text/html；</p>
<h3 id="15-4-2-多部分媒体类型"><a href="#15-4-2-多部分媒体类型" class="headerlink" title="15.4.2 多部分媒体类型"></a>15.4.2 多部分媒体类型</h3><p>MIME中的multipart（多部分）电子邮件报文中包含多个报文，它们一起作为复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同的部分之间用分界字符串连接。</p>
<p>HTTP也支持多部分主体。通常只用在下列两种情形之一：</p>
<ol>
<li>多部分表格提交，HTTP使用<strong>Content-Type：multipart/form-data</strong>或<strong>Content-Type：multipart/mixed</strong>首部以及多部分主体来发送这种请求，e.g. Content-Type：multipart/form-data；boundary=[abc]，其中的boundary参数说明了分割主体中不同部分所用的字符串。</li>
<li>作为承载若干文档片段的范围响应。HTTP对范围请求的响应也可以是多部分的，这样的响应中有<strong>Content-Type：multipart/byteranges</strong>首部和带有不同范围的多部分主体。<h2 id="15-5-内容编码"><a href="#15-5-内容编码" class="headerlink" title="15.5 内容编码"></a>15.5 内容编码</h2></li>
</ol>
<p>HTTP应用程序有时在发送之前对内容进行编码，有助于减少传输实体的时间，还可以把内容搅乱或加密，以此来防止未经授权的第三方看到文档的内容。这种类型的编码是在发送方应用到内容之上的。</p>
<h3 id="15-5-1-内容编码过程"><a href="#15-5-1-内容编码过程" class="headerlink" title="15.5.1 内容编码过程"></a>15.5.1 内容编码过程</h3><p>内容编码的过程如下所述：</p>
<ol>
<li>网站服务器生成原始响应报文，其中有原始的Content-Type和Content-Length首部。</li>
<li>内容编码服务器（也可能就是原始的服务器或下行的代理）创建编码后的报文。编码后的报文有同样的Content-Type，但Content-Length可能不同，在编码后的报文中增加Content-Encoding首部，这样接收的应用程序就可以进行解码。</li>
<li>接收程序得到编码后的报文，进行解码，获得原始报文。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ny5FQBflWuTLOAi.png"
                      alt="wfXRqxnk1BEU33wW__thumbnail.png"
                ></p>
<h3 id="15-5-2-内容编码类型"><a href="#15-5-2-内容编码类型" class="headerlink" title="15.5.2 内容编码类型"></a>15.5.2 内容编码类型</h3><p>HTTP定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联网号码分配机构（IANA）对各种编码进行标准化，它给每个内容编码算法分配了唯一的代号。Content-Encoding首部就用这些标准化的代号来说明编码时使用的算法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/z2TfyUgZSmcl75A.png"
                      alt="Bd5Wji9r83iXfpN0__thumbnail.png"
                ></p>
<h3 id="15-5-3-Accept-Encoding首部"><a href="#15-5-3-Accept-Encoding首部" class="headerlink" title="15.5.3 Accept-Encoding首部"></a>15.5.3 Accept-Encoding首部</h3><p>为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放在请求的Accept-Encoding首部里发出去。如果HTTP请求中没有包含Accept-Encoding首部，服务器就可以假设客户端能够接受任何编码方式。</p>
<p>客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q值范围从0.0到1.0，0.0说明客户端不想接受所说明的编码，1.0则表明最希望使用的编码。*表示“任何其他方法”。</p>
<p>identity编码代号只能在Accept-Encoding首部中出现，客户端用它来说明相对于其他内容编码算法的优先级。</p>
<h2 id="15-6-传输编码和分块编码"><a href="#15-6-传输编码和分块编码" class="headerlink" title="15.6 传输编码和分块编码"></a>15.6 传输编码和分块编码</h2><p>传输编码也是作用在实体主体上的可逆变换，使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/qlKXONDHRMSLdmr.png"
                      alt="KmJHDOGZldzZmjDu__thumbnail.png"
                ></p>
<h3 id="15-6-1-可靠传输"><a href="#15-6-1-可靠传输" class="headerlink" title="15.6.1 可靠传输"></a>15.6.1 可靠传输</h3><p>在HTTP协议中，底层的传输设施已经标准化且容错性好，只有少数情况下，所传输的报文主体可能会引发问题：</p>
<ol>
<li><strong>未知的尺寸</strong>。如果不先生成内容，某些网关应用程序和内容编码器无法确定报文主体的最终大小，所以它们希望在知道大小前就开始传输数据。因为HTTP协议要求Content-Length首部必须在数据之前，所以使用传输编码来发送数据，并用特别的结束脚注表明数据结束。</li>
<li><strong>安全性</strong>。可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。但由于像SSL这样的传输层安全体系，很少需要靠传输编码来实现安全性。<h3 id="15-6-2-Transfer-Encoding首部"><a href="#15-6-2-Transfer-Encoding首部" class="headerlink" title="15.6.2 Transfer-Encoding首部"></a>15.6.2 Transfer-Encoding首部</h3></li>
</ol>
<p>用来描述和控制传输编码的两个首部:</p>
<ol>
<li>Transfer-Encoding。告知接收方为了可靠地传输报文，已经对其进行了何种编码。</li>
<li>TE。用在请求首部中，告知服务器可以使用哪些传输编码扩展。</li>
</ol>
<p>HTTP规范只定义了一种传输编码，就是分块编码（chunked）。TE首部也可以使用Q值来说明传输编码的优先顺序，但禁止设为0.0。</p>
<h3 id="15-6-3-分块编码"><a href="#15-6-3-分块编码" class="headerlink" title="15.6.3 分块编码"></a>15.6.3 分块编码</h3><p>分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。</p>
<p>分块编码是一种传输编码，因此是报文的属性，而不是主体的属性。而多部分编码，是主体的属性，它和分块编码是完全独立的。</p>
<h4 id="15-6-3-1-分块与持久连接"><a href="#15-6-3-1-分块与持久连接" class="headerlink" title="15.6.3.1 分块与持久连接"></a>15.6.3.1 分块与持久连接</h4><p>若客户端和服务器之间不是持久连接，客户端就不需要知道主体的长度，而只需要读到服务器关闭主体连接为止。否则必须加上Content-Length首部发送。</p>
<p>但如果服务器动态创建内容，就可能在发送之前无法知道主体的长度，于是通过分块编码解决。服务器可以用大小为0的块作为主体结束的信号，来继续保持连接，为下一个响应做准备。</p>
<p>客户端也可以发送分块的数据给服务器。因为客户端事先不知道服务器是否接受分块编码（因为客户端才会发送TE首部），所以客户端必须做好服务器用411 Length Required响应来拒绝分块请求的准备。</p>
<p>分块编码报文的基本结构：它由起始的HTTP响应首部块开始，随后是一系列分块。每个分块包含一个长度值和该分块的数据。长度值是十六进制形式并将CRLF与数据分隔开。分块中数据的大小以字节计算，不包括长度值与数据之间的CRLF序列以及分块结尾的CRLF序列。最后一个块长度值为0，表示“主体结束”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/yqf1AQakN5l3EWL.png"
                      alt="QefkJBLxwkzvePyF__thumbnail.png"
                ></p>
<h4 id="15-6-3-2-分块报文的拖挂"><a href="#15-6-3-2-分块报文的拖挂" class="headerlink" title="15.6.3.2 分块报文的拖挂"></a>15.6.3.2 分块报文的拖挂</h4><p>只有客户端的TE首部中说明可以接受拖挂，才在分块的报文最后加上。产生原始响应的服务器也可以在分块的报文最后加上拖挂。</p>
<p>拖挂的内容是可选的元数据，客户端不一定需要理解和使用（甚至可以忽略并丢弃拖挂中的内容）。拖挂中可以包含附带的首部字段，它们的值在报文开始的时候可能是无法确定的。比如Content-MD5 ，在文档生成之前很难算出它的MD5。</p>
<p>报文首部中包含一个Trailer首部，列出了跟在分块报文之后的首部列表，除了Transfer-Encoding、Trailer 以及Content-Length首部之外，其他HTTP首部都可以作为拖挂发送，这些首部紧接在最后一个分块之后。</p>
<h3 id="15-6-4-内容编码与传输编码的结合"><a href="#15-6-4-内容编码与传输编码的结合" class="headerlink" title="15.6.4 内容编码与传输编码的结合"></a>15.6.4 内容编码与传输编码的结合</h3><p>内容编码与传输编码可以同时使用。接收方“重构”主体的过程和发送方相反。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/t1bpNjzZSgG4XVv.png"
                      alt="R2V1NNz6yChk86Tq__thumbnail.png"
                ></p>
<h3 id="15-6-5-传输编码的规则"><a href="#15-6-5-传输编码的规则" class="headerlink" title="15.6.5 传输编码的规则"></a>15.6.5 传输编码的规则</h3><p>对报文主体使用传输编码时，必须遵守以下规则，使得接收方能够确定报文的传输长度：</p>
<ol>
<li>传输编码集合中必须包括“分块”，唯一例外是使用关闭连接来结束报文。</li>
<li>当使用分块传输编码时，它必须是最后一个作用到报文主体之上的。</li>
<li>分块传输编码不能多次作用到一个报文主体上。</li>
</ol>
<p>实现传输编码的服务器必须意不把经传输编码后的报文发送给非HTTP/1.1的应用程序。否则如果服务器收到无法理解的经过传输编码的报文，用501 Unimplemented状态码来回复。</p>
<h2 id="15-7-随时间变化的实例"><a href="#15-7-随时间变化的实例" class="headerlink" title="15.7 随时间变化的实例"></a>15.7 随时间变化的实例</h2><p>网站对象并不是静态的。同样的URL会随着时间变化而指向对象的不同版，也就是实例。</p>
<p>HTTP协议规定了称为<strong>实例操控</strong>（instance manipulations）的一系列请求和响应操作，用以操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两种方法都要求客户端能够标识它所拥有（如果有的话）的资源的特定副本，并在一定的条件下请求新的实例。</p>
<h2 id="15-8-验证码和新鲜度"><a href="#15-8-验证码和新鲜度" class="headerlink" title="15.8 验证码和新鲜度"></a>15.8 验证码和新鲜度</h2><p>当文档在客户端“过期”之后（客户端不认为该副本有效），客户端须从服务器请求一份新副本。如果该文档在服务器上并未改变，客户端也就不需要再接收，继续使用缓存的副本即可。</p>
<p>这种特殊的请求，称为<strong>有条件的请求</strong>（conditional request），要求客户端使用验证码</p>
<p>（validator）来告知服务器它当前拥有的版本号，并仅当它当前副本无效才要求发送新的副本。</p>
<h3 id="15-8-1-新鲜度"><a href="#15-8-1-新鲜度" class="headerlink" title="15.8.1 新鲜度"></a>15.8.1 新鲜度</h3><p>服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。服务器可以用Expires（过期）和Cache-Control（缓存控制）来提供这种信息。</p>
<p>同时服务器和客户端不仅都可以用Cache-Control来说明新鲜度，并且除了使用期或过期时间之外，还有很多指令可用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ysK29bnJzuWZOcB.png"
                      alt="m7VrGBnCBAIpGjwd__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zUOXlkoVYQ3txPF.png"
                      alt="27woIO882zhDrUbJ__thumbnail.png"
                ></p>
<h3 id="15-8-2-有条件的请求与验证码"><a href="#15-8-2-有条件的请求与验证码" class="headerlink" title="15.8.2 有条件的请求与验证码"></a>15.8.2 有条件的请求与验证码</h3><p>当原始服务器上的文档与缓存中已过期的副本相同，而缓存服务器还是要从原始服务器上取文档的话，那缓存服务器就是在浪费网络带宽，给缓存服务器和原始服务器增加不必要的负载。</p>
<p>解决方案：仅当资源改变时才请求副本，这种特殊请求称为有条件的请求，仅当某个特定条件为真时才执行，如果条件不满足，服务器就发回一个HTTP错误码。</p>
<p>每个有条件的请求都通过特定的验证码来发挥作用。验证码是文档实例的特殊属性，用它来测试条件是否为真。可以把验证码看作文件的序列号、版本号，或者最后发生改变的日期时间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/2kSovtqjD1YQaNu.png"
                      alt="ZOLwYk7M1G3NhugX__thumbnail.png"
                ></p>
<p>HTTP把验证码分为两类：<strong>弱验证码</strong>（weak validators）和<strong>强验证码</strong>（strong validators）。</p>
<p>弱验证码不一定能唯一标识资源的一个实例，而强验证码可以。</p>
<p>弱验证码：</p>
<ol>
<li>字节计数验证码，可能资源的内容改变了，而大小还保持不变，资源内容的加密校验和就是强验证码，文档改变时总是会变。</li>
<li>最后修改时间，因为它的描述精度最大就是1秒。资源可能在1秒内可以改变很多次。</li>
</ol>
<p>强验证码：ETag首部被当作强验证码，因为每当资源内容改变时，服务器都可以在ETag首部放置不同的值。ETag首部很灵活，它可以带上任意的文本值，这样就可以设计出各种各样的客户端和服务器验证策略。版本号和摘要校验是很好的ETag首部候选，但不能带有任意的文本。</p>
<p>有时候，不想在缓存服务器再验证时产生很大的传输流量，就需要采用不那么精确的实体标记验证方法。服务器可以在标记前加上”W/“前缀来广播一个“弱”实体标记。对于弱实体标记来说，只有当关联的实体在语义上发生了重大改变时，标记才变化。而强实体标记只要内容变化，标记都一定会改变。</p>
<h2 id="15-9-范围请求"><a href="#15-9-范围请求" class="headerlink" title="15.9 范围请求"></a>15.9 范围请求</h2><p>范围请求允许客户端实际上只请求文档的一部分。比如HTTP客户端可以通过请求曾获取失败的实体的一个范围，来恢复下载该实体。前提是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象没有改变过。</p>
<p>可以使用Range：bytes=4000-这种形式的范围请求，因为请求方可能不知道文档的大小。还可以用Range首部来请求多个范围（可以按任意顺序给出，也可以相互重叠）。因为客户端可以同时连接多个服务器下载同一个文档的不同部分。</p>
<p>对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多部分主体及Content-Type：multipart/byteranges 首部。</p>
<p>不是所有服务器都接受范围请求，服务器可以通过在响应中包含Accept-Ranges首部的形式向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，规范中只定义了bytes 记号，但具体实现可以用服务器和客户端自己认定的单位来衡量或切分实体。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/A2MzCgNQdYvInuW.png"
                      alt="W7dJGGZkH5D2R8X5__thumbnail.png"
                ></p>
<p>Range首部在流行的<strong>点对点</strong>（Peer-to-Peer，P2P）文件共享客户端软件中得到广泛应用，它们从不同的对等实体同时下载多媒体文件的不同部分。</p>
<p>范围请求属于实例操控，因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是客户端的范围请求仅当客户端和服务器拥有文档的同一个版本时才有意义。</p>
<h2 id="15-10-差异编码"><a href="#15-10-差异编码" class="headerlink" title="15.10 差异编码"></a>15.10 差异编码</h2><p>差异编码通过交换对象改变的部分而不是完整的对象来优化传输性能。差异编码也属于实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。</p>
<p>客户端必须告诉服务器现有资源的版本，是否接受资源最新版的差异（delta），知道将差异应用于现有版本的哪些算法。</p>
<p>服务器必须检查客户端是否有这个资源现有版本，通过算法计算客户端资源现有版本与新版之间的差异，然后发送给客户端，告知客户端所发送的是差异，并说明新资源的（ETag），因为客户端将差异应用于其老版本之后就会得到这个版本。</p>
<p>如果客户端想告诉服务器接受资源的差异，就发送A-IM（Accept-Instance-Manipulation）首部，而不用发送完整的资源。在A-IM首部中，客户端说明知道哪些算法可以把差异应用于老版本而得到最新版本。</p>
<p>服务端发送的是一个特殊的响应代码一226 IM Used，告知客户端它正在发送的是所请求对象的实例操控，而不是完整的对象。IM（Instance-Manipulation）首部，说明用于计算差异的算法，还有新的ETag首部，以及Delta-Base首部，说明用于计算差异的基线文档的ETag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/a6SjMEOpBYmCJHl.png"
                      alt="1zeEzzzA7jllslxR__thumbnail.png"
                ></p>
<p>客户端用A-IM首部说明可以接受的一些实例操控的类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/wRvzhJaXt6FPfme.png"
                      alt="l9MCr1VSHCxu3wQi__thumbnail.png"
                ></p>
<p>服务器侧的<strong>差异生成器</strong>根据基线文档和该文档的最新实例，并用客户端在A-IM首部中指明的算法计算它们之间的差异。客户端侧的<strong>差异应用器</strong>得到差异，将其应用于基线文档，得到文档的最新实例。</p>
<p>在返回给客户端之前，文档可以经过多种实例操控，这样可以获得最大程度的压缩。例如，用vcdiff算法产生的差异后可以再用gzip算法压缩。</p>
<p>差异编码可以减少传输次数，但支持差异编码的服务器必须保存资源的所有不同版本，才能计算新版本与所请求的客户端持有的现有版本之间的差异。这样服务器必须增加磁盘空间来保存文档的各种旧的实例，可能反而得不偿失。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/wtf3A2NQOVrXn8U.png"
                      alt="Ttoo45eBe0QpTIHZ__thumbnail.png"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>13-摘要认证</title>
    <url>/2021/01/23/note/HTTP/13-%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h2 id="13-1-摘要认证的改进"><a href="#13-1-摘要认证的改进" class="headerlink" title="13.1 摘要认证的改进"></a>13.1 摘要认证的改进</h2><p>摘要认证相比于基本认证协议进行了如下改进：</p>
<ol>
<li>不会以明文方式在网络上发送密码。</li>
<li>可以防止恶意用户捕获并重放认证的握手过程。</li>
<li>可以有选择地防止对报文内容的篡改。</li>
<li>防范其他几种常见的攻击方式。</li>
</ol>
<p>但摘要认证并不能满足安全HTTP事务的很多需求。对这些需求来说，使用<strong>传输层安全</strong>（Transport Layer Security，TLS）和<strong>安全HTTP</strong>（Secure HTTP，HTTPS）协议更为合适。</p>
<h2 id="13-2-用摘要保护密码"><a href="#13-2-用摘要保护密码" class="headerlink" title="13.2 用摘要保护密码"></a>13.2 用摘要保护密码</h2><p>客户端不发送密码，而是会发送一个“指纹”或密码的“摘要”，这是密码的不可逆扰码。客户端和服务器都知道这个密码，因此服务器验证所提供的摘要是否与密码相匹配。</p>
<h3 id="13-2-1-单向摘要"><a href="#13-2-1-单向摘要" class="headerlink" title="13.2.1 单向摘要"></a>13.2.1 单向摘要</h3><p>摘要是“对信息主体的浓缩”。摘要是一种单向函数，有时也称为加密的校验和、单向散列函数或指纹函数。主要用于将无限的输入值转换为有限的浓缩输出值。常见的摘要函数MD5，会将任意长度的字节序列转换为一个128位的摘要，输出的128位的摘要通常会被写成32个十六进制的字符，每个字符表示4位。</p>
<h3 id="13-2-2-用随机数防止重放攻击"><a href="#13-2-2-用随机数防止重放攻击" class="headerlink" title="13.2.2 用随机数防止重放攻击"></a>13.2.2 用随机数防止重放攻击</h3><p>仅仅隐藏密码并不能避免危险，因为即便不知道密码，也可以截获摘要，并一遍遍地重放给服务器。解决办法：服务器在www-Authenticate质询中传送给客户端一个称为<strong>随机数</strong>（nonce）的特殊令牌，这个数会经常发生变化。客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。</p>
<p>在密码中加入随机数就会使摘要随着随机数的每–次变化而变化。记录下的密码摘要只对特定的随机值有效，而没有密码的话，攻击者就无法计算出正确的摘要，这样就可以防止重放攻击的发生。</p>
<h3 id="13-2-3-摘要认证的握手机制"><a href="#13-2-3-摘要认证的握手机制" class="headerlink" title="13.2.3 摘要认证的握手机制"></a>13.2.3 摘要认证的握手机制</h3><p>HTTP摘要认证协议所用首部与基本认证类似。它在传统首部中添加了一个新的可选首部Authorization-Info。</p>
<p>![图片]<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/kS9wKW172HulOen.png"
                      alt="LKKAx2TPmRP22yYG__thumbnail.png"
                ></p>
<h2 id="13-3-摘要的计算"><a href="#13-3-摘要的计算" class="headerlink" title="13.3 摘要的计算"></a>13.3 摘要的计算</h2><p>摘要认证的核心是对公共信息、保密信息和有时限的随机值这个组合的单向摘要。摘要是根据以下三个组件计算出来的：</p>
<ol>
<li>由<strong>单向散列函数H（d）</strong>和<strong>摘要KD（s，d）</strong>组成的一对函数，其中s表示密码，d表示数据。</li>
<li><strong>A1的数据块</strong>。它是密码和受保护信息的产物，包含用户名、密码、保护域和随机数等内容，A1只涉及安全信息，与底层报文自身无关。</li>
<li><strong>数据块A2</strong>。它是与报文自身有关的信息，比如URL、请求方法和报文实体的主体部分。A2有助于防止方法、资源或报文被篡改。</li>
</ol>
<p>摘要认证支持对各种摘要算法的选择，有两种算法：<strong>MD5</strong>和<strong>MD5-sess</strong>（“sess”表示会话），默认算法为MD5。两种算法都是用函数H来计算数据的MD5，用摘要函数KD来计算以冒号连接的密码和非保密数据的MD5。H和KD处理两块数据A1和A2，A2与H、KD和A1一起用于摘要的计算。</p>
<h3 id="13-2-1-与安全性相关的数据（A1）"><a href="#13-2-1-与安全性相关的数据（A1）" class="headerlink" title="13.2.1 与安全性相关的数据（A1）"></a>13.2.1 与安全性相关的数据（A1）</h3><p>根据选择的算法定义了两种计算A1的方式:</p>
<ol>
<li>MD5为每条请求运行单向散列函数。A1是由冒号连接起来的用户名、域以及密码三元组。</li>
<li>MD5-sess只在第一次www-Authenticate握手时运行一次散列函数。对用户名、域和密码进行一次CPU密集型散列，并将其放在当前随机数和客户端随机数（cnonce）的前面。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/gLWk6sqniwXRo1x.png"
                      alt="wds6DoVwtCD0ntzK__thumbnail.png"
                ></p>
<h3 id="13-2-2-与报文有关的数据（A2）"><a href="#13-2-2-与报文有关的数据（A2）" class="headerlink" title="13.2.2 与报文有关的数据（A2）"></a>13.2.2 与报文有关的数据（A2）</h3><p>根据所选择的保护质量（qop），为A2定义了两种策略:</p>
<ol>
<li>第一种策略只包含HTTP请求方法和URL。当qop=”auth”时使用这种策略，也是默认情况。</li>
<li>第二种策略添加了报文实体的主体部分，以提供一定程度的报文完整性检测。qop=”auth-int”时使用。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/4iLBptYUodeIlJ7.png"
                      alt="wDzTpT57Nsji2JHp__thumbnail.png"
                ></p>
<p>request-method是HTTP的请求方法。uri-directive-value 是请求行中的请求URI。可能是个”*”、absoluteURL或者abs_path，但它必须与请求URI一致。如果请求URI是absoluteURL，它必须是个绝对URL。</p>
<h3 id="13-2-3-摘要算法总述"><a href="#13-2-3-摘要算法总述" class="headerlink" title="13.2.3 摘要算法总述"></a>13.2.3 摘要算法总述</h3><p>得到了两种给定了H、KD、A1和A2之后，计算摘要的方式：</p>
<ol>
<li>第一种没有qop选项的时候，它是用保密信息和随机报文数据的散列值来计算摘要的。</li>
<li>第二种是现在推荐使用的方式，包含了对随机数计算和对称认证的支持。只要qop为auth或auth-int，就要使用这种方式。它向摘要中添加了随机计数、qop 和cnonce数据。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/jYnmcVkHxNKuFZw.png"
                      alt="g0aHLWSGVCRuUveg__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/O1Bl5K6i7xDS2Hm.png"
                      alt="DRNNnrURitHX377G__thumbnail.png"
                ></p>
<h3 id="13-2-4-预授权"><a href="#13-2-4-预授权" class="headerlink" title="13.2.4 预授权"></a>13.2.4 预授权</h3><p>预授权对基本认证来说并不重要，因为一旦用户与某站点进行了认证，浏览器通常会为后继对那个URL的请求发送正确的Authorization首部。</p>
<p>对摘要认证来说，服务器会产生任意的随机数，所以在客户端收到质询之前，不一定能判定应该发送什么样的Authorization首部。</p>
<p>如如果客户端能在服务器要求它计算Authorization首部之前将其计算出来，就可以预先将Authorization首部发送给服务器，而不用再次进行请求/质询了。</p>
<p>三种可选的方式，通过这些方式，客户端无需等待新的WWW-Authenticate质询，就可以获得正确的随机数：</p>
<ol>
<li>服务器预先在Authentication-Info成功首部中发送下一个随机数。但破坏了对同一台服务器的多条请求进行管道化的功能，而管道化能避免延迟的，所以可能会造成很大的性能损失。</li>
<li>服务器允许在一小段时间内使用同一个随机数。随机数过期时，服务器要向客户端发送401 Unauthorized质询，并设置WWW Authenticate:stale=true指令：</li>
<li>客户端和服务器使用同步的、可预测的随机数生成算法。客户端和服务器可根据共享的密钥，生成第三方无法轻易预测的、相同的随机数序列（比如安全ID卡）。<h3 id="13-2-5-随机数的选择"><a href="#13-2-5-随机数的选择" class="headerlink" title="13.2.5 随机数的选择"></a>13.2.5 随机数的选择</h3></li>
</ol>
<p>随机数公式：BASE64（time-stamp H（time-stamp”：”ETag“：”private-key））</p>
<pre><code>1. **time-stamp**:服务器产生的时间或其他不会重复的值。可以通过这种方式来限制随机数的有效持续时间，
2. **ETag**：所请求实体有关的HTTP ETag首部的值。能防止对已更新资源版本的重放请求。
3. **private-key：**只有服务器知道的数据。</code></pre>
<h3 id="13-2-6-对称认证"><a href="#13-2-6-对称认证" class="headerlink" title="13.2.6 对称认证"></a>13.2.6 对称认证</h3><p>通过提供客户端随机值来实现客户端对服务器的认证，服务器会根据它对共享保密信息的正确了解生成正确的响应摘要。然后，服务器在Authorization-Info首部中将此摘要返回给客户端。只要提供了qop指令，就要求执行对称认证，而没有qop指令时则不要求执行对称认证。</p>
<p>响应摘要的计算方法与请求摘要类似，但由于响应中没有方法，而且报文实体数据有所不同，所以只有报文主体信息A2不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/aMbvEZ6RpLPWJ4k.png"
                      alt="FpD971kcIakNiitO__thumbnail.png"
                ></p>
<p>cnonce值和nc值必须是本报文所响应的客户端请求中的相应值。如果指定了qop=”auth”或qop=”auth-int”，就必须提供响应auth、cnonce 和nonce计数指令。</p>
<h2 id="13-4-增强保护质量"><a href="#13-4-增强保护质量" class="headerlink" title="13.4 增强保护质量"></a>13.4 增强保护质量</h2><p>在三种摘要首部中提供qop字段：WWW-Authenticate、Authorization 和Authentication-Info可以实现客户端和服务器对不同类型及质量的保护进行协商。</p>
<p>服务器首先在www-Authenticate首部输出由逗号分隔的qop选项列表。然后客户端从中选择一个它支持且满足其需求的选项，并将其放在Authorization的qop字段中回送给服务器。</p>
<p>两种保护质量的初始值：表示认证的auth，带有报文完整性保护的认证auth-int。</p>
<h3 id="13-4-1-报文完整性保护"><a href="#13-4-1-报文完整性保护" class="headerlink" title="13.4.1 报文完整性保护"></a>13.4.1 报文完整性保护</h3><p>如果使用了完整性保护（qop=”auth-int”），H（实体的主体部分）就是对实体主体部分，而不是报文主体部分的散列。对于发送者，要在应用任意传输编码方式之前计算；而对于接收者，则应在去除所有传输编码之后计算。对于任何含有多部分的内容类型来说，多部分的边界和每部分中嵌入的首部都要包含在内。</p>
<h2 id="13-5-摘要认证实际问题"><a href="#13-5-摘要认证实际问题" class="headerlink" title="13.5 摘要认证实际问题"></a>13.5 摘要认证实际问题</h2><h3 id="13-5-1-差错处理"><a href="#13-5-1-差错处理" class="headerlink" title="13.5.1 差错处理"></a>13.5.1 差错处理</h3><p>在摘要认证中，如果某个指令或其值使用不当，或者缺少某个必要指令，就应该使用响应400 Bad Request。</p>
<p>如果请求的摘要不匹配，应该记录登录失败。因为多次失败说明可能有攻击者在猜测密码。</p>
<p>认证服务器一定要确保URI指令指定的资源与请求行中指定的资源相同。如果不同，服务器就应该返回400 Bad Request错误，因为这可能是一种攻击的迹象，也用来应对中间代理可能对客户端请求进行的修改，修改的请求计算后得到的摘要可能会与客户端计算出的摘要有所不同。</p>
<h3 id="13-5-2-保护空间"><a href="#13-5-2-保护空间" class="headerlink" title="13.5.2 保护空间"></a>13.5.2 保护空间</h3><p>域值与被访问服务器的标准根URL结合在一起，定义了保护空间。域值是一个字符串，通常由原始服务器分配，可能会有认证方案特有的附加语义。</p>
<p>可能会有多个授权方案相同，而域不同的质询。保护空间确定了可以自动应用证书的区域。如果前面的某条请求已被授权，在一段时间内，该保护空间中所有其他请求都可以重用同一个证书，时间的长短由认证方案、参数和/或用户喜好来决定。除非认证方案进行了其他定义，否则单个保护空间是不能扩展到其服务器范围之外的。</p>
<p>对保护空间的具体计算取决于认证机制：</p>
<ol>
<li>在基本认证中，客户端会假定请求URI中或其下的所有路径都与当前的质询处于同一个保护空间内。客户端可以预先提交对此空间中资源的认证，无需等待来自服务器的另一条质询。</li>
<li>在摘要认证中，质询的WWW-Authenticate：domain字段对保护空间作了更精确的定义。通常domain列表中的所有URI和逻辑上处于这些前缀之下的所有URI，都位于同一个保护空间中。如果没有domain字段，或此字段为空，质询服务器上的所有URI就都在保护空间内。</li>
</ol>
<p>认证客户端应该记住用户名、密码、随机数、随机数计数以及一些与认证会话有关的隐晦值，以便将来在此保护空间中构建请求的Authorization首部时使用。</p>
<p>即便老的Authorization首部所包含的随机数不再新鲜了，服务器可以接受其中的信息，也可以返回一个带有新随机数的401响应，让客户端重试请求，这需要指定这个响应为stale=true，表示服务器在告知客户端用新的随机数来重试，而无须提示输人新的用户名和密码。</p>
<h3 id="13-5-3-重写URI"><a href="#13-5-3-重写URI" class="headerlink" title="13.5.3 重写URI"></a>13.5.3 重写URI</h3><p>代理可以通过改变URI语法，而不改变所描述的实际资源的方式来重写URI，比如：</p>
<ol>
<li>可以对主机名进行标准化，或用IP地址来取代；</li>
<li>可以用“%”转义形式来取代嵌入的字符；</li>
<li>如果某类型的一些附加属性不会影响从特定原始服务器上获取资源，就可以将其附加或插入到URI中。</li>
</ol>
<p>代理可修改URI，而且摘要认证会检查URI值的完整性，所以如果进行了修改，摘要认证就会被破坏。</p>
<h3 id="13-5-4-缓存"><a href="#13-5-4-缓存" class="headerlink" title="13.5.4 缓存"></a>13.5.4 缓存</h3><p>共享的缓存收到包含Authorization首部的请求和转接那条请求产生的响应时，不能将那条响应作为对任何其他请求的应答使用，除非响应中提供了下列两种Cache-Control指令之一：</p>
<ol>
<li>如果原始响应中包含有Cache-Control指令must-revalidate，缓存可以在应答后继请求时使用那条响应的实体部分。但它首先要用新请求的请求首部，与原始服务器再次进行验证，这样原始服务器就可以对新请求进行认证。</li>
<li>如果原始响应中包含有Cache-Control指令public，在对任意后继请求的应答中都可以返回响应的实体部分。<h2 id="13-6-安全性考虑"><a href="#13-6-安全性考虑" class="headerlink" title="13.6 安全性考虑"></a>13.6 安全性考虑</h2></li>
</ol>
<h3 id="13-6-1-首部篡改"><a href="#13-6-1-首部篡改" class="headerlink" title="13.6.1 首部篡改"></a>13.6.1 首部篡改</h3><p>为了提供一个简单明了的防首部篡改系统，要么就得进行端到端的加密，要么就得对首部进行数字签名一最好是两者的结合！摘要认证的重点在于提供一种防篡改认证机制，但并不一定要将这种保护扩展到数据上去。具有一定保护级别的首部只有www-Authenticate和Authorization.</p>
<h3 id="13-6-2-重放攻击"><a href="#13-6-2-重放攻击" class="headerlink" title="13.6.2 重放攻击"></a>13.6.2 重放攻击</h3><p>重放攻击指的就是有人将从某个事务中窃取的认证证书用于另一个事务。缓解方法：让服务器产生的随机数包含根据客户端IP地址、时间戳、资源Etag和私有服务器密钥算出的摘要。</p>
<p>但缺点在于随机数中包含客户端的IP地址，会破坏代理集群的工作。来自单个用户的多条请求通常会经过不同的代理进行传输，而且还可以通过IP地址欺骗实现。</p>
<p>另外一种方法：服务器为每个事务发布唯一的随机数和超时值，发布的随机数只对指定的事务有效，而且只在超时值的持续区间内有效。虽然增加服务器的负担，但可忽略不计。</p>
<h3 id="13-6-3-多重认证机制"><a href="#13-6-3-多重认证机制" class="headerlink" title="13.6.3 多重认证机制"></a>13.6.3 多重认证机制</h3><p>服务器支持多重认证机制时，通常会在WWW-Authenticate首部提供选项。同时需要让客户端总是去选择可用认证方案中功能最强的那个。如果无法实现，就只有使用只维护最强认证方案的代理服务器。但只有在已知所有客户端都支持所选认证方案的区域中才能采用这种方式。</p>
<h3 id="13-6-4-词典攻击"><a href="#13-6-4-词典攻击" class="headerlink" title="13.6.4 词典攻击"></a>13.6.4 词典攻击</h3><p>词典攻击是典型的密码猜测型攻击方式。恶意用户对某个事务进行窃听，并对<strong>随机数/响应对</strong>使用标准的密码猜测程序。如果没有密码过期策略，就容易搜集到足够多的密码，造成破坏。</p>
<h3 id="13-6-5-恶意代理攻击和中间人攻击"><a href="#13-6-5-恶意代理攻击和中间人攻击" class="headerlink" title="13.6.5 恶意代理攻击和中间人攻击"></a>13.6.5 恶意代理攻击和中间人攻击</h3><p>入侵受信代理的方式之一是使用其扩展接口，因为有时代理会提供复杂的编程接口，可以为这类代理编写一个扩展来拦截流量并对其进行修改。</p>
<p>攻击方式：</p>
<ol>
<li>采用窃听的形式；</li>
<li>删除提供的所有选项；</li>
<li>用最薄弱的认证策略来取代现有的认证机制。</li>
</ol>
<p>可行的解决方案：</p>
<ol>
<li>由客户端提供与认证功能有关的可见线索；</li>
<li>对客户端进行配置使其总是使用可用认证策略中功能最强的那一种；</li>
<li>最简单的方式使用SSL。<h3 id="13-6-6-选择明文攻击"><a href="#13-6-6-选择明文攻击" class="headerlink" title="13.6.6 选择明文攻击"></a>13.6.6 选择明文攻击</h3></li>
</ol>
<p>如果中间有被入侵的或恶意的代理甚至服务器在拦截流量，就可以为客户端的响应计算提供随机数。使用已知密钥来计算响应可以简化响应的密码分析过程。这种方式被称为<strong>选择明文攻击</strong>（chosen plaintext attack）。选择明文攻击有以下几种变体形式:</p>
<ol>
<li><strong>预先计算的词典攻击。</strong>词典攻击和选择明文攻击的组合。首先发起攻击的服务器会用预先确定的随机数和常见密码的变化形式产生一组响应，创建一个词典。一旦规模可观，攻击者从客户端得到一个响应时，会搜索生成的词典，寻找匹配项。如果有匹配项，攻击者就捕获了这个用户的密码。</li>
<li><strong>批量暴力型攻击。</strong>它没有匹配预先计算出来的摘要，而是用一组机器枚举了指定空间内所有可能的密码。</li>
</ol>
<p>防止这些攻击的方法：配置客户端使用可选的cnonce指令，这样响应就是基于客户端的判断产生的，而不是用服务器提供的随机数（因为随机数可能会被攻击者人侵）产生的。，再结合强制使用合理强密码的策略，以及密码过期策略，就可以完全消除选择明文攻击的威胁。</p>
<h3 id="13-6-7-存储密码"><a href="#13-6-7-存储密码" class="headerlink" title="13.6.7 存储密码"></a>13.6.7 存储密码</h3><p>摘要认证机制将对比用户的响应与服务器内部存储的内容，通常就是用户名和H（A1）元组对。如果摘要认证密码文件被入侵，攻击者马上就能够使用域中所有文件，不需要再进行解码。</p>
<p>消除这个问题的方法包括：</p>
<ol>
<li>就像密码文件中包含的是明文密码一样来保护它；</li>
<li>确保域名在所有域中是唯一的。如果密码文件被入侵，所造成的破坏也只局限于特定的域中。包含主机和domain的全路径域名就可以满足这个要求。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>The elements of HTML（一）</title>
    <url>/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"><strong>element</strong></th>
<th><strong>meaning</strong></th>
<th align="center"><strong>Categories</strong></th>
<th align="left"><strong>Contexts in which this element can be used</strong></th>
<th align="center"><strong>Content model</strong></th>
<th align="left"><strong>Tag omission in text/html</strong></th>
<th align="center"><strong>Content attributes</strong></th>
<th align="left"><strong>remark</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">html</td>
<td>文档的根</td>
<td align="center">none</td>
<td align="left">document、子片段</td>
<td align="center">head后面跟一个body</td>
<td align="left">第一个子元素不是注释，可以省略起始标签。html后没有紧跟注释，可以省略结束标签</td>
<td align="center">manifest （现已不建议使用）</td>
<td align="left">建议在htm添加lang属性</td>
</tr>
<tr>
<td align="center">head</td>
<td>metadata的集合（title、link、script、meta）</td>
<td align="center">none</td>
<td align="left">html内的第一个元素</td>
<td align="center">如果是 iframe srcdoc 文档，可以有没有或多个元数据，title和base最多各有一个,其他类型，至少有一个以上的元数据，且必须有且只有一个title，最多一个base</td>
<td align="left">head内为空可以省略起始标签，结束标签没有紧跟空格或者注释可以省略</td>
<td align="center">Global attributes</td>
<td align="left">大多数情况必须含title,除非html用作电子邮件格式</td>
</tr>
<tr>
<td align="center">titile</td>
<td>文档标题或名称</td>
<td align="center">Metadata content</td>
<td align="left">head内</td>
<td align="center">text文本</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">text属性的getter方法返回title元素的子文本内容，text属性的setter方法用该元素内的给定值替换所有字符串title。用户代理在其用户界面中引用文档时，应使用文档标题。在用户界面titile的directionality应该设置为文档title的directionality（directionality暂未理解）</td>
</tr>
<tr>
<td align="center">base</td>
<td>页面上的所有链接规定默认地址或默认目标</td>
<td align="center">Metadata content</td>
<td align="left">head内</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">href— 文档基本URL<br>target— 用于超链接导航和表单提交的默认浏览上下文</td>
<td align="left">target、href两个属性至少有一个。多个base的href,只有第一个有效果。href如果指定了content属性，则该属性必须包含一个有效的URL。base如果有href属性，必须在其他有定义获取url属性的元素之前（除了html元素，它的maifest不受影响）。target的frozen base URL这个概念不理解，那里一坨都没看懂</td>
</tr>
<tr>
<td align="center">link</td>
<td>文档链接到其他资源</td>
<td align="center">Metadata content</td>
<td align="left">head内、在noscript 元素作为head元素的子元素、allowed in the body:phrasing content元素</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">href— 超链接的地址<br>crossorigin —元素如何处理跨域请求<br>rel—包含超链接的文档和目标资源之间的关系<br>media —适用媒体<br>integrity—子资源完整性检查中使用的完整性元数据<br>hreflang —链接资源的语言<br>type —提示所引用资源的类型<br>referrerpolicy-  Referrer policy的取发起由元素<br>sizes—图标的大小（用于“ rel=“ icon”）<br>imagesrcset —在不同情况下使用的图像（例如，高分辨率显示器，小型显示器等）<br>imagesizes —不同页面布局的图像大小<br>as— 预加载请求的Potential destination（对于rel=“ preload”和rel=“ modulepreload”）<br>color—自定义网站图标时使用的颜色（对于rel=“ mask-icon”）<br>disabled —是否禁用链接<br>title —链接的标题；CSS样式表集名称。</td>
<td align="left">必须有rel或者itemprop属性，不能同时使用。如果link元素具有itemprop属性，或者仅包含关键字的rel属性 ，也就是body-ok.link元素可以创建外部资源链接（stylesheet）和超链接(next)，链接类型和数量取决于rel属性的关键字,每个链接对会被单独处理。link创建的超链接和rel属性作用于全文档，a和area相反。</td>
</tr>
<tr>
<td align="center">meta</td>
<td>提供有关页面的元信息</td>
<td align="center">Metadata content</td>
<td align="left">如果charset存在，或者元素的http-equiv属性处于Encoding声明状态：head内。<br>如果http-equiv存在但不处于Encoding声明状态：head内。<br>如果http-equiv存在，但不处于Encoding声明状态：在作为head元素的子元素的noscript元素中。<br>如果name存在： metadata content。<br>如果itemprop存在： metadata content。<br>如果itemprop属性存在： phrasing content。</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">name —元数据名称<br>http-equiv —编译指示指令<br>content —元素的值<br>charset— 字符编码声明</td>
<td align="left">每个文档meta的charset属性不得超过一个。name的值：application-name（提供页面代表的Web应用程序的名称）、author（作者）、description（描述页面）、generator（标识用于生成文档的软件包）、keywords（关键字，许多搜索引擎不考虑）、referrer（没懂）、theme-color（定义建议的颜色），以及其他自己定义的。http-equiv：content-language（设置编译设定的默认语言,鼓励使用lang）、content-type（字符编码声明）、default-style（设置默认 CSS样式表集的名称）、refresh（定义文档自动刷新的时间间隔）、set-cookie（此实用程序不符合要求，没有任何效果）、    x-ua-compatible（指定网页的兼容性模式设置）、content-security-policy（启用CSP内容安全策略）。</td>
</tr>
<tr>
<td align="center">style</td>
<td>将CSS样式表嵌入其文档中</td>
<td align="center">Metadata content</td>
<td align="left">metadata content、在作为head元素的子元素的noscript元素中</td>
<td align="center">Text that gives a conformant style sheet</td>
<td align="left">不可省略</td>
<td align="center">media —适用媒体<br>title属性–CSS样式表集名称</td>
<td align="left">如果media 省略该属性，则默认值为“ all”，这意味着默认情况下样式适用于所有媒体</td>
</tr>
<tr>
<td align="center">body</td>
<td>文档的内容</td>
<td align="center">Sectioning root</td>
<td align="left">html内的第二个元素</td>
<td align="center">Flow content</td>
<td align="left">如果元素为空，或第一个子元素不是空格或注释，除非第一个子元素是meta, link, script, style, 或者 template元素，起始标签可以省略。如果元素后面没有紧跟注释，可以省略结束标签。</td>
<td align="center">onafterprint<br>onbeforeprint<br>onbeforeunload<br>onhashchange<br>onlanguagechange<br>onmessage<br>onmessageerror<br>onoffline<br>ononline<br>onpagehide<br>onpageshow<br>onpopstate<br>onrejectionhandled<br>onstorage<br>onunhandledrejection<br>onunload</td>
<td align="left">文档只能有一个body元素。onerror事件将从目标冒泡到body、html、document、window，而body上的事件处理程序监视的是window而不是body。但是，使用addEventListener（）添加的事件侦听器将在事件冒泡通过body时运行，而不是在事件到达window对象时运行。</td>
</tr>
<tr>
<td align="center">article</td>
<td>规定独立的自包含内容，比如论坛帖子、报纸文章、博客条目、用户评论</td>
<td align="center">Flow content<br>Sectioning content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">与article元素关联的作者信息不适用于嵌套的article元素。</td>
</tr>
<tr>
<td align="center">scetion</td>
<td>文档或应用的通用部分，比如比如章节、页眉、页脚等</td>
<td align="center">Flow content<br>Sectioning content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">当需要syndicate元素内容时，使用article而不是section.使用section时可以一直使h1</td>
</tr>
<tr>
<td align="center">nav</td>
<td>定义导航链接的部分</td>
<td align="center">Flow content<br>Sectioning content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">用于服务条款、版权信息的链接一般放在底部的footer而不是nav</td>
</tr>
<tr>
<td align="center">aside</td>
<td>与页面主内容无关，比如侧边栏，广告、拉引号</td>
<td align="center">Flow content<br>Sectioning content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">aside仅将元素用于括号是不合适的</td>
</tr>
<tr>
<td align="center">h1、h2、h3……</td>
<td>定义标题</td>
<td align="center">Flow content<br>Sectioning content<br>Palpable content</td>
<td align="left">作为hgroup的子元素，flow content 、heading content</td>
<td align="center">flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">不要因为字体大小，来选择不同的h,一般css里改</td>
</tr>
<tr>
<td align="center">hgroup</td>
<td>标题部分，比如副标题、标语等</td>
<td align="center">Flow content<br>Heading conten<br>Palpable content</td>
<td align="left">flow content、heading content</td>
<td align="center">包含一个以上h1-h6，并可以选择性的与支持脚本的元素（script、template）一起使用</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">hgroup的rank是其包含的h标签里的最高的一个。hgroup对两个标题进行分组，即便都是同等级的h标签，也是不对等的</td>
</tr>
<tr>
<td align="center">header</td>
<td>定义文档的页眉（介绍信息、导航辅助）</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">没有footer和header子代的flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">header不会引入新的部分</td>
</tr>
<tr>
<td align="center">footer</td>
<td>义文档或节的页脚，通常包含文档的作者、版权信息、使用条款链接、联系信息等等</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">没有footer和header子代的flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">通常在底部，但不是绝对的。比如像联系信息等有可能在footer也可以在address</td>
</tr>
<tr>
<td align="center">address</td>
<td>定义文档或文章作者的联系信息</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">没有heading content 、sectioning content 、header, footer,  address 子代的Flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">address可以在articel内，也可以在body内(引用于整个文档)。address不能用于任何地址比如邮政地址（通常用P标签）,也不得用于除联系方式以外的信息，通常和其他信息包含在footer内。</td>
</tr>
<tr>
<td align="center">p</td>
<td>段落</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">Phrasing content</td>
<td align="left">结束标签省略：p后紧跟address, p, aside, div, 等，或父元素没有内容，且父元素不是 a, audio, del, ins, map, noscript, video或自定义元素</td>
<td align="center">Global attributes</td>
<td align="left">当有更适用的标签时，不应该使用p。p 元素会自动在其前后创建一些空白。列表元素特别是ol、ul不能作为p的子元素。设计由多个结构段落组成的逻辑段落时，用div来代替p。</td>
</tr>
<tr>
<td align="center">hr</td>
<td>水平线</td>
<td align="center">Flow content</td>
<td align="left">Flow content</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">Global attributes</td>
<td align="left">hr不影响文档的轮廓</td>
</tr>
<tr>
<td align="center">pre</td>
<td>预格式化的文本块</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">Phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">pre的结构是由印刷规定而不是元素来表示。常用于表示：电子邮件、代码块（与code、samp、kbd一起使用）、ASCII文字</td>
</tr>
<tr>
<td align="center">blockquote</td>
<td>引用块</td>
<td align="center">Flow content<br>Sectioning root<br>Palpable content</td>
<td align="left">flow content</td>
<td align="center">flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes<br>cite —链接引用和编辑信息资源</td>
<td align="left">blockquote中的内容是引用的其他资源， blockquote中的内容可以缩写，也可以按照文本语言的传统方式添加上下文。引用内容的属性必须放在blockquote外部。</td>
</tr>
<tr>
<td align="center">ol</td>
<td>有序列表</td>
<td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td>
<td align="left">flow content</td>
<td align="center">li和脚本支持元素</td>
<td align="left">不可省略</td>
<td align="center">reversed —降序<br>start— 列表的起始值<br>type —列表标记的类型</td>
<td align="left">type关键字：1（十进制数）、a（小写拉丁字母）、A（大写拉丁字母）、i（小写罗马数字）、I（大写罗马数字）</td>
</tr>
<tr>
<td align="center">ul</td>
<td>无序列表</td>
<td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td>
<td align="left">flow content</td>
<td align="center">li和脚本支持元素</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">menu</td>
<td>代表命令的工具栏</td>
<td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td>
<td align="left">flow content</td>
<td align="center">li和脚本支持元素</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">li</td>
<td>列表项</td>
<td align="center">none</td>
<td align="left">ol、ul、menu内</td>
<td align="center">Flow content</td>
<td align="left">如果li后紧跟另一个li元素或者其父元素没有内容，则结束标签可以省略</td>
<td align="center">value—只有在ol内情况下，代表列表项的顺序值，必须为整数</td>
<td align="left">不建议在li内放入h1元素</td>
</tr>
<tr>
<td align="center">dl</td>
<td>描述性列表</td>
<td align="center">Flow content、Palpable content</td>
<td align="left">flow content</td>
<td align="center">一个以上的dt后面跟着一个以上的dd，或者一个以上的div,可以和脚本支持的元素搭配使用</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">在单个dl元素中，每个名称不应该有多个dt元素。dl可以被包含在div内</td>
</tr>
<tr>
<td align="center">dt</td>
<td>列表中的项目（术语部分、名称）</td>
<td align="center">none</td>
<td align="left">在dl内的dd、dt之前，或者在div内的dd、dt之前</td>
<td align="center">Flow content(没有footer、header、 sectioning content、heading content后代)</td>
<td align="left">dt元素后面紧跟其他dd、dt，则结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left">可以使用dfn元素表示术语的定义</td>
</tr>
<tr>
<td align="center">dd</td>
<td>条目的定义部分</td>
<td align="center">none</td>
<td align="left">在dl内的dd、dt之后，或者在div内的dd、dt之后</td>
<td align="center">Flow content</td>
<td align="left">dd元素后面紧跟其他dd、dt，或父元素没有内容，则结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">figure</td>
<td>独立的流内容（图表，图片，代码）</td>
<td align="center">Flow content<br>Sectioning root<br>Palpable content</td>
<td align="left">Flow content</td>
<td align="center">Flow content 或Flow content后跟figcaption，或者figcaption前跟Flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">figure被删除后，不能对文档流产生影响</td>
</tr>
<tr>
<td align="center">figcaption</td>
<td>figure的标题</td>
<td align="center">none</td>
<td align="left">figure内的第一个或最后一个元素</td>
<td align="center">Flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">mian</td>
<td>文档的主要内容</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">Flow content，但只能有一个</td>
<td align="center">Flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">如果有多个main必须有hidden属性。main的父元素只能是html, body, div, form</td>
</tr>
<tr>
<td align="center">div</td>
<td>块级元素，无特殊含义</td>
<td align="center">Flow content<br>Palpable content</td>
<td align="left">Flow content，或作为dl的子元素</td>
<td align="center">如果是dl的子元素：一个以上的dt后跟一个以上dd，且可以与脚本支持元素使用。否则，Flow content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">当没有元素适合，建议使用div</td>
</tr>
<tr>
<td align="center">a</td>
<td>如果有href属性，代表资源的超链接。没有则表示为占位符。</td>
<td align="center">Flow content.<br>Phrasing content.<br>Interactive content:如果存在href属性.<br>Palpable content.</td>
<td align="left">phrasing content</td>
<td align="center">不能有交互式内容的子代，a元素子代，或者带有tabindex属性的子代</td>
<td align="left">不可省略</td>
<td align="center">href — 超链接的地址<br>target — 在何处打开链接文档<br>download — 被下载的超链接目标<br>ping — ping 的URL地址<br>rel —当前文档与被链接文档之间的关系<br>hreflang — 被链接资源的语言<br>type —提示被链接资源的的 MIME 类型<br>referrerpolicy— Referrer policy for fetches initiated by the element</td>
<td align="left">如果没有href属性，则a元素其他属性必须省略。如果有 itemprop 属性，则必须有href属性。</td>
</tr>
<tr>
<td align="center">em</td>
<td>强调重点的内容</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">强调的级别由em数量决定。</td>
</tr>
<tr>
<td align="center">strong</td>
<td>对内容极其强调</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">strong通常强调标题、段落、警告、危险标志、用户更需要长时间看见的内容等，比em强调程度更大。</td>
</tr>
<tr>
<td align="center">small</td>
<td>小号字体</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">常用于免责声明、警告、法律限制、版权信息、属性、许可要求等。使用small并不代表内容不重要，不重要只需不使用em、strong即可，small和strong、em也可嵌套使用。small不适用于大篇幅如段落、列表等。只用于小段文本，也不适用于副标题。</td>
</tr>
<tr>
<td align="center">s</td>
<td>无关或不准确的内容（文本添加删除线）</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">更推荐使用del元素。</td>
</tr>
<tr>
<td align="center">cite</td>
<td>引用或参考的内容，也可以是顺带提及的内容，通常是论文、文章、杂志等的标题</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">不能用于人名。</td>
</tr>
<tr>
<td align="center">q</td>
<td>引用了其他资源的phrasing content</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">cite — 引用的资源链接</td>
<td align="left">不需要添加标点符号，UA会渲染添加。引用的资源可以是虚构的，不适合引用单独一个单词。不能用q代替不表示引用的引用（讽刺语句，通常会加标点符号，但这并不是引用）</td>
</tr>
<tr>
<td align="center">dfn</td>
<td>定义术语</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content，不包含dfn的子代</td>
<td align="left">不可省略</td>
<td align="center">title— 显示完整的术语或缩写的扩展</td>
<td align="left">dfn的父元素需包含dfn内术语的定义，且其title属性不影响dfn。title只能是这个术语的定义，不能包含其他。</td>
</tr>
<tr>
<td align="center">abbr</td>
<td>简称或缩写</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">title— 显示完整的术语或缩写的扩展</td>
<td align="left">适用情况：开发者想要解释缩写的含义；用户不熟悉的术语；存在需要进行语义注释的缩写。有title的abbr与没有title的abbr不会影响。</td>
</tr>
<tr>
<td align="center">ruby</td>
<td>定义 ruby 注释（有注音或其他注释）</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">Phrasing content，不包含ruby或ruby子元素。单独的ruby,且自身不喊ruby。一个或多个rt。一个rb包含一个或多个rt</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">在没有ruby父元素的ruby中，内容被分为三段：基本文本片段；注释片段；可忽略片段（空格或rp）。其中tr对应注释片段，通常只有一个。</td>
</tr>
<tr>
<td align="center">rt</td>
<td>标记ruby注释的ruby文本组件</td>
<td align="center">none</td>
<td align="left">ruby的子元素</td>
<td align="center">Phrasing content</td>
<td align="left">rt后紧跟rt或tp，或其父元素没有内容，则结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left">当它是ruby元素的子元素时，它本身并不表示任何东西，但是ruby元素使用它来确定它所代表的内容。</td>
</tr>
<tr>
<td align="center">rp</td>
<td>在ruby注释的ruby文本组件周围提供括号或其他内容</td>
<td align="center">none</td>
<td align="left">ruby的子元素，紧跟在rt之前或之后</td>
<td align="center">Text</td>
<td align="left">tp后紧跟tr或rp，或其父元素没有内容，则结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left">由不支持ruby注释的UA显示。</td>
</tr>
<tr>
<td align="center">data</td>
<td>本身的内容及其value的值</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">value — 机器可读的值</td>
<td align="left">value属性必须存在，并且是以机器可读的格式来代表元素的内容。当内容与时间有关，使用time。适用于：当与微格式或微数据属性相结合时，元素用于提供用于数据处理的机器可读值和用于在Web浏览器中呈现的人可读值。在这种情况下，value的格式由所使用的微格式或微数据决定；当脚本有一个文本值要与人可读的值一起存储时，可以与页面中的脚本一起使用，value格式只取决于脚本的需要。</td>
</tr>
<tr>
<td align="center">time</td>
<td>时间相关的内容及其value的值</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">当有datatime属性：phrasing content ，否则为Text</td>
<td align="left">不可省略</td>
<td align="center">datetime — 机器可读的值</td>
<td align="left">time的datetime值是datetime内容属性的值，否则为time元素的子文本内容。没有datetime属性的time元素不能有子元素。</td>
</tr>
<tr>
<td align="center">code</td>
<td>计算机代码片段</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">可以添加一个值为“language-XX”的class属性来指示所使用的语言。</td>
</tr>
<tr>
<td align="center">var</td>
<td>变量</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">samp</td>
<td>样本；程序或计算机输出的引用</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">kbd</td>
<td>用户输入（通常是键盘文本）</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">当kbd嵌套在samp中，表示系统回显的输入；当包含samp，表示基于系统输出的输入，例如调用菜单项；当kbd嵌套在另一个kbd中，表示一个实际的键或其他适合输入机制的单个输入单元。code、var、samp、kbd这些常与pre一起使用。</td>
</tr>
<tr>
<td align="center">sub/sup</td>
<td>上标/下标</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">特殊的排版要求才使用。</td>
</tr>
<tr>
<td align="center">i</td>
<td>斜体文本效果</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">适用于i的情况，要考虑是否用em和dfn更合适。</td>
</tr>
<tr>
<td align="center">b</td>
<td>粗体</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">当没有其他元素适合时，才考虑用b。并非有重要的语义。</td>
</tr>
<tr>
<td align="center">u</td>
<td>下划线</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">注意避免导致用户错认为超链接。</td>
</tr>
<tr>
<td align="center">mark</td>
<td>突出显示文本</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">bdi</td>
<td>从周围的文本格式设置中隔离</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">dir –默认为auto,不会继承父元素的样式</td>
<td align="left">在发布用户生成的内容时，该标签很有用。</td>
</tr>
<tr>
<td align="center">bdo</td>
<td>可覆盖默认的文本方向</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">dir –定义文字的方向（ltr<br>、rtl）</td>
<td align="left">必须设置dir属性，不能设置为auto。</td>
</tr>
<tr>
<td align="center">sapn</td>
<td>行内元素</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">phrasing content</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">br</td>
<td>换行符</td>
<td align="center">Flow content<br>Phrasing content</td>
<td align="left">phrasing content</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">Global attributes</td>
<td align="left">当段落只有br元素，代表占位符空行</td>
</tr>
<tr>
<td align="center">wbr</td>
<td>换行符的时机</td>
<td align="center">Flow content<br>Phrasing content</td>
<td align="left">phrasing content</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">Global attributes</td>
<td align="left">如果文本过长，可能会导致换行，浏览器会按照wbr来换行，避免语义混乱。</td>
</tr>
<tr>
<td align="center">ins</td>
<td>文档新的添加</td>
<td align="center">Flow content<br>Phrasing content<br>Palpable content</td>
<td align="left">phrasing content</td>
<td align="center">Transparent</td>
<td align="left">不可省略</td>
<td align="center">cite —引用文档的URL（解释变动原因）。<br>datetime —变化的日期和时间</td>
<td align="left">ins 不应该跨越 implied paragraph边界</td>
</tr>
<tr>
<td align="center">del</td>
<td>文档的删除部分</td>
<td align="center">Flow content<br>Phrasing content</td>
<td align="left">phrasing content</td>
<td align="center">Transparent</td>
<td align="left">不可省略</td>
<td align="center">cite —引用文档的URL（解释变动原因）。<br>datetime —变化的日期和时间</td>
<td align="left">ins和del不能作为ul、ol的子元素。</td>
</tr>
<tr>
<td align="center">img</td>
<td>图片的展示</td>
<td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Form-associated element<br>Interactive content(有usemap属性)<br>Palpable content</td>
<td align="left">embedded content</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">alt —不能正常显示时的替代文本<br>src —资源的地址<br>srcset — 图片应用的场景<br>sizes —图片设置的尺寸<br>crossorigin — 如何处理跨域请求<br>usemap—定义为客户器端图像映射<br>ismap—定义为服务器端图像映射<br>width — 宽度<br>height — 高度<br>referrerpolicy— 设置引用策略<br>decoding —图像解码的首选方法<br>loading — 确定懒加载时使用</td>
<td align="left">建议懒加载的图片设置宽高属性，防止加载后页面布局改变。img元素不能当做页面的布局工具或展示透明的图片。设置了src和alt属性，但alt属性值为空字符串，图片是内容的装饰或补充，没有设置alt属性，代表图片是内容的关键部分，但没有可替换的文本内容。</td>
</tr>
<tr>
<td align="center">iframe</td>
<td>嵌套的浏览上下文</td>
<td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content<br>Palpable content</td>
<td align="left">embedded content</td>
<td align="center">无</td>
<td align="left">不可省略</td>
<td align="center">src — 资源地址<br>srcdoc —需要渲染的html文档<br>name — 名称<br>sandbox — 嵌套内容的安全规则<br>allow — iframe内容的功能策略<br>allowfullscreen—允许使用requestFullscreen()方法<br>allowpaymentrequest—允许使用PaymentRequest 界面处理支付请求<br>width — 宽度<br>height — 高度<br>referrerpolicy —引用策略</td>
<td align="left">1、srcdoc属性“”内的&amp;和‘“”符号必须转义的,否则会提前结束，沙盒内容中提到的原始&amp;必须双重转义，以便在最初解析srcdoc属性时保留&amp;，防止再一次解析沙盒内容时误解&amp;。<br>2、同时有src和srcdoc属性，则后者的优先级更高。<br>3、iframe可能会延迟load事件。<br>4、如果没有设置src和srcdoc,或设置了不能解析，浏览上下文会保持在原始的about:blank页面。<br>5、sandbox属性值： allow-forms（重启表单）, allow-modals（重启模态对话框）, allow-orientation-lock（重启屏幕方向锁）, allow-pointer-lock（重启pointer lock API）, allow-popups（重启弹出框）, allow-popups-to-escape-sandbox（重新创建无沙箱的auxiliary浏览器上下文）, allow-presentation（重启presentation API）, allow-same-origin（使得内容被视为来自真实来源，而不是强制其进入唯一的来源）, allow-scripts（重启脚本）, allow-top-navigation（允许内容导航到顶级浏览器上下文）, allow-top-navigation-by-user-activation（只有当浏览器上下文的 active window短暂的激活时）, and allow-downloads。 allow-top-navigation 和allow-top-navigation-by-user-activation不能通知指定，否则只有前者起作用。</td>
</tr>
<tr>
<td align="center">embed</td>
<td>额外的程序或交互内容</td>
<td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content<br>Palpable content</td>
<td align="left">embedded content</td>
<td align="center">无</td>
<td align="left">不可省略</td>
<td align="center">src — 资源地址<br>type —嵌套资源的类型<br>width — 宽度<br>height — 高度</td>
<td align="left">1、如果跳转到其他浏览器上下文，src属性不会改变<br>2、没有回退内容，子元素会被忽略。</td>
</tr>
<tr>
<td align="center">object</td>
<td>表示外部资源</td>
<td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content（如果有usemap属性）<br>Listed and submittable form-associated element.<br>Palpable content.</td>
<td align="left">embedded content</td>
<td align="center">没有或多个param元素</td>
<td align="left">不可省略</td>
<td align="center">data — 资源地址<br>type —嵌套资源的类型<br>name — 名称<br>usemap —规定与对象一同使用的客户端图像映射的 URL<br>form — 规定对象所属的一个表单<br>width — 宽度<br>height — 高度</td>
<td align="left">可以插入HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。</td>
</tr>
<tr>
<td align="center">param</td>
<td>作为脚本，嵌套在object的参数</td>
<td align="center">None</td>
<td align="left">在flow content前面的object子元素</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">name —参数名称<br>value — 参数的值</td>
<td align="left">两个属性都必须存在。</td>
</tr>
<tr>
<td align="center">video</td>
<td>播放视频、电影，或带字幕的音频文件</td>
<td align="center">Flow content.<br>Phrasing content.<br>Embedded content.<br>Interactive content(如果有controls属性 )<br>Palpable content.</td>
<td align="left">embedded content</td>
<td align="center">如果有src属性：没有或多个track,并且是透明的，没有媒体子元素。<br>没有src属性：没有或多个source，接着没有或多个track,并且是透明的，没有媒体子元素。</td>
<td align="left">不可省略</td>
<td align="center">src — 资源地址<br>crossorigin — 如何处理跨域请求<br>poster — 播放前显示的画面url<br>preload—页面加载时视频也加载<br>autoplay—页面加载好后自动播放<br>playsinline —内联形式播放<br>loop —循环播放<br>muted —默认静音<br>controls —展示控件<br>width —宽<br>height — 高</td>
<td align="left">1、可以在video内插入文本，当浏览器不支持时，用于提供一些帮助信息。<br>2、字幕、手语、音频描述可以直接嵌入到视频，其中字幕也可以用track外引文件，音频描述可以以文本通过WebVTT 文件，track会将文本合成语音，WebVTT也可以提供章节信息。<br>3、视频中的每一帧对应哪个播放位置由视频流的格式决定。</td>
</tr>
<tr>
<td align="center">audio</td>
<td>音频</td>
<td align="center">Flow content.<br>Phrasing content.<br>Embedded content.<br>Interactive content、Palpable content(如果有controls属性 )</td>
<td align="left">embedded content</td>
<td align="center">如果有src属性：没有或多个track,并且是透明的，没有媒体子元素。<br>没有src属性：没有或多个source，接着没有或多个track,并且是透明的，没有媒体子元素。</td>
<td align="left">不可省略</td>
<td align="center">src — 资源地址<br>crossorigin — 如何处理跨域请求<br>preload—页面加载时音频也加载<br>autoplay—页面加载好后自动播放<br>loop —循环播放<br>muted —默认静音<br>controls —展示控件</td>
<td align="left">当字幕和手语视频可以使用时，video可以代替audio.</td>
</tr>
<tr>
<td align="center">track</td>
<td></td>
<td align="center">none</td>
<td align="left">在flow content前面的媒体子元素</td>
<td align="center">无</td>
<td align="left">没有结束标签</td>
<td align="center">kind — 轨道的文本类型<br>src — 资源地址<br>srclang — 轨道语言<br>label — 标签<br>default — 默认的轨道</td>
<td align="left">1、kind关键字（可以省略，缺失默认 subtitles ，无效默认 metadata）<br>captions：播放器中显示的简短说明<br>chapters：定义章节，用于导航媒介资源<br>descriptions：定描述，用于通过音频描述媒介的内容<br>metadata：定义脚本使用的内容<br>subtitles：定义字幕，用于在视频中显示字幕<br>2、媒体元素的最多有一个这样的track（kind属性除metadata以外，并且指定了default）<br>3、track的readstatus：<br>0：未加载<br>1：正在加载<br>2：加载完成<br>3：加载失败</td>
</tr>
<tr>
<td align="center">table</td>
<td>表格</td>
<td align="center">Flow content.<br>Palpable content.</td>
<td align="left">flow content</td>
<td align="center">顺序如下：caption（可选）、colgroup(0个或多个)、thead 、tbody 或tr（0个或多个）、tfoot0个或多个）、脚本支持元素（可选）</td>
<td align="left">不可省略</td>
<td align="center">Global attributes</td>
<td align="left">1、table不能用于布局的工具<br>2、如果一个表格不以第一行和第一列作为标题，或着其他特殊情况，应该引入介绍该表格的解释性信息。</td>
</tr>
<tr>
<td align="center">caption</td>
<td>表格标题</td>
<td align="center">none</td>
<td align="left">table内的第一个元素</td>
<td align="center">没有子代table元素的Flow content</td>
<td align="left">如果caption后没有紧跟空格或注释，则结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left">1、当figure元素除了figurecaption以外，只有table元素，应该省略caption而使用figurecaption。<br>2、caption可以用来解释表格内容，使得其更容易理解</td>
</tr>
<tr>
<td align="center">colgroup</td>
<td>对表格中的列进行组合，以便对其进行格式化</td>
<td align="center">none</td>
<td align="left">table内，在caption后，在thead, tbody, tfoot或tr前.</td>
<td align="center">有span属性，nothing，否则，零个或多个col和template元素</td>
<td align="left">起始标签省略：colgroup内是一个元素col，或元素前面没有紧跟另一个已省略结束标签的colgroup，如元素为空，则不可省略<br>结束标签省略：colgroup后没有紧跟空格或注释</td>
<td align="center">Global attributes<br>span —列组应该横跨的列数</td>
<td align="left">1、colgroup内没有col,则应该在元素上设置span属性，值在1—1000之间。</td>
</tr>
<tr>
<td align="center">col</td>
<td>为表格中一个或多个列定义属性值</td>
<td align="center">none</td>
<td align="left">作为没有span属性的colgroup子元素</td>
<td align="center">nothing</td>
<td align="left">没有结束标签</td>
<td align="center">Global attributes<br>span —列组应该横跨的列数</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">tbody</td>
<td>表格主体</td>
<td align="center">none</td>
<td align="left">table的子元素，在caption、colgroup和thead之后，但前提是没有作为table子元素的tr。</td>
<td align="center">零个或多个tr以及支持脚本的元素</td>
<td align="left">起始标签省略：tbody内的第一个元素是tr，或没有紧在省略了结束标签的tbody、thead、tfoot之前，元素内为空时不能省略。<br>结束标签省略：tbody后紧跟tbody、tfoot，或父元素没有内容</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">thead</td>
<td>表格的表头</td>
<td align="center">none</td>
<td align="left">table的子元素，在caption、colgroup之后，在tbody、tfoot之前，但前提是没有其他head。</td>
<td align="center">零个或多个tr以及支持脚本的元素</td>
<td align="left">如果thead元素后紧跟tbody或tfoot元素，结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">tfoot</td>
<td>表格的页脚</td>
<td align="center">none</td>
<td align="left">table的子元素，在caption、colgroup和thead、tbody、tr之后，但前提是没有其他tfoot。</td>
<td align="center">零个或多个tr以及支持脚本的元素</td>
<td align="left">父元素没有内容，可以省略结束标签</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">tr</td>
<td>表格中的行</td>
<td align="center">none</td>
<td align="left">thead的子元素.<br>tbody的子元素.<br>tfoot 的子元素.<br>table的子元素，在caption, colgroup,thead之后，前提是没有作为table子元素的tbody</td>
<td align="center">零个或多个 td, th，或支持脚本的元素</td>
<td align="left">tr后紧跟另一个tr，或父元素没有内容，结束标签可以省略</td>
<td align="center">Global attributes</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">td</td>
<td>表格的标准单元格</td>
<td align="center">Sectioning root</td>
<td align="left">tr的子元素</td>
<td align="center">Flow content</td>
<td align="left">td后紧跟td或th，或父元素没有内容，结束标签可以省略</td>
<td align="center">colspan — 单元格可横跨的列数<br>rowspan — 单元格可横跨的行数<br>headers — 与单元格相关的表头</td>
<td align="left">用户代理，特别是在非可视环境中，或者在无法将表显示为2D网格的情况下，当呈现单元格的内容时，可能会提供单元格的用户上下文；例如，给出单元格在表模型中的位置，或列出单元格的标题单元格（由分配标题单元格的算法确定）。</td>
</tr>
<tr>
<td align="center">th</td>
<td>表头单元格</td>
<td align="center">none</td>
<td align="left">th的子元素</td>
<td align="center">Flow content,但没有header,footer,sectioning content,heading content后代</td>
<td align="left">th后紧跟td或th，或父元素没有内容，结束标签可以省略</td>
<td align="center">colspan — 单元格可横跨的列数<br>rowspan — 单元格可横跨的行数<br>headers — 与单元格相关的表头<br>scope — 表头数据与单元数据相关联的方法<br>abbr — 单元格中内容的缩写版本</td>
<td align="left">scope属性值字：<br>1、col   规定单元格是列的表头。<br>2、row    规定单元格是行的表头。<br>3、colgroup    规定单元格是列组的表头。<br>4、rowgroup    规定单元格是行组的表头。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML standard</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>The elements of HTML（二）</title>
    <url>/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>基于设备像素比。</strong>缩放级别和屏幕像素密度（上一点）都会影响单个CSS pixel 上的物理屏幕像素。适用当图片的于染大小固定的情况下，在 img 元素上用 src 和 srcset 属性， 使用 x 描述符来提供多个只有大小不同的图片（小图是大图的缩略版）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>基于视口的选择：</strong>作者可能要显示同一张图片，但渲染大小根据 viewport 宽度有所不同。 可以使用 srcset 和 sizes 属性，使用 w 描述符来提供多个只有大小不同的图片 （小图是大图的缩略版）。 用户代理将会根据指定的 w 描述符和 sizes 属性指定的渲染大小为每个图片计算等效像素密度。 然后它可以根据用户屏幕的像素密度、缩放级别和任何可能的其他因素（比如用户网络状态）选择任何一个资源。  通过使用 w 描述符和 sizes 属性， 不论用户设备有多大用户代理都可以选择下载正确的图片资源。 在新的用户代理中，当 srcset 属性使用 w 描述符时， src 属性会被忽略。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">sizes</span>=<span class="string">&quot;100vw&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w&quot;</span>   <span class="attr">src</span>=<span class="string">&quot;wolf-400.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The rad wolf&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>基于艺术选择：</strong>作者可能会根据图片的渲染大小显示不同的图片内容。可以用 picture 元素和 source 元素和 media 属性提供多张内容不同的图片 （例如小的图片是大图的裁剪版）。 用户代理会选择 media 属性中的媒体查询匹配的第一个 source 元素，然后从它的 srcset 属性中选择一个合适的 URL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 45em)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;large.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 32em)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;med.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;small.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The wolf runs through the snow.&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>基于图片格式的选择：</strong>作者可能希望显示同样的图片内容但根据用户代理的支持情况使用不同的图片格式。 可以使用 source 元素上的 type 属性来提供多种格式的图片。在这个例子中，用户代理会选择第一个 type 属性为支持的 MIME 类型的源。 如果用户代理支持 WebP 就会选择第一个 source 元素。 如果不支持 WebP，但支持 JPEG XR 就会选择第二个 source 元素。 如果这两种都不支持，就会选择 img 元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/100-marie-lloyd.webp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jxr&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/vnd.ms-photo&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a><strong>Decoding</strong></h2><table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">State</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sync</td>
<td align="left">Sync</td>
<td align="left">表示优先同步解码此图像，以便与其他内容进行原子表示。</td>
</tr>
<tr>
<td align="left">async</td>
<td align="left">Async</td>
<td align="left">指示优先选择异步解码此图像，以避免延迟其他内容的呈现。</td>
</tr>
<tr>
<td align="left">auto</td>
<td align="left">Auto</td>
<td align="left">表示默认值，用户代理可以自由选择任何解码行为。</td>
</tr>
</tbody></table>
<p>可以使用该decode()方法来控制解码行为。由于该decode()方法独立于负责将内容呈现到屏幕的过程执行解码，因此它不受decoding属性的影响</p>
<h2 id="alt使用"><a href="#alt使用" class="headerlink" title="alt使用"></a><strong>alt使用</strong></h2><p>除非另有说明，必须指定 alt 属性且它的值不能为空，且必须适合替代图片。 对 alt 属性具体的要求取决于它要表示什么图片.编写替代文本时要考虑的最一般规则如下：1、 alt 属性的文本替换每个图像不会改变页面的含义。2、 alt 属性的值不应该包含图片的 caption, title 或 legend 文本。3、 应该包含的替代文本是用于替代图片的，而不是图片的补充， 用 title 属性可以提供补充信息。5、 alt 属性的值不应该重复已经由后面的文字提供的信息。</p>
<p><strong>使用情况：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1、当创建 超链接 的 a 元素或 button 元素没有文本内容只包含一个或更多图片时，alt 属性必须包含一些文字来传达链接或按钮的用途。</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;green.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;green.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>2、具有替代图形表示形式的短语或段落：图表，图表，图形，地图，插图，文本必须在alt属性中给出，并且必须传达与src 属性中指定的图像相同的消息。重要的是要意识到替代文本是图像的替代品，而不是图像的描述。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;house.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The house is white, with a boarded front door.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3、一个文档可以包含图标信息，图标是为了帮助视觉浏览器的用户一目了然地识别功能。有些情况下，图标是文本标签的补充，它们传达同样的含义。 那些情况下，alt 属性必须存在且为空。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/help/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/icons/help.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span> Help<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外一些情况下，图标旁边没有文字来描述它的含义；这样的图标就应该解释自己的含义。 那些情况下，同等的文本标签必须通过alt 属性给出。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;movies.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4、图像仅由文本组成，并且图像的目的是不是突出显示用于渲染文本的实际印刷效果，而是传达文本本身。在这种情况下，alt必须存在属性，但属性必须包含与图像本身相同的文本。在这种情况下，替代文本就是图像所代表的字符。（ps:如果由于作者的默认系统字体不支持给定字符而使他们倾向于使用图像，那么考虑Web字体。）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;initials/o.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;O&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5、图像实际上只是补充，它的存在只会增强周围的文本。在这些情况下，alt必须存在该属性，但其值必须为空字符串。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>According to a study covering several billion pages,about 9% triggered the Standards mode.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;rendering-mode-pie-chart.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6、辅助图像。图像对内容并不重要，但它既不是纯粹的装饰，也不是文本的全部多余。在这些情况下，该alt属性必须存在，并且其值应为空字符串或图像传达的信息的文本表示形式。</p>
<p>7、纯装饰性图像，这样的图像是装饰性的，但仍构成内容的一部分。alt必须存在该属性，但其值必须为空字符串。</p>
<p>8、组成但个没有链接的大图的图片组，当一张图片被切分为若干个小图片文件，用来拼装成原来的大图时，这些图片中要有一个的 alt 属性按照相关规则设置为大图的替代文本。 然后其他所有剩余图片必须把 alt 属性设为空字符串。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;XYZ Corp&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo2.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>9、组成单个有链接的大图的图片组。通常带连接的图片应该使用 图片映射 而不是切分图片。但是，如果图片确实已经被切分了，而且切分后的部分是链接的唯一内容， 那么每个链接必须有一个图片必须把它的 alt 属性设置为表示链接用途的替代文本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?go=left&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-left.png&quot;</span>  <span class="attr">alt</span>=<span class="string">&quot;Left side. &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-middle.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?go=right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-right.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Right side.&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>10、内容的关键部分，图片是内容的关键部分。比如照片库页面中的图片，如何为内容关键的图片提供替代文本，取决于图片的出处。</p>
<p>通常情况：通过 alt 属性给出替代图片的文字。</p>
<p>难以提供完整描述的图片： alt 属性也必须包含一些适当的替代文本， 但可以比较简短。</p>
<p>未知内容的图片：alt 属性可以忽略，但必须符合以下条件之一：（1）img 元素在 包含 figcaption 的 figure 元素中， 且这个 figcaption 元素包含除元素间空白的内容，而且忽略 figcaption 元素及其后代节点后， figure 元素没有其他 流式内容 后代， 元素间空白 和 img 元素除外。（2）title 属性存在且值非空。</p>
<p>11、不是给用户看的图片，首先应该避免使用不用来显示的 img 元素。如果一个 img 元素不是用于显示的，比如用于计算页面浏览量的服务。 那么 alt 属性必须为空字符串。在这些场景下，width 和 height 属性必须设为 0。</p>
<p>12、给特定的、已知一定可以查看图片的人的 e-mail 或私人文档中的图片，可以省略alt 属性。但是，即使在这种情况下，也强烈建议作者包括替代文本，如上所示。</p>
<p>13、标记生成器指引</p>
<p>标记生成器应尽可能从用户那里获取替代文本。但是在许多情况下这是不可能的。</p>
<p>对于仅作为链接内容的图像，标记生成器应检查链接目标以确定目标标题或目标URL，并将以此方式获得的信息用作替代文本。</p>
<p>对于具有标题的图像，标记生成器应使用figure和 figcaption元素或title属性来提供图像的标题。</p>
<p>作为最后的选择，实现者应在图像为纯装饰性图像下（第7条），将alt 属性设置为空字符串，或假设图像是内容的关键部分（第10条未知内容的图片）完全省略alt属性。</p>
<p>标记生成器可以 在img元素上指定generator-unable-to-provide-required-alt 属性，这些元素他们无法为其获取替代文本，因此为其省略了该alt属性。</p>
<p>14、规范检查工具指引</p>
<p>规范检查工具必须把缺少 alt 属性报告为错误， 以下除外：上面第10条、12条、13条所举特殊情况。</p>
<h1 id="Media"><a href="#Media" class="headerlink" title="Media"></a><strong>Media</strong></h1><p>audio和video元素，都可用于音频和视频。主要区别只是audio元素没有视觉内容（例如视频或字幕）的播放区域，而video元素却有 。</p>
<h2 id="error-codes"><a href="#error-codes" class="headerlink" title="error codes"></a><strong>error codes</strong></h2><p>media.error  返回一个表示该元素当前错误状态的MediaError 对象。如无，返回null</p>
<p>media.error.code   返回当错错误状态的代码</p>
<p>media.error.message返回有关遇到的错误情况的特定信息诊断消息。消息和消息格式通常在不同的用户代理之间不一致。如果没有此类消息，则返回空字符串。</p>
<ul>
<li>1 = MEDIA_ERR_ABORTED - 取回过程被用户中止</li>
<li>2 = MEDIA_ERR_NETWORK - 当下载时某种网络发生错误</li>
<li>3 = MEDIA_ERR_DECODE - 当解码时发生错误</li>
<li>4 = MEDIA_ERR_SRC_NOT_SUPPORTED - 不支持音频/视频<h2 id="媒体资源位置"><a href="#媒体资源位置" class="headerlink" title="媒体资源位置"></a><strong>媒体资源位置</strong></h2></li>
</ul>
<p>media . srcObject [ = source ]    允许为media元素分配一个media provider对象。</p>
<p>media . currentSrc 返回当前媒体资源的URL。没有媒体资源或没有 URL时返回空字符串。</p>
<p>有三种方法可以指定媒体资源（优先级从大到小）：srcObjectIDL属性，src内容属性和source元素。</p>
<h2 id="MIME-types"><a href="#MIME-types" class="headerlink" title="MIME types"></a><strong>MIME types</strong></h2><p>只有不带参数的 application/octet-stream”MIME类型 “是特殊情况；如果出现任何参数，则将其与任何其他MIME type一样对待。</p>
<p>media . canPlayType(type)    检测浏览器是否能播放指定的音频/视频类型</p>
<p>返回值：</p>
<ol>
<li>“probably” - 浏览器最可能支持该音频/视频类型</li>
<li>“maybe” - 浏览器也许支持该音频/视频类型</li>
<li>“” - （空字符串）浏览器不支持该音频/视频类型</li>
</ol>
<p>source元素的type属性允许用户代理避免下载使用其无法呈现的格式的资源。</p>
<h2 id="Network-states"><a href="#Network-states" class="headerlink" title="Network states"></a><strong>Network states</strong></h2><p>media . networkState  从下面的代码列表中，返回该元素网络活动的当前状态。</p>
<ol>
<li>0 = NETWORK_EMPTY - 音频/视频尚未初始化</li>
<li>1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络</li>
<li>2 = NETWORK_LOADING - 浏览器正在下载数据</li>
<li>3 = NETWORK_NO_SOURCE - 未找到音频/视频来源<h2 id="Loading-the-media-resource"><a href="#Loading-the-media-resource" class="headerlink" title="Loading the media resource"></a><strong>Loading the media resource</strong></h2></li>
</ol>
<p>media . load()    重新加载音频/视频元素。</p>
<p>media . buffered  属性返回 TimeRanges 对象，表示用户的音视频缓冲范围。</p>
<p>TimeRanges 对象属性：</p>
<ol>
<li>length - 获得音视频中已缓冲范围的数量</li>
<li>start(index) - 获得某个已缓冲范围的开始位置</li>
<li>end(index) - 获得某个已缓冲范围的结束位置<h2 id="Offsets-into-the-media-resource"><a href="#Offsets-into-the-media-resource" class="headerlink" title="Offsets into the media resource"></a><strong>Offsets into the media resource</strong></h2></li>
</ol>
<p>media . duration  返回当前音频/视频的长度，以秒计。如果未设置音频/视频，则返回NaN，如果是无限流，返回 Infinity</p>
<p>media . currentTime [ = value ]    设置或返回音频/视频播放的当前位置</p>
<h2 id="Playing-the-media-resource"><a href="#Playing-the-media-resource" class="headerlink" title="Playing the media resource"></a><strong>Playing the media resource</strong></h2><p>media . paused   返回音频/视频是否已暂停。true 指示音频/视频已暂停。否则为 false。</p>
<p>media . ended  返回音频/视频是否已结束。如果播放已结束，则返回 true。否则返回 false。</p>
<p>media . defaultPlaybackRate [ = value ]  设置或返回音频/视频的默认播放速度。</p>
<p>media . playbackRate [ = value ]   属性设置或返回音频/视频的当前播放速度。</p>
<p>media . played   返回TimeRanges 对象。TimeRanges 对象表示用户已经播放或看到的音频/视频范围。</p>
<p>media . play() 开始播放当前的音频或视频。</p>
<p>media . pause()  暂停当前播放的音频/视频</p>
<h2 id="Seeking"><a href="#Seeking" class="headerlink" title="Seeking"></a><strong>Seeking</strong></h2><p>media . seeking  返回用户目前是否在音频/视频中寻址，如果用户正在寻址，则为 true。否则为 false。</p>
<p>media . seekable  返回TimeRanges对象。表示音频/视频中用户可寻址的范围。</p>
<ol>
<li>length - 获得音频/视频中可寻址范围的数量</li>
<li>start(<em>index</em>) - 获得可寻址范围的开始位置</li>
<li>end(<em>index</em>) - 获得可寻址范围的结束位置</li>
</ol>
<p>media . fastSeek( time )  寻求尽可能快地接近给定的时间，以精度换取速度。（要查找精确的时间，使用currentTime属性。）如果媒体资源尚未加载，则不执行任何操作。</p>
<h2 id="Media-resources-with-multiple-media-tracks"><a href="#Media-resources-with-multiple-media-tracks" class="headerlink" title="Media resources with multiple media tracks"></a><strong>Media resources with multiple media tracks</strong></h2><p>media . audioTracks返回一个表示该媒体资源可用的音频轨的AudioTrackList对象(包含有audioTrack对象)</p>
<p>media . videoTracks   返回一个表示该媒体资源可用的视频轨道的 videoTrackList对象。(包含有videoTrack对象)</p>
<p>media . audioTracks . length           media . videoTracks . length</p>
<p>返回可用音轨的数量</p>
<p>audioTrack=media.audioTracks[index]       videoTrack=media.videoTracks[index]</p>
<p>通过 index 来获得 AudioTrack或VideoTrack 对象</p>
<p>audioTrack=media.audioTracks.getTrackById(id)</p>
<p>videoTrack=media.videoTracks.getTrackById(id)</p>
<p>通过 id 来获得AudioTrack或VideoTrack 对象</p>
<p>audioTrack . id           videoTrack . id</p>
<p>获得音轨、视频轨道的 id</p>
<p>audioTrack . kind      videoTrack . kind</p>
<p>获得音轨、视频轨道的类型</p>
<p>audioTrack . label          videoTrack . label</p>
<p>获得音轨、视频轨道的标签</p>
<p>audioTrack . language          videoTrack . language</p>
<p>获得音轨、视频轨道的语言</p>
<p>audioTrack . enabled [ = value ]    获得或设置音轨是否是活动的 (true|false)</p>
<p>videoTrack . selected [ = value ]    获得或设置视频轨道是否是活动的 (true|false)</p>
<p>media . videoTracks . selectedIndex获得当前 VideoTrack 对象的下标，没有返回-1</p>
<h2 id="AudioTrack和VideoTrack的kind-关键字"><a href="#AudioTrack和VideoTrack的kind-关键字" class="headerlink" title="AudioTrack和VideoTrack的kind 关键字"></a>AudioTrack和VideoTrack的kind 关键字</h2><p>|类别|定义|适用于|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|“ alternative”|主音轨的一种替代，例如不同的歌曲（音频）或不同的角度（视频）。|音频和视频。|<br>|“ captions”|带有字幕的主视频轨道的版本。（对于旧内容，新内容将使用文本轨道。）|仅视频。|<br>|“ descriptions”|视频轨道的音频描述。|仅音频。|<br>|“ main”|主要音频或视频轨道。|音频和视频。|<br>|“ main-desc”|主要音轨，混合有音频说明。|仅音频。|<br>|“ sign”|音轨的手语解释。|仅视频。|<br>|“ subtitles”|带有字幕的主视频轨道版本。（对于旧内容，新内容将使用文本轨道。）|仅视频。|<br>|“ translation”|主音轨的翻译版本。|仅音频。|<br>|“ commentary”|有关主要音频或视频轨道的评论，例如导演的评论。|音频和视频。|<br>|“ ”|用户代理无法识别任何明确的种类或轨道的元数据给出的种类。|音频和视频。<br>|</p>
<h2 id="Text-track-API"><a href="#Text-track-API" class="headerlink" title="Text track API"></a><strong>Text track API</strong></h2><p>media . textTracks . length    获得音频/视频中可用的文本轨道的数量</p>
<p>media . textTracks[ n ]    返回TextTrack对象，表示媒体元素的文本轨道列表中的第n个文本轨道。</p>
<p>textTrack = media . textTracks . getTrackById( id )     返回给定id的TextTrack对象，如果没有，则返回null。</p>
<p>textTrack = media . addTextTrack( kind [, label [, language ] ] )</p>
<p>创建和返回新的文本轨道。新的TextTrack对象会被添加到视频/音频元素的文本轨道列表中。</p>
<p>textTrack . kind    返回文本轨道的类型。</p>
<p>textTrack . label   返回文本轨道的标签。</p>
<p>textTrack . language    返回文本轨道的语言。</p>
<p>textTrack . id    返回文本轨道的id</p>
<p>textTrack.inBandMetadataTrackDispatchType     返回文本轨道 in-band metadata track dispatch type字符串。</p>
<p>textTrack.mode [=value]</p>
<p>获得或设置该轨道是否是活动的(“disabled”|”hidden”|”showing”)</p>
<p>textTrack . cues        获得 TextTrackCueList 对象的 cues 列表</p>
<p>textTrack . activeCues       获得 TextTrackCueList 对象形式的当前活动文本轨道 cues</p>
<p>textTrack . addCue( cue )          向 cues 列表添加一个 cue</p>
<p>textTrack . removeCue( cue )      向 cues 列表删除一个 cue</p>
<p>cuelist . length    返回cuse列表的cue数量</p>
<p>cuelist[index]        返回给定index的cue</p>
<p>cuelist . getCueById( id )   返回给定id的cue</p>
<p>cue . track    返回属于文本轨道cue的TextTract</p>
<p>cue . id [ = value ]   返回或设置cue的id</p>
<p>cue . startTime [ = value ]   返回或设置cue的开始时间的id</p>
<p>cue . endTime [ = value ]    返回或设置cue的结束时间的id</p>
<p>cue . pauseOnExit [ = value ]   是否设置暂停或退出标志，是则返回true,否则为false</p>
<h2 id="User-interface"><a href="#User-interface" class="headerlink" title="User interface"></a><strong>User interface</strong></h2><p>media . volume [ = value ]</p>
<p>设置或返回音频/视频的当前音量,必须是介于 0.0 与 1.0 之间的数字。0是静音，1最大</p>
<p>media . muted [ = value ]</p>
<p>设置或返回音频/视频是否应该被静音（true）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML standard</category>
      </categories>
      <tags>
        <tag>WHATWG</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>07-迭代器与生成器</title>
    <url>/2021/03/28/note/JavaScript/07-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="7-1-理解迭代"><a href="#7-1-理解迭代" class="headerlink" title="7.1　理解迭代"></a>7.1　理解迭代</h2><p>在JavaScript中，计数循环就是一种最简单的迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。<br>迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是JavaScript中有序集合的最典型例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; collection.length; ++index) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(collection[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。但由于如下原因，通过这种循环来执行例程并不理想。</p>
<ul>
<li><strong>迭代之前需要事先知道如何使用数据结构</strong>。数组中的每一项都只能先通过引用取得数组对象，然后再通过<code>[]</code>操作符取得特定索引位置上的项。这种情况不适用于所有数据结构。</li>
<li><strong>遍历顺序并不是数据结构固有的</strong>。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。</li>
</ul>
<p><code>Array.prototype.forEach()</code>方法，向通用迭代需求迈进了一步（但仍然不够理想）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line">collection.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
<p>这个方法解决了单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止。因此这个方法只适用于数组，而且回调结构也比较笨拙。<br>在ECMAScript较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。解决方案就是<strong>迭代器模式，</strong>而且开发者无须事先知道如何迭代就能实现迭代操作。</p>
<h2 id="7-2-迭代器模式"><a href="#7-2-迭代器模式" class="headerlink" title="7.2　迭代器模式"></a>7.2　迭代器模式</h2><p><strong>迭代器模式</strong>描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的<code>Iterable</code>接口，而且可以通过迭代器<code>Iterator</code>消费。</p>
<p>可迭代对象是一种抽象的说法。可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的元素是有限的，递增索引可以按序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 集合的元素是有限的，可以按插入顺序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">3</span>).add(<span class="number">1</span>).add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>但可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如本章开头提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。</p>
<blockquote>
<p><strong>注意</strong>临时性可迭代对象可以实现为生成器，本章后面会讨论。</p>
</blockquote>
<p>任何实现<code>Iterable</code>接口的数据结构都可以被实现<code>Iterator</code>接口的结构“消费”（consume）。<strong>迭代器</strong>（iterator）是按需创建的一次性对象。每个迭代器都会关联一个<strong>可迭代对象</strong>，而迭代器会暴露出迭代其关联可迭代对象的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。</p>
<h3 id="7-2-1-可迭代协议"><a href="#7-2-1-可迭代协议" class="headerlink" title="7.2.1　可迭代协议"></a>7.2.1　可迭代协议</h3><p>实现<code>Iterable</code>接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现<code>Iterator</code>接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的<code>Symbol.iterator</code>作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p>
<p>很多内置类型都实现了<code>Iterable</code>接口：</p>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li><code>arguments</code>对象</li>
<li><code>NodeList</code>等DOM集合类型</li>
</ul>
<p>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 这两种类型没有实现迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(num[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).set(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>).set(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;a&#x27;</span>).add(<span class="string">&#x27;b&#x27;</span>).add(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> els = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 这些类型都实现了迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(els[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// 调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// MapIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// SetIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(els[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：</p>
<ul>
<li><code>for-of</code>循环</li>
<li>数组解构</li>
<li>扩展操作符</li>
<li><code>Array.from()</code></li>
<li>创建集合</li>
<li>创建映射</li>
<li><code>Promise.all()</code>接收由期约组成的可迭代对象</li>
<li><code>Promise.race()</code>接收由期约组成的可迭代对象</li>
<li><code>yield*</code>操作符，在生成器中使用</li>
</ul>
<p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="comment">// for-of循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// foo, bar, baz</span></span><br><span class="line"><span class="comment">// 扩展操作符</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.from(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="comment">// Set构造函数</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set(3) &#123;&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;&#125;</span></span><br><span class="line"><span class="comment">// Map构造函数</span></span><br><span class="line"><span class="keyword">let</span> pairs = arr.map(<span class="function">(<span class="params">x, i</span>) =&gt;</span> [x, i]);</span><br><span class="line"><span class="built_in">console</span>.log(pairs); <span class="comment">// [[&#x27;foo&#x27;, 0], [&#x27;bar&#x27;, 1], [&#x27;baz&#x27;, 2]]</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(pairs);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(3) &#123; &#x27;foo&#x27;=&gt;0, &#x27;bar&#x27;=&gt;1, &#x27;baz&#x27;=&gt;2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果对象原型链上的父类实现了<code>Iterable</code>接口，那这个对象也就实现了这个接口：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fooArr = <span class="keyword">new</span> FooArray(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> fooArr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-2-迭代器协议"><a href="#7-2-2-迭代器协议" class="headerlink" title="7.2.2　迭代器协议"></a>7.2.2　迭代器协议</h3><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API使用<code>next()</code>方法在可迭代对象中遍历数据。每次成功调用<code>next()</code>，都会返回一个<code>IteratorResult</code>对象，其中包含迭代器返回的下一个值。若不调用<code>next()</code>，则无法知道迭代器的当前位置。</p>
<p><code>next()</code>方法返回的迭代器对象<code>IteratorResult</code>包含两个属性：<code>done</code>和<code>value</code>。<code>done</code>是一个布尔值，表示是否还可以再次调用<code>next()</code>取得下一个值；<code>value</code>包含可迭代对象的下一个值（<code>done</code>为<code>false</code>），或者<code>undefined</code>（<code>done</code>为<code>true</code>）。<code>done: true</code>状态称为“耗尽”。只要迭代器到达<code>done: true</code>状态，后续调用<code>next()</code>就一直返回同样的值了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>
<p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> iter2 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter2.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter2.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter1.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;baz&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p>
</blockquote>
<p>“迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型。下面的例子比较了一个显式的迭代器实现和一个原生的迭代器实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用默认的迭代器工厂函数会返回</span></span><br><span class="line"><span class="comment">// 一个实现迭代器接口（Iterator）的迭代器对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">// 打印出实现了迭代器接口的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// &#123; next: f() &#123;&#125; &#125;</span></span><br><span class="line"><span class="comment">// Array类型实现了可迭代接口（Iterable）</span></span><br><span class="line"><span class="comment">// 调用Array类型的默认迭代器工厂函数</span></span><br><span class="line"><span class="comment">// 会创建一个ArrayIterator的实例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 打印出ArrayIterator的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// Array Iterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-自定义迭代器"><a href="#7-2-3-自定义迭代器" class="headerlink" title="7.2.3　自定义迭代器"></a>7.2.3　自定义迭代器</h3><p>与<code>Iterable</code>接口类似，任何实现<code>Iterator</code>接口的对象都可以作为迭代器使用。下面这个例子中的<code>Counter</code>类只能被迭代一定的次数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Counter的实例应该迭代limit次</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt;= <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.count++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这个类实现了<code>Iterator</code>接口，但不理想。因为它的每个实例只能被迭代一次：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// (nothing logged)</span></span><br></pre></td></tr></table></figure>
<p>为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">        limit = <span class="built_in">this</span>.limit;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>每个以这种方式创建的迭代器也实现了<code>Iterable</code>接口。<code>Symbol.iterator</code>属性引用的工厂函数会返回相同的迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1[<span class="built_in">Symbol</span>.iterator]); <span class="comment">//f values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="keyword">let</span> iter2 = iter1[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1 === iter2);         <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为每个迭代器也实现了<code>Iterable</code>接口，所以它们也可以用在任何期待可迭代对象的地方，比如<code>for-of</code>循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr ) &#123; <span class="built_in">console</span>.log(item); &#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iter ) &#123; <span class="built_in">console</span>.log(item); &#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-4-提前终止迭代器"><a href="#7-2-4-提前终止迭代器" class="headerlink" title="7.2.4　提前终止迭代器"></a>7.2.4　提前终止迭代器</h3><p>可选的<code>return()</code>方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：</p>
<ul>
<li><code>for-of</code>循环通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>throw</code>提前退出；</li>
<li>解构操作并未消费所有值。</li>
</ul>
<p><code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象。简单情况下，可以只返回<code>&#123; done: true &#125;</code>。因为这个返回值只会用在生成器的上下文中，所以本章后面再讨论这种情况。</p>
<p>如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用<code>return()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="built_in">this</span>.limit;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">return</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Exiting early&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;err&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3;</span><br><span class="line"><span class="comment">// Exiting early</span></span><br></pre></td></tr></table></figure>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>因为<code>return()</code>方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的<code>return</code>属性是不是函数对象。但即便给一个不可关闭的迭代器增加这个方法<strong>也不能</strong>让它变成可关闭的。这是因为调用<code>return()</code>不会强制迭代器进入关闭状态。当然，<code>return()</code>方法还是会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iter.return = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Exiting early&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 提前退出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-生成器"><a href="#7-3-生成器" class="headerlink" title="7.3　生成器"></a>7.3　生成器</h2><p>生成器是ECMAScript 6新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。比如，使用生成器可以自定义迭代器和实现协程。</p>
<h3 id="7-3-1-生成器基础"><a href="#7-3-1-生成器基础" class="headerlink" title="7.3.1　生成器基础"></a>7.3.1　生成器基础</h3><p>生成器的形式是一个函数，函数名称前面加一个星号（<code>*</code>）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。并且星号不受两侧空格的影响：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>箭头函数不能用来定义生成器函数。</p>
</blockquote>
<p>调用生成器函数会产生一个<strong>生成器对象</strong>。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了<code>Iterator</code>接口，因此具有<code>next()</code>方法。调用这个方法会让生成器开始或恢复执行。返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code>属性。函数体为空的生成器函数中间不会停留，调用一次<code>next()</code>就会让生成器到达<code>done: true</code>状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject);        <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>value</code>属性是生成器函数的返回值，默认值为<code>undefined</code>，可以通过生成器函数的返回值指定：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject);         <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());  <span class="comment">// &#123; done: true, value: &#x27;foo&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>生成器函数只会在初次调用<code>next()</code>方法后开始执行，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line">generatorObject.next();  <span class="comment">// foobar</span></span><br></pre></td></tr></table></figure>
<p>生成器对象实现了<code>Iterable</code>接口，它们默认的迭代器是自引用的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(generatorFn);</span><br><span class="line"><span class="comment">// f* generatorFn() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorFn()[<span class="built_in">Symbol</span>.iterator]);</span><br><span class="line"><span class="comment">// f [Symbol.iterator]() &#123;native code&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorFn());</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorFn()[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g === g[<span class="built_in">Symbol</span>.iterator]());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-2-通过yield中断执行"><a href="#7-3-2-通过yield中断执行" class="headerlink" title="7.3.2　通过yield中断执行"></a>7.3.2　通过<code>yield</code>中断执行</h3><p><code>yield</code>关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到<code>yield</code>关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());  <span class="comment">// &#123; done: false, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());  <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>
<p>此时的<code>yield</code>关键字有点像函数的中间返回语句，它生成的值会出现在<code>next()</code>方法返回的对象里。通过<code>yield</code>关键字退出的生成器函数会处在<code>done: false</code>状态；通过<code>return</code>关键字退出的生成器函数会处于<code>done: true</code>状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());<span class="comment">//&#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());<span class="comment">//&#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());<span class="comment">//&#123; done: true, value: &#x27;baz&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用<code>next()</code>不会影响其他生成器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject1 = generatorFn();</span><br><span class="line"><span class="keyword">let</span> generatorObject2 = generatorFn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject1.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject2.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject2.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject1.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>yield</code>关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的<code>return</code>关键字，<code>yield</code>关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">validGeneratorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-2-1-生成器对象作为可迭代对象"><a href="#7-3-2-1-生成器对象作为可迭代对象" class="headerlink" title="7.3.2.1   生成器对象作为可迭代对象"></a><strong>7.3.2.1   生成器对象作为可迭代对象</strong></h4><p>在生成器对象上显式调用<code>next()</code>方法的用处并不大。更方便使用的是把生成器对象当成可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>传给生成器的函数可以控制迭代循环的次数。在<code>n</code>为0时，<code>while</code>条件为假，循环退出，生成器函数返回。</p>
<h4 id="7-3-2-2-使用yield实现输入和输出"><a href="#7-3-2-2-使用yield实现输入和输出" class="headerlink" title="7.3.2.2   使用yield实现输入和输出"></a><strong>7.3.2.2   使用</strong><code>yield</code>实现输入和输出</h4><p><code>yield</code>关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的<code>yield</code>关键字会接收到传给<code>next()</code>方法的第一个值。同时第一次调用<code>next()</code>传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(initial);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">generatorObject.next(<span class="string">&#x27;bar&#x27;</span>);  <span class="comment">// foo</span></span><br><span class="line">generatorObject.next(<span class="string">&#x27;baz&#x27;</span>);  <span class="comment">// baz</span></span><br><span class="line">generatorObject.next(<span class="string">&#x27;qux&#x27;</span>);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<p><code>yield</code>关键字可以同时用于输入和输出，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());       <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next(<span class="string">&#x27;bar&#x27;</span>));  <span class="comment">// &#123; done: true, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>yield</code>关键字并非只能使用一次。比如，以下代码就定义了一个无穷计数生成器函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;;++i) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value);  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value);  <span class="comment">// 3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>假设要定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>使用<code>while</code>循环也可以实现，而且代码稍微简洁一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这样使用生成器也可以实现范围和填充数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(end &gt; start) &#123;</span><br><span class="line">    <span class="keyword">yield</span> start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> range(<span class="number">4</span>, <span class="number">7</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">zeroes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(zeroes(<span class="number">8</span>))); <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h4 id="7-3-2-3-产生可迭代对象"><a href="#7-3-2-3-产生可迭代对象" class="headerlink" title="7.3.2.3   产生可迭代对象"></a><strong>7.3.2.3   产生可迭代对象</strong></h4><p>可以使用星号增强<code>yield</code>的行为，让它能够迭代一个可迭代对象，从而一次产出一个值，与生成器函数的星号类似，<code>yield</code>星号两侧的空格不影响其行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价的generatorFn：</span></span><br><span class="line"><span class="comment">// function* generatorFn() &#123;</span></span><br><span class="line"><span class="comment">//   for (const x of [1, 2, 3]) &#123;</span></span><br><span class="line"><span class="comment">//     yield x;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>yield*</code>是一个表达式，而不是语句，它本身的值是关联迭代器返回<code>done: true</code>时的<code>value</code>属性。对于普通迭代器来说，这个值是<code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value:&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value: 1</span></span><br><span class="line"><span class="comment">// value: 2</span></span><br><span class="line"><span class="comment">// value: 3</span></span><br><span class="line"><span class="comment">// iter value: undefined</span></span><br></pre></td></tr></table></figure>
<p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">innerGeneratorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outerGeneratorFn</span>(<span class="params">genObj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* innerGeneratorFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> outerGeneratorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value:&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value: foo</span></span><br><span class="line"><span class="comment">// iter value: bar</span></span><br></pre></td></tr></table></figure>
<h4 id="7-3-2-4-使用yield-实现递归算法"><a href="#7-3-2-4-使用yield-实现递归算法" class="headerlink" title="7.3.2.4   使用yield*实现递归算法*"></a><strong>7.3.2.4   使用</strong><code>yield*</code>实现递归算法*</h4><p><code>yield*</code>最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* nTimes(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。<br>使用递归生成器结构和<code>yield*</code>可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.neighbors = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connect</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.neighbors.add(node);</span><br><span class="line">      node.neighbors.add(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomGraph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nodes = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="built_in">this</span>.nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机连接节点</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">1</span> / size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="built_in">this</span>.nodes) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> y <span class="keyword">of</span> <span class="built_in">this</span>.nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; threshold) &#123;</span><br><span class="line">          x.connect(y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个方法仅用于调试</span></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="built_in">this</span>.nodes) &#123;</span><br><span class="line">      <span class="keyword">const</span> ids = [...node.neighbors]</span><br><span class="line">                      .map(<span class="function">(<span class="params">n</span>) =&gt;</span> n.id)</span><br><span class="line">                      .join(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;node.id&#125;</span>: <span class="subst">$&#123;ids&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> RandomGraph(<span class="number">6</span>);</span><br><span class="line">g.print();</span><br><span class="line"><span class="comment">// 示例输出：</span></span><br><span class="line"><span class="comment">// 0: 2,3,5</span></span><br><span class="line"><span class="comment">// 1: 2,3,4,5</span></span><br><span class="line"><span class="comment">// 2: 1,3</span></span><br><span class="line"><span class="comment">// 3: 0,1,2,4</span></span><br><span class="line"><span class="comment">// 4: 2,3</span></span><br><span class="line"><span class="comment">// 5: 0,4</span></span><br></pre></td></tr></table></figure>
<p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connect</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomGraph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isConnected</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visitedNodes = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">traverse</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visitedNodes.has(node)) &#123;</span><br><span class="line">          <span class="keyword">yield</span> node;</span><br><span class="line">          <span class="keyword">yield</span>* traverse(node.neighbors);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得集合中的第一个节点</span></span><br><span class="line">    <span class="keyword">const</span> firstNode = <span class="built_in">this</span>.nodes[<span class="built_in">Symbol</span>.iterator]().next().value;</span><br><span class="line">    <span class="comment">// 使用递归生成器迭代每个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> traverse([firstNode])) &#123;</span><br><span class="line">      visitedNodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitedNodes.size === <span class="built_in">this</span>.nodes.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-生成器作为默认迭代器"><a href="#7-3-3-生成器作为默认迭代器" class="headerlink" title="7.3.3　生成器作为默认迭代器"></a>7.3.3　生成器作为默认迭代器</h3><p>因为生成器对象实现了<code>Iterable</code>接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面例子中，这个类的默认迭代器可以用一行代码产出类的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="built_in">this</span>.values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> f) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>for-of</code>循环调用了默认迭代器（且它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。</p>
<h3 id="7-3-4-提前终止生成器"><a href="#7-3-4-提前终止生成器" class="headerlink" title="7.3.4　提前终止生成器"></a>7.3.4　提前终止生成器</h3><p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现<code>Iterator</code>接口的对象一定有<code>next()</code>方法，还有一个可选的<code>return()</code>方法用于提前终止迭代器。除此之外，生成器对象还有第三个方法：<code>throw()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g);         <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next);    <span class="comment">// f next() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return);  <span class="comment">// f return() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.throw);   <span class="comment">// f throw() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>return()</code>和<code>throw()</code>方法都可以用于强制生成器进入关闭状态。</p>
<h4 id="7-3-4-1return"><a href="#7-3-4-1return" class="headerlink" title="7.3.4.1return()"></a>7.3.4.1<code>return()</code></h4><p><code>return()</code>方法会强制生成器进入关闭状态。提供给<code>return()</code>方法的值，就是终止迭代器对象的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g);            <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>));  <span class="comment">// &#123; done: true, value: 4 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g);            <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>与迭代器不同，所有生成器对象都有<code>return()</code>方法，只要通过它进入关闭状态，就无法恢复了。后续调用<code>next()</code>会显示<code>done: true</code>状态，而提供的任何返回值都不会被存储或传播：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());     <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>));  <span class="comment">// &#123; done: true, value: 4 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());     <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());     <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>for-of</code>循环等内置语言结构会忽略状态为<code>done: true</code>的<code>IteratorObject</code>内部返回的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> g) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    g.return(<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="7-3-4-2throw"><a href="#7-3-4-2throw" class="headerlink" title="7.3.4.2throw()"></a>7.3.4.2<code>throw()</code></h4><p><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g);   <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// foo</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(g);   <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>但如果生成器函数<strong>内部通过</strong>try/catch处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的<code>yield</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 1&#125;</span></span><br><span class="line">g.throw(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 3&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>如果生成器对象还没有开始执行，那么调用<code>throw()</code>抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p>
</blockquote>
<h2 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4　小结"></a>7.4　小结</h2><p>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现<code>Iterable</code>接口的对象都有一个<code>Symbol.iterator</code>属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现了<code>Iterator</code>接口的对象。</p>
<p>迭代器必须通过连续调用<code>next()</code>方法才能连续取得值，这个方法返回一个<code>IteratorObject</code>。这个对象包含一个<code>done</code>属性和一个<code>value</code>属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用<code>next()</code>方法来消费，也可以通过原生消费者，比如<code>for-of</code>循环来自动消费。</p>
<p>生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了<code>Iterable</code>接口，因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持<code>yield</code>关键字，这个关键字能够暂停执行生成器函数。使用<code>yield</code>关键字还可以通过<code>next()</code>方法接收输入和产生输出。在加上星号之后，<code>yield</code>关键字可以将跟在它后面的可迭代对象序列化为一连串值。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>09-代理与反射</title>
    <url>/2021/04/08/note/JavaScript/09-%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>ECMAScript 6新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</p>
<blockquote>
<p><strong>注意</strong>在ES6之前，ECMAScript中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的ECMAScript代码。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。</p>
</blockquote>
<h2 id="9-1-代理基础"><a href="#9-1-代理基础" class="headerlink" title="9.1　代理基础"></a>9.1　代理基础</h2><p>代理是目标对象的抽象。从很多方面看，代理类似C++指针但有重大区别，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象可以直接被操作，但直接操作会绕过代理施予的行为，也可以通过代理来操作。</p>
<h3 id="9-1-1-创建空代理"><a href="#9-1-1-创建空代理" class="headerlink" title="9.1.1　创建空代理"></a>9.1.1　创建空代理</h3><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p>
<p>代理是使用<code>Proxy</code>构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出<code>TypeError</code>。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p>
<p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// id属性会访问同一个值</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id);  <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);   <span class="comment">// target</span></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值</span></span><br><span class="line">target.id = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);  <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上，因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.id = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);  <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方，都会应用到目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.hasOwnProperty(<span class="string">&#x27;id&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Proxy.prototype是undefined，因此不能使用instanceof操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(target <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>);  <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="built_in">console</span>.log(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-2-定义捕获器"><a href="#9-1-2-定义捕获器" class="headerlink" title="9.1.2　定义捕获器"></a>9.1.2　定义捕获器</h3><p>使用代理的主要目的是可以定义<strong>捕获器</strong>（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<blockquote>
<p><strong>注意</strong>捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。</p>
</blockquote>
<p>例如，可以定义一个<code>get()</code>捕获器，在ECMAScript操作以某种形式调用<code>get()</code>时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>这样，当通过代理对象执行<code>get()</code>操作时，就会触发定义的<code>get()</code>捕获器。当然，<code>get()</code>不是ECMAScript对象可以调用的方法。这个操作在JavaScript代码中可以通过多种形式触发并被<code>get()</code>捕获器拦截到。<code>proxy[property]</code>、<code>proxy.property</code>或<code>Object.create(proxy)[property]</code>等操作都会触发基本的<code>get()</code>操作以获取属性。所有这些操作只要也只能发生在代理对象上，就会触发<code>get()</code>捕获器，否则在目标对象上执行这些操作仍然会产生正常的行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(target.foo);                    <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);                     <span class="comment">// handler override</span></span><br><span class="line"><span class="built_in">console</span>.log(target[<span class="string">&#x27;foo&#x27;</span>]);                 <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="string">&#x27;foo&#x27;</span>]);                  <span class="comment">// handler override</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(target)[<span class="string">&#x27;foo&#x27;</span>]);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(proxy)[<span class="string">&#x27;foo&#x27;</span>]);   <span class="comment">// handler override</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-3-捕获器参数和反射API"><a href="#9-1-3-捕获器参数和反射API" class="headerlink" title="9.1.3　捕获器参数和反射API"></a>9.1.3　捕获器参数和反射API</h3><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，<code>get()</code>捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(trapTarget === target);</span><br><span class="line">    <span class="built_in">console</span>.log(property);</span><br><span class="line">    <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有了这些参数，就可以重建被捕获方法的原始行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像<code>get()</code>那么简单。因此，无法如法炮制。实际上，开发者可以通过调用全局<code>Reflect</code>对象上（封装了原始行为）的同名方法来轻松重建。<br>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射API也可以像下面这样定义出空代理对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>甚至还可以写得更简洁一些：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="built_in">Reflect</span>.get</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射API的空代理，那么甚至不需要定义处理程序对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, <span class="built_in">Reflect</span>);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>反射API为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;qux&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> decoration = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">      decoration = <span class="string">&#x27;!!!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments) + decoration;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// bar!!!</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.baz);   <span class="comment">// qux</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-4-捕获器不变式"><a href="#9-1-4-捕获器不变式" class="headerlink" title="9.1.4　捕获器不变式"></a>9.1.4　捕获器不变式</h3><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p>
<p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出<code>TypeError</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-5-可撤销代理"><a href="#9-1-5-可撤销代理" class="headerlink" title="9.1.5　可撤销代理"></a>9.1.5　可撤销代理</h3><p>对于使用<code>new Proxy()</code>创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</p>
<p>有时候可能需要中断代理对象与目标对象之间的联系。<code>revocable()</code>方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（<code>revoke()</code>）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出<code>TypeError</code>。</p>
<p>撤销函数和代理对象是在实例化时同时生成的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// intercepted</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-6-实用反射API"><a href="#9-1-6-实用反射API" class="headerlink" title="9.1.6　实用反射API"></a>9.1.6　实用反射API</h3><p>某些情况下应该优先使用反射API，这是有一些理由的。</p>
<ol>
<li><strong>反射API与对象API</strong></li>
</ol>
<p>在使用反射API时，要记住：</p>
<ul>
<li>反射API并不限于捕获处理程序；</li>
<li>大多数反射API方法在<code>Object</code>类型上有对应的方法。</li>
</ul>
<p>通常，<code>Object</code>上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p>
<ol start="2">
<li><strong>状态标记</strong></li>
</ol>
<p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API方法更有用。例如，可以使用反射API对下面的代码进行重构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义新属性时如果发生问题，<code>Reflect.defineProperty()</code>会返回<code>false</code>，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Reflect</span>.defineProperty(o, <span class="string">&#x27;foo&#x27;</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下反射方法都会提供状态标记：</p>
<ul>
<li> <code>Reflect.defineProperty()</code></li>
<li> <code>Reflect.preventExtensions()</code></li>
<li> <code>Reflect.setPrototypeOf()</code></li>
<li> <code>Reflect.set()</code></li>
<li> <code>Reflect.deleteProperty()</code></li>
</ul>
<ol start="3">
<li><strong>用一等函数替代操作符</strong></li>
</ol>
<p>以下反射方法提供只有通过操作符才能完成的操作。</p>
<ul>
<li><code>Reflect.get()</code>：可以替代对象属性访问操作符。</li>
<li><code>Reflect.set()</code>：可以替代<code>=</code>赋值操作符。</li>
<li><code>Reflect.has()</code>：可以替代<code>in</code>操作符或<code>with()</code>。</li>
<li><code>Reflect.deleteProperty()</code>：可以替代<code>delete</code>操作符。</li>
<li><code>Reflect.construct()</code>：可以替代<code>new</code>操作符。</li>
</ul>
<ol start="4">
<li><strong>安全地应用函数</strong></li>
</ol>
<p>在通过<code>apply</code>方法调用函数时，被调用的函数可能也定义了自己的<code>apply</code>属性（虽然可能性极小）。为绕过这个问题，可以使用定义在<code>Function</code>原型上的<code>apply</code>方法，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(myFunc, thisVal, argumentList);</span><br></pre></td></tr></table></figure>
<p>使用<code>Reflect.apply</code>更方便：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(myFunc, thisVal, argumentsList);</span><br></pre></td></tr></table></figure>
<h3 id="9-1-7-代理另一个代理"><a href="#9-1-7-代理另一个代理" class="headerlink" title="9.1.7　代理另一个代理"></a>9.1.7　代理另一个代理</h3><p>代理可以拦截反射API的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;first proxy&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(firstProxy, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;second proxy&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(secondProxy.foo);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h3 id="9-1-8-代理的问题与不足"><a href="#9-1-8-代理的问题与不足" class="headerlink" title="9.1.8　代理的问题与不足"></a>9.1.8　代理的问题与不足</h3><p>代理是在ECMAScript现有基础之上构建起来的一套新API。虽然很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的ECMAScript机制很好地协同。</p>
<h4 id="9-1-8-1-代理中的this？"><a href="#9-1-8-1-代理中的this？" class="headerlink" title="9.1.8.1   代理中的this？"></a><strong>9.1.8.1   代理中的</strong><code>this</code>？</h4><p>代理潜在的一个问题来源是<code>this</code>值，<code>this</code>通常指向调用这个方法的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="function"><span class="title">thisValEqualsProxy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> === proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(target.thisValEqualsProxy());  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.thisValEqualsProxy());   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这样完全没有问题：调用代理上的任何方法，比如<code>proxy.outerMethod()</code>，而这个方法进而又会调用另一个方法，如<code>this.innerMethod()</code>，实际上都会调用<code>proxy.innerMethod()</code>。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。<br>还记得第6章中通过<code>WeakMap</code>保存私有变量的例子吧，以下是它的简化版：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">userId</span>)</span> &#123;</span><br><span class="line">    wm.set(<span class="built_in">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">id</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    wm.set(<span class="built_in">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个实现依赖<code>User</code>实例的对象标识，在这个实例被代理的情况下就会出问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.id); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(userInstanceProxy.id); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>这是因为<code>User</code>实例一开始使用目标对象作为<code>WeakMap</code>的键，代理对象却尝试从<strong>自身</strong>取得这个实例。要解决这个问题，就需要重新配置代理，把代理<code>User</code>实例改为代理<code>User</code>类本身。之后再创建代理的实例就会以代理实例作为<code>WeakMap</code>的键了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UserClassProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> UserClassProxy(<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(proxyUser.id);</span><br></pre></td></tr></table></figure>
<h4 id="9-1-8-2代理与内部槽位"><a href="#9-1-8-2代理与内部槽位" class="headerlink" title="9.1.8.2代理与内部槽位"></a>9.1.8.2<strong>代理与内部槽位</strong></h4><p>代理与内置引用类型（比如<code>Array</code>）的实例通常可以很好地协同，但有些内置类型（比如<code>Date</code>）可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p>
<p>根据ECMAScript规范，<code>Date</code>类型方法的执行依赖<code>this</code>值上的内部槽位<code>[[NumberDate]]</code>。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的<code>get()</code>和<code>set()</code>操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出<code>TypeError</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Date</span>);  <span class="comment">// true</span></span><br><span class="line">proxy.getDate();  <span class="comment">// TypeError: &#x27;this&#x27; is not a Date object</span></span><br></pre></td></tr></table></figure>
<h2 id="9-2-代理捕获器与反射方法"><a href="#9-2-代理捕获器与反射方法" class="headerlink" title="9.2　代理捕获器与反射方法"></a>9.2　代理捕获器与反射方法</h2><p>代理可以捕获13种不同的基本操作。这些操作有各自不同的反射API方法、参数、关联ECMAScript操作和不变式。</p>
<p>对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</p>
<p>只要在代理上调用，所有捕获器都会拦截它们对应的反射API操作。</p>
<h3 id="9-2-1get"><a href="#9-2-1get" class="headerlink" title="9.2.1get()"></a>9.2.1<code>get()</code></h3><p><code>get()</code>捕获器会在获取属性值的操作中被调用。对应的反射API方法为<code>Reflect.get()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.foo;  <span class="comment">// get()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：无限制。</li>
<li>拦截的操作<ul>
<li><code>proxy.property</code></li>
<li><code>proxy[property]</code></li>
<li><code>Object.create(proxy)[property]</code></li>
<li><code>Reflect.get(proxy, property, receiver)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>property</code>：引用的目标对象上的字符串键属性。</li>
<li><code>receiver</code>：代理对象或继承代理对象的对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果<code>target.property</code>不可写且不可配置，则处理程序返回的值必须与<code>target.property</code>匹配。</li>
<li>如果<code>target.property</code>不可配置且<code>[[Get]]</code>特性为<code>undefined</code>，处理程序的返回值也必须是<code>undefined</code>。<blockquote>
<p><strong>注意</strong>严格来讲，property参数除了字符串键，也可能是符（symbol）键。后面几处也一样。</p>
</blockquote>
<h3 id="9-2-2set"><a href="#9-2-2set" class="headerlink" title="9.2.2set()"></a>9.2.2<code>set()</code></h3></li>
</ul>
</li>
</ol>
<p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射API方法为<code>Reflect.set()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.foo = <span class="string">&#x27;bar&#x27;</span>;  <span class="comment">// set()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：<code>true</code>表示成功；<code>false</code>表示失败，严格模式下会抛出<code>TypeError</code>。</li>
<li>拦截的操作<ul>
<li><code>proxy.property = value</code></li>
<li><code>proxy[property] = value</code></li>
<li><code>Object.create(proxy)[property] = value</code></li>
<li><code>Reflect.set(proxy, property, value, receiver)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>property</code>：引用的目标对象上的字符串键属性。</li>
<li><code>value</code>：要赋给属性的值。</li>
<li><code>receiver</code>：接收最初赋值的对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果<code>target.property</code>不可写且不可配置，则不能修改目标属性的值。</li>
<li>如果<code>target.property</code>不可配置且<code>[[Set]]</code>特性为<code>undefined</code>，则不能修改目标属性的值。</li>
<li>在严格模式下，处理程序中返回<code>false</code>会抛出<code>TypeError</code>。</li>
</ul>
</li>
</ol>
<h3 id="9-2-3has"><a href="#9-2-3has" class="headerlink" title="9.2.3has()"></a>9.2.3<code>has()</code></h3><p><code>has()</code>捕获器会在<code>in</code>操作符中被调用。对应的反射API方法为<code>Reflect.has()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;has()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">// has()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<ul>
<li><code>property in proxy</code></li>
<li><code>property in Object.create(proxy)</code></li>
<li><code>with(proxy) &#123;(property);&#125;</code></li>
<li><code>Reflect.has(proxy, property)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>property</code>：引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果<code>target.property</code>存在且不可配置，则处理程序必须返回<code>true</code>。</li>
<li>如果<code>target.property</code>存在且目标对象不可扩展，则处理程序必须返回<code>true</code>。<h3 id="9-2-4defineProperty"><a href="#9-2-4defineProperty" class="headerlink" title="9.2.4defineProperty()"></a>9.2.4<code>defineProperty()</code></h3></li>
</ul>
</li>
</ol>
<p><code>defineProperty()</code>捕获器会在<code>Object.defineProperty()</code>中被调用。对应的反射API方法为<code>Reflect.defineProperty()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">defineProperty</span>(<span class="params">target, property, descriptor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;defineProperty()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// defineProperty()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<ul>
<li><code>Object.defineProperty(proxy, property, descriptor)</code></li>
<li><code>Reflect.defineProperty(proxy, property, descriptor)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>property</code>：引用的目标对象上的字符串键属性。</li>
<li><code>descriptor</code>：包含可选的<code>enumerable</code>、<code>configurable</code>、<code>writable</code>、<code>value</code>、<code>get</code>和<code>set</code>定义的对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果目标对象不可扩展，则无法定义属性。</li>
<li>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。</li>
<li>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。<h3 id="9-2-5getOwnPropertyDescriptor"><a href="#9-2-5getOwnPropertyDescriptor" class="headerlink" title="9.2.5getOwnPropertyDescriptor()"></a>9.2.5<code>getOwnPropertyDescriptor()</code></h3></li>
</ul>
</li>
</ol>
<p><code>getOwnPropertyDescriptor()</code>捕获器会在<code>Object.getOwnPropertyDescriptor()</code>中被调用。对应的反射API方法为<code>Reflect.getOwnPropertyDescriptor()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;getOwnPropertyDescriptor()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：属性不存在时返回<code>undefined</code>，否则必须返回对象。</li>
<li>拦截的操作<ul>
<li><code>Object.getOwnPropertyDescriptor(proxy, property)</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(proxy, property)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>property</code>：引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果自有的<code>target.property</code>存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。</li>
<li>如果自有的<code>target.property</code>存在且可配置，则处理程序必须返回表示该属性可配置的对象。</li>
<li>如果自有的<code>target.property</code>存在且<code>target</code>不可扩展，则处理程序必须返回一个表示该属性存在的对象。</li>
<li>如果<code>target.property</code>不存在且<code>target</code>不可扩展，则处理程序必须返回<code>undefined</code>表示该属性不存在。</li>
<li>如果<code>target.property</code>不存在，则处理程序不能返回表示该属性可配置的对象。<h3 id="9-2-6deleteProperty"><a href="#9-2-6deleteProperty" class="headerlink" title="9.2.6deleteProperty()"></a>9.2.6<code>deleteProperty()</code></h3></li>
</ul>
</li>
</ol>
<p><code>deleteProperty()</code>捕获器会在<code>delete</code>操作符中被调用。对应的反射API方法为<code>Reflect.deleteProperty()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;deleteProperty()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> proxy.foo  <span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<ul>
<li><code>delete proxy.property</code></li>
<li><code>delete proxy[property]</code></li>
<li><code>Reflect.deleteProperty(proxy, property)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>property</code>：引用的目标对象上的字符串键属性。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果自有的<code>target.property</code>存在且不可配置，则处理程序不能删除这个属性。<h3 id="9-2-7ownKeys"><a href="#9-2-7ownKeys" class="headerlink" title="9.2.7ownKeys()"></a>9.2.7<code>ownKeys()</code></h3></li>
</ul>
</li>
</ol>
<p><code>ownKeys()</code>捕获器会在<code>Object.keys()</code>及类似方法中被调用。对应的反射API方法为<code>Reflect.ownKeys()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ownKeys()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.keys(proxy);  <span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：<code>ownKeys()</code>必须返回包含字符串或符号的可枚举对象。</li>
<li>拦截的操作<ul>
<li><code>Object.getOwnPropertyNames(proxy)</code></li>
<li><code>Object.getOwnPropertySymbols(proxy)</code></li>
<li><code>Object.keys(proxy)</code></li>
<li><code>Reflect.ownKeys(proxy)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>返回的可枚举对象必须包含<code>target</code>的所有不可配置的自有属性。</li>
<li>如果<code>target</code>不可扩展，则返回可枚举对象必须准确地包含自有属性键。<h3 id="9-2-8getPrototypeOf"><a href="#9-2-8getPrototypeOf" class="headerlink" title="9.2.8getPrototypeOf()"></a>9.2.8<code>getPrototypeOf()</code></h3></li>
</ul>
</li>
</ol>
<p><code>getPrototypeOf()</code>捕获器会在<code>Object.getPrototypeOf()</code>中被调用。对应的反射API方法为<code>Reflect.getPrototypeOf()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">getPrototypeOf</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;getPrototypeOf()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(proxy);  <span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：<code>getPrototypeOf()</code>必须返回对象或<code>null</code>。</li>
<li>拦截的操作<ul>
<li><code>Object.getPrototypeOf(proxy)</code></li>
<li><code>Reflect.getPrototypeOf(proxy)</code></li>
<li><code>proxy.__proto__</code></li>
<li><code>Object.prototype.isPrototypeOf(proxy)</code></li>
<li><code>proxy instanceof Object</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果<code>target</code>不可扩展，则<code>Object.getPrototypeOf(proxy)</code>唯一有效的返回值就是<code>Object.getPrototypeOf(target)</code>的返回值。<h3 id="9-2-9setPrototypeOf"><a href="#9-2-9setPrototypeOf" class="headerlink" title="9.2.9setPrototypeOf()"></a>9.2.9<code>setPrototypeOf()</code></h3></li>
</ul>
</li>
</ol>
<p><code>setPrototypeOf()</code>捕获器会在<code>Object.setPrototypeOf()</code>中被调用。对应的反射API方法为<code>Reflect.setPrototypeOf()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">setPrototypeOf</span>(<span class="params">target, prototype</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setPrototypeOf()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, <span class="built_in">Object</span>);  <span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<ul>
<li><code>Object.setPrototypeOf(proxy)</code></li>
<li><code>Reflect.setPrototypeOf(proxy)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>prototype</code>：<code>target</code>的替代原型，如果是顶级原型则为<code>null</code>。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>若<code>target</code>不可扩展，则唯一有效的<code>prototype</code>参数就是<code>Object.getPrototypeOf(target)</code>的返回值。<h3 id="9-2-10isExtensible"><a href="#9-2-10isExtensible" class="headerlink" title="9.2.10isExtensible()"></a>9.2.10<code>isExtensible()</code></h3></li>
</ul>
</li>
</ol>
<p><code>isExtensible()</code>捕获器会在<code>Object.isExtensible()</code>中被调用。对应的反射API方法为<code>Reflect.isExtensible()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">isExtensible</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;isExtensible()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(proxy);</span><br><span class="line"><span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回布尔值，表示<code>target</code>是否可扩展。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<ul>
<li><code>Object.isExtensible(proxy)</code></li>
<li><code>Reflect.isExtensible(proxy)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果<code>target</code>可扩展，则处理程序必须返回<code>true</code>。</li>
<li>如果<code>target</code>不可扩展，则处理程序必须返回<code>false</code>。<h3 id="9-2-11preventExtensions"><a href="#9-2-11preventExtensions" class="headerlink" title="9.2.11preventExtensions()"></a>9.2.11<code>preventExtensions()</code></h3></li>
</ul>
</li>
</ol>
<p><code>preventExtensions()</code>捕获器会在<code>Object.preventExtensions()</code>中被调用。对应的反射API方法为<code>Reflect.preventExtensions()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">preventExtensions</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;preventExtensions()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</span><br><span class="line"><span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回布尔值，表示<code>target</code>是否已经不可扩展。返回非布尔值会被转型为布尔值。</li>
<li>拦截的操作<ul>
<li><code>Object.preventExtensions(proxy)</code></li>
<li><code>Reflect.preventExtensions(proxy)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li>如果<code>Object.isExtensible(proxy)</code>是<code>false</code>，则处理程序必须返回<code>true</code>。<h3 id="9-2-12apply"><a href="#9-2-12apply" class="headerlink" title="9.2.12apply()"></a>9.2.12<code>apply()</code></h3></li>
</ul>
</li>
</ol>
<p><code>apply()</code>捕获器会在调用函数时中被调用。对应的反射API方法为<code>Reflect.apply()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;apply()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy();  <span class="comment">// apply()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：返回值无限制。</li>
<li>拦截的操作<ul>
<li><code>proxy(...argumentsList)</code></li>
<li><code>Function.prototype.apply(thisArg, argumentsList)</code></li>
<li><code>Function.prototype.call(thisArg, ...argumentsList)</code></li>
<li><code>Reflect.apply(target, thisArgument, argumentsList)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标对象。</li>
<li><code>thisArg</code>：调用函数时的<code>this</code>参数。</li>
<li><code>argumentsList</code>：调用函数时的参数列表</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li><code>target</code>必须是一个函数对象。<h3 id="9-2-13construct"><a href="#9-2-13construct" class="headerlink" title="9.2.13construct()"></a>9.2.13<code>construct()</code></h3></li>
</ul>
</li>
</ol>
<p><code>construct()</code>捕获器会在<code>new</code>操作符中被调用。对应的反射API方法为<code>Reflect.construct()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">construct</span>(<span class="params">target, argumentsList, newTarget</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;construct()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy;</span><br><span class="line"><span class="comment">// construct()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值：必须返回一个对象。</li>
<li>拦截的操作<ul>
<li><code>new proxy(...argumentsList)</code></li>
<li><code>Reflect.construct(target, argumentsList, newTarget)</code></li>
</ul>
</li>
<li>捕获器处理程序参数<ul>
<li><code>target</code>：目标构造函数。</li>
<li><code>argumentsList</code>：传给目标构造函数的参数列表。</li>
<li><code>newTarget</code>：最初被调用的构造函数。</li>
</ul>
</li>
<li>捕获器不变式<ul>
<li><code>target</code>必须可以用作构造函数。<h2 id="9-3-代理模式"><a href="#9-3-代理模式" class="headerlink" title="9.3　代理模式"></a>9.3　代理模式</h2></li>
</ul>
</li>
</ol>
<p>使用代理可以在代码中实现一些有用的编程模式。</p>
<h3 id="9-3-1-跟踪属性访问"><a href="#9-3-1-跟踪属性访问" class="headerlink" title="9.3.1　跟踪属性访问"></a>9.3.1　跟踪属性访问</h3><p>通过捕获<code>get</code>、<code>set</code>和<code>has</code>等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name;     <span class="comment">// Getting name</span></span><br><span class="line">proxy.age = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-隐藏属性"><a href="#9-3-2-隐藏属性" class="headerlink" title="9.3.2　隐藏属性"></a>9.3.2　隐藏属性</h3><p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  baz: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetObject, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.includes(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.includes(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.bar);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.baz);  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span> <span class="keyword">in</span> proxy);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span> <span class="keyword">in</span> proxy);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-属性验证"><a href="#9-3-3-属性验证" class="headerlink" title="9.3.3　属性验证"></a>9.3.3　属性验证</h3><p>因为所有赋值操作都会触发<code>set()</code>捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  onlyNumbersGoHere: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.onlyNumbersGoHere = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.onlyNumbersGoHere);  <span class="comment">// 1</span></span><br><span class="line">proxy.onlyNumbersGoHere = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.onlyNumbersGoHere);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-函数与构造函数参数验证"><a href="#9-3-4-函数与构造函数参数验证" class="headerlink" title="9.3.4　函数与构造函数参数验证"></a>9.3.4　函数与构造函数参数验证</h3><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">median</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.sort()[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(median, &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, argumentsList</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Non-number argument provided&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>));  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">4</span>, <span class="string">&#x27;7&#x27;</span>, <span class="number">1</span>));<span class="comment">//Error: Non-number argument provided</span></span><br></pre></td></tr></table></figure>
<p>类似地，可以要求实例化时必须给构造函数传参：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id_ = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  <span class="function"><span class="title">construct</span>(<span class="params">target, argumentsList, newTarget</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;User cannot be instantiated without id&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> proxy();  <span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-5-数据绑定与可观察对象"><a href="#9-3-5-数据绑定与可观察对象" class="headerlink" title="9.3.5　数据绑定与可观察对象"></a>9.3.5　数据绑定与可观察对象</h3><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p>
<p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name_ = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  <span class="function"><span class="title">construct</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="built_in">Reflect</span>.construct(...arguments);</span><br><span class="line">    userList.push(newUser);</span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">&#x27;Jacob&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">&#x27;Jingleheimerschmidt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(userList); <span class="comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span></span><br></pre></td></tr></table></figure>
<p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(userList, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      emit(<span class="built_in">Reflect</span>.get(target, property, receiver));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.push(<span class="string">&#x27;John&#x27;</span>);  <span class="comment">// John</span></span><br><span class="line">proxy.push(<span class="string">&#x27;Jacob&#x27;</span>); <span class="comment">// Jacob</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>06-集合引用类型</title>
    <url>/2021/03/28/note/JavaScript/06-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="6-1-Object"><a href="#6-1-Object" class="headerlink" title="6.1　Object"></a>6.1　Object</h2><p>大多数引用值的示例使用的是<code>Object</code>类型。显式地创建<code>Object</code>的实例有两种方式。第一种是使用<code>new</code>操作符和<code>Object</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用<strong>对象字面量</strong>表示法。目的是为了简化包含大量属性的对象的创建。在对象字面量表示法中，属性名可以是字符串或数值，注意，数值属性会自动转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：</p>
<blockquote>
<p>**注意 **在使用对象字面量表示法定义对象时，并不会实际调用<code>Object</code>构造函数。</p>
</blockquote>
<p>属性一般是通过<strong>点语法</strong>来存取的，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&quot;name&quot;</span>]); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用中括号的主要优势就是可以通过变量访问属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[propertyName]); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，不能使用点语法来访问，就可以使用中括号语法。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Array"><a href="#6-2-Array" class="headerlink" title="6.2　Array"></a>6.2　Array</h2><p>ECMAScript数组跟其他编程语言的数组有很大区别。ECMAScript数组也同样是一组有序的数据，但数组中每个槽位可以存储任意类型的数据。</p>
<h3 id="6-2-1-创建数组"><a href="#6-2-1-创建数组" class="headerlink" title="6.2.1　创建数组"></a>6.2.1　创建数组</h3><p>有几种基本的方式可以创建数组。一种是使用<code>Array</code>构造函数，可以给构造函数传一个值。如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);     <span class="comment">// 创建一个包含3个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">3</span>);      <span class="comment">// [2,3]</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Greg&quot;</span>); <span class="comment">// 创建一个只包含一个元素，即字符串&quot;Greg&quot;的数组</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>Array</code>构造函数时，也可以省略<code>new</code>操作符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>);     <span class="comment">// 创建一个包含3个元素的数组</span></span><br></pre></td></tr></table></figure>
<p>另一种创建数组的方式是使用<strong>数组字面量</strong>（array literal）表示法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,];                    <span class="comment">// 创建一个包含2个元素的数组</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 与对象一样，在使用数组字面量表示法创建数组不会调用<code>Array</code>构造函数。</p>
</blockquote>
<p><code>Array</code>构造函数有两个用于创建数组的静态方法：<code>from()</code>和<code>of()</code>。</p>
<p><code>from()</code>用于将类数组结构转换为数组实例，第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个<code>length</code>属性和可索引元素的结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">                   .set(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">1</span>)</span><br><span class="line">                   .add(<span class="number">2</span>)</span><br><span class="line">                   .add(<span class="number">3</span>)           </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(m)); <span class="comment">// [[1, 2], [3, 4]]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s)); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1);</span><br><span class="line"><span class="built_in">console</span>.log(a2);        <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">alert(a1 == a2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrayLikeObject));<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>Array.from()</code>还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用<code>Array.from().map()</code>那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中<code>this</code>的值，但这个重写的<code>this</code>值在箭头函数中不适用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="built_in">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="built_in">console</span>.log(a3);  <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>
<p><code>Array.of()</code>把一组参数转换为数组，用于替代在ES6之前常用的<code>Array.prototype.slice.call(arguments)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>));  <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-数组空位"><a href="#6-2-2-数组空位" class="headerlink" title="6.2.2　数组空位"></a>6.2.2　数组空位</h3><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ES6新增方法普遍将这些空位当成存在的元素，只不过值为<code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(option === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// map()会跳过空位置</span></span><br><span class="line"><span class="built_in">console</span>.log(options.map(<span class="function">() =&gt;</span> <span class="number">6</span>));  <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br><span class="line"><span class="comment">// join()视空位置为空字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(options.join(<span class="string">&#x27;-&#x27;</span>));     <span class="comment">// &quot;1----5&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用<code>undefined</code>值代替。</p>
</blockquote>
<h3 id="6-2-3-数组索引"><a href="#6-2-3-数组索引" class="headerlink" title="6.2.3　数组索引"></a>6.2.3　数组索引</h3><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">alert(colors[<span class="number">0</span>]);                       <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">&quot;black&quot;</span>;                    <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">&quot;brown&quot;</span>;                    <span class="comment">// 添加第四项</span></span><br></pre></td></tr></table></figure>
<p>数组中元素的数量保存在<code>length</code>属性中，这个属性始终返回0或大于0的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">alert(colors.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>length</code>属性不是只读的。通过修改<code>length</code>属性，可以从数组末尾删除或添加元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果将<code>length</code>设置为大于数组元素数的值，则新添加的元素都将以<code>undefined</code>填充。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">colors.length = <span class="number">4</span>;</span><br><span class="line">alert(colors[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>使用<code>length</code>属性可以方便地向数组末尾添加元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">colors[colors.length] = <span class="string">&quot;black&quot;</span>;        </span><br></pre></td></tr></table></figure>
<p>这里，<code>colors</code>数组有一个值被插入到位置99，这中间的所有元素，即位置3~98，实际上并不存在，因此在访问时会返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">&quot;black&quot;</span>;                   <span class="comment">// 添加一种颜色（位置99）</span></span><br><span class="line">alert(colors.length);                   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **数组最多可以包含4 294 967 295个元素，如果尝试添加更多项，则会导致抛出错误。</p>
</blockquote>
<h3 id="6-2-4-检测数组"><a href="#6-2-4-检测数组" class="headerlink" title="6.2.4　检测数组"></a>6.2.4　检测数组</h3><p>判断一个对象是不是数组，在只有一个网页（因而只有一个全局作用域）的情况下，使用<code>instanceof</code>操作符足矣</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>instanceof</code>的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的<code>Array</code>构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。<br>为解决这个问题，提供了<code>Array.isArray()</code>方法，确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-5-迭代器方法"><a href="#6-2-5-迭代器方法" class="headerlink" title="6.2.5　迭代器方法"></a>6.2.5　迭代器方法</h3><p>在ES6中，<code>Array</code>的原型上暴露了3个用于检索数组内容的方法：<code>keys()</code>、<code>values()</code>和<code>entries()</code>。<code>keys()</code>返回数组索引的迭代器，<code>values()</code>返回数组元素的迭代器，而<code>entries()</code>返回索引/值对的迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容通过Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys());</span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values());</span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries());</span><br><span class="line"><span class="built_in">console</span>.log(aKeys);     <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(aValues);   <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries);  <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br></pre></td></tr></table></figure>
<p>使用ES6的解构可以非常容易地在循环中拆分键/值对：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.entries()) &#123;</span><br><span class="line">  alert(idx);</span><br><span class="line">  alert(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-6-复制和填充方法"><a href="#6-2-6-复制和填充方法" class="headerlink" title="6.2.6　复制和填充方法"></a>6.2.6　复制和填充方法</h3><p>填充数组方法<code>fill()</code>以及批量复制方法<code>copyWithin()</code>，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。这个方法不会改变数组的大小。</p>
<p>填充数组方法<code>fill()</code>可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。如果有负值索引，则相当于数组长度加上它转换成的一个正索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 用5填充整个数组</span></span><br><span class="line">zeroes.fill(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);       <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用6填充索引大于等于3的元素</span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 6, 6]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用7填充索引大于等于1且小于3的元素</span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 7, 7, 0, 0];</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用8填充索引大于等于1且小于4的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1)</span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4)</span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure>
<p><code>fill()</code>静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.fill(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与<code>fill()</code>使用同样的计算方法，第一个参数，插入到哪个索引的位置，剩下两个参数是复制内容的索引范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line">    reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ints中复制索引0开始的内容，插入到索引5开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints);  <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ints中复制索引5开始的内容，插入到索引0开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints);  <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ints中复制索引0开始到索引3结束的内容，插入到索引4开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript引擎在插值前会完整复制范围内的值，因此复制期间不存在重写的风险</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.copyWithin(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); <span class="comment">//  ints.copyWithin(6, 3, 7);</span></span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p><code>copyWithin()</code>静默忽略超出数组边界、零长度及方向相反的索引范围，与上面<code>fill()</code>例子相同。</p>
<h3 id="6-2-7-转换方法"><a href="#6-2-7-转换方法" class="headerlink" title="6.2.7　转换方法"></a>6.2.7　转换方法</h3><p>所有对象都有<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。<code>valueOf()</code>返回的是数组本身。<code>toString()</code>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其<code>toString()</code>方法，以得到最终的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">alert(colors.toString());   <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors.valueOf());    <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors);              <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>因为<code>alert()</code>期待字符串，所以会在后台调用数组的<code>toString()</code>方法，从而得到跟前面一样的结果。<br><code>toLocaleString()</code>方法可能返回跟<code>toString()</code>和<code>valueOf()</code>相同的结果。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的<code>toLocaleString()</code>方法，而不是<code>toString()</code>方法。</p>
<p>如果想使用不同的分隔符，则可以使用<code>join()</code>方法。<code>join()</code>方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">alert(colors.join(<span class="string">&quot;,&quot;</span>));     <span class="comment">// red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">&quot;||&quot;</span>));    <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>如果不给<code>join()</code>传入任何参数，或者传入<code>undefined</code>，则仍然使用逗号作为分隔符。</p>
<blockquote>
<p><strong>注意</strong> 如果数组中某一项是<code>null</code>或<code>undefined</code>，则在<code>join()</code>、<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>返回的结果中会以空字符串表示。</p>
</blockquote>
<h3 id="6-2-8-栈方法"><a href="#6-2-8-栈方法" class="headerlink" title="6.2.8　栈方法"></a>6.2.8　栈方法</h3><p>ECMAScript数组提供了<code>push()</code>和<code>pop()</code>方法，以实现类似栈的行为。</p>
<p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。<code>pop()</code>方法则用于删除数组的最后一项，同时减少数组的<code>length</code>值，返回被删除的项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                </span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  </span><br><span class="line">alert(colors);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();       <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(colors);          <span class="comment">// [&quot;red&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-9-队列方法"><a href="#6-2-9-队列方法" class="headerlink" title="6.2.9　队列方法"></a>6.2.9　队列方法</h3><p><code>shift()</code>，删除数组的第一项并返回它，然后数组长度减1。</p>
<p><code>shift()</code>和<code>push()</code>，可以把数组当成队列来使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();       </span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  <span class="comment">// 推入两项</span></span><br><span class="line"><span class="keyword">let</span> item = colors.shift();  <span class="comment">// 取得第一项</span></span><br><span class="line">alert(item);         <span class="comment">// red</span></span><br><span class="line">alert(colors);       <span class="comment">// [&quot;green&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>unshift()</code>方法，在数组开头添加任意多个值，然后返回新的数组长度。</p>
<h3 id="6-2-10-排序方法"><a href="#6-2-10-排序方法" class="headerlink" title="6.2.10　排序方法"></a>6.2.10　排序方法</h3><p><code>reverse()</code>方法就是将数组元素反向排列，会修改原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values);  <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>sort()</code>会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，<code>sort()</code>会在每一项上调用<code>String()</code>转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。因此，10还会排到5前面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);  <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>为此，<code>sort()</code>方法可以接收一个<strong>比较函数</strong>，用于判断哪个值应该排在前面。<br>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个比较函数可以适用于大多数数据类型，可以把它当作参数传给sort()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);  <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>比较函数也可以产生降序效果，只要把返回值交换一下即可。</p>
<p>此外，这个比较函数还可简写为一个箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? <span class="number">1</span> : a &gt; b ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">alert(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> <code>reverse()</code>和<code>sort()</code>都返回调用它们的数组的引用。</p>
</blockquote>
<p>如果数组的元素是数值，或者是其<code>valueOf()</code>方法返回数值的对象（如<code>Date</code>对象），还可以更简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-11-操作方法"><a href="#6-2-11-操作方法" class="headerlink" title="6.2.11　操作方法"></a>6.2.11　操作方法</h3><p><code>concat()</code>方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则<code>concat()</code>会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。原始数组保持不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure>
<p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcatSpreadable</code>。参见3.4.7.7  。</p>
<p><code>slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。如果只有一个参数，则<code>slice()</code>会返回该索引到数组末尾的所有元素。如果有两个参数，则<code>slice()</code>返回从开始索引到结束索引对应的所有元素，不包含结束索引对应的元素。不影响原始数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">alert(colors2);  <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line">alert(colors3);  <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **如果<code>slice()</code>的参数有负值，那么就以数值长度加上这个负值的结果确定位置。</p>
</blockquote>
<p><code>splice()</code>的主要目的是在数组中间插入元素，但有<code>3</code>种不同的方式使用这个方法。</p>
<ul>
<li><strong>删除</strong>。需要给<code>splice()</code>传2个参数：开始位置和要删除的元素数量。。</li>
<li><strong>插入</strong>。需要给<code>splice()</code>传3个参数：开始位置、0（要删除的元素数量）和要插入的任意多个元素，在数组中指定的位置前插入元素。</li>
<li><strong>替换</strong>。<code>splice()</code>在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。</li>
</ul>
<p><code>splice()</code>方法始终返回包含了从数组中被删除的元素数组（如果没有删除元素，则返回空数组）。会影响原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(colors);                     <span class="comment">// [&quot;green&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed);                    <span class="comment">// [&quot;red&quot;]</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>);   <span class="comment">// 在位置1前插入两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);              <span class="comment">// [&quot;green&quot;, &quot;yellow&quot;, &quot;orange&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed);             <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>);  <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);               <span class="comment">// [&quot;green&quot;, &quot;red&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed);              <span class="comment">// [&quot;yellow&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-12-搜索和位置方法"><a href="#6-2-12-搜索和位置方法" class="headerlink" title="6.2.12　搜索和位置方法"></a>6.2.12　搜索和位置方法</h3><p>ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p>
<h4 id="6-2-12-1-严格相等"><a href="#6-2-12-1-严格相等" class="headerlink" title="6.2.12.1   严格相等"></a><strong>6.2.12.1   严格相等</strong></h4><p>3个严格相等的搜索方法：<code>indexOf()</code>、<code>lastIndexOf()</code>和<code>includes()</code>。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。<code>indexOf()</code>和<code>includes()</code>方法从起始搜索位置（默认第一项）开始向后搜索，而<code>lastIndexOf()</code>从起始搜索位置（默认最后一项）开始向前搜索。</p>
<p><code>indexOf()</code>和<code>lastIndexOf()</code>都返回要查找的元素在数组中的位置，如果没找到则返回-1。<code>includes()</code>返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（<code>===</code>）比较，也就是必须严格相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>));          <span class="comment">// 3</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>));      <span class="comment">// 5</span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>));         <span class="comment">// true</span></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>));       <span class="comment">// 5</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>));   <span class="comment">// 3</span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>, <span class="number">7</span>));      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> morePeople = [person];</span><br><span class="line">alert(people.indexOf(person));      <span class="comment">// -1</span></span><br><span class="line">alert(morePeople.includes(person)); <span class="comment">// true</span></span><br><span class="line">alert(morePeople.indexOf(person));  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="6-2-12-2-断言函数"><a href="#6-2-12-2-断言函数" class="headerlink" title="6.2.12.2   断言函数"></a><strong>6.2.12.2   断言函数</strong></h4><p>按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p>
<p>断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p>
<p><code>find()</code>和<code>findIndex()</code>方法使用了断言函数。这两个方法都从数组的最小索引开始。<code>find()</code>返回第一个匹配的元素，<code>findIndex()</code>返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部<code>this</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">alert(people.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br><span class="line">alert(people.findIndex(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>找到匹配项后，这两个方法都不再继续搜索。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 找到第一个匹配项后，不会继续搜索</span></span><br><span class="line">evens.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element);</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">  <span class="built_in">console</span>.log(array);</span><br><span class="line">  <span class="keyword">return</span> element === <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-13-迭代方法"><a href="#6-2-13-迭代方法" class="headerlink" title="6.2.13　迭代方法"></a>6.2.13　迭代方法</h3><p>ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中<code>this</code>的值）。传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。这些方法都不改变调用它们的数组。</p>
<ul>
<li><code>every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回<code>true</code>，则这个方法返回<code>true</code>。</li>
<li><code>filter()</code>：对数组每一项都运行传入的函数，函数返回<code>true</code>的项会组成数组之后返回。适合从数组中筛选满足给定条件的元素。</li>
<li><code>forEach()</code>：对数组每一项都运行传入的函数，没有返回值。相当于使用<code>for</code>循环遍历数组</li>
<li><code>map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。适合创建一个与原始数组元素一一对应的新数组。</li>
<li><code>some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回<code>true</code>，则这个方法返回<code>true</code>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(everyResult);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(someResult);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(filterResult);  <span class="comment">// 3,4,5,4,3</span></span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line">alert(mapResult);  <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-2-14-归并方法"><a href="#6-2-14-归并方法" class="headerlink" title="6.2.14　归并方法"></a>6.2.14　归并方法</h3></li>
</ul>
<p>ECMAScript为数组提供了两个归并方法：<code>reduce()</code>和<code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。<code>reduce()</code>方法从数组第一项开始遍历到最后一项。而<code>reduceRight()</code>从最后一项开始遍历至第一项。</p>
<p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。归并函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
<p>可以使用<code>reduce()</code>函数执行累加数组中所有数值的操作，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line">alert(sum);  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p><code>reduceRight()</code>方法与之类似，只是方向相反。</p>
<h2 id="6-3-定型数组"><a href="#6-3-定型数组" class="headerlink" title="6.3　定型数组"></a>6.3　定型数组</h2><p>在WebGL的早期版本中，JavaScript数组与原生数组之间不匹配，因为图形驱动程序API通常不需要以JavaScript默认双精度浮点格式传递给它们的数值，因此每次WebGL与JavaScript运行时之间传递数组时，WebGL绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式。</p>
<p>定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。</p>
<h3 id="6-3-1-ArrayBuffer"><a href="#6-3-1-ArrayBuffer" class="headerlink" title="6.3.1   ArrayBuffer"></a>6.3.1   ArrayBuffer</h3><p><code>ArrayBuffer</code>对象代表储存二进制数据的一段内存，不能直接读写，只能通过<code>DataView</code>视图和定型数组来读写，<code>ArrayBuffer</code>是所有定型数组及视图引用的基本单位。视图的作用是以指定格式解读<code>ArrayBuffer</code>存储的二进制数据。</p>
<blockquote>
<p>**注意 **<code>SharedArrayBuffer</code>是<code>ArrayBuffer</code>的一个变体，可以无须复制就在执行上下文间传递它。</p>
</blockquote>
<p><code>ArrayBuffer()</code>是一个普通的JavaScript构造函数，可用于在内存中分配特定数量的字节空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);  <span class="comment">// 在内存中分配16字节</span></span><br><span class="line">alert(buf.byteLength);            <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p><code>ArrayBuffer</code>一经创建就不能再调整大小。不过可以使用<code>slice()</code>复制其全部或部分到一个新实例中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.slice(<span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line">alert(buf2.byteLength);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p><code>ArrayBuffer</code>某种程度上类似于C++的<code>malloc()</code>，但也有几个明显的区别。</p>
<ul>
<li><code>malloc()</code>在分配失败时会返回一个<code>null</code>指针。<code>ArrayBuffer</code>在分配失败时会抛出错误。</li>
<li><code>malloc()</code>可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。<code>ArrayBuffer</code>分配的内存不能超过<code>Number.MAX_SAFE_INTEGER</code>（<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/28/gr45RjvVdkUATbH.gif"
                      alt="gif _1_.gif"
                >)）字节。</li>
<li><code>malloc()</code>调用成功不会初始化实际的地址。声明<code>ArrayBuffer</code>则会将所有二进制位初始化为0。</li>
<li>通过<code>malloc()</code>分配的堆内存除非调用<code>free()</code>或程序退出，否则系统不能再使用。而通过声明<code>ArrayBuffer</code>分配的堆内存可以被当成垃圾回收，不用手动释放。<h3 id="6-3-2-DataView"><a href="#6-3-2-DataView" class="headerlink" title="6.3.2   DataView"></a>6.3.2   DataView</h3></li>
</ul>
<p><code>DataView</code>视图专为文件I/O和网络I/O设计，其API支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。<code>DataView</code>对缓冲内容没有任何预设，也不能迭代。</p>
<p>必须在对已有的<code>ArrayBuffer</code>读取或写入时才能创建<code>DataView</code>实例。这个实例可以使用全部或部分<code>ArrayBuffer</code>，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// DataView默认使用整个ArrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">alert(fullDataView.byteOffset);      <span class="comment">// 0</span></span><br><span class="line">alert(fullDataView.byteLength);      <span class="comment">// 16</span></span><br><span class="line">alert(fullDataView.buffer === buf);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">//   byteOffset=0表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">//   byteLength=8限制视图为前8个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">alert(firstHalfDataView.byteOffset);      <span class="comment">// 0</span></span><br><span class="line">alert(firstHalfDataView.byteLength);      <span class="comment">// 8</span></span><br><span class="line">alert(firstHalfDataView.buffer === buf);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不指定，则DataView会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">//   byteOffset=8表示视图从缓冲的第9个字节开始</span></span><br><span class="line"><span class="comment">//   byteLength未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">8</span>);</span><br><span class="line">alert(secondHalfDataView.byteOffset);      <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.byteLength);      <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.buffer === buf);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>要通过<code>DataView</code>读取缓冲，还需要几个组件。<br>• 首先是要读或写的字节偏移量。可以看成<code>DataView</code>中的某种“地址”。</p>
<p>•<code>DataView</code>应该使用<code>ElementType</code>来实现JavaScript的<code>Number</code>类型到缓冲内二进制格式的转换。</p>
<p>• 最后是内存中值的字节序默认为大端字节序。</p>
<h4 id="6-3-2-1-ElementType"><a href="#6-3-2-1-ElementType" class="headerlink" title="6.3.2.1   ElementType"></a>6.3.2.1   ElementType</h4><p><code>DataView</code>对存储在缓冲内的数据类型没有预设。它暴露的API强制开发者在读、写时指定一个<code>ElementType</code>，然后<code>DataView</code>为读、写而完成相应的转换。</p>
<p>ECMAScript 6支持8种不同的<code>ElementType</code>。</p>
<table>
<thead>
<tr>
<th align="center">ElementType</th>
<th align="center">字节</th>
<th align="center">说明</th>
<th align="center">值的范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Int8</td>
<td align="center">1</td>
<td align="center">8位有符号整数</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">Uint8</td>
<td align="center">1</td>
<td align="center">8位无符号整数</td>
<td align="center">0~255</td>
</tr>
<tr>
<td align="center">Int16</td>
<td align="center">2</td>
<td align="center">16位有符号整数</td>
<td align="center">-32 768~32 767</td>
</tr>
<tr>
<td align="center">Uint16</td>
<td align="center">2</td>
<td align="center">16位无符号整数</td>
<td align="center">0~65 535</td>
</tr>
<tr>
<td align="center">Int32</td>
<td align="center">4</td>
<td align="center">32位有符号整数</td>
<td align="center">-2 147 483 648~2 147 483 647</td>
</tr>
<tr>
<td align="center">Uint32</td>
<td align="center">4</td>
<td align="center">32位无符号整数</td>
<td align="center">0~4 294 967 295</td>
</tr>
<tr>
<td align="center">Float32</td>
<td align="center">4</td>
<td align="center">32位IEEE-754浮点数</td>
<td align="center">-3.4e+38~+3.4e+38</td>
</tr>
<tr>
<td align="center">Float64</td>
<td align="center">8</td>
<td align="center">64位IEEE-754浮点数</td>
<td align="center">-1.7e+308~+1.7e+308</td>
</tr>
</tbody></table>
<p><code>DataView</code>为上表中的每种类型都暴露了<code>get</code>和<code>set</code>方法，这些方法使用<code>byteOffset</code>定位要读取或写入值的字节开始位置。不同类型之间是可以互换使用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个DataView</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 读取缓冲第一个和第二个字节，说明整个缓冲所有二进制位都是0</span></span><br><span class="line">alert(view.getInt8(<span class="number">0</span>));  <span class="comment">// 0</span></span><br><span class="line">alert(view.getInt8(<span class="number">1</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 读取整个缓冲</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为1</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">255</span>);  <span class="comment">// 255的二进制表示是11111111（2^8 - 1）</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0xFF</span>); <span class="comment">// DataView会自动将数据转换为特定的ElementType，255的十六进制表示是0xFF</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-2-字节序"><a href="#6-3-2-2-字节序" class="headerlink" title="6.3.2.2   字节序"></a><strong>6.3.2.2   字节序</strong></h4><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。<code>DataView</code>只支持两种约定：大端字节序（也称为网络字节序）和小端字节序。大端字节序是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反。</p>
<p>JavaScript运行时所在系统的原生字节序决定了如何读取或写入字节，但对一段内存而言，<code>DataView</code>是一个中立接口，它会遵循指定的字节序。<code>DataView</code>的所有API方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为<code>true</code>即可启用小端字节序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 填充缓冲 1000 0000 0000 0001</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">0x80</span>);</span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0x01</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按大端字节序读取Uint16，0x80是高字节，0x01是低字节</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>)); <span class="comment">// 2^15 + 2^0 = 32769</span></span><br><span class="line"><span class="comment">// 按小端字节序读取Uint16，0x01是高字节，0x80是低字节</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 0x0180 = 2^8 + 2^7 = 384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按大端字节序写入Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0004</span>);</span><br><span class="line"><span class="comment">// 填充缓冲 0000 0000 0000 0100</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按小端字节序写入Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 缓冲内容 0000 0010 0000 0000</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 2</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-3-边界情形"><a href="#6-3-2-3-边界情形" class="headerlink" title="6.3.2.3   边界情形"></a><strong>6.3.2.3   边界情形</strong></h4><p><code>DataView</code>完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出<code>RangeError</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">3</span>); <span class="comment">// RangeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">6</span>); <span class="comment">// RangeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(-<span class="number">1</span>); <span class="comment">// RangeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.setInt32(<span class="number">3</span>, <span class="number">123</span>); <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p><code>DataView</code>在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0。如果无法转换，则抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">1.5</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">view.setInt8(<span class="number">0</span>, [<span class="number">4</span>]);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="built_in">Symbol</span>());  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-定型数组"><a href="#6-3-3-定型数组" class="headerlink" title="6.3.3   定型数组"></a>6.3.3   定型数组</h3><p>定型数组是另一种形式的<code>ArrayBuffer</code>视图。虽然概念上与<code>DataView</code>接近，但区别在于它特定于一种<code>ElementType</code>且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API和更高的性能。</p>
<p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过<code>&lt;ElementType&gt;.from()</code>和<code>&lt;ElementType&gt;.of()</code>也可以创建定型数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">12</span>);  <span class="comment">// 创建一个12字节的缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buf); <span class="comment">// 创建一个引用该缓冲的Int32Array</span></span><br><span class="line">alert(ints.length); <span class="comment">// 这个定型数组知道自己的每个元素需要4字节，因此长度为3</span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">6</span>); <span class="comment">// 创建一个长度为6的Int32Array，每个数值使用4字节，因此ArrayBuffer是24字节</span></span><br><span class="line">alert(ints2.length);             <span class="comment">// 6</span></span><br><span class="line">alert(ints2.buffer.byteLength);  <span class="comment">// 24，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line">alert(ints3.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints3.buffer.byteLength); <span class="comment">// 16</span></span><br><span class="line">alert(ints3[<span class="number">2</span>]);                <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(ints3); <span class="comment">//这个新类型数组会分配自己的缓冲，对应索引的每个值也会相应地转换为新格式</span></span><br><span class="line">alert(ints4.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints4.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints4[<span class="number">2</span>]);                <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="built_in">Int16Array</span>.from([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br><span class="line">alert(ints5.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints5.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints5[<span class="number">2</span>]);                <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> floats = <span class="built_in">Float32Array</span>.of(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>);</span><br><span class="line">alert(floats.length);            <span class="comment">// 3</span></span><br><span class="line">alert(floats.buffer.byteLength); <span class="comment">// 12</span></span><br><span class="line">alert(floats[<span class="number">2</span>]);                <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure>
<p>定型数组的构造函数和实例都有一个<code>BYTES_PER_ELEMENT</code>属性，返回该类型数组中每个元素的大小：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT);  <span class="comment">// 2</span></span><br><span class="line">alert(<span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT);  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">1</span>),</span><br><span class="line">      floats = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">1</span>);</span><br><span class="line">alert(ints.BYTES_PER_ELEMENT);        <span class="comment">// 4</span></span><br><span class="line">alert(floats.BYTES_PER_ELEMENT);      <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>如果定型数组没有用任何值初始化，则其关联的缓冲会以0填充：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">2</span>);</span><br><span class="line">alert(ints[<span class="number">0</span>]);  <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">1</span>]);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-1-定型数组行为"><a href="#6-3-3-1-定型数组行为" class="headerlink" title="6.3.3.1   定型数组行为"></a><strong>6.3.3.1   定型数组行为</strong></h4><p>从很多方面看，定型数组与普通数组都很相似。定型数组支持大多数数组的操作符、方法和属性。</p>
<p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> doubleints = ints.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span>*x);</span><br><span class="line">alert(doubleints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>定型数组有一个<code>Symbol.iterator</code>符号属性，因此可以通过<code>for..of</code>循环和扩展操作符来操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> int <span class="keyword">of</span> ints) &#123;</span><br><span class="line">  alert(int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">alert(<span class="built_in">Math</span>.max(...ints)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-2-合并、复制和修改定型数组"><a href="#6-3-3-2-合并、复制和修改定型数组" class="headerlink" title="6.3.3.2   合并、复制和修改定型数组"></a><strong>6.3.3.2   合并、复制和修改定型数组</strong></h4><p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p>
<ul>
<li><code>concat()</code></li>
<li><code>pop()</code></li>
<li><code>push()</code></li>
<li><code>shift()</code></li>
<li><code>splice()</code></li>
<li><code>unshift()</code></li>
</ul>
<p>不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：<code>set()</code>和<code>subarray()</code>。</p>
<p><code>set()</code>从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 把定型数组复制为前4个值，偏移量默认为索引0</span></span><br><span class="line">container.set(<span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(container);  <span class="comment">// [1,2,3,4,0,0,0,0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把普通数组复制为后4个值，偏移量4表示从索引4开始插入</span></span><br><span class="line">container.set([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(container);  <span class="comment">// [1,2,3,4,5,6,7,8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出会抛出错误</span></span><br><span class="line">container.set([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">7</span>); <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p><code>subarray()</code>执行与<code>set()</code>相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">Int16Array</span>.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 把整个数组复制为一个同类型的新数组</span></span><br><span class="line"><span class="keyword">const</span> fullCopy = source.subarray();</span><br><span class="line"><span class="built_in">console</span>.log(fullCopy);  <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始复制数组</span></span><br><span class="line"><span class="keyword">const</span> halfCopy = source.subarray(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(halfCopy);  <span class="comment">// [6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引1开始复制到索引3</span></span><br><span class="line"><span class="keyword">const</span> partialCopy = source.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(partialCopy);  <span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure>
<p>定型数组没有原生的拼接能力，但使用定型数组API提供的很多工具可以手动构建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是应该返回的数组类型</span></span><br><span class="line"><span class="comment">// 其余参数是应该拼接在一起的定型数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typedArrayConcat</span>(<span class="params">typedArrayConstructor, ...typedArrays</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计算所有数组中包含的元素总数</span></span><br><span class="line">  <span class="keyword">const</span> numElements = typedArrays.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> (x.length || x) + y.length);</span><br><span class="line">  <span class="comment">// 按照提供的类型创建一个数组，为所有元素留出空间</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> typedArrayConstructor(numElements);</span><br><span class="line">  <span class="comment">// 依次转移数组</span></span><br><span class="line">  <span class="keyword">let</span> currentOffset = <span class="number">0</span>;</span><br><span class="line">  typedArrays.map(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    resultArray.set(x, currentOffset);</span><br><span class="line">    currentOffset += x.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> concatArray = typedArrayConcat(<span class="built_in">Int32Array</span>,</span><br><span class="line">                                     <span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                                     <span class="built_in">Int16Array</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">                                     <span class="built_in">Float32Array</span>.of(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line"><span class="built_in">console</span>.log(concatArray);  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(concatArray <span class="keyword">instanceof</span> <span class="built_in">Int32Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-3-下溢和上溢"><a href="#6-3-3-3-下溢和上溢" class="headerlink" title="6.3.3.3   **下溢和上溢 **"></a>6.3.3.3   **下溢和上溢 **</h4><p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长度为2的有符号整数数组，每个索引保存一个二补数形式的有符号整数，范围是-128~127</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 长度为2的无符号整数数组，每个索引保存一个无符号整数，范围是0~255</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引，索引只取最低有效位上的8位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>;      <span class="comment">// 0x100</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 0]</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>;      <span class="comment">// 0x1FF</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = -<span class="number">1</span>        <span class="comment">// 0xFF (truncated to 8 bits)</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80是无符号整数的128，是二补数形式的-128</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>;        <span class="comment">// 0x80    1000 0000</span></span><br><span class="line"><span class="built_in">console</span>.log(ints);    <span class="comment">// [0, -128]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF是无符号整数的255，是二补数形式的-1</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>;        <span class="comment">// 0xFF</span></span><br><span class="line"><span class="built_in">console</span>.log(ints);    <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure>
<p>除了8种元素类型，还有一种“夹板”数组类型：<code>Uint8ClampedArray</code>，不允许任何方向溢出。超出最大值255的值会被向下舍入为255，而小于最小值0的值会被向上舍入为0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clampedInts = <span class="keyword">new</span> <span class="built_in">Uint8ClampedArray</span>([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">256</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(clampedInts); <span class="comment">// [0, 0, 255, 255]</span></span><br></pre></td></tr></table></figure>
<p><code>Uint8ClampedArray</code>完全是HTML5<code>canvas</code>元素的历史留存，除非真的做跟<code>canvas</code>相关的开发，否则不要使用它。</p>
<h2 id="6-4-Map"><a href="#6-4-Map" class="headerlink" title="6.4　Map"></a>6.4　<code>Map</code></h2><p><code>Map</code>是一种新的集合类型，<code>Map</code>的大多数特性都可以通过<code>Object</code>类型实现，但二者之间还是存在细微差异。</p>
<h3 id="6-4-1-基本API"><a href="#6-4-1-基本API" class="headerlink" title="6.4.1　基本API"></a>6.4.1　基本API</h3><p>使用<code>new</code>关键字和<code>Map</code>构造函数可以创建一个空映射：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>
<p>如果想在创建的同时初始化实例，可以给<code>Map</code>构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中。</p>
<p>初始化之后，可以使用<code>set()</code>方法再添加键/值对，<code>set()</code>方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明。另外，可以使用<code>get()</code>和<code>has()</code>进行查询，可以通过<code>size</code>属性获取映射中的键/值对的数量，还可以使用<code>delete()</code>和<code>clear()</code>删除值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(m1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(m2.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[]]);</span><br><span class="line">alert(m3.has(<span class="literal">undefined</span>));  <span class="comment">// true</span></span><br><span class="line">alert(m3.get(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>)</span><br><span class="line"> .set(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt</span></span><br><span class="line">alert(m.size);             <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="string">&quot;firstName&quot;</span>);     <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.size);             <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">m.clear(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">alert(m.size);             <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>与<code>Object</code>只能使用数值、字符串或符号作为键不同，<code>Map</code>可以使用任何JavaScript数据类型作为键。映射的值与<code>Object</code>类似，是没有限制的。<code>Map</code>内部使用SameValueZero比较操作（ECMAScript规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">m.set(functionKey, <span class="string">&quot;functionValue&quot;</span>);</span><br><span class="line">m.set(symbolKey, <span class="string">&quot;symbolValue&quot;</span>);</span><br><span class="line">m.set(objectKey, <span class="string">&quot;objectValue&quot;</span>);</span><br><span class="line">alert(m.get(functionKey));  <span class="comment">// functionValue</span></span><br><span class="line">alert(m.get(symbolKey));    <span class="comment">// symbolValue</span></span><br><span class="line">alert(m.get(objectKey));    <span class="comment">// objectValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SameValueZero比较意味着独立实例不冲突</span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>与严格相等一样，在映射中用作键以及值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;,</span><br><span class="line">      objVal = &#123;&#125;,</span><br><span class="line">      arrKey = [],</span><br><span class="line">      arrVal = [];</span><br><span class="line">m.set(objKey, objVal);</span><br><span class="line">m.set(arrKey, arrVal);</span><br><span class="line">objKey.foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arrKey.push(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure>
<p>但SameValueZero比较也可能导致意想不到的冲突：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">&quot;&quot;</span>,   <span class="comment">// NaN</span></span><br><span class="line">      b = <span class="number">0</span>/<span class="string">&quot;&quot;</span>,   <span class="comment">// NaN</span></span><br><span class="line">      pz = +<span class="number">0</span>,</span><br><span class="line">      nz = -<span class="number">0</span>;</span><br><span class="line">alert(a === b);   <span class="comment">// false</span></span><br><span class="line">alert(pz === nz); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.set(a, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">m.set(pz, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">alert(m.get(b));  <span class="comment">// foo</span></span><br><span class="line">alert(m.get(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-2-顺序与迭代"><a href="#6-4-2-顺序与迭代" class="headerlink" title="6.4.2　顺序与迭代"></a>6.4.2　顺序与迭代</h3><p>与<code>Object</code>类型的一个主要差异是，<code>Map</code>实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。</p>
<p>映射实例可以提供一个迭代器（<code>Iterator</code>），能以插入顺序生成<code>[key, value]</code>形式的数组。可以通过<code>entries()</code>方法（或者<code>Symbol.iterator</code>属性，它引用<code>entries()</code>）取得这个迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br></pre></td></tr></table></figure>
<p>因为<code>entries()</code>是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure>
<p>如果不使用迭代器，则可以调用映射的<code>forEach(callback, opt_thisArg)</code>方法并传入回调，依次迭代每个键/值对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">m.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// key1 -&gt; val1</span></span><br><span class="line"><span class="comment">// key2 -&gt; val2</span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure>
<p><code>keys()</code>和<code>values()</code>分别返回以插入顺序生成键和值的迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1</span></span><br><span class="line"><span class="comment">// key2</span></span><br><span class="line"><span class="comment">// key3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure>
<p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.keys()) &#123;</span><br><span class="line">  key = <span class="string">&quot;newKey&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// newKey  </span></span><br><span class="line">  <span class="built_in">console</span>.log(m1.get(<span class="string">&quot;newKey&quot;</span>)); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(m1.get(<span class="string">&quot;key1&quot;</span>));  <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [keyObj, <span class="string">&quot;val1&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  key.id = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">  alert(key);            <span class="comment">// &#123;id: &quot;2&quot;&#125;</span></span><br><span class="line">  alert(m.get(keyObj));  <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line">alert(keyObj);           <span class="comment">// &#123;id: &quot;2&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-3-选择Object还是Map"><a href="#6-4-3-选择Object还是Map" class="headerlink" title="6.4.3　选择Object还是Map"></a>6.4.3　选择<code>Object</code>还是<code>Map</code></h3><ol>
<li><strong>内存占用</strong></li>
</ol>
<p>固定大小的内存，<code>Map</code>大约可以比<code>Object</code>多存储50%的键/值对。</p>
<ol start="2">
<li><strong>插入性能</strong></li>
</ol>
<p>对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，Map`的性能更佳。</p>
<ol start="3">
<li><strong>查找速度</strong></li>
</ol>
<p>对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，Object`更好一些。</p>
<ol start="4">
<li><strong>删除性能</strong></li>
</ol>
<p>使用<code>delete</code>删除<code>Object</code>属性的性能一直以来饱受诟病，为此，出现了一些伪删除对象属性的操作，包括把属性值设置为<code>undefined</code>或<code>null</code>。因此代码涉及大量删除操作，选择<code>Map</code>。</p>
<h2 id="6-5-WeakMap"><a href="#6-5-WeakMap" class="headerlink" title="6.5　WeakMap"></a>6.5　<code>WeakMap</code></h2><p>ECMAScript 6新增的“弱映射”（<code>WeakMap</code>）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。<code>WeakMap</code>是<code>Map</code>的“兄弟”类型，其API也是<code>Map</code>的子集。<code>WeakMap</code>中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱映射”中键的弱引用。</p>
<h3 id="6-5-1-基本API"><a href="#6-5-1-基本API" class="headerlink" title="6.5.1　基本API"></a>6.5.1　基本API</h3><p>可以使用<code>new</code>关键字实例化一个空的<code>WeakMap</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure>
<p>弱映射中的键只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置键会抛出<code>TypeError</code>。值的类型没有限制。除此之外，可参照<code>6.4.1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm21 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [key3, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<h3 id="6-5-2-弱键"><a href="#6-5-2-弱键" class="headerlink" title="6.5.2　弱键"></a>6.5.2　弱键</h3><p><code>WeakMap</code>表示弱映射的键不属于正式的引用，不会阻止垃圾回收。但值不是，只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</p>
<p>下面这个例子，因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收，而且值也没有被引用，这个键/值对就从弱映射中消失了，使其成为一个空映射。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(&#123;&#125;, <span class="string">&quot;val&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>再看一个稍微不同的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> container = &#123;</span><br><span class="line">  key: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">wm.set(container.key, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.key = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>container</code>对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。但如果调用了<code>removeReference()</code>，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键/值对清理掉，这也是使用<code>WeakMap</code>的目的。因为当没有任何指向这个对象的引用的时候，就只有<code>WeakMap</code>对键对象的弱引用，而弱引用不会阻止垃圾回收。</p>
<h3 id="6-5-3-不可迭代键"><a href="#6-5-3-不可迭代键" class="headerlink" title="6.5.3　不可迭代键"></a>6.5.3　不可迭代键</h3><p>因为<code>WeakMap</code>中的键/值对任何时候都可能被销毁，所以没有提供迭代其键/值对的能力，同时也没有像<code>clear()</code>这样一次性销毁所有键/值的方法。</p>
<p>如果<code>WeakMap</code>实例允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。因为原始值是按值传递，这样的话实例中的键与变量<code>key</code>就失去联系了，即便变量<code>key</code>的内存被回收了，实例中的键也还存在，重新创建一个和之前字符串相等的变量就可以获得键值对的信息，所以<code>WeakMap</code>实例只用对象作为键，保证只有通过键对象的引用才能取得值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">wm.set(key, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6-5-4-使用弱映射"><a href="#6-5-4-使用弱映射" class="headerlink" title="6.5.4　使用弱映射"></a>6.5.4　使用弱映射</h3><h4 id="6-5-4-1-私有变量"><a href="#6-5-4-1-私有变量" class="headerlink" title="6.5.4.1   私有变量"></a><strong>6.5.4.1   私有变量</strong></h4><p>弱映射造就了在JavaScript中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">      <span class="built_in">this</span>.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setPrivate</span>(<span class="params">property, value</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> privateMembers = wm.get(<span class="built_in">this</span>) || &#123;&#125;;</span><br><span class="line">      privateMembers[property] = value;</span><br><span class="line">      wm.set(<span class="built_in">this</span>, privateMembers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getPrivate</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> wm.get(<span class="built_in">this</span>)[property];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setPrivate(<span class="built_in">this</span>.idProperty, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getPrivate(<span class="built_in">this</span>.idProperty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>
<p>这样拿不到弱映射中的健，也就无法取得弱映射中对应的值，但整个代码也完全陷入了ES6之前的闭包私有变量模式。</p>
<h4 id="6-5-4-2-DOM节点元数据"><a href="#6-5-4-2-DOM节点元数据" class="headerlink" title="6.5.4.2   DOM节点元数据"></a><strong>6.5.4.2   DOM节点元数据</strong></h4><p>因为<code>WeakMap</code>实例不会妨碍垃圾回收，所以非常适合保存关联元数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.set(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>假设代码执行后，原来的登录按钮从DOM树中被删掉了，那么垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）。但如果使用映射，由于映射中还保存着按钮的引用，所以对应的DOM节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。</p>
<h2 id="6-6-Set"><a href="#6-6-Set" class="headerlink" title="6.6　Set"></a>6.6　<code>Set</code></h2><p>ECMAScript 6新增的<code>Set</code>是一种新集合类型。<code>Set</code>在很多方面都像是加强的<code>Map</code>，这是因为它们的大多数API和行为都是共有的。</p>
<h3 id="6-6-1-基本API"><a href="#6-6-1-基本API" class="headerlink" title="6.6.1　基本API"></a>6.6.1　基本API</h3><p>使用<code>new</code>关键字和<code>Set</code>构造函数可以创建一个空集合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure>
<p>如果想在创建的同时初始化实例，则可以给<code>Set</code>构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素。</p>
<p>初始化之后，可以使用<code>add()</code>增加值，<code>add()</code>返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化。也可以使用<code>has()</code>查询，通过<code>size</code>取得元素数量，以及使用<code>delete()</code>和<code>clear()</code>删除元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">&quot;Matt&quot;</span>)</span><br><span class="line"> .add(<span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// true</span></span><br><span class="line">alert(s.size);           <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// false</span></span><br><span class="line">alert(s.size);           <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">s.clear(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line">alert(s.size);           <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>与<code>Map</code>类似，<code>Set</code>可以包含任何JavaScript数据类型作为值。集合也使用SameValueZero操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">s.add(functionVal);</span><br><span class="line">s.add(symbolVal);</span><br><span class="line">s.add(objectVal);</span><br><span class="line">alert(s.has(functionVal));   <span class="comment">// true</span></span><br><span class="line">alert(s.has(symbolVal));     <span class="comment">// true</span></span><br><span class="line">alert(s.has(objectVal));     <span class="comment">// true</span></span><br><span class="line"><span class="comment">// SameValueZero检查意味着独立的实例不会冲突</span></span><br><span class="line">alert(s.has(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;,</span><br><span class="line">      arrVal = [];</span><br><span class="line">s.add(objVal)</span><br><span class="line"> .add(arrVal);</span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">alert(s.has(objVal)); <span class="comment">// true</span></span><br><span class="line">alert(s.has(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>add()</code>和<code>delete()</code>操作是幂等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="6-6-2-顺序与迭代"><a href="#6-6-2-顺序与迭代" class="headerlink" title="6.6.2　顺序与迭代"></a>6.6.2　顺序与迭代</h3><p><code>Set</code>会维护值插入时的顺序，因此支持按顺序迭代。集合实例可以提供一个迭代器<code>Iterator</code>，能以插入顺序生成集合内容。可以通过<code>values()</code>方法及其别名方法<code>keys()</code>或者<code>Symbol.iterator</code>属性，它引用<code>values()</code>取得这个迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">alert(s.values === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line">alert(s.keys === s[<span class="built_in">Symbol</span>.iterator]);   <span class="comment">// true</span></span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br><span class="line"><span class="comment">// val3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>因为<code>values()</code>是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...s]); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果使用回调方式，则可以调用集合的<code>forEach()</code>方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">s.forEach(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// val1 -&gt; val1</span></span><br><span class="line"><span class="comment">// val2 -&gt; val2</span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure>
<p>修改集合中值的属性同样不会影响其作为集合值的身份。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>]);</span><br><span class="line"><span class="comment">// 字符串原始值作为值不会被修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.values()) &#123;</span><br><span class="line">  value = <span class="string">&quot;newVal&quot;</span>;</span><br><span class="line">  alert(value);          <span class="comment">// newVal</span></span><br><span class="line">  alert(s1.has(<span class="string">&quot;val1&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> valObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([valObj]);</span><br><span class="line"><span class="comment">// 修改值对象的属性，但对象仍然存在于集合中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s2.values()) &#123;</span><br><span class="line">  value.id = <span class="string">&quot;newVal&quot;</span>;</span><br><span class="line">  alert(value);           <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br><span class="line">  alert(s2.has(valObj));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">alert(valObj);            <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-6-3-定义正式集合操作"><a href="#6-6-3-定义正式集合操作" class="headerlink" title="6.6.3　定义正式集合操作"></a>6.6.3　定义正式集合操作</h3><p>扩展<code>Set</code>操作需要手动实现：通过子类化<code>Set</code>，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。</p>
<ul>
<li>某些<code>Set</code>操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</li>
<li><code>Set</code>保留插入顺序，所有方法返回的集合必须保证顺序。</li>
<li>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。</li>
<li>不要修改已有的集合实例。<code>union(a, b)</code>或<code>a.union(b)</code>应该返回包含结果的新集合实例。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSet</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">...sets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.union(<span class="built_in">this</span>, ...sets)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">intersection</span>(<span class="params">...sets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.intersection(<span class="built_in">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">difference</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.difference(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">symmetricDifference</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.symmetricDifference(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">cartesianProduct</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.cartesianProduct(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">powerSet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.powerSet(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">union</span>(<span class="params">a, ...bSets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.add(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">intersection</span>(<span class="params">a, ...bSets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.has(aValue)) &#123;</span><br><span class="line">          intersectionSet.delete(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">difference</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.has(bValue)) &#123;</span><br><span class="line">        differenceSet.delete(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">symmetricDifference</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">    <span class="keyword">return</span> a.union(b).difference(a.intersection(b));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line">  <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">cartesianProduct</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> XSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.add([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">powerSet</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> XSet().add(<span class="keyword">new</span> XSet());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> set <span class="keyword">of</span> <span class="keyword">new</span> XSet(powerSet)) &#123;</span><br><span class="line">        powerSet.add(<span class="keyword">new</span> XSet(set).add(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-7-WeakSet"><a href="#6-7-WeakSet" class="headerlink" title="6.7　WeakSet"></a>6.7　<code>WeakSet</code></h2></li>
</ul>
<p>ES 6新增的<code>WeakSet</code>是一种新的集合类型，<code>WeakSet</code>中的“weak”，描述的是JavaScript垃圾回收程序对待“弱集合”中值的弱引用。</p>
<h3 id="6-7-1-基本API"><a href="#6-7-1-基本API" class="headerlink" title="6.7.1　基本API"></a>6.7.1　基本API</h3><p>可以使用<code>new</code>关键字实例化一个空的<code>WeakSet</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure>
<p>弱集合中的值只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置值会抛出<code>TypeError</code>。其余参照<code>6.6.1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">&quot;BADVAL&quot;</span>, val3]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet</span></span><br></pre></td></tr></table></figure>
<h3 id="6-7-2-弱值"><a href="#6-7-2-弱值" class="headerlink" title="6.7.2　弱值"></a>6.7.2　弱值</h3><p>可参照<code>6.5.2</code>。</p>
<h3 id="6-7-3-不可迭代值"><a href="#6-7-3-不可迭代值" class="headerlink" title="6.7.3　不可迭代值"></a>6.7.3　不可迭代值</h3><p>可参照<code>6.5.3</code>。</p>
<h3 id="6-7-4-使用弱集合"><a href="#6-7-4-使用弱集合" class="headerlink" title="6.7.4　使用弱集合"></a>6.7.4　使用弱集合</h3><p>相比于<code>WeakMap</code>实例，<code>WeakSet</code>实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.add(loginButton);</span><br></pre></td></tr></table></figure>
<p>这样，如果查询元素在<code>disabledElements</code>中，就可以知道被禁用了。只要从DOM树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。</p>
<p>但如果使用<code>Set</code>，它的引用却仍然保存在<code>Set</code>中，因此垃圾回收程序也不能回收它。</p>
<h2 id="6-8-迭代与扩展操作"><a href="#6-8-迭代与扩展操作" class="headerlink" title="6.8　迭代与扩展操作"></a>6.8　迭代与扩展操作</h2><p>ES6新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。有4种原生集合类型定义了默认迭代器：</p>
<ul>
<li><code>Array</code></li>
<li>所有定型数组</li>
<li><code>Map</code></li>
<li><code>Set</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [</span><br><span class="line">  <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">  typedArr = <span class="built_in">Int16Array</span>.of(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// [5, 6]</span></span><br><span class="line"><span class="comment">// [7, 8]</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);          <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);          <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">0</span>, ...arr1, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>浅复制意味着只会复制对象引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]);</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(map1);</span><br><span class="line"><span class="built_in">console</span>.log(map1); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map2); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面四种类型都支持<code>Array.of()</code>和<code>Array.from()</code>静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 把数组复制到定型数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="built_in">Int16Array</span>.of(...arr1);</span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="built_in">Int16Array</span>.from(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(typedArr1);   <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(typedArr2);   <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 把数组复制到映射</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, <span class="string">&#x27;val&#x27;</span> + x]));</span><br><span class="line"><span class="built_in">console</span>.log(map);   <span class="comment">// Map &#123;1 =&gt; &#x27;val 1&#x27;, 2 =&gt; &#x27;val 2&#x27;, 3 =&gt; &#x27;val 3&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 把定型数组复制到集合</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(typedArr2);</span><br><span class="line"><span class="built_in">console</span>.log(set);   <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 把集合复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>05-基本引用类型</title>
    <url>/2021/03/14/note/JavaScript/05-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>引用值（或者对象）是某个特定<strong>引用类型</strong>的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”，引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法。</p>
<p>对象被认为是某个特定引用类型的<strong>实例</strong>。新对象通过使用<code>new</code>操作符后跟一个<strong>构造函数</strong>（constructor）来创建。构造函数就是用来创建新对象的函数。</p>
<blockquote>
<p>**注意 **函数也是一种引用类型。</p>
</blockquote>
<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1　Date"></a>5.1　Date</h2><p><code>Date</code>类型将日期保存为自协调世界时（UTC）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式，<code>Date</code>类型可以精确表示1970年1月1日之前及之后285616年的日期。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>在不给<code>Date</code>构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示。为此提供了两个辅助方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。<br><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。所有实现都必须支持下列日期格式：</p>
<ul>
<li>“月/日/年”，如<code>&quot;5/23/2019&quot;</code>；</li>
<li>“月 日, 年”，如<code>&quot;May 23, 2019&quot;</code>；</li>
<li>“周几 月 日 年 时:分:秒 时区”，如<code>&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;</code>；</li>
<li>ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如<code>2019-05-23T00:00:00</code>（只适用于兼容ES5的实现）。</li>
</ul>
<p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法会返回<code>NaN</code>。如果直接把表示日期的字符串传给<code>Date</code>构造函数，那么<code>Date</code>会在后台调用<code>Date.parse()</code>。换句话说，下面这行代码跟前面那行代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">&quot;May 23, 2019&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **不同的浏览器对<code>Date</code>类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期。</p>
</blockquote>
<p><code>Date.UTC()</code>方法也返回日期的毫秒表示。传给<code>Date.UTC()</code>的参数是年、零起点月数（1月是0，2月是1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GMT时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure>
<p><code>Date.UTC()</code>也会被<code>Date</code>构造函数隐式调用，但这种情况下创建的是本地日期，不是GMT日期。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br></pre></td></tr></table></figure>
<p><code>Date.now()</code>方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="built_in">Date</span>.now(),</span><br><span class="line">	result = stop - start;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-继承的方法"><a href="#5-1-1-继承的方法" class="headerlink" title="5.1.1　继承的方法"></a>5.1.1　继承的方法</h3><p><code>Date</code>类型重写了<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。</p>
<p><code>toLocaleString()</code>，返回与浏览器运行的本地环境一致的日期和时间。格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息。</p>
<p><code>toString()</code>方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">toLocaleString() <span class="comment">// 2/1/2019 12:00:00 AM</span></span><br><span class="line">toString() <span class="comment">// Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)</span></span><br></pre></td></tr></table></figure>
<p>在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着<code>toLocaleString()</code>和<code>toString()</code>可能只对调试有用，不能用于显示。<br><code>Date</code>类型的<code>valueOf()</code>方法不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。这也是确保日期先后的一个简单方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 2019年1月1日</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// 2019年2月1日</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt; date2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-日期格式化方法"><a href="#5-1-2-日期格式化方法" class="headerlink" title="5.1.2　日期格式化方法"></a>5.1.2　日期格式化方法</h3><p><code>Date</code>类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p>
<ul>
<li><code>toDateString()</code>显示日期中的周几、月、日、年（格式特定于实现）；</li>
<li><code>toTimeString()</code>显示日期中的时、分、秒和时区（格式特定于实现）；</li>
<li><code>toLocaleDateString()</code>显示日期中的周几、月、日、年（格式特定于实现和地区）；</li>
<li><code>toLocaleTimeString()</code>显示日期中的时、分、秒（格式特定于实现和地区）；</li>
<li><code>toUTCString()</code>显示完整的UTC日期（格式特定于实现）。</li>
</ul>
<p>这些方法的输出与<code>toLocaleString()</code>和<code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p>
<blockquote>
<p>**注意 **还有一个方法叫<code>toGMTString()</code>，这个方法跟<code>toUTCString()</code>是一样的，目的是为了向后兼容。不过，规范建议新代码使用<code>toUTCString()</code>。</p>
</blockquote>
<h3 id="5-1-3-日期-时间组件方法"><a href="#5-1-3-日期-时间组件方法" class="headerlink" title="5.1.3　日期/时间组件方法"></a>5.1.3　日期/时间组件方法</h3><p><code>Date</code>类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getTime()/setTime(<em>milliseconds</em>)</td>
<td align="left">返回/设置日期的毫秒表示；返回与valueOf()相同</td>
</tr>
<tr>
<td align="left">getFullYear()/getUTCFullYear()<br/>setFullYear(<em>year</em>)/setUTCFullYear(<em>year</em>)</td>
<td align="left">返回/设置4位数年（即2019而不是19）</td>
</tr>
<tr>
<td align="left">getMonth()/getUTCMonth()<br>setMonth(<em>month</em>)/setUTCMonth(<em>month</em>)</td>
<td align="left">返回/设置日期的月（0表示1月，11表示12月），设置大于11加年</td>
</tr>
<tr>
<td align="left">getDate()/getUTCDate()<br>setUTCDate(<em>date</em>)/setDate(<em>date</em>)</td>
<td align="left">返回/设置日期中的日（1~31），设置大于该月天数，则加月</td>
</tr>
<tr>
<td align="left">getDay()/getUTCDay()</td>
<td align="left">返回日期中表示周几的数值（0表示周日，6表示周六）</td>
</tr>
<tr>
<td align="left">getHours()/getUTCHours()<br>setHours(<em>hours</em>)/setUTCHours(<em>hours</em>)</td>
<td align="left">返回/设置日期中的时（0~23），设置<em>hours</em>大于23，则加日</td>
</tr>
<tr>
<td align="left">getMinutes()/getUTCMinutes()<br>setMinutes(<em>minutes</em>)/setUTCMinutes(<em>minutes</em>)</td>
<td align="left">返回日期中的分（0~59），设置<em>minutes</em>大于59，则加时</td>
</tr>
<tr>
<td align="left">getSeconds()/getUTCSeconds()<br>setSeconds(<em>seconds</em>)/setUTCSeconds(<em>seconds</em>)</td>
<td align="left">返回/设置日期中的秒（0~59），设置<em>seconds</em>大于59，则加分</td>
</tr>
<tr>
<td align="left">getMilliseconds()/getUTCMilliseconds()<br>setMilliseconds(<em>milliseconds</em>)/setUTCMilliseconds(<em>milliseconds</em>)</td>
<td align="left">返回/设置日期中的毫秒</td>
</tr>
<tr>
<td align="left">getTimezoneOffset()</td>
<td align="left">返回以分钟计的UTC与本地时区的偏移量</td>
</tr>
</tbody></table>
<h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2　RegExp"></a>5.2　RegExp</h2><p>ECMAScript通过<code>RegExp</code>类型支持正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>
<p>这个正则表达式的<code>pattern</code>（模式）可以是任何的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个<code>flags</code>（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p>
<ul>
<li><code>g</code>：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li>
<li><code>i</code>：不区分大小写，表示在查找匹配时忽略<code>pattern</code>和字符串的大小写。</li>
<li><code>m</code>：多行模式，表示查找到一行文本末尾时会继续查找。</li>
<li><code>y</code>：粘附模式，表示只查找从<code>lastIndex</code>开始及之后的字符串。</li>
<li><code>u</code>：Unicode模式，启用Unicode匹配。</li>
<li><code>s</code>：<code>dotAll</code>模式，表示元字符<code>.</code>匹配任何字符（包括<code>\n</code>或<code>\r</code>）。</li>
</ul>
<p>使用不同模式和标记可以创建出各种正则表达式，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中的所有&quot;at&quot;</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，所有<strong>元字符</strong>在模式中也必须转义，包括：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ] &#125; ? * + .</span><br></pre></td></tr></table></figure>
<p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;[bc]at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有&quot;.at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用<code>RegExp</code>构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 跟pattern1一样，只不过是用构造函数创建的</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>RegExp</code>构造函数的两个参数都是字符串。因为<code>RegExp</code>的模式参数是字符串，所以所有元字符都必须二次转义，包括转义字符序列。</p>
<table>
<thead>
<tr>
<th align="left">字面量模式</th>
<th align="left">对应的字符串</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/name\/age/</code></td>
<td align="left"><code>&quot;name\\/age&quot;</code></td>
</tr>
<tr>
<td align="left"><code>/\w\\hello\\123/</code></td>
<td align="left"><code>&quot;\\w\\\\hello\\\\123&quot;</code></td>
</tr>
</tbody></table>
<p>此外，使用<code>RegExp</code>也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/cat/g</span>;</span><br><span class="line"><span class="keyword">const</span> re3 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(re3);     <span class="comment">//   /cat/i </span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1   RegExp实例属性"></a>5.2.1   <code>RegExp</code>实例属性</h3><p>每个<code>RegExp</code>实例都有下列属性，提供有关模式的各方面信息。</p>
<ul>
<li><code>global</code>：布尔值，表示是否设置了<code>g</code>标记。</li>
<li><code>ignoreCase</code>：布尔值，表示是否设置了<code>i</code>标记。</li>
<li><code>unicode</code>：布尔值，表示是否设置了<code>u</code>标记。</li>
<li><code>sticky</code>：布尔值，表示是否设置了<code>y</code>标记。</li>
<li><code>lastIndex</code>：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。</li>
<li><code>multiline</code>：布尔值，表示是否设置了<code>m</code>标记。</li>
<li><code>dotAll</code>：布尔值，表示是否设置了<code>s</code>标记。</li>
<li><code>source</code>：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li>
<li><code>flags</code>：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回，没有前后斜杠。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);      <span class="comment">// &quot;\[bc\]at&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.flags);       <span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-RegExp实例方法"><a href="#5-2-2-RegExp实例方法" class="headerlink" title="5.2.2   RegExp实例方法"></a>5.2.2   <code>RegExp</code>实例方法</h3></li>
</ul>
<p><code>RegExp</code>实例的主要方法是<code>exec()</code>，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，返回一个数组，否则返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但包含两个额外的属性：<code>index</code>和<code>input</code>。<code>index</code>是字符串中匹配模式的起始位置，<code>input</code>是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input);   <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);      <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);      <span class="comment">// &quot; and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);      <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果在这个模式上设置了<code>g</code>标记，则每次调用<code>exec()</code>都会在字符串中向前搜索下一个匹配项，直到搜索到字符串末尾，并且每次调用<code>exec()</code>都会更新<code>lastIndex</code>值，以反映上次匹配的最后一个字符的索引。否则无论对同一个字符串调用多少次<code>exec()</code>，也只会返回第一个匹配的信息，<code>lastIndex</code>在非全局模式下始终不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// sat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>如果模式设置了粘附标记<code>y</code>，则每次调用<code>exec()</code>就只会在<code>lastIndex</code>的位置上寻找匹配项。粘附标记覆盖全局标记。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/y</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以索引3对应的字符开头找不到匹配项，因此exec()返回null</span></span><br><span class="line"><span class="comment">// exec()没找到匹配项，于是将lastIndex设置为0</span></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches);             <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置lastIndex可以让粘附的模式通过exec()找到下一个匹配项：</span></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>;</span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>正则表达式的另一个方法是<code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回<code>true</code>，否则返回<code>false</code>。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况，常用于验证用户输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;000-00-0000&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;The pattern was matched.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>toLocaleString()</code>和<code>toString()</code>都返回正则表达式的字面量表示，而<code>valueOf()</code>方法返回正则表达式本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;gi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern.toString());        <span class="comment">//  /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.toLocaleString());  <span class="comment">//  /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.valueOf() === pattern);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3   RegExp构造函数属性"></a>5.2.3   <code>RegExp</code>构造函数属性</h3><p><code>RegExp</code>构造函数本身也有几个属性。这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。</p>
<table>
<thead>
<tr>
<th align="left">全名</th>
<th align="left">简写</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">input</td>
<td align="left">$_</td>
<td align="left">最后搜索的字符串（非标准特性）</td>
</tr>
<tr>
<td align="left">lastMatch</td>
<td align="left">$&amp;</td>
<td align="left">最后匹配的文本</td>
</tr>
<tr>
<td align="left">lastParen</td>
<td align="left">$+</td>
<td align="left">最后匹配的捕获组（非标准特性）</td>
</tr>
<tr>
<td align="left">leftContext</td>
<td align="left">$`</td>
<td align="left">input字符串中出现在lastMatch前面的文本</td>
</tr>
<tr>
<td align="left">rightContext</td>
<td align="left">$’</td>
<td align="left">input字符串中出现在lastMatch后面的文本</td>
</tr>
</tbody></table>
<p>通过这些属性可以提取出与<code>exec()</code>和<code>test()</code>执行的操作相关的信息。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);        <span class="comment">// this has been a short summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);  <span class="comment">// this has been a</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);    <span class="comment">// short</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen);    <span class="comment">// s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中括号语法来访问，因为大多数简写形式都不是合法的ECMAScript标识符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：Opera 不支持简写属性名</span></span><br><span class="line"><span class="comment"> * IE 不支持多行匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);      <span class="comment">// this has been a short summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$`&quot;</span>]);   <span class="comment">// this has been a</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]);   <span class="comment">// summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]);   <span class="comment">// short</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$+&quot;</span>]);   <span class="comment">// s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RegExp</code>还有其他几个构造函数属性，可以存储最多9个捕获组的匹配项。这些属性通过<code>RegExp.$1~RegExp.$9</code>来访问，分别包含第1~9个捕获组的匹配项。在调用<code>exec()</code>或<code>test()</code>时，这些属性就会被填充，然后就可以像下面这样使用它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);  <span class="comment">// sh</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2);  <span class="comment">// t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> <code>RegExp</code>构造函数的所有属性没有任何Web标准出处，因此不要在生产环境中使用它们。</p>
</blockquote>
<h3 id="5-2-4-正则表达式（补充）"><a href="#5-2-4-正则表达式（补充）" class="headerlink" title="5.2.4   正则表达式（补充）"></a>5.2.4   正则表达式（补充）</h3><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">只有在特殊字符之前的反斜杠表示下一个字符不是特殊字符，按照字面理解。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入的开始。如果有标记m，也匹配换行符后紧跟的位置。</td>
<td align="left"><code>/^A/</code>不匹配 <code>an A</code> 中的 <code>A</code>，但匹配 <code>An E</code> 中的 <code>A</code>。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入的结束。如果有标记m，也匹配换行符前的位置。<br>如果 ^和 $ 在一起，表示必须是精确匹配。</td>
<td align="left"><code>/t$/</code>不匹配 <code>eater</code> 中的 <code>t</code>，但匹配 <code>eat</code> 中的 <code>t</code>。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配前一个表达式 0 次或多次。等价于{0,}。</td>
<td align="left"><code>/bo*/</code>会匹配 <code>A ghost boooooed</code> 中的 <code>booooo</code> 和 <code>A bird warbled</code> 中的 <code>b</code>。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配前面一个表达式 1 次或者多次。等价于{1,}。</td>
<td align="left"><code>/a+/</code>会匹配 <code>candy</code> 中的 <code>a</code> 和 <code>caaaaaaandy</code> 中所有的 <code>a</code>。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面一个表达式 0 次或者 1 次。等价于{0,1}。<br>如果*<em>紧跟在任何量词 <em>、 +、? 或 {} 的后面</em></em>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）相反。</td>
<td align="left"><code>/e?le?/</code>匹配 <code>angel</code> 中的 <code>el</code>、<code>angle</code> 中的 <code>le</code> 以及 <code>oslo</code> 中的 <code>l</code>。<br><code>123abc</code> 使用<code>/\d+/</code>将会匹配 <code>123</code>，而使用<code>/\d+?/</code>则只会匹配到 <code>1</code>。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">（小数点）默认匹配除换行符之外的任何单个字符。</td>
<td align="left"><code>/.n/</code>将会匹配 <code>nay, an apple is on the tree</code> 中的 <code>an</code> 和 <code>on</code>。如果有s标记，也会匹配换行符。</td>
</tr>
<tr>
<td align="center">(x)</td>
<td align="left">匹配 <code>x</code> 并且记住匹配项，供此后使用。其中括号被称为<em>捕获括号</em>。</td>
<td align="left"><code>/(foo) (bar) \1 \2/ </code>中的 <code>(foo)</code> 和 <code>(bar)</code> 匹配并记住<code>foo bar foo bar</code> 中的前两个单词<code>foo</code>和<code>bar</code>。模式中的\1和\2表示第一个和第二个被捕获括号匹配的子字符串，即foo和bar，匹配原字符串中的后两个单词。\1、\2、…、\n是用在正则表达式的匹配环节，而在正则表达式的替换环节，则要使用像$1、$2、…、$n，例如”bar foo”.replace(/(…) (…)/,’ $2$1’)。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)，这里的n是数字。</td>
<td align="left"><code>/apple(,)\sorange\1/</code>匹配<code>apple, orange, cherry, peach.</code>中的<code>apple, orange,</code> 。</td>
</tr>
<tr>
<td align="center">(?:x)</td>
<td align="left">匹配 <code>x</code> 但是不记住匹配项。这种括号叫作<em>非捕获括号</em>，使得定义与正则表达式运算符一起使用的子表达式。</td>
<td align="left"><code>/foo&#123;1,2&#125;/</code>，<code>&#123;1,2&#125;</code> 将只应用于 <code>foo</code> 的最后一个 <code>o</code>。如果使用非捕获括号，<code>/(?:foo)&#123;1,2&#125;/</code>则会应用于整个 <code>foo</code> 单词。</td>
</tr>
<tr>
<td align="center">x(?=y)</td>
<td align="left">匹配<code>x</code>仅仅当<code>x</code>后面跟着<code>y</code>。这叫做先行断言。</td>
<td align="left"><code>/Jack(?=Sprat|Frost)/</code>匹配<code>Jack</code>仅当它后面跟着<code>Sprat</code>或者是<code>Frost</code>。但<code>Sprat</code>和<code>Frost</code>都不是匹配结果的一部分。</td>
</tr>
<tr>
<td align="center">(?&lt;=y)x</td>
<td align="left">匹配<code>x</code>仅当<code>x</code>前面是<code>y</code>。这叫做后行断言。</td>
<td align="left"><code>/(?&lt;=Jack|Tom)Sprat/</code>匹配<code>Sprat</code>仅仅当它前面是<code>Jack</code>或者是<code>Tom</code>。但<code>Jack</code>和<code>Tom</code>都不是匹配结果的一部分。</td>
</tr>
<tr>
<td align="center">x(?!y)</td>
<td align="left">仅仅当<code>x</code>后面不跟着<code>y</code>时匹配<code>x</code>，这被称为正向否定查找。</td>
<td align="left"><code>/\d+(?!.)/</code>匹配<code>141</code>而不是<code>3.141</code>。</td>
</tr>
<tr>
<td align="center">(?&lt;!<em>y</em>)x</td>
<td align="left">仅仅当<code>x</code>前面不是<code>y</code>时匹配<code>x</code>，这被称为反向否定查找。</td>
<td align="left"><code>/(?&lt;!-)\d+/</code>匹配 <code>3</code>而不是<code>-3</code>。</td>
</tr>
<tr>
<td align="center">x|y</td>
<td align="left">匹配<code>x</code>或者<code>y</code>。</td>
<td align="left"><code>/green|red/</code>匹配<code>green apple</code>中的<code>green</code>。</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n 是一个正整数，匹配了前面一个字符必须刚好出现了 n 次。</td>
<td align="left"><code>/a&#123;2&#125;/ </code>不匹配<code>candy</code>中的<code>a</code>,但匹配<code>caaandy</code>中的前两个<code>a</code>。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n是一个正整数，匹配前一个字符至少出现了n次。</td>
<td align="left"><code>/a&#123;2,&#125;/ </code>匹配 <code>aa</code>, <code>aaaa</code> ，但不匹配 <code>a</code>。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td>
<td align="left"><code>/a&#123;1, 3&#125;/</code> 匹配<code>candy</code>中的a，也匹配<code>caaaaaaandy</code>中的前三个a。</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="left">一个字符集合。匹配方括号中的任意字符，包括转义序列。可以使用破折号（-）来指定一个字符范围。点（.）和星号（*）这样的特殊符号在字符集中没有特殊的意义，可以但不用转义。</td>
<td align="left">[abcd] 和[a-d]是一样的。他们都匹配<code>brisket</code>中的<code>b</code>,也都匹配<code>city</code>中的<code>c</code>。</td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="left">一个反向字符集。它匹配任何没有包含在方括号中的字符。可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</td>
<td align="left">[^abc] 和 <code>[^a-c] </code>是一样的。他们匹配<code>brisket</code>中的<code>r</code>，也匹配<code>chop</code>中的<code>h</code>。</td>
</tr>
<tr>
<td align="center">[\b]</td>
<td align="left">匹配一个退格(U+0008)。（特例）</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个词的边界。但不包括匹配的字边界。</td>
<td align="left">/\bm/匹配<code>moon</code>中的<code>m</code>；<code>/oon\b/</code>匹配<code>oon</code>。<br><strong>注意：</strong>大写和小写的罗马字母，十进制数字和下划线字符被视为断词，不作为’’字’’字符。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">匹配一个非单词边界。</td>
<td align="left"><code>/\B../</code>匹配<code>noonday</code>中的<code>oo</code>, 而<code>/y\B../</code>匹配<code>possibly yesterday</code>中的<code>yes</code></td>
</tr>
<tr>
<td align="center">\cX</td>
<td align="left">当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。</td>
<td align="left"><code>/\cM/</code>匹配字符串中的 control-M (U+000D)。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配一个数字。等价于[0-9]。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符。等价于<code>[^0-9]</code>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符 (U+000C)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符 (U+000A)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符 (U+000D)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配一个空白字符，包括空格、制表符、换页符和换行符。</td>
<td align="left"><code>/\s\w*/</code>匹配<code>foo bar.</code>中的<code> bar</code>。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配一个非空白字符。</td>
<td align="left"><code>/\S\w*/</code>匹配<code>foo bar.</code>中的<code>foo</code>。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个水平制表符 (U+0009)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符 (U+000B)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配一个非单字字符。等价于<code>[^A-Za-z0-9_]</code>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\0</td>
<td align="left">匹配 NULL（U+0000）字符， 后面不能跟其它小数，因为\0<digits>是一个八进制转义序列。</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">\xhh</td>
<td align="left">匹配一个两位十六进制数（\x00-\xFF）表示的字符。</td>
<td align="left"><code>\x0A</code>等价于\n</td>
</tr>
<tr>
<td align="center">\uhhhh</td>
<td align="left">匹配一个四位十六进制数表示的 UTF-16 代码单元。</td>
<td align="left"><code>\u0009</code>等价于\t</td>
</tr>
<tr>
<td align="center">\u{hhhh}或\u{hhhhh}</td>
<td align="left">（仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3　原始值包装类型"></a>5.3　原始值包装类型</h2><p>ECMAScript提供了3种特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>原始值本身不是对象，因此逻辑上不应该有方法。这是因为当第二行访问<code>s1</code>时，是以读模式访问的，也就是从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3步：<br>(1) 创建一个<code>String</code>类型的实例；</p>
<p>(2) 调用实例上的特定方法；</p>
<p>(3) 销毁实例。</p>
<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也类似如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过<code>new</code>实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间，也就是无法在运行时给原始值添加属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.color);  <span class="comment">// undefined 实际上，这里又创建了一个新的String对象，但没有color属性</span></span><br></pre></td></tr></table></figure>
<p>虽然可以显式地使用<code>Boolean</code>、<code>Number</code>和<code>String</code>构造函数创建原始值包装对象。不过应该在必要时才这样，否则容易让开发者分不清到底是原始值还是引用值。在显式创建的原始值包装类型的实例上调用<code>typeof</code>会返回<code>&quot;object&quot;</code>，所有原始值包装对象都会转换为布尔值<code>true</code>。</p>
<p>另外，<code>Object</code>构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，使用<code>new</code>调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value);    <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number);    <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);   <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);       <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1   Boolean"></a>5.3.1   <code>Boolean</code></h3><p><code>Boolean</code>是对应布尔值的引用类型。要创建一个<code>Boolean</code>对象，就使用<code>Boolean</code>构造函数并传入<code>true</code>或<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><code>Boolean</code>的实例会重写<code>valueOf()</code>方法，返回一个原始值<code>true</code>或<code>false</code>。<code>toString()</code>方法被调用时也会被覆盖，返回字符串<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>。</p>
<p>建议不要使用<code>Boolean</code>对象，因为在布尔表达式中使用<code>Boolean</code>对象时，在布尔表达式中都会自动转换为<code>true</code>，容易引起误会。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(falseObject &amp;&amp; <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(falseValue &amp;&amp; <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>原始值和引用值（<code>Boolean</code>对象）还有几个区别。首先，<code>typeof</code>操作符对原始值返回<code>boolean</code>，但对引用值返回<code>&quot;object&quot;</code>。同样，<code>Boolean</code>对象是<code>Boolean</code>类型的实例，在使用<code>instaceof</code>操作符时返回<code>true</code>，但对原始值则返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);             <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);              <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2   Number"></a>5.3.2   <code>Number</code></h3><p><code>Number</code>是对应数值的引用类型。要创建一个<code>Number</code>对象，就使用<code>Number</code>构造函数并传入一个数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><code>Number</code>类型重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法。<code>valueOf()</code>方法返回<code>Number</code>对象表示的原始数值，另外两个方法返回数值字符串。<code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());   <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));  <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));  <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Number</code>类型还提供了几个用于将数值格式化为字符串的方法，如下：<br><code>toFixed()</code>方法返回包含指定小数点位数的数值字符串，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果返回值为<code>&quot;10.00&quot;</code>，小数位填充了0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。</p>
<p><code>toFixed()</code>自动舍入的特点可以用于处理货币。不过，多个浮点数值的数学计算不一定得到精确的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.01&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toExponential()</code>，返回以科学记数法表示的数值字符串。<code>toExponential()</code>接收一个参数，表示结果中小数的位数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>));  <span class="comment">// &quot;1.0e+1&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果想得到数值最适当的形式，可以使用<code>toPrecision()</code>，根据数值和精度来决定调用<code>toFixed()</code>还是<code>toExponential()</code>。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>与<code>Boolean</code>对象类似，同样不建议直接实例化<code>Number</code>对象。在处理原始数值和引用数值时，<code>typeof</code>和<code>instacnceof</code>操作符也会返回不同的结果。</p>
<p><code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>IEEE 754数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code>（<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/14/rLyY1VZMH5oQtD9.gif"
                      alt="gif.gif"
                >）到<code>Number.MAX_SAFE_INTEGER</code>（<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/14/3YnaD86ptI9Zwly.gif"
                      alt="gif _1_.gif"
                >）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用<code>Number.isSafeInteger()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>));             <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>));       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3   String"></a>5.3.3   <code>String</code></h3><p><code>String</code>是对应字符串的引用类型。要创建一个<code>String</code>对象，使用<code>String</code>构造函数并传入一个数值。<code>String</code>对象的方法可以在所有字符串原始值上调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>3个继承的方法<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。</p>
<h4 id="5-3-3-1-JavaScript字符"><a href="#5-3-3-1-JavaScript字符" class="headerlink" title="5.3.3.1   JavaScript字符"></a><strong>5.3.3.1   JavaScript字符</strong></h4><p>JavaScript字符串由16位码元（code unit）组成。对多数字符来说，每16位码元对应一个字符。字符串的<code>length</code>属性表示字符串包含多少16位码元。如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><code>charAt()</code>方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16位码元，并返回该码元对应的字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)); <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript字符串使用两种Unicode编码混合的策略：<code>UCS-2</code>和<code>UTF-16</code>。对于可以采用16位编码的字符<code>（U+0000~U+FFFF）</code>，这两种编码实际上是一样的。<br><code>charCodeAt()</code>方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;   <span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是U+0063</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">// 99</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>方法用于根据给定的<code>UTF-16</code>码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>));  <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>));          <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于U+0000~U+FFFF范围内的字符，在Unicode中称为<strong>基本多语言平面</strong><code>（BMP）</code>，都是用16位表示的，<code>length</code>、<code>charAt()</code>、<code>charCodeAt()</code>和<code>fromCharCode()</code>返回的结果都跟预期是一样的。<br>为了表示更多的字符，每个字符使用另外16位去选择一个<strong>增补平面</strong>，这种策略称为<strong>代理对</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;smiling face with smiling eyes&quot; 表情符号的编码是U+1F60A</span></span><br><span class="line"><span class="comment">// 0x1F60A === 128522</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length);          <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>));       <span class="comment">// &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">3</span>));       <span class="comment">// &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));   <span class="comment">// 55357</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">3</span>));   <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1F60A</span>)); <span class="comment">// 😊</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成）。<br>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用<code>codePointAt()</code>来代替<code>charCodeAt()</code>。<code>codePointAt()</code>接收16位码元的索引并返回该索引位置上的码点（code point）。<strong>码点</strong>是Unicode中一个字符的完整标识，可能是16位，也可能是32位，但如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">2</span>)); <span class="comment">// 128522</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">3</span>)); <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">4</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...<span class="string">&quot;ab😊de&quot;</span>]); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;😊&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>也有一个对应的<code>fromCodePoint()</code>。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>, <span class="number">98</span>, <span class="number">128522</span>, <span class="number">100</span>, <span class="number">101</span>));   <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-2-normalize-方法"><a href="#5-3-3-2-normalize-方法" class="headerlink" title="5.3.3.2   normalize()方法"></a>5.3.3.2   <code>normalize()</code><strong>方法</strong></h4><p>某些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP字符表示，也可以通过一个代理对表示。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>));       <span class="comment">// Å，上面带圆圈的大写拉丁字母A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>));       <span class="comment">// Å，长度单位“埃”</span></span><br><span class="line"><span class="comment">// Å，U+004：大写拉丁字母A， U+030A：上面加个圆圈</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>));</span><br></pre></td></tr></table></figure>
<p>比较操作符不在乎字符看起来是什么样的，因此这3个字符互不相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1, a2, a3); <span class="comment">// Å, Å, Å</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a2);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a3);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>为解决这个问题，Unicode提供了4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。</p>
<ul>
<li>NFD（Normalization Form D）；</li>
<li>NFC（Normalization Form C）；</li>
<li>NFKD（Normalization Form KD）；</li>
<li>NFKC（Normalization Form KC）。</li>
</ul>
<p>可以使用<code>normalize()</code>方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：<code>&quot;NFD&quot;</code>、<code>&quot;NFC&quot;</code>、<code>&quot;NFKD&quot;</code>或<code>&quot;NFKC&quot;</code>。<br>通过比较字符串与其调用<code>normalize()</code>的返回值，就可以知道该字符串是否已经规范化了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="comment">// U+00C5是对0+212B进行NFC/NFKC规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// U+212B是未规范化的</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// U+0041/U+030A是对0+212B进行NFD/NFKD规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFD&quot;</span>) === a2.normalize(<span class="string">&quot;NFD&quot;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2.normalize(<span class="string">&quot;NFKC&quot;</span>) === a3.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFC&quot;</span>) === a3.normalize(<span class="string">&quot;NFC&quot;</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-3-字符串操作方法"><a href="#5-3-3-3-字符串操作方法" class="headerlink" title="5.3.3.3   字符串操作方法"></a><strong>5.3.3.3   字符串操作方法</strong></h4><p><code>concat()</code>，可以接收任意多个参数，用于将一个或多个字符串拼接成一个新字符串。但更常用的方式是使用加号操作符（<code>+</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);      <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>slice()</code>、<code>substr()</code>和<code>substring()</code>。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数都表示子字符串开始的位置，对<code>slice()</code>和<code>substring()</code>而言，第二个参数是提取结束的位置（不包含该位置）。对<code>substr()</code>而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾，且不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));    <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));   <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure>
<p>当某个参数是负值时，这3个方法的行为又有不同。<code>slice()</code>方法将所有负值参数都当成字符串长度加上负参数值。<code>substring()</code>方法会将所有负参数值都转换为0。<code>substr()</code>方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(-<span class="number">3</span>));         <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(-<span class="number">3</span>));     <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(-<span class="number">3</span>));        <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, -<span class="number">4</span>));      <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, -<span class="number">4</span>));  <span class="comment">// &quot;hel&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, -<span class="number">4</span>));     <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure>
<p><code>substring(3, 0)</code>，等价于<code>substring(0, 3)</code>，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对<code>substr()</code>来说，第二个参数会被转换为<code>0</code>，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</p>
<h4 id="5-3-3-4-字符串位置方法"><a href="#5-3-3-4-字符串位置方法" class="headerlink" title="5.3.3.4   字符串位置方法"></a><strong>5.3.3.4   字符串位置方法</strong></h4><p>有两个方法用于在字符串中定位子字符串：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回<code>-1</code>）。区别在于，<code>indexOf()</code>方法从字符串开头开始查找子字符串，而<code>lastIndexOf()</code>方法从字符串末尾开始查找子字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>));     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，<code>indexOf()</code>会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；<code>lastIndexOf()</code>则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>));     <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>使用第二个参数并循环调用<code>indexOf()</code>或<code>lastIndexOf()</code>，就可以在字符串中找到所有的目标子字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> pos = stringValue.indexOf(<span class="string">&quot;e&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">  positions.push(pos);</span><br><span class="line">  pos = stringValue.indexOf(<span class="string">&quot;e&quot;</span>, pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positions); <span class="comment">// [3,24,32,35,52]</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-5-字符串包含方法"><a href="#5-3-3-5-字符串包含方法" class="headerlink" title="5.3.3.5   字符串包含方法"></a>5.3.3.5   <strong>字符串包含方法</strong></h4><p>用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code>、<code>endsWith()</code>和<code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。区别在于，<code>startsWith()</code>检查开始于索引0的匹配项，<code>endsWith()</code>检查开始于索引<code>(string.length - substring.length)</code>的匹配项，而<code>includes()</code>检查整个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;bar&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;qux&quot;</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>startsWith()</code>和<code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-6-trim-方法"><a href="#5-3-3-6-trim-方法" class="headerlink" title="5.3.3.6   trim()方法"></a>5.3.3.6   <code>trim()</code><strong>方法</strong></h4><p><code>trim()</code>方法，会创建字符串的一个副本，删除前、后所有空格符，再返回结果，原始字符串不受影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;  hello world  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.trim();</span><br><span class="line"><span class="built_in">console</span>.log(stringValue);         <span class="comment">// &quot;  hello world &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(trimmedStringValue);  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>trimLeft()</code>和<code>trimRight()</code>方法分别清理字符串开始和末尾空格符。</p>
<h4 id="5-3-3-7-repeat-方法"><a href="#5-3-3-7-repeat-方法" class="headerlink" title="5.3.3.7   repeat()方法"></a>5.3.3.7   <code>repeat()</code><strong>方法</strong></h4><p>ECMAScript在所有字符串上都提供了<code>repeat()</code>方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>);</span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-8-padStart-和padEnd-方法"><a href="#5-3-3-8-padStart-和padEnd-方法" class="headerlink" title="5.3.3.8   padStart()和padEnd()方法"></a>5.3.3.8   <code>padStart()</code><strong>和</strong><code>padEnd()</code><strong>方法</strong></h4><p><code>padStart()</code>和<code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>));       <span class="comment">// &quot;   foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));  <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>));         <span class="comment">// &quot;foo   &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));    <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二个参数如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>));        <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>));   <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>));          <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-9-字符串迭代与解构"><a href="#5-3-3-9-字符串迭代与解构" class="headerlink" title="5.3.3.9   字符串迭代与解构"></a>5.3.3.9   <strong>字符串迭代与解构</strong></h4><p>字符串的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>在<code>for-of</code>循环中可以通过这个迭代器按序访问每个字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure>
<p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...message]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-10-字符串大小写转换"><a href="#5-3-3-10-字符串大小写转换" class="headerlink" title="5.3.3.10   字符串大小写转换"></a><strong>5.3.3.10   字符串大小写转换</strong></h4><p>大小写转换，包括4个方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>。<code>toLocaleLowerCase()</code>和<code>toLocaleUpperCase()</code>方法旨在基于特定地区实现。在少数语言中，Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());  <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-11-字符串模式匹配方法"><a href="#5-3-3-11-字符串模式匹配方法" class="headerlink" title="5.3.3.11   字符串模式匹配方法"></a>5.3.3.11   <strong>字符串模式匹配方法</strong></h4><p><code>match()</code>方法，这个方法本质上跟<code>RegExp</code>对象的<code>exec()</code>方法相同。<code>match()</code>方法接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">// 等价于pattern.exec(text)</span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// &quot;cat&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>match()</code>方法返回的数组与<code>RegExp</code>对象的<code>exec()</code>方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。<br>另一个查找模式的字符串方法是<code>search()</code>。这个方法唯一的参数与<code>match()</code>方法一样：正则表达式字符串或<code>RegExp</code>对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。<code>search()</code>始终从字符串开头向后匹配模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>replace()</code>方法，接收两个参数，第一个参数可以是一个<code>RegExp</code>对象或一个字符串（不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.replace(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &quot;cond, bat, sat, fat&quot;</span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure>
<p>当第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262中规定了下表中的值。<br>|字符序列|替换文本|<br>|:—:|:—:|<br>|$$|$|<br>|$&amp;|匹配整个模式的子字符串。与RegExp.lastMatch相同。|<br>|$’|匹配的子字符串之前的字符串。与RegExp.rightContext相同。|<br>|$`|匹配的子字符串之后的字符串。与RegExp.leftContext相同。|<br>|$<em>n</em>或$<em>nn</em>|匹配第<em>n</em>个或第<em>nn</em>个捕获组的字符串，其中<em>n</em>是0<del>9或01</del>99。比如，$1是匹配第一个捕获组的字符串，$2是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串。|</p>
<p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">&quot;word ($1)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure>
<p>当<code>replace()</code>的第二个参数是一个函数时，在只有一个匹配项时，这个函数会收到3个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(htmlEscape(<span class="string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后一个与模式匹配相关的字符串方法是<code>split()</code>。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是<code>RegExp</code>对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;red,blue,green,yellow&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.split(<span class="string">&quot;,&quot;</span>);       <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.split(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>);    <span class="comment">// [&quot;red&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.split(<span class="regexp">/[^,]+/</span>);   <span class="comment">// [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>
<p>注意在最后一次调用<code>split()</code>时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（<code>&quot;red&quot;</code>）和末尾（<code>&quot;yellow&quot;</code>）。</p>
<h4 id="5-3-3-12-localeCompare-方法"><a href="#5-3-3-12-localeCompare-方法" class="headerlink" title="5.3.3.12   localeCompare()方法"></a>5.3.3.12   <code>localeCompare()</code>方法</h4><p><code>localeCompare()</code>，比较两个字符串，返回如下3个值中的一个。</p>
<ul>
<li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是<code>-1</code>，具体还要看与实际值相关的实现。）</li>
<li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是<code>1</code>，具体还要看与实际值相关的实现。）</li>
<li>如果字符串与字符串参数相等，则返回<code>0</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>));    <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用<code>localeCompare()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = stringValue.localeCompare(value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; comes before the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; comes after the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; is equal to the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">determineOrder(<span class="string">&quot;brick&quot;</span>);</span><br><span class="line">determineOrder(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">determineOrder(<span class="string">&quot;zoo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>localeCompare()</code>的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是ECMAScript实现的标准语言，<code>localeCompare()</code>区分大小写，大写字母排在小写字母前面。</p>
<h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4　单例内置对象"></a>5.4　单例内置对象</h2><p>内置对象：由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象。包括<code>Object</code>、<code>Array</code>和<code>String</code>，还有另外两个单例内置对象：<code>Global</code>和<code>Math</code>。</p>
<h3 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1   Global"></a>5.4.1   <code>Global</code></h3><p>代码不会显式地访问<code>Global</code>对象，事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成<code>Global</code>对象的属性 。</p>
<h4 id="5-4-1-1-URL编码方法"><a href="#5-4-1-1-URL编码方法" class="headerlink" title="5.4.1.1   URL编码方法"></a><strong>5.4.1.1   URL编码方法</strong></h4><p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。</p>
<p><code>ecnodeURI()</code>方法用于对整个URI进行编码，<code>encodeURIComponent()</code>方法用于编码URI中单独的组件，主要区别是，<code>encodeURI()</code>不会编码属于URL组件的特殊字符，比如：、/、?、#，而<code>encodeURIComponent()</code>会编码它发现的所有非标准字符。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));  </span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 一般来说，使用<code>encodeURIComponent()</code>应该频率更高，因为编码查询字符串参数比编码基准URI的次数更多。</p>
</blockquote>
<p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>相对的是<code>decodeURI()</code>和<code>decodeURIComponent()</code>。<code>decodeURI()</code>只对使用<code>encodeURI()</code>编码过的字符解码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));<span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));<span class="comment">// http:// www.wrox.com/illegal value.js#start</span></span><br></pre></td></tr></table></figure>
<h4 id="5-4-1-2-eval-方法"><a href="#5-4-1-2-eval-方法" class="headerlink" title="5.4.1.2   eval()方法"></a>5.4.1.2   <code>eval()</code><strong>方法</strong></h4><p><code>eval()</code>方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过<code>eval()</code>执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在<code>eval()</code>调用内部被引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>);  <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;let msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//Reference Error: msg is not defined</span></span><br></pre></td></tr></table></figure>
<p>通过<code>eval()</code>定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在<code>eval()</code>执行的时候才会被创建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sayHi();<span class="comment">// sayHi is not defined</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>但在严格模式下，在<code>eval()</code>内部创建的变量和函数无法被外部访问，赋值给<code>eval</code>也会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="string">&quot;hi&quot;</span>;  <span class="comment">// 导致错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 ** 使用<code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS利用暴露出很大的攻击面。</p>
</blockquote>
<h4 id="5-4-1-3-window对象"><a href="#5-4-1-3-window对象" class="headerlink" title="5.4.1.3   window对象"></a>5.4.1.3   <code>window</code><strong>对象</strong></h4><p>虽然ECMA-262没有规定直接访问<code>Global</code>对象的方式，但浏览器将<code>window</code>对象实现为<code>Global</code>对象的代理。因此，所有全局作用域中声明的变量和函数都变成了<code>window</code>的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一种获取<code>Global</code>对象的方式是使用如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">global</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2   Math"></a>5.4.2   <code>Math</code></h3><p><code>Math</code>对象提供了一些辅助计算的属性和方法，它提供的计算要比在JavaScript实现快，因为<code>Math</code>对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令，但问题是精度会因浏览器、操作系统、指令集和硬件而异。</p>
<h4 id="5-4-2-1-Math对象属性"><a href="#5-4-2-1-Math对象属性" class="headerlink" title="5.4.2.1   Math对象属性"></a>5.4.2.1   <code>Math</code><strong>对象属性</strong></h4><p><code>Math</code>对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Math.E</code></td>
<td align="left">自然对数的基数e的值</td>
</tr>
<tr>
<td align="left"><code>Math.LN10</code></td>
<td align="left">10为底的自然对数</td>
</tr>
<tr>
<td align="left"><code>Math.LN2</code></td>
<td align="left">2为底的自然对数</td>
</tr>
<tr>
<td align="left"><code>Math.LOG2E</code></td>
<td align="left">以2为底e的对数</td>
</tr>
<tr>
<td align="left"><code>Math.LOG10E</code></td>
<td align="left">以10为底e的对数</td>
</tr>
<tr>
<td align="left"><code>Math.PI</code></td>
<td align="left">π的值</td>
</tr>
<tr>
<td align="left"><code>Math.SQRT1_2</code></td>
<td align="left">1/2的平方根</td>
</tr>
<tr>
<td align="left"><code>Math.SQRT2</code></td>
<td align="left">2的平方根</td>
</tr>
</tbody></table>
<h4 id="5-4-2-2-min-和max-方法"><a href="#5-4-2-2-min-和max-方法" class="headerlink" title="5.4.2.2   min()和max()方法"></a>5.4.2.2   <code>min()</code><strong>和</strong><code>max()</code><strong>方法</strong></h4><p><code>min()</code>和<code>max()</code>方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>));  <span class="comment">// 54</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>));  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...val);</span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-3-舍入方法"><a href="#5-4-2-3-舍入方法" class="headerlink" title="5.4.2.3   舍入方法"></a>5.4.2.3   <strong>舍入方法</strong></h4><p>接下来是用于把小数值舍入为整数的4个方法，这几个方法处理舍入的方式如下所述。</p>
<ul>
<li><code>Math.ceil()</code>方法始终向上舍入为最接近的整数。</li>
<li><code>Math.floor()</code>方法始终向下舍入为最接近的整数。</li>
<li><code>Math.round()</code>方法执行四舍五入。</li>
<li><code>Math.fround()</code>方法返回数值最接近的单精度（32位）浮点值表示。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>));   <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>));  <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>));  <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.4</span>));  <span class="comment">// 0.4000000059604645</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.5</span>));  <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>));  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-4-random-方法"><a href="#5-4-2-4-random-方法" class="headerlink" title="5.4.2.4   random()方法"></a>5.4.2.4   <code>random()</code><strong>方法</strong></h4><p><code>Math.random()</code>方法返回一个0~1范围内的随机数，其中包含0但不包含1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total_number_of_choices + first_possible_value)</span><br></pre></td></tr></table></figure>
<p>比如如果想从1~10范围内随机选择一个数，代码就是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **如果为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），建议使用<code>window.crypto.getRandomValues()</code>。</p>
</blockquote>
<h4 id="5-4-2-5-其他方法"><a href="#5-4-2-5-其他方法" class="headerlink" title="5.4.2.5   其他方法"></a>5.4.2.5   <strong>其他方法</strong></h4><p><code>Math</code>对象还有很多涉及各种简单或高阶数运算的方法。下表总结了<code>Math</code>对象的其他方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Math.abs(x)</code></td>
<td align="left">返回x的绝对值</td>
</tr>
<tr>
<td align="left"><code>Math.exp(x)</code></td>
<td align="left">返回<code>Math.E</code>的x次幂</td>
</tr>
<tr>
<td align="left"><code>Math.expm1(x)</code></td>
<td align="left">等于<code>Math.exp(x)</code> - 1</td>
</tr>
<tr>
<td align="left"><code>Math.log(x)</code></td>
<td align="left">返回x的自然对数</td>
</tr>
<tr>
<td align="left"><code>Math.log1p(x)</code></td>
<td align="left">等于1 +<code> Math.log(x)</code></td>
</tr>
<tr>
<td align="left"><code>Math.pow(x,power)</code></td>
<td align="left">返回x的<em>power</em>次幂</td>
</tr>
<tr>
<td align="left"><code>Math.hypot(...nums)</code></td>
<td align="left">返回<code>nums</code>中每个数平方和的平方根</td>
</tr>
<tr>
<td align="left"><code>Math.clz32(x)</code></td>
<td align="left">返回32位整数x的前置零的数量</td>
</tr>
<tr>
<td align="left"><code>Math.sign(x)</code></td>
<td align="left">返回表示x符号的1、0、-0或-1</td>
</tr>
<tr>
<td align="left"><code>Math.trunc(x)</code></td>
<td align="left">返回x的整数部分，删除所有小数</td>
</tr>
<tr>
<td align="left"><code>Math.sqrt(x)</code></td>
<td align="left">返回x的平方根</td>
</tr>
<tr>
<td align="left"><code>Math.cbrt(x)</code></td>
<td align="left">返回x的立方根</td>
</tr>
<tr>
<td align="left"><code>Math.atan2(y,x)</code></td>
<td align="left">返回<em>y</em>/x的反正切</td>
</tr>
<tr>
<td align="left"><code>Math.cos(x)</code>/<code>Math.acos(x)</code>/<code>Math.acosh(x)</code></td>
<td align="left">返回x的余弦/反余弦/反双曲余弦</td>
</tr>
<tr>
<td align="left"><code>Math.sin(x)</code>/<code>Math.asin(x)</code>/<code>Math.asinh(x)</code></td>
<td align="left">返回x的正弦/反正弦/反双曲正弦</td>
</tr>
<tr>
<td align="left"><code>Math.tan(x)</code>/<code>Math.atan(x)</code>/<code>Math.atanh(x)</code></td>
<td align="left">返回x的正切/反正切/反双曲正切</td>
</tr>
</tbody></table>
<p>即便这些方法都是由ECMA-262定义的，对正弦、余弦、正切等计算的实现仍然取决于浏览器，因为计算这些值的方式有很多种。因此，这些方法的精度可能因实现而异。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>10-函数</title>
    <url>/2021/04/19/note/JavaScript/10-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数实际上是对象，每个函数都是<code>Function</code>类型的实例，而<code>Function</code>也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，函数定义最后没有加分号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的，这里的函数末尾是有分号的，与任何变量初始化语句一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后一种定义函数的方式是使用<code>Function</code>构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>);  <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
<p>不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规ECMAScript代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是很重要的。而上面这种语法很好地诠释了这些概念。</p>
<blockquote>
<p><strong>注意</strong>这几种实例化函数对象的方式之间存在微妙但重要的差别。</p>
</blockquote>
<h2 id="10-1-箭头函数"><a href="#10-1-箭头函数" class="headerlink" title="10.1　箭头函数"></a>10.1　箭头函数</h2><p>ECMAScript 6新增了使用胖箭头（<code>=&gt;</code>）语法定义函数表达式的能力。很大程度上，这与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrowSum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> functionExpressionSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>箭头函数简洁的语法非常适合嵌入函数的场景：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(ints.map(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;));  <span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; <span class="keyword">return</span> i + <span class="number">1</span> &#125;));        <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">3</span> * x; &#125;;</span><br><span class="line"><span class="comment">// 没有参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> getRandom = <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random(); &#125;;</span><br><span class="line"><span class="comment">// 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, <span class="function"><span class="params">b</span> =&gt;</span> &#123; <span class="keyword">return</span> a * b; &#125;;</span><br></pre></td></tr></table></figure>
<p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效，而且返回相应的值</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="number">3</span> * x;</span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> setName = <span class="function">(<span class="params">x</span>) =&gt;</span> x.name = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line">setName(value);</span><br><span class="line"><span class="built_in">console</span>.log(value.name); <span class="comment">// &quot;Matt&quot;</span></span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="keyword">return</span> a * b;</span><br></pre></td></tr></table></figure>
<p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用<code>arguments</code>、<code>super</code>和<code>new.target</code>，也不能用作构造函数，箭头函数也没有<code>prototype</code>属性。</p>
<h2 id="10-2-函数名"><a href="#10-2-函数名" class="headerlink" title="10.2　函数名"></a>10.2　函数名</h2><p>因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称。使用不带括号的函数名会访问函数指针，而不会执行函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));         <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;</span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 6的所有函数对象都会暴露一个只读的<code>name</code>属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用<code>Function</code>构造函数创建的，则会标识成<code>&quot;anonymous&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.name);               <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.name);               <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.name);               <span class="comment">// baz</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function">() =&gt;</span> &#123;&#125;).name);        <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);  <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure>
<p>如果函数是一个获取函数、设置函数，或者使用<code>bind()</code>实例化，那么标识符前面会加上一个前缀：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name);    <span class="comment">// bound foo</span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  years: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.years;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">newAge</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.years = newAge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(dog, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.get.name);  <span class="comment">// get age</span></span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.set.name);  <span class="comment">// set age</span></span><br></pre></td></tr></table></figure>
<h2 id="10-3-理解参数"><a href="#10-3-理解参数" class="headerlink" title="10.3　理解参数"></a>10.3　理解参数</h2><p>ECMAScript函数的参数跟大多数其他语言不同。ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型。当定义函数时确定了要接收参数的个数，在调用时可以多传、少传，甚至不传，解释器都不会报错。</p>
<p>之所以会这样，主要是因为ECMAScript函数的参数在内部表现为一个数组。在使用<code>function</code>关键字定义（非箭头）函数时，可以在函数内部访问<code>arguments</code>对象，从中取得传进来的每个参数值。</p>
<p><code>arguments</code>对象是一个类数组对象（但不是<code>Array</code>的实例），因此可以使用中括号语法访问其中的元素。</p>
<p>在下面的例子中，<code>sayHi()</code>函数的第一个参数叫<code>name</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>arguments[0]</code>取得相同的参数值。因此，把函数重写成不声明参数也可以。与其他语言不同，在ECMAScript中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>arguments</code>对象的<code>length</code>属性检查传入的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howManyArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">howManyArgs(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>);  <span class="comment">// 2</span></span><br><span class="line">howManyArgs();              <span class="comment">// 0</span></span><br><span class="line">howManyArgs(<span class="number">12</span>);            <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>arguments</code>对象还可以跟命名参数一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num1 + <span class="number">10</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>arguments</code>对象的值始终会与对应的命名参数同步。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只传了一个参数，然后把<code>arguments[1]</code>设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为<code>arguments</code>对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。<br>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是<code>undefined</code>。这就类似于定义了变量而没有初始化。比如，如果只给<code>doAdd()</code>传了一个参数，那么<code>num2</code>的值就是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>);  <span class="comment">// 1,undefined</span></span><br></pre></td></tr></table></figure>
<p>严格模式下，<code>arguments</code>会有一些变化。首先，像前面那样给<code>arguments[1]</code>赋值不会再影响<code>num2</code>的值。其次，在函数中尝试重写<code>arguments</code>对象会导致语法错误。（代码也不会执行。）</p>
<h3 id="10-3-1-箭头函数中的参数"><a href="#10-3-1-箭头函数中的参数" class="headerlink" title="10.3.1   箭头函数中的参数"></a>10.3.1   箭头函数中的参数</h3><p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用<code>arguments</code>关键字访问，而只能通过定义的命名参数访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">bar(<span class="number">5</span>);  <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>虽然箭头函数中没有<code>arguments</code>对象，但可以在包装函数中把它提供给箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line">  &#125;;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>ECMAScript中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</p>
</blockquote>
<h2 id="10-4-没有重载"><a href="#10-4-没有重载" class="headerlink" title="10.4　没有重载"></a>10.4　没有重载</h2><p>ECMAScript函数不能像传统编程那样重载。在其他语言如Java，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。</p>
<p>如果在ECMAScript中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>
<p>前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。</p>
<h2 id="10-5-默认参数值"><a href="#10-5-默认参数值" class="headerlink" title="10.5　默认参数值"></a>10.5　默认参数值</h2><p>在ECMAScript5.1及以前，实现默认参数的一种常用方式就是检测某个参数是否等于<code>undefined</code>，如果是则意味着没有传这个参数，那就给它赋一个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = (<span class="keyword">typeof</span> name !== <span class="string">&#x27;undefined&#x27;</span>) ? name : <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());         <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br></pre></td></tr></table></figure>
<p>ES6写法，只要在函数定义中的参数后面用<code>=</code>就可以为参数赋一个默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing());         <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br></pre></td></tr></table></figure>
<p>给参数传<code>undefined</code>相当于没有传值，不过这样可以利用多个独立的默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                 <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));          <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="literal">undefined</span>, <span class="string">&#x27;VI&#x27;</span>));  <span class="comment">// &#x27;King Henry VI&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在使用默认参数时，<code>arguments</code>对象的值不反映参数的默认值，只反映传给函数的参数。跟ES5严格模式一样，修改命名参数也不会影响<code>arguments</code>对象，它始终以调用函数时传入的值为准：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());         <span class="comment">// &#x27;King undefined&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis&#x27;</span></span><br></pre></td></tr></table></figure>
<p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> romanNumerals = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> ordinality = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumerals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每次调用后递增</span></span><br><span class="line">  <span class="keyword">return</span> romanNumerals[ordinality++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = getNumerals()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                <span class="comment">// &#x27;King Henry I&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>, <span class="string">&#x27;XVI&#x27;</span>));  <span class="comment">// &#x27;King Louis XVI&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                <span class="comment">// &#x27;King Henry II&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                <span class="comment">// &#x27;King Henry III&#x27;</span></span><br></pre></td></tr></table></figure>
<p>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。<br>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> makeKing = <span class="function">(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) =&gt;</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-1-默认参数作用域与暂时性死区"><a href="#10-5-1-默认参数作用域与暂时性死区" class="headerlink" title="10.5.1   默认参数作用域与暂时性死区"></a>10.5.1   默认参数作用域与暂时性死区</h3><p>因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。</p>
<p>给多个参数定义默认值实际上跟使用<code>let</code>关键字顺序声明变量一样。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry VIII</span></span><br></pre></td></tr></table></figure>
<p>这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象这个过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> numerals = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry Henry</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;king&#x27;</span>)); <span class="comment">// King King King</span></span><br></pre></td></tr></table></figure>
<p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第一个参数会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = numerals, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第二个参数会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = defaultNumeral</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defaultNumeral = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-6-参数扩展与收集"><a href="#10-6-参数扩展与收集" class="headerlink" title="10.6　参数扩展与收集"></a>10.6　参数扩展与收集</h2><p>ECMAScript 6新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p>
<h3 id="10-6-1-扩展参数"><a href="#10-6-1-扩展参数" class="headerlink" title="10.6.1　扩展参数"></a>10.6.1　扩展参数</h3><p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。</p>
<p>假设有如下函数定义，它会将所有传入的参数累加起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用扩展操作符，想把定义在这个函数里的数组拆分，那么就得用<code>apply()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum.apply(<span class="literal">null</span>, values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum(...values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum(-<span class="number">1</span>, ...values));          <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values, <span class="number">5</span>));           <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(-<span class="number">1</span>, ...values, <span class="number">5</span>));       <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]));  <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<p>对函数中的<code>arguments</code>对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">countArguments(-<span class="number">1</span>, ...values);          <span class="comment">// 5</span></span><br><span class="line">countArguments(...values, <span class="number">5</span>);           <span class="comment">// 5</span></span><br><span class="line">countArguments(-<span class="number">1</span>, ...values, <span class="number">5</span>);       <span class="comment">// 6</span></span><br><span class="line">countArguments(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]);  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p><code>arguments</code>对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">a, b, c = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>]));      <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));    <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>]));          <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]));        <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));      <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="10-6-2-收集参数"><a href="#10-6-2-收集参数" class="headerlink" title="10.6.2　收集参数"></a>10.6.2　收集参数</h3><p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似<code>arguments</code>对象的构造机制，只不过收集参数的结果会得到一个<code>Array</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 顺序累加values中的所有值</span></span><br><span class="line">  <span class="comment">// 初始值的总和为0</span></span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">...values, lastValue</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ignoreFirst</span>(<span class="params">firstValue, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line">ignoreFirst();       <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>);      <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// [2]</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<p>箭头函数虽然不支持<code>arguments</code>对象，但支持收集参数的定义方式，因此也可以实现与使用<code>arguments</code>一样的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>使用收集参数并不影响<code>arguments</code>对象，它仍然反映调用时传给函数的参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);         <span class="comment">// [1, 2, 3]</span></span><br><span class="line">  <span class="built_in">console</span>.log(values);            <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<h2 id="10-7-函数声明与函数表达式"><a href="#10-7-函数声明与函数表达式" class="headerlink" title="10.7　函数声明与函数表达式"></a>10.7　函数声明与函数表达式</h2><p>函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作<strong>函数声明提升</strong>（function declaration hoisting）。在执行代码时，JavaScript引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明<strong>提升</strong>到顶部。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 没问题</span><br><span class="line">console.log(sum(10, 10));</span><br><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数定义包含在一个变量初始化语句中，这意味着代码如果没有执行到那一行，那么执行上下文中就没有函数的定义。这并不是因为使用<code>let</code>而导致的，使用<code>var</code>关键字也会碰到同样的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>在使用函数表达式初始化变量时，也可以给函数一个名称，比如<code>let sum = function sum() &#123;&#125;</code>。</p>
</blockquote>
<h2 id="10-8-函数作为值"><a href="#10-8-函数作为值" class="headerlink" title="10.8　函数作为值"></a>10.8　函数作为值</h2><p>因为函数名在ECMAScript中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，如果是访问函数而不是调用函数，那就必须不带括号，而不能是它们的执行结果。<br>从一个函数中返回另一个函数也是可以的。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个<code>sort()</code>方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;Zachary&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;</span><br><span class="line">];</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Nicholas</span></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Zachary</span></span><br></pre></td></tr></table></figure>
<h2 id="10-9-函数内部"><a href="#10-9-函数内部" class="headerlink" title="10.9　函数内部"></a>10.9　函数内部</h2><h3 id="10-9-1arguments"><a href="#10-9-1arguments" class="headerlink" title="10.9.1arguments"></a>10.9.1<code>arguments</code></h3><p><code>arguments</code>是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以<code>function</code>关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但<code>arguments</code>对象其实还有一个<code>callee</code>属性，是一个指向<code>arguments</code>对象所在函数的指针。来看下面这个经典的阶乘函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这个函数要正确执行就必须保证函数名是<code>factorial</code>，从而导致了紧密耦合。使用<code>arguments.callee</code>就可以让函数逻辑与函数名解耦，这意味着无论函数叫什么名称，都可以引用正确的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-9-2this"><a href="#10-9-2this" class="headerlink" title="10.9.2this"></a>10.9.2<code>this</code></h3><p>另一个特殊的对象是<code>this</code>，它在标准函数和箭头函数中有不同的行为。</p>
<p>在标准函数中，<code>this</code>引用的是把函数当成方法调用的上下文对象，这时候通常称其为<code>this</code>值（在网页的全局上下文中调用函数时，<code>this</code>指向<code>windows</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;  </span><br><span class="line">sayColor();    <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">// &#x27;blue&#x27;</span></span><br></pre></td></tr></table></figure>
<p>函数名只是保存指针的变量。因此全局定义的<code>sayColor()</code>函数和<code>o.sayColor()</code>是同一个函数，只不过执行的上下文不同。<br>在箭头函数中，<code>this</code>引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对<code>sayColor()</code>的两次调用中，<code>this</code>引用的都是<code>window</code>对象，因为这个箭头函数是在<code>window</code>上下文中定义的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> sayColor = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">sayColor();    <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在事件回调或定时回调中调用某个函数时，<code>this</code>值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的<code>this</code>会保留定义该函数时的上下文：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">  <span class="comment">// this引用King的实例</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line">  <span class="comment">// this引用window对象</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King();  <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> Queen(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="10-9-3caller"><a href="#10-9-3caller" class="headerlink" title="10.9.3caller"></a>10.9.3<code>caller</code></h3><p>函数对象上的<code>caller</code>属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer(); </span><br></pre></td></tr></table></figure>
<p>如果要降低耦合度，则可以通过<code>arguments.callee.caller</code>来引用同样的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>在严格模式下访问<code>arguments.callee</code>会报错。在非严格模式下<code>arguments.caller</code>始终是<code>undefined</code>，但在严格模式下访问它会报错。<br>严格模式下不能给函数的<code>caller</code>属性赋值，否则会导致错误。</p>
<h3 id="10-9-4new-target"><a href="#10-9-4new-target" class="headerlink" title="10.9.4new.target"></a>10.9.4<code>new.target</code></h3><p>ECMAScript中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6新增了检测函数是否使用<code>new</code>关键字调用的<code>new.target</code>属性。如果函数是正常调用的，则<code>new.target</code>的值是<code>undefined</code>；如果是使用<code>new</code>关键字调用的，则<code>new.target</code>将引用被调用的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// King instantiated using &quot;new&quot;</span></span><br><span class="line">King();     <span class="comment">// Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="10-10-函数属性与方法"><a href="#10-10-函数属性与方法" class="headerlink" title="10.10　函数属性与方法"></a>10.10　函数属性与方法</h2><p>ECMAScript中的函数是对象，因此有属性和方法。每个函数都有两个属性：<code>length</code>和<code>prototype</code>。其中，<code>length</code>属性保存函数定义的命名参数的个数，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayName.length);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.length);      <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHi.length);    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>prototype</code>是保存引用类型所有实例方法的地方，<code>toString()</code>、<code>valueOf()</code>等方法实际上都保存在<code>prototype</code>上，进而由所有实例共享。<code>prototype</code>属性是不可枚举的，因此使用<code>for-in</code>循环不会返回这个属性。<br>函数还有两个方法：<code>apply()</code>和<code>call()</code>。这两个方法都会以指定的<code>this</code>值来调用函数，即会设置调用函数时函数体内<code>this</code>对象的值。<code>apply()</code>方法接收两个参数：函数内<code>this</code>的值和一个参数数组。第二个参数可以是<code>Array</code>的实例或<code>arguments</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入arguments对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>在严格模式下，调用函数时如果没有使用<code>apply()</code>或<code>call()</code>把函数指定给一个对象，也就是没有指定上下文对象，则<code>this</code>值不会指向<code>window</code>，会变成<code>undefined</code>。</p>
</blockquote>
<p><code>call()</code>方法与<code>apply()</code>的作用一样，只是传参的形式不同。第一个参数跟<code>apply()</code>一样，也是<code>this</code>值，而剩下的要传给被调用函数的参数则是逐个传递的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="built_in">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>到底是使用<code>apply()</code>还是<code>call()</code>，完全取决于怎么给要调用的函数传参更方便。如果不用给被调用的函数传参，则使用哪个方法都一样。<br><code>apply()</code>和<code>call()</code>真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内<code>this</code>值的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  fn.call(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callFn); <span class="comment">//callFn函数代码</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();             <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">this</span>);    <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);  <span class="comment">// red</span></span><br><span class="line">sayColor.call(o);       <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>使用<code>call()</code>或<code>apply()</code>的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。<br>ECMAScript 5出于同样的目的定义了一个新方法：<code>bind()</code>。<code>bind()</code>方法会创建一个新的函数实例，其<code>this</code>值会被<strong>绑定</strong>到传给<code>bind()</code>的对象。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();  <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<p>对函数而言，继承的方法<code>toLocaleString()</code>和<code>toString()</code>始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法<code>valueOf()</code>返回函数本身。</p>
<h2 id="10-11-函数表达式"><a href="#10-11-函数表达式" class="headerlink" title="10.11　函数表达式"></a>10.11　函数表达式</h2><p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样创建的函数叫作<strong>匿名函数</strong>（anonymous funtion），因为<code>function</code>关键字后面没有标识符。（匿名函数有也时候也被称为<strong>兰姆达函数</strong>）。未赋值给其他变量的匿名函数的<code>name</code>属性是空字符串。<br>函数表达式跟JavaScript中的其他表达式一样，需要先赋值再使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sayHi();  <span class="comment">// Error! function doesn&#x27;t exist yet</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Yo!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码看起来正常，事实上，这种写法不是有效的语法。JavaScript引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略<code>condition</code>直接返回第二个声明。Firefox会在<code>condition</code>为<code>true</code>时返回第一个声明。<br>不过，如果把上面的函数声明换成函数表达式就没问题了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> sayHi;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>createComparisonFunction()</code>函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在<code>createComparisonFunction()</code>内部，那个函数是匿名的。任何时候，只要函数被当作值来使用，它就是一个函数表达式。</p>
<h2 id="10-12-递归"><a href="#10-12-递归" class="headerlink" title="10.12　递归"></a>10.12　递归</h2><p><strong>递归函数</strong>通常的形式是一个函数通过名称调用自己，在编写递归函数时，<code>arguments.callee</code>是引用当前函数的首选。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在严格模式下运行的代码是不能访问<code>arguments.callee</code>的。可以使用命名函数表达式（named function expression）达到目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里创建了一个命名函数表达式<code>f()</code>，然后将它赋值给了变量<code>factorial</code>。即使把函数赋值给另一个变量，函数表达式的名称<code>f</code>也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。</p>
<h2 id="10-13-尾调用优化"><a href="#10-13-尾调用优化" class="headerlink" title="10.13　尾调用优化"></a>10.13　尾调用优化</h2><p>ECMAScript 6规范新增了一项内存管理优化机制，让JavaScript引擎在满足条件时可以重用栈帧。这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6优化之前，执行这个例子会在内存中发生如下操作。</p>
<ol>
<li>执行到<code>outerFunction</code>函数体，第一个栈帧被推到栈上。</li>
<li>执行<code>outerFunction</code>函数体，到<code>return</code>语句。计算返回值必须先计算<code>innerFunction</code>。</li>
<li>执行到<code>innerFunction</code>函数体，第二个栈帧被推到栈上。</li>
<li>执行<code>innerFunction</code>函数体，计算其返回值。</li>
<li>将返回值传回<code>outerFunction</code>，然后<code>outerFunction</code>再返回值。</li>
<li>将栈帧弹出栈外。</li>
</ol>
<p>在ES6优化之后，执行这个例子会在内存中发生如下操作。</p>
<ol>
<li>执行到<code>outerFunction</code>函数体，第一个栈帧被推到栈上。</li>
<li>执行<code>outerFunction</code>函数体，到达<code>return</code>语句。为求值返回语句，必须先求值<code>innerFunction</code>。</li>
<li>引擎发现把第一个栈帧弹出栈外也没问题，因为<code>innerFunction</code>的返回值也是<code>outerFunction</code>的返回值。</li>
<li>弹出<code>outerFunction</code>的栈帧。</li>
<li>执行到<code>innerFunction</code>函数体，栈帧被推到栈上。</li>
<li>执行<code>innerFunction</code>函数体，计算其返回值。</li>
<li>将<code>innerFunction</code>的栈帧弹出栈外。</li>
</ol>
<p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是ES6尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p>
<blockquote>
<p><strong>注意</strong>现在还没有办法测试尾调用优化是否起作用。不过，因为这是ES6规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。</p>
</blockquote>
<h3 id="10-13-1-尾调用优化的条件"><a href="#10-13-1-尾调用优化的条件" class="headerlink" title="10.13.1　尾调用优化的条件"></a>10.13.1　尾调用优化的条件</h3><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：</p>
<ul>
<li>代码在严格模式下执行；</li>
<li>外部函数的返回值是对尾调用函数的调用；</li>
<li>尾调用函数返回后不需要执行额外的逻辑；</li>
<li>尾调用函数不是引用外部函数作用域中自由变量的闭包。</li>
</ul>
<p>下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> innerFunctionResult = innerFunction();</span><br><span class="line">  <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是几个符合尾调用优化条件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> condition ? innerFunctionA() : innerFunctionB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</p>
<blockquote>
<p><strong>注意</strong>之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用<code>f.arguments</code>和<code>f.caller</code>，而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。</p>
</blockquote>
<h3 id="10-13-2-尾调用优化的代码"><a href="#10-13-2-尾调用优化的代码" class="headerlink" title="10.13.2　尾调用优化的代码"></a>10.13.2　尾调用优化的代码</h3><p>可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">0</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">2</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">3</span>));  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">4</span>));  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">5</span>));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">6</span>));  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈帧数的内存复杂度是。<br>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fibImpl(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibImpl</span>(<span class="params">a, b, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibImpl(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-14-闭包"><a href="#10-14-闭包" class="headerlink" title="10.14　闭包"></a>10.14　闭包</h2><p>匿名函数经常被人误认为是闭包（closure）。<strong>闭包</strong>指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部函数（匿名函数）中引用了外部函数的变量<code>propertyName</code>。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含<code>createComparisonFunction()</code>函数的作用域。<br>而这又是因为在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用<code>arguments</code>和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。</p>
<p>在函数执行时，要从作用域链中查找变量，以便读、写值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义<code>compare()</code>函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的<code>[[Scope]]</code>中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的<code>[[Scope]]</code>来创建其作用域链。接着会创建函数的活动对象并将其推入作用域链的前端。这意味着<code>compare()</code>函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。<br>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。图10-1展示了以上关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/19/3DP5j2RAqBbulFL.png"
                      alt="016.png"
                ></p>
<p><strong>图　10-1</strong></p>
<p>但是，闭包就不一样了。在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在<code>createComparisonFunction()</code>函数中，匿名函数的作用域链中实际上包含<code>createComparisonFunction()</code>的活动对象。图10-2展示了调用<code>compareNames()</code>之后作用域链之间的关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/19/tr1VLpm6fqW2oG4.png"
                      alt="017.png"
                ></p>
<p><strong>图　10-2</strong></p>
<p>在<code>createComparisonFunction()</code>返回匿名函数后，它的作用域链被初始化为包含<code>createComparisonFunction()</code>的活动对象和全局变量对象。这样，匿名函数就可以访问到<code>createComparisonFunction()</code>可以访问的所有变量。副作用是，<code>createComparisonFunction()</code>的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在<code>createComparisonFunction()</code>执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;); <span class="comment">// 调用函数</span></span><br><span class="line">compare= <span class="literal">null</span>; <span class="comment">// 解除对函数的引用，这样就可以释放内存了</span></span><br></pre></td></tr></table></figure>
<p>创建的比较函数被保存在变量<code>compareNames</code>中。把<code>compareNames</code>设置为等于<code>null</code>会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p>
<blockquote>
<p><strong>注意</strong>因为闭包会保留它们包含函数的作用域，所以过度使用闭包可能导致内存过度占用，建议仅在十分必要时使用。</p>
</blockquote>
<h3 id="10-14-1this对象"><a href="#10-14-1this对象" class="headerlink" title="10.14.1this对象"></a>10.14.1<code>this</code>对象</h3><p>如果内部函数没有使用箭头函数定义，则<code>this</code>对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则<code>this</code>在非严格模式下等于<code>window</code>，在严格模式下等于<code>undefined</code>。如果作为某个对象的方法调用，则<code>this</code>等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着<code>this</code>会指向<code>window</code>，除非在严格模式下<code>this</code>是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure>
<p>匿名函数之所以没有使用其包含作用域（<code>getIdentityFunc()</code>）的<code>this</code>对象，是因为<br>内部函数永远不可能直接访问外部函数在被调用时都会自动创建两个特殊变量：<code>this</code>和<code>arguments</code>。但如果把<code>this</code>保存到闭包可以访问的另一个变量中，则是行得通的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.identity;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;My Object&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>this</code>和<code>arguments</code>都是不能直接在内部函数中访问的。如果想访问包含作用域中的<code>arguments</code>对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p>
</blockquote>
<p>在一些特殊情况下，<code>this</code>值可能并不是我们所期待的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  getIdentity () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getIdentity();             <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.getIdentity)();           <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.getIdentity = object.getIdentity)();  <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure>
<p>第一次调用时把<code>object.getIdentity</code>放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但<code>this</code>值并没有变。这是因为按照规范，<code>object.getIdentity</code>和<code>(object.getIdentity)</code>是相等的。第二次执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，<code>this</code>值不再与任何对象绑定，所以返回的是<code>&quot;The Window&quot;</code>。</p>
<h3 id="10-14-2-内存泄漏"><a href="#10-14-2-内存泄漏" class="headerlink" title="10.14.2　内存泄漏"></a>10.14.2　内存泄漏</h3><p>由于IE在IE9之前对JScript对象和COM对象使用了不同的垃圾回收机制，所以闭包在这些旧版本IE中可能会导致问题。比如，把HTML元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line">  element.onclick = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(element.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个闭包，即<code>element</code>元素的事件处理程序。而这个处理程序又创建了一个循环引用。匿名函数引用着<code>assignHandler()</code>的活动对象，阻止了对<code>element</code>的引用计数归零。只要这个匿名函数存在，<code>element</code>的引用计数就至少等于1。也就是说，内存不会被回收。<br>稍加修改，就可以避免这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> id = element.id;</span><br><span class="line">  element.onclick = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(id);</span><br><span class="line">  element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包改为引用一个保存着<code>element.id</code>的变量<code>id</code>，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含<code>element</code>。即使闭包没有直接引用<code>element</code>，包含函数的活动对象上还是保存着对它的引用。因此，必须再把<code>element</code>设置为<code>null</code>。这样就解除了对这个COM对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。</p>
<h2 id="10-15-立即调用的函数表达式"><a href="#10-15-立即调用的函数表达式" class="headerlink" title="10.15　立即调用的函数表达式"></a>10.15　立即调用的函数表达式</h2><p>立即调用的匿名函数又被称作<strong>立即调用的函数表达式</strong>（IIFE，Immediately Invoked Function Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>使用IIFE可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure>
<p>在ECMAScript 5.1及以前，尚未支持块级作用域，为了防止变量定义外泄，IIFE是个普遍且有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。<br>在ECMAScript 6以后，IIFE就没有那么必要了，因为块级作用域中的变量无须IIFE就可以实现同样的隔离。下面展示了两种不同的块级作用域形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="comment">// 循环的块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure>
<p>说明IIFE用途的一个实际的例子，就是可以用它锁定参数值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用<code>var</code>关键字声明了循环迭代变量<code>i</code>，但这个变量并不会被限制在<code>for</code>循环的块级作用域内。因此渲染到页面上之后，点击每个<code>&lt;div&gt;</code>都会弹出元素总数。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量<code>i</code>存在于循环体外部，随时可以访问。<br>以前，为了实现点击第几个<code>&lt;div&gt;</code>就显示相应的索引值，需要借助IIFE来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用ECMAScript块级作用域变量更加方便简洁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，事件处理程序执行时就会引用<code>for</code>循环块级作用域中的索引值。这是因为在ECMAScript 6中，如果对<code>for</code>循环使用块级作用域变量关键字，在这里就是<code>let</code>，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。<br>但如果把变量声明拿到<code>for</code>循环外部，会跟在循环中使用<code>var i = 0</code>有同样的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-16-私有变量"><a href="#10-16-私有变量" class="headerlink" title="10.16　私有变量"></a>10.16　私有变量</h2><p>严格来讲，JavaScript没有私有成员的概念，所有对象属性都公有的。不过有<strong>私有变量</strong>的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，函数<code>add()</code>有3个私有变量：<code>num1</code>、<code>num2</code>和<code>sum</code>。这几个变量只能在函数内部使用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的这3个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。<br><strong>特权方法</strong>（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="built_in">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。<br>如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());  <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person.setName(<span class="string">&#x27;Greg&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());  <span class="comment">// &#x27;Greg&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这段代码中的构造函数定义了两个特权方法：<code>getName()</code>和<code>setName()</code>。每个方法都可以构造函数外部调用，并通过它们来读写私有的<code>name</code>变量。在<code>Person</code>构造函数外部，没有别的办法访问<code>name</code>。因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问<code>name</code>的闭包。私有变量<code>name</code>对每个<code>Person</code>实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。不过这样也有个问题：必须通过构造函数来实现这种隔离。构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用第二种方式，静态私有变量实现特权方法可以避免这个问题。</p>
<h3 id="10-16-1-静态私有变量"><a href="#10-16-1-静态私有变量" class="headerlink" title="10.16.1　静态私有变量"></a>10.16.1　静态私有变量</h3><p>特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 公有和特权方法</span></span><br><span class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。公有方法定义在构造函数的原型上。这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里并不是必需的，并且不使用关键字声明的变量会创建在全局作用域中，所以<code>MyObject</code>变成了全局变量，可以在这个私有作用域外部被访问。注意在严格模式下给未声明的变量赋值会导致错误。<br>这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());  <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person1.setName(<span class="string">&#x27;Matt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Michael&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());  <span class="comment">// &#x27;Michael&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName());  <span class="comment">// &#x27;Michael&#x27;</span></span><br></pre></td></tr></table></figure>
<p>使用这种模式，<code>name</code>变成了静态变量，可供所有实例使用。这意味着在任何实例上调用<code>setName()</code>修改这个变量都会影响其他实例。调用<code>setName()</code>或创建新的<code>Person</code>实例都要把<code>name</code>变量设置为一个新值。而所有实例都会返回相同的值。<br>像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。</p>
<blockquote>
<p><strong>注意</strong>使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。</p>
</blockquote>
<h3 id="10-16-2-模块模式"><a href="#10-16-2-模块模式" class="headerlink" title="10.16.2　模块模式"></a>10.16.2　模块模式</h3><p>单例对象（singleton）就是只有一个实例的对象。JavaScript是通过对象字面量来创建单例对象的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line">  name: value,</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicProperty: <span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">publicMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。<br>如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用下面这个模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">getComponentCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> components.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">registerComponent</span>(<span class="params">component</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        components.push(component);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>在Web开发中，经常需要使用单例对象管理应用程序级的信息。上面这个例子创建了一个<code>application</code>对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组<code>components</code>，然后将一个<code>BaseComponent</code>组件的新实例添加到数组中。<code>BaseComponent</code>组件的代码并不重要，在这里只是为了说明模块模式的用法。对象字面量中定义的<code>getComponentCount()</code>和<code>registerComponent()</code>方法都是可以访问<code>components</code>私有数组的特权方法。<br>以这种方式创建的每个单例对象都是<code>Object</code>的实例，因为最终单例都由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以无需使用<code>instanceof</code>操作符确定参数是不是对象类型。</p>
<h3 id="10-16-3-模块增强模式"><a href="#10-16-3-模块增强模式" class="headerlink" title="10.16.3　模块增强模式"></a>10.16.3　模块增强模式</h3><p>另一种利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">  <span class="comment">// 创建局部变量保存实例</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="keyword">new</span> BaseComponent();</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  app.getComponentCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> components.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.registerComponent = <span class="function"><span class="keyword">function</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      components.push(component);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>在这个重写的<code>application</code>单例对象的例子中，首先定义了私有变量和私有函数，跟之前一样。主要区别在于这里创建了一个名为<code>app</code>的变量，其中保存了<code>BaseComponent</code>组件的实例。这是最终要变成<code>application</code>的那个对象的局部版本。在给这个局部变量<code>app</code>添加了能够访问私有变量的公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给<code>application</code>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>11-期约与异步函数</title>
    <url>/2021/04/22/note/JavaScript/11-%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>ECMAScript 6新增了正式的<code>Promise</code>（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用<code>async</code>和<code>await</code>关键字定义异步函数的机制。</p>
<blockquote>
<p><strong>注意</strong>本章示例将大量使用异步日志输出的方式<code>setTimeout(console.log, 0, .. params)</code>，旨在演示执行顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约等返回的值达到其最终状态。<br>此外，浏览器控制台的输出经常能打印出JavaScript运行中无法获取的对象信息（比如期约的状态）。</p>
</blockquote>
<h2 id="11-1-异步编程"><a href="#11-1-异步编程" class="headerlink" title="11.1　异步编程"></a>11.1　异步编程</h2><p><strong>异步行为</strong>是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。</p>
<p>重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。</p>
<h3 id="11-1-1-同步与异步"><a href="#11-1-1-同步与异步" class="headerlink" title="11.1.1　同步与异步"></a>11.1.1　同步与异步</h3><p><strong>同步行为</strong>对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。这是因为后面的指令总是在前面的指令完成后才会执行。</p>
<p>相对地，<strong>异步行为</strong>类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待，但无法预知何时完成。</p>
<h3 id="11-1-2-以往的异步编程模式"><a href="#11-1-2-以往的异步编程模式" class="headerlink" title="11.1.2　以往的异步编程模式"></a>11.1.2　以往的异步编程模式</h3><p>在早期的JavaScript中，只支持定义回调函数来表明异步操作完成。假设有以下异步函数，使用了<code>setTimeout</code>在一秒钟之后执行某些操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>);<span class="comment">// 6（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure>
<p><code>setTimeout</code>可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000毫秒之后，JavaScript运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对JavaScript代码就完全不可见了。还有一点，<code>double()</code>函数在<code>setTimeout</code>成功调度异步操作之后会立即退出。</p>
<h4 id="11-1-2-1-异步返回值"><a href="#11-1-2-1-异步返回值" class="headerlink" title="11.1.2.1   异步返回值"></a><strong>11.1.2.1   异步返回值</strong></h4><p>如果<code>setTimeout</code>操作会返回一个有用的值后续要用，策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> callback(value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`I was given: <span class="subst">$&#123;x&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I was given: 6（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure>
<p>位于函数闭包中的回调及其参数在异步执行时仍然是可用的。</p>
<h4 id="11-1-2-2-失败处理"><a href="#11-1-2-2-失败处理" class="headerlink" title="11.1.2.2   失败处理"></a><strong>11.1.2.2   失败处理</strong></h4><p>异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      success(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line">double(<span class="string">&#x27;b&#x27;</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 6（大约1000毫秒之后）</span></span><br><span class="line"><span class="comment">// Failure: Must provide number as first argument（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure>
<p>这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。</p>
<h4 id="11-1-2-3-嵌套异步回调"><a href="#11-1-2-3-嵌套异步回调" class="headerlink" title="11.1.2.3   嵌套异步回调"></a><strong>11.1.2.3   嵌套异步回调</strong></h4><p>如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。这就要嵌套回调（俗称“回调地狱”）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      success(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  double(x, <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;y&#125;</span>`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 12（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure>
<h2 id="11-2-期约"><a href="#11-2-期约" class="headerlink" title="11.2　期约"></a>11.2　期约</h2><p>期约是对尚不存在结果的一个替身，描述的是一种异步程序执行的机制。</p>
<h3 id="11-2-1-Promises-A-规范"><a href="#11-2-1-Promises-A-规范" class="headerlink" title="11.2.1　Promises/A+规范"></a>11.2.1　Promises/A+规范</h3><p>ECMAScript 6增加了对Promises/A+规范的完善支持，即<code>Promise</code>类型，成为了主导性的异步编程机制。所有现代浏览器都支持ES6期约，很多其他浏览器API（如<code>fetch()</code>和Battery Status API）也以期约为基础。</p>
<h3 id="11-2-2-期约基础"><a href="#11-2-2-期约基础" class="headerlink" title="11.2.2　期约基础"></a>11.2.2　期约基础</h3><p>ECMAScript 6新增的引用类型<code>Promise</code>，可以通过<code>new</code>操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器，因为如果不提供执行器函数，就会抛出<code>SyntaxError</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);  <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-2-1-期约状态机"><a href="#11-2-2-1-期约状态机" class="headerlink" title="11.2.2.1   期约状态机"></a><strong>11.2.2.1   期约状态机</strong></h4><p>把一个期约实例传给<code>console.log()</code>时，控制台输出表明该实例处于<strong>待定</strong>（pending）状态。期约是一个有状态的对象，可能处于如下3种状态之一：</p>
<pre><code>1. 待定（pending）,表示尚未开始或者正在执行中，最初始状态。
2. 兑现（fulfilled，有时候也称为“解决”，resolved）,表示已经成功完成。
3. 拒绝（rejected），表示没有成功完成。</code></pre>
<p>在待定状态下，期约可以<strong>落定</strong>（settled）为代表成功的<strong>兑现</strong>（fulfilled）状态，或者代表失败的<strong>拒绝</strong>（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。</p>
<p>期约的状态是私有的，不能直接通过JavaScript检测到，这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。</p>
<h4 id="11-2-2-2-解决值、拒绝理由及期约用例"><a href="#11-2-2-2-解决值、拒绝理由及期约用例" class="headerlink" title="11.2.2.2   解决值、拒绝理由及期约用例"></a><strong>11.2.2.2   解决值、拒绝理由及期约用例</strong></h4><p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，知道一段异步代码已经完成，对于其他代码而言已经足够了。</p>
<p>其次每个期约只要状态切换为兑现，就会有一个私有的内部<strong>值</strong>（value）。状态切换为拒绝，就会有一个私有的内部<strong>理由</strong>（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，默认值为<code>undefined</code>。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p>
<h4 id="11-2-2-3-通过执行函数控制期约状态"><a href="#11-2-2-3-通过执行函数控制期约状态" class="headerlink" title="11.2.2.3   通过执行函数控制期约状态"></a><strong>11.2.2.3   通过执行函数控制期约状态</strong></h4><p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。这是通过调用它的两个函数参数<code>resolve()</code>和<code>reject()</code>实现的。调用<code>resolve()</code>会把状态切换为兑现，调用<code>reject()</code>会把状态切换为拒绝，并且也会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught error (in promise)</span></span><br></pre></td></tr></table></figure>
<p>执行器函数是<strong>同步</strong>执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"><span class="comment">// executor</span></span><br><span class="line"><span class="comment">// promise initialized</span></span><br></pre></td></tr></table></figure>
<p>添加<code>setTimeout</code>可以推迟切换状态：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 在console.log打印期约实例的时候，还不会执行超时回调（即resolve()）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);  <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure>
<p>无论<code>resolve()</code>和<code>reject()</code>中的哪个被调用，状态转换都不可撤销了。继续修改状态会静默失败，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  reject(); <span class="comment">// 没有效果</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure>
<p>为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过<code>setTimeout</code>设置一个10秒钟后无论如何都会拒绝期约的回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">10000</span>);  <span class="comment">// 10秒后调用reject()</span></span><br><span class="line">  <span class="comment">// 执行函数的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);      <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">11000</span>, p);  <span class="comment">// 11秒后再检查状态</span></span><br><span class="line"><span class="comment">// (After 10 seconds) Uncaught error</span></span><br><span class="line"><span class="comment">// (After 11 seconds) Promise &lt;rejected&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。</p>
<h4 id="11-2-2-4Promise-resolve"><a href="#11-2-2-4Promise-resolve" class="headerlink" title="11.2.2.4Promise.resolve()"></a><strong>11.2.2.4</strong><code>Promise.resolve()</code></h4><p>期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用<code>Promise.resolve()</code>静态方法，可以实例化一个解决的期约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的两个期约实例实际上是一样的</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure>
<p>这个解决的期约的值对应着传给<code>Promise.resolve()</code>的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 4</span></span><br></pre></td></tr></table></figure>
<p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，<code>Promise.resolve()</code>可以说是一个幂等方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p === <span class="built_in">Promise</span>.resolve(p));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p === <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)));  <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<p>这个幂等性会保留传入期约的状态：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);                  <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: Error: foo</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-2-5Promise-reject"><a href="#11-2-2-5Promise-reject" class="headerlink" title="11.2.2.5Promise.reject()"></a><strong>11.2.2.5</strong><code>Promise.reject()</code></h4><p><code>Promise.reject()</code>会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过<code>try</code>/<code>catch</code>捕获，只能通过拒绝处理程序捕获）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的两个期约实例实际上是一样的</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br></pre></td></tr></table></figure>
<p>这个拒绝的期约的理由就是传给<code>Promise.reject()</code>的第一个参数。这个参数也会传给后续的拒绝处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3</span></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.reject()</code>并没有照搬<code>Promise.resolve()</code>的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.reject(<span class="built_in">Promise</span>.resolve()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-2-6-同步-异步执行的二元性"><a href="#11-2-2-6-同步-异步执行的二元性" class="headerlink" title="11.2.2.6   同步/异步执行的二元性"></a><strong>11.2.2.6   同步/异步执行的二元性</strong></h4><p><code>Promise</code>的设计很大程度上会导致一种完全不同于JavaScript的计算模式。下面的例子展示了这一点，其中包含了两种模式下抛出错误的情形：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure>
<p>第一个<code>try</code>/<code>catch</code>抛出并捕获了错误，第二个<code>try</code>/<code>catch</code>抛出错误却<strong>没有</strong>捕获到。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过<strong>异步模式</strong>捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是<strong>异步</strong>执行模式的媒介。<br>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，<code>try</code>/<code>catch</code>块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构，也就是期约的方法。</p>
<h3 id="11-2-3-期约的实例方法"><a href="#11-2-3-期约的实例方法" class="headerlink" title="11.2.3　期约的实例方法"></a>11.2.3　期约的实例方法</h3><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p>
<h4 id="11-2-3-1-实现Thenable接口"><a href="#11-2-3-1-实现Thenable接口" class="headerlink" title="11.2.3.1   实现Thenable接口"></a><strong>11.2.3.1   实现</strong><code>Thenable</code>接口</h4><p>在ECMAScript暴露的异步结构中，任何对象都有一个<code>then()</code>方法。这个方法被认为实现了<code>Thenable</code>接口。下面的例子展示了实现这一接口的最简单的类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThenable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ECMAScript的<code>Promise</code>类型实现了<code>Thenable</code>接口。这个简化的接口跟TypeScript或其他包中的接口或类型定义不同，它们都设定了<code>Thenable</code>接口更具体的形式。</p>
<h4 id="11-2-3-2Promise-prototype-then"><a href="#11-2-3-2Promise-prototype-then" class="headerlink" title="11.2.3.2Promise.prototype.then()"></a><strong>11.2.3.2</strong><code>Promise.prototype.then()</code></h4><p><code>Promise.prototype.then()</code>是为期约实例添加处理程序的主要方法。这个<code>then()</code>方法接收最多两个参数：<code>onResolved</code>处理程序和<code>onRejected</code>处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p1&#x27;</span>), <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p1&#x27;</span>));</span><br><span class="line">p2.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p2&#x27;</span>), <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">//（3秒后）</span></span><br><span class="line"><span class="comment">// p1 resolved</span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure>
<p>因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。传给<code>then()</code>的任何非函数类型的参数都会被静默忽略。如果想只提供<code>onRejected</code>参数，那就要在<code>onResolved</code>参数的位置上传入<code>undefined</code>。这样有助于避免在内存中创建多余的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line"><span class="comment">// 非函数处理程序会被静默忽略，不推荐</span></span><br><span class="line">p1.then(<span class="string">&#x27;gobbeltygook&#x27;</span>);</span><br><span class="line"><span class="comment">// 不传onResolved处理程序的规范写法</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">// p2 rejected（3秒后）</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.prototype.then()</code>方法返回一个新的期约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then();  <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这个新期约实例基于<code>onResovled</code>处理程序的返回值构建，也就是通过<code>Promise.resolve()</code>包装生成的新期约。如果没有提供这个处理程序，则<code>Promise.resolve()</code>就会包装上一个期约解决之后的值。如果没有显式的返回语句，则<code>Promise.resolve()</code>会包装默认的返回值<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 若调用then()时不传处理程序，则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function">() =&gt;</span> <span class="literal">undefined</span>); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;);  <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br></pre></td></tr></table></figure>
<p>如果有显式的返回值，则<code>Promise.resolve()</code>会包装这个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="built_in">console</span>.log(p6 === p7); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()); <span class="comment">//Promise &lt;rejected&gt;: undefine</span></span><br></pre></td></tr></table></figure>
<p>抛出异常会返回拒绝的期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt; baz</span></span><br></pre></td></tr></table></figure>
<p>注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure>
<p><code>onRejected</code>处理程序返回的值也会被<code>Promise.resolve()</code>包装，因为<code>onRejected</code>处理程序的任务就是捕获异步错误，如果被<code>Promise.reject()</code>包装则会抛出异常。<br>下面的代码片段展示了用<code>Promise.reject()</code>替代之前例子中的<code>Promise.resolve()</code>之后的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用then()时不传处理程序则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); <span class="comment">// Uncaught (in promise) foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2);  <span class="comment">// Promise &lt;rejected&gt;: foo</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="literal">undefined</span>);<span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line">　</span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));<span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());  </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line">); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-3Promise-prototype-catch"><a href="#11-2-3-3Promise-prototype-catch" class="headerlink" title="11.2.3.3Promise.prototype.catch()"></a><strong>11.2.3.3</strong><code>Promise.prototype.catch()</code></h4><p><code>Promise.prototype.catch()</code>方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：<code>onRejected</code>处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用<code>Promise.prototype.then(null, onRejected)</code>。</p>
<p>下面的代码展示了这两种同样的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.then(<span class="literal">null</span>, onRejected);  <span class="comment">// rejected</span></span><br><span class="line">p.catch(onRejected);       <span class="comment">// rejected</span></span><br></pre></td></tr></table></figure>
<p>在返回新期约实例方面，<code>Promise.prototype.catch()</code>的行为与<code>Promise.prototype.then()</code>的<code>onRejected</code>处理程序是一样的。</p>
<h4 id="11-2-3-4Promise-prototype-finally"><a href="#11-2-3-4Promise-prototype-finally" class="headerlink" title="11.2.3.4Promise.prototype.finally()"></a><strong>11.2.3.4</strong><code>Promise.prototype.finally()</code></h4><p><code>Promise.prototype.finally()</code>方法用于给期约添加<code>onFinally</code>处理程序，这个处理程序在期约转换为解决<strong>或</strong>拒绝状态时都会执行。这个方法可以避免<code>onResolved</code>和<code>onRejected</code>处理程序中出现冗余代码。但<code>onFinally</code>处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;Finally!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">p1.finally(onFinally); <span class="comment">// Finally</span></span><br><span class="line">p2.finally(onFinally); <span class="comment">// Finally</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.prototype.finally()</code>方法返回一个新的期约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();   <span class="comment">// Promise &lt;pending&gt;    </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>但这个新期约实例不同于<code>then()</code>或<code>catch()</code>方式返回的实例。因为<code>onFinally</code>被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 这里都会原样后传，都是Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();</span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="keyword">let</span> p6 = p1.finally(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> p8 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>如果返回的是一个待定的期约，或者<code>onFinally</code>处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p10 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());<span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9);  <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.finally(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br></pre></td></tr></table></figure>
<p>返回待定期约的情形并不常见，因为只要期约一解决，新期约仍然会原样后传初始的期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 忽略解决的值</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&#x27;bar&#x27;</span>), <span class="number">100</span>)));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2), <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 200毫秒后：</span></span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-5-非重入期约方法"><a href="#11-2-3-5-非重入期约方法" class="headerlink" title="11.2.3.5   非重入期约方法"></a><strong>11.2.3.5   非重入期约方法</strong></h4><p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被<strong>排期</strong>，推进消息队列，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由JavaScript运行时保证，被称为“非重入”（non-reentrancy）特性。下面的例子演示了这个特性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建解决的期约</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="comment">// 添加解决处理程序</span></span><br><span class="line"><span class="comment">// 直觉上，这个处理程序会等期约一解决就执行</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;onResolved handler&#x27;</span>));</span><br><span class="line"><span class="comment">// 同步输出，证明then()已经返回</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;then() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// then() returns</span></span><br><span class="line"><span class="comment">// onResolved handler</span></span><br></pre></td></tr></table></figure>
<p>先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"><span class="comment">// 创建一个期约并将解决函数保存在一个局部变量中</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  synchronousResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1: invoking resolve()&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2: resolve() returns&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;4: then() handler executes&#x27;</span>));</span><br><span class="line">synchronousResolve();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 1: invoking resolve()</span></span><br><span class="line"><span class="comment">// 2: resolve() returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure>
<p>非重入适用于<code>onResolved</code>/<code>onRejected</code>处理程序、<code>catch()</code>处理程序和<code>finally()</code>处理程序。下面的例子演示了这些处理程序都只能异步执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p1.then() onResolved&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p1.then() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p2.then() onRejected&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p2.then() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p3.catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p3.catch() onRejected&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p3.catch() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p4.finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p4.finally() onFinally&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p4.finally() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// p1.then() returns</span></span><br><span class="line"><span class="comment">// p2.then() returns</span></span><br><span class="line"><span class="comment">// p3.catch() returns</span></span><br><span class="line"><span class="comment">// p4.finally() returns</span></span><br><span class="line"><span class="comment">// p1.then() onResolved</span></span><br><span class="line"><span class="comment">// p2.then() onRejected</span></span><br><span class="line"><span class="comment">// p3.catch() onRejected</span></span><br><span class="line"><span class="comment">// p4.finally() onFinally</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-6-邻近处理程序的执行顺序"><a href="#11-2-3-6-邻近处理程序的执行顺序" class="headerlink" title="11.2.3.6   邻近处理程序的执行顺序"></a><strong>11.2.3.6   邻近处理程序的执行顺序</strong></h4><p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是<code>then()</code>、<code>catch()</code>还是<code>finally()</code>添加的处理程序都是如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">2</span>));  <span class="comment">// 2</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">3</span>));  <span class="comment">// 3</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">4</span>));  <span class="comment">// 4</span></span><br><span class="line">p2.catch(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">5</span>));  <span class="comment">// 5</span></span><br><span class="line">p2.catch(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">6</span>));  <span class="comment">// 6</span></span><br><span class="line">p1.finally(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">7</span>));  <span class="comment">// 7</span></span><br><span class="line">p1.finally(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">8</span>));  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-7-传递解决值和拒绝理由"><a href="#11-2-3-7-传递解决值和拒绝理由" class="headerlink" title="11.2.3.7   传递解决值和拒绝理由"></a><strong>11.2.3.7   传递解决值和拒绝理由</strong></h4><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。</p>
<p>在执行函数中，解决的值和拒绝的理由是分别作为<code>resolve()</code>和<code>reject()</code>的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为<code>onResolved</code>或<code>onRejected</code>处理程序的唯一参数。下面的例子展示了上述传递过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value));    <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason));  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-8-拒绝期约与拒绝错误处理"><a href="#11-2-3-8-拒绝期约与拒绝错误处理" class="headerlink" title="11.2.3.8   拒绝期约与拒绝错误处理"></a><strong>11.2.3.8   拒绝期约与拒绝错误处理</strong></h4><p>拒绝期约类似于<code>throw()</code>表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line">　</span><br><span class="line"><span class="comment">// 也会抛出4个未捕获错误</span></span><br></pre></td></tr></table></figure>
<p>期约可以以任何理由拒绝，包括<code>undefined</code>，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的4个错误的栈追踪信息如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at Promise (test.html:5)</span><br><span class="line">    at new Promise (<span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span><br><span class="line">    at test.html:5</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at Promise (test.html:6)</span><br><span class="line">    at new Promise (<span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span><br><span class="line">    at test.html:6</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at test.html:8</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at Promise.resolve.then (test.html:7)</span><br></pre></td></tr></table></figure>
<p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：<code>Promise.resolve().then()</code>的错误最后才出现，这是因为它需要在运行时消息队列中<strong>添加</strong>处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。<br>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过<code>throw()</code>关键字抛出错误时，JavaScript运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 这一行不会执行</span></span><br><span class="line"><span class="comment">// Uncaught Error: foo</span></span><br></pre></td></tr></table></figure>
<p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: foo</span></span><br></pre></td></tr></table></figure>
<p>如本章前面的<code>Promise.reject()</code>示例所示，异步错误只能通过异步的<code>onRejected</code>处理程序捕获：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用<code>try</code>/<code>catch</code>在执行函数中捕获错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">  resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br></pre></td></tr></table></figure>
<p><code>then()</code>和<code>catch()</code>的<code>onRejected</code>处理程序在语义上相当于<code>try</code>/<code>catch</code>。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，<code>onRejected</code>处理程序的任务应该是在捕获异步错误之后返回一个<strong>解决</strong>的期约。下面的例子中对比了同步错误处理与异步错误处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;begin synchronous execution&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;continue synchronous execution&#x27;</span>);</span><br><span class="line"><span class="comment">// begin synchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: foo</span></span><br><span class="line"><span class="comment">// continue synchronous execution</span></span><br><span class="line">　</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;begin asynchronous execution&#x27;</span>);</span><br><span class="line">  reject(<span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;continue asynchronous execution&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// begin asynchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: bar</span></span><br><span class="line"><span class="comment">// continue asynchronous execution</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-4-期约连锁与期约合成"><a href="#11-2-4-期约连锁与期约合成" class="headerlink" title="11.2.4　期约连锁与期约合成"></a>11.2.4　期约连锁与期约合成</h3><p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p>
<h4 id="11-2-4-1-期约连锁"><a href="#11-2-4-1-期约连锁" class="headerlink" title="11.2.4.1   期约连锁"></a><strong>11.2.4.1   期约连锁</strong></h4><p>之所以可以这样把期约逐个地串联起来，是因为每个期约实例的方法（<code>then()</code>、<code>catch()</code>和<code>finally()</code>）都会返回一个<strong>新的</strong>期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;))</span><br><span class="line"><span class="comment">// p1 executor（1秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3秒后）</span></span><br></pre></td></tr></table></figure>
<p>把生成期约的代码提取到一个工厂函数中，就可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedResolve</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">delayedResolve(<span class="string">&#x27;p1 executor&#x27;</span>)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p2 executor&#x27;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p3 executor&#x27;</span>))</span><br><span class="line"><span class="comment">// p1 executor（1秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3秒后）</span></span><br></pre></td></tr></table></figure>
<p>因为<code>then()</code>、<code>catch()</code>和<code>finally()</code>都返回期约，所以串联这些方法也很直观。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;initial promise rejects&#x27;</span>);</span><br><span class="line">  reject();</span><br><span class="line">&#125;);</span><br><span class="line">p.catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;reject handler&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;resolve handler&#x27;</span>))</span><br><span class="line"> .finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;finally handler&#x27;</span>));</span><br><span class="line"><span class="comment">// initial promise rejects</span></span><br><span class="line"><span class="comment">// reject handler</span></span><br><span class="line"><span class="comment">// resolve handler</span></span><br><span class="line"><span class="comment">// finally handler</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-4-2-期约图"><a href="#11-2-4-2-期约图" class="headerlink" title="11.2.4.2**期约图**"></a><strong>11.2.4.2**</strong>期约图**</h4><p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建<strong>有向非循环图</strong>的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。</p>
<p>下面的例子展示了一种期约有向图，也就是二叉树：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//      A</span></span><br><span class="line"><span class="comment">//    /   \</span></span><br><span class="line"><span class="comment">//   B     C</span></span><br><span class="line"><span class="comment">//  / \   / \</span></span><br><span class="line"><span class="comment">// D   E F   G</span></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> B = A.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> C = A.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">B.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line">B.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">C.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">C.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;G&#x27;</span>));</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// E</span></span><br><span class="line"><span class="comment">// F</span></span><br><span class="line"><span class="comment">// G</span></span><br></pre></td></tr></table></figure>
<p>期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是<strong>先</strong>添加到消息队列，<strong>然后</strong>才逐个执行，因此日志的输出语句构成了对二叉树的层序遍历。</p>
<h4 id="11-2-4-3Promise-all-和Promise-race"><a href="#11-2-4-3Promise-all-和Promise-race" class="headerlink" title="11.2.4.3Promise.all()和Promise.race()"></a><strong>11.2.4.3</strong><code>Promise.all()</code>和<code>Promise.race()</code></h4><p>Promise类提供两个将多个期约实例组合成一个期约的静态方法：<code>Promise.all()</code>和<code>Promise.race()</code>。而合成后期约的行为取决于内部期约的行为。</p>
<ul>
<li><code>Promise.all()</code></li>
</ul>
<p><code>Promise.all()</code>静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.all([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于Promise.resolve()</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.all([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure>
<p>合成的期约只会在每个包含的期约都解决之后才解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;all() resolved!&#x27;</span>));</span><br><span class="line"><span class="comment">// all() resolved!（大约1秒后）</span></span><br></pre></td></tr></table></figure>
<p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure>
<p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">4</span>)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4]</span></span><br></pre></td></tr></table></figure>
<p>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入拒绝处理程序，第二个期约的拒绝也会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Promise.race()</code></li>
</ul>
<p><code>Promise.race()</code>静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于new Promise(() =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure>
<p><code>Promise.race()</code>不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，<code>Promise.race()</code>就会包装其解决值或拒绝理由并返回新期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4</span></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">5</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">6</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">7</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5</span></span><br></pre></td></tr></table></figure>
<p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与<code>Promise.all()</code>类似，合成的期约<strong>会</strong>静默处理所有包含期约的拒绝操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入拒绝处理程序，第二个期约的拒绝也会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-4-4-串行期约合成"><a href="#11-2-4-4-串行期约合成" class="headerlink" title="11.2.4.4   串行期约合成"></a><strong>11.2.4.4   串行期约合成</strong></h4><p>基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像<strong>函数合成</strong>，即将多个函数合成为一个函数，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x)</span><br><span class="line">    .then(addTwo)</span><br><span class="line">    .then(addThree)</span><br><span class="line">    .then(addFive);</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>使用<code>Array.prototype.reduce()</code>可以写成更简洁的形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [addTwo, addThree, addFive]</span><br><span class="line">      .reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addTen = compose(addTwo, addThree, addFive);</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-5-期约扩展"><a href="#11-2-5-期约扩展" class="headerlink" title="11.2.5　期约扩展"></a>11.2.5　期约扩展</h3><p>ES6不支持取消期约和进度通知，一个主要原因是这样会导致期约连锁和期约合成过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了通知，那么接下来应该发生什么完全说不清楚。</p>
<h4 id="11-2-5-1-期约取消"><a href="#11-2-5-1-期约取消" class="headerlink" title="11.2.5.1   期约取消"></a><strong>11.2.5.1   期约取消</strong></h4><p>ES6期约的逻辑开始执行，就没有办法阻止它执行到完成，但经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。</p>
<p>这可以用到“取消令牌”（cancel token），在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params">cancelFn</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        cancelFn(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;delay cancelled&quot;</span>);</span></span><br><span class="line">          resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> startButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#start&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cancelButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#cancel&#x27;</span>);</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">cancellableDelayedResolve</span>(<span class="params">delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;set delay&quot;</span>);</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> id = <span class="built_in">setTimeout</span>((<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;delayed resolve&quot;</span>);</span></span><br><span class="line">        resolve();</span><br><span class="line">      &#125;), delay);</span><br><span class="line">  </span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function">(<span class="params">cancelCallback</span>) =&gt;</span></span></span><br><span class="line"><span class="javascript">        cancelButton.addEventListener(<span class="string">&quot;click&quot;</span>, cancelCallback));</span></span><br><span class="line"><span class="javascript">    cancelToken.promise.then(<span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(id));</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript">startButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> cancellableDelayedResolve(<span class="number">1000</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每次单击“Start”按钮都会开始计时，并实例化一个新的<code>CancelToken</code>的实例。此时，“Cancel”按钮一旦被点击，就会触发令牌实例中的期约解决。而解决之后，单击“Start”按钮设置的超时也会被取消。</p>
<h4 id="11-2-5-2-期约进度通知"><a href="#11-2-5-2-期约进度通知" class="headerlink" title="11.2.5.2   期约进度通知"></a><strong>11.2.5.2   期约进度通知</strong></h4><p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。监控期约的执行进度会很有用。</p>
<p>一种实现方式是扩展<code>Promise</code>类，为它添加<code>notify()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackablePromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">      <span class="built_in">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executor(resolve, reject, <span class="function">(<span class="params">status</span>) =&gt;</span> &#123;</span><br><span class="line">        notifyHandlers.map(<span class="function">(<span class="params">handler</span>) =&gt;</span> handler(status));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.notifyHandlers = notifyHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params">notifyHandler</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.notifyHandlers.push(notifyHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，<code>TrackablePromise</code>就可以在执行函数中使用<code>notify()</code>函数了。这个期约会连续5次递归地设置1000毫秒的超时。每个超时回调都会调用<code>notify()</code>并传入状态值。假设通知处理程序简单地这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  countdown(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;progress:&#x27;</span>, x));</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"><span class="comment">// （约1秒后）progress: 80% remaining</span></span><br><span class="line"><span class="comment">// （约2秒后）progress: 60% remaining</span></span><br><span class="line"><span class="comment">// （约3秒后）progress: 40% remaining</span></span><br><span class="line"><span class="comment">// （约4秒后）progress: 20% remaining</span></span><br><span class="line"><span class="comment">// （约5秒后）completed</span></span><br></pre></td></tr></table></figure>
<h2 id="11-3-异步函数"><a href="#11-3-异步函数" class="headerlink" title="11.3　异步函数"></a>11.3　异步函数</h2><p>异步函数，也称为“async/await”（语法关键字），让以同步方式写的代码能够异步执行。下面来看一个最简单的例子，这个期约在超时之后会解决为一个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>这个期约在1000毫秒之后解决为数值3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; setTimeout(resolve, 1000, 3));</span><br><span class="line">p.then((x) &#x3D;&gt; console.log(x));  &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<p>这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">x</span>) </span>&#123; <span class="built_in">console</span>.log(x); &#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.then(handler); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>但这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码照样还是要放到处理程序里。ES8为此提供了async/await关键字。</p>
<h3 id="11-3-1-异步函数"><a href="#11-3-1-异步函数" class="headerlink" title="11.3.1　异步函数"></a>11.3.1　异步函数</h3><p><code>async</code>和<code>await</code>旨在解决利用异步结构组织代码的问题。</p>
<h4 id="11-3-1-1async"><a href="#11-3-1-1async" class="headerlink" title="11.3.1.1async"></a>11.3.1.1<code>async</code></h4><p><code>async</code>关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">qux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>async</code>关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通JavaScript函数的正常行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>不过，异步函数如果使用<code>return</code>关键字返回了值（如果没有<code>return</code>则会返回<code>undefined</code>），这个值会被<code>Promise.resolve()</code>包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure>
<p>当然，直接返回一个期约对象也是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure>
<p>异步函数的返回值期待一个实现<code>thenable</code>接口的对象，但常规的值也可以。如果返回的是实现<code>thenable</code>接口的对象，则这个对象可以由提供给<code>then()</code>的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="built_in">console</span>.log);  <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 返回一个没有实现thenable接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">bar().then(<span class="built_in">console</span>.log); <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 返回一个实现了thenable接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">callback</span>)</span> &#123; callback(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line">baz().then(<span class="built_in">console</span>.log);  <span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">qux().then(<span class="built_in">console</span>.log);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure>
<p>不过，拒绝期约的错误不会被异步函数捕获：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3</span></span><br></pre></td></tr></table></figure>
<h4 id="11-3-1-2await"><a href="#11-3-1-2await" class="headerlink" title="11.3.1.2await"></a>11.3.1.2<code>await</code></h4><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用<code>await</code>关键字可以暂停异步函数代码的执行，等待期约解决。来看下面这个本章开始就出现过的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.then(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>使用async/await可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>await</code>关键字会暂停执行异步函数后面的代码，让出JavaScript运行时的执行线程。这个行为与生成器函数中的<code>yield</code>关键字是一样的。<code>await</code>关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。<br><code>await</code>关键字的用法与JavaScript的一元操作一样。它可以单独使用，也可以在表达式中使用，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步打印&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo</span></span><br><span class="line">　</span><br><span class="line">　</span><br><span class="line"><span class="comment">// 异步打印&quot;bar&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar().then(<span class="built_in">console</span>.log);  <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 1000毫秒后异步打印&quot;baz&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">baz();  <span class="comment">// baz（1000毫秒后）</span></span><br></pre></td></tr></table></figure>
<p><code>await</code>关键字期待（但实际上并不要求）一个实现<code>thenable</code>接口的对象，但常规的值也可以。如果是实现<code>thenable</code>接口的对象，则这个对象可以由<code>await</code>来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 等待一个没有实现thenable接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> [<span class="string">&#x27;bar&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 等待一个实现了thenable接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">callback</span>)</span> &#123; callback(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line">baz();  <span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">qux();  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<p><code>await</code>会抛出错误的同步操作，会返回拒绝的期约：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="number">3</span>; &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure>
<p>单独的<code>Promise.reject()</code>不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用<code>await</code>则会释放（unwrap）错误值（将拒绝期约返回）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure>
<h4 id="11-3-1-3await的限制"><a href="#11-3-1-3await的限制" class="headerlink" title="11.3.1.3await的限制"></a>11.3.1.3<code>await</code>的限制</h4><p><code>await</code>关键字必须在异步函数中使用，不能在顶级上下文如<code>&lt;script&gt;</code>标签或模块中使用。不过，定义并立即调用异步函数是没问题的。下面两段代码实际是相同的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 立即调用的异步函数表达式</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line">&#125;)();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>此外，异步函数的特质不会扩展到嵌套函数。因此，<code>await</code>关键字也只能直接出现在异步函数的定义中。在同步函数内部使用<code>await</code>会抛出<code>SyntaxError</code>。<br>下面展示了一些会出错的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许：await出现在了箭头函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> syncFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await出现在了同步函数声明中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">syncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await出现在了同步函数表达式中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> syncFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：IIFE使用同步函数表达式或箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>)); &#125;)();</span><br><span class="line">  (<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>)))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-2-停止和恢复执行"><a href="#11-3-2-停止和恢复执行" class="headerlink" title="11.3.2　停止和恢复执行"></a>11.3.2　停止和恢复执行</h3><p><code>await</code>不仅只是等待一个值，并且会记录在哪里暂停执行。等到<code>await</code>右边的值可用了，JavaScript运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。</p>
<p>因此，即使<code>await</code>后面跟着一个立即可用的值，函数的其余部分也会被<strong>异步</strong>求值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">6</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3、4、5、6、7、8、9</span></span><br></pre></td></tr></table></figure>
<h3 id="11-3-3-异步函数策略"><a href="#11-3-3-异步函数策略" class="headerlink" title="11.3.3　异步函数策略"></a>11.3.3　异步函数策略</h3><p>因为简单实用，所以异步函数很快成为JavaScript项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。</p>
<h4 id="11-3-3-1-实现sleep"><a href="#11-3-3-1-实现sleep" class="headerlink" title="11.3.3.1   实现sleep()"></a><strong>11.3.3.1   实现</strong><code>sleep()</code></h4><p>以前实现Java中<code>Thread.sleep()</code>之类的函数，好在程序中加入非阻塞的暂停，基本上都通过<code>setTimeout()</code>利用JavaScript运行时的行为来实现的。</p>
<p>有了异步函数之后，就可以简单实现sleep()：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1500</span>); <span class="comment">// 暂停约1500毫秒</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - t0);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 1502</span></span><br></pre></td></tr></table></figure>
<h4 id="11-3-3-2-利用平行执行"><a href="#11-3-3-2-利用平行执行" class="headerlink" title="11.3.3.2   利用平行执行"></a><strong>11.3.3.2   利用平行执行</strong></h4><p>就算期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟0~1000毫秒</span></span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">await</span> randomDelay(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 1607ms elapsed</span></span><br></pre></td></tr></table></figure>
<p>但如果顺序不是必需保证的，那么就可以先一次性初始化所有期约，然后再分别等待它们的结果。虽然期约没有按照顺序执行，但<code>await</code>是按顺序收到了每个期约的值的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> promises = <span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> randomDelay(i));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">await</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 717ms elapsed</span></span><br></pre></td></tr></table></figure>
<h4 id="11-3-3-3-串行执行期约"><a href="#11-3-3-3-串行执行期约" class="headerlink" title="11.3.3.3   串行执行期约"></a><strong>11.3.3.3   串行执行期约</strong></h4><p>使用async/await，期约连锁会变得很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">    x = <span class="keyword">await</span> fn(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<p>如果要使用期约，则可以把所有函数都改成异步函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">    x = <span class="keyword">await</span> fn(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<h4 id="11-3-3-4-栈追踪与内存管理-？"><a href="#11-3-3-4-栈追踪与内存管理-？" class="headerlink" title="11.3.3.4   栈追踪与内存管理 ？"></a><strong>11.3.3.4   栈追踪与内存管理 ？</strong></h4><p>期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。下面的例子，展示了拒绝期约的栈追踪信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">//   setTimeout</span></span><br><span class="line"><span class="comment">//   setTimeout (async)</span></span><br><span class="line"><span class="comment">//   fooPromiseExecutor</span></span><br><span class="line"><span class="comment">//   foo</span></span><br></pre></td></tr></table></figure>
<p>栈追踪信息应该相当直接地表现JavaScript引擎当前栈内存中函数调用之间的嵌套关系。在超时处理程序执行时和拒绝期约时，我们看到的错误信息包含嵌套函数的标识符，那是被调用以创建最初期约实例的函数。可是，我们知道这些函数<strong>已经返回</strong>了，因此栈追踪信息中不应该看到它们。<br>答案很简单，这是因为JavaScript引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。</p>
<p>如果在前面的例子中使用的是异步函数，那又会怎样呢？比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">//   foo</span></span><br><span class="line"><span class="comment">//   async function (async)</span></span><br><span class="line"><span class="comment">//   foo</span></span><br></pre></td></tr></table></figure>
<p>这样栈追踪信息就准确地反映了当前的调用栈。<code>fooPromiseExecutor()</code>已经返回，所以它不在错误信息中。但<code>foo()</code>此时被挂起了，并没有退出。JavaScript运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>03-语言基础</title>
    <url>/2021/01/23/note/JavaScript/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1　语法"></a>3.1　语法</h2><h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1　区分大小写"></a>3.1.1　区分大小写</h3><p>ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符。</p>
<h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2　标识符"></a>3.1.2　标识符</h3><p><strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p>
<ol>
<li>第一个字符必须是一个字母或下划线或$；</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。</p>
<p>ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>不能作为标识符。</p>
<h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3　注释"></a>3.1.3　注释</h3><p>包括单行注释和块注释。单行注释以两个斜杠字符开头，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>
<p>块注释以一个斜杠和一个星号（<code>/*</code>）开头，以它们的反向组合（<code>*/</code>）结尾，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是多行</span></span><br><span class="line"><span class="comment">注释 */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4　严格模式"></a>3.1.4　严格模式</h3><p>严格模式是一种不同的JavaScript解析和执行模型，要对整个脚本启用严格模式，在脚本开头加上：”use strict”;，它其实是一个预处理指令也可以单独指定一个函数在严格模式下执行，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5　语句"></a>3.1.5　语句</h3><p>ECMAScript中的语句以分号结尾。省略分号则由解析器确定语句在哪里结尾(不推荐)。</p>
<p>加分号有助于防止省略造成的问题，比如避免输入内容不完整，也便于开发者通过删除空行来压缩代码，也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。</p>
<p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号（<code>&#123;</code>）标识开始，一个右花括号（<code>&#125;</code>）标识结束.</p>
<p>if之类的控制语句只在执行多条语句时要求必须有代码块。最好始终在控制语句中使用代码块，即使要执行的只有一条语句。</p>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2　关键字与保留字"></a>3.2　关键字与保留字</h2><p>保留的关键字不能用作标识符或属性名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>       <span class="keyword">do</span>          <span class="keyword">in</span>            <span class="keyword">typeof</span></span><br><span class="line"><span class="keyword">case</span>        <span class="keyword">else</span>        <span class="keyword">instanceof</span>    <span class="keyword">var</span></span><br><span class="line"><span class="keyword">catch</span>       <span class="keyword">export</span>      <span class="keyword">new</span>           <span class="keyword">void</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>       <span class="keyword">extends</span>     <span class="title">return</span>        <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">const</span>       <span class="title">finally</span>     <span class="title">super</span>         <span class="title">with</span></span></span><br><span class="line"><span class="class"><span class="title">continue</span>    <span class="title">for</span>         <span class="title">switch</span>        <span class="title">yield</span></span></span><br><span class="line"><span class="class"><span class="title">debugger</span>    <span class="title">function</span>    <span class="title">this</span></span></span><br><span class="line"><span class="class"><span class="title">default</span>     <span class="title">if</span>          <span class="title">throw</span></span></span><br><span class="line"><span class="class"><span class="title">delete</span>      <span class="title">import</span>      <span class="title">try</span></span></span><br></pre></td></tr></table></figure>
<p><strong>未来的保留字</strong>，同样不能用作标识符或属性名。但现在还可以用作对象的属性名（不推荐）。它们是保留给将来做关键字用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//始终保留:</span></span><br><span class="line">enum</span><br><span class="line"><span class="comment">//严格模式下保留:</span></span><br><span class="line">implements  package     public</span><br><span class="line">interface   protected   <span class="keyword">static</span></span><br><span class="line"><span class="keyword">let</span>         private</span><br><span class="line"><span class="comment">//模块代码中保留:</span></span><br><span class="line"><span class="keyword">await</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3　变量"></a>3.3　变量</h2><p>ECMAScript变量是松散类型的，变量可以用于保存任何类型的数据。有3个关键字可以声明变量：<code>var</code>、<code>const</code>和<code>let</code>。</p>
<h3 id="3-3-1-var关键字"><a href="#3-3-1-var关键字" class="headerlink" title="3.3.1   var关键字"></a>3.3.1   <code>var</code>关键字</h3><p>要定义变量，可以使用<code>var</code>操作符，后跟变量名（即标识符）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">//不初始化的情况下，变量会保存一个特殊值`undefined`</span></span><br></pre></td></tr></table></figure>
<p>初始化变量不会将它标识为字符串类型，随后不仅可以改变保存的值，也可以改变值的类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">message = <span class="number">100</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-1-var声明作用域"><a href="#3-3-1-1-var声明作用域" class="headerlink" title="3.3.1.1   var声明作用域"></a>3.3.1.1   <code>var</code>声明作用域</h4><p><code>var</code>声明作用域关键的问题在于，使用<code>var</code>操作符定义的变量会成为包含它的函数的局部变量。使用<code>var</code>在一个函数内部定义一个变量，该变量将在函数退出时被销毁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<p>在函数内定义变量时省略<code>var</code>操作符，可以创建一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   message = <span class="string">&quot;hi&quot;</span>;     <span class="comment">// 全局变量,不推荐，严格模式会报错</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量及可选的初始化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">    found = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>在严格模式下，不能定义名为<code>eval</code>和<code>arguments</code>的变量，否则会导致语法错误。</p>
<h4 id="3-3-1-2-var声明提升"><a href="#3-3-1-2-var声明提升" class="headerlink" title="3.3.1.2   var声明提升"></a>3.3.1.2   <code>var</code>声明提升</h4><p>使用<code>var</code>时，声明的变量会自动提升到函数作用域顶部，反复多次使用<code>var</code>声明同一个变量也没有问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-let声明"><a href="#3-3-2-let声明" class="headerlink" title="3.3.2   let声明"></a>3.3.2   <code>let</code>声明</h3><p><code>var</code>声明的范围是函数作用域，而<code>let</code>声明的范围是块作用域，作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于<code>var</code>的作用域限制同样也适用于<code>let</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);   <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);   <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>不允许同一个块作用域中出现冗余声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;  <span class="comment">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，这是因为同一个块中没有重复声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);    <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混用<code>let</code>和<code>var</code>同样可能会到冗余声明。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-1-暂时性死区"><a href="#3-3-2-1-暂时性死区" class="headerlink" title="**3.3.2.1 **  暂时性死区"></a>**3.3.2.1 **  暂时性死区</h4><p><code>let</code>声明的变量不会在作用域中被提升。在<code>let</code>声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-2-全局声明"><a href="#3-3-2-2-全局声明" class="headerlink" title="3.3.2.2   全局声明"></a><strong>3.3.2.2</strong>   全局声明</h4><p>使用<code>let</code>在全局作用域中声明的变量不会成为<code>window</code>对象的属性（<code>var</code>声明的变量会）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>let</code>声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为避免<code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p>
<h4 id="3-3-2-3-条件声明"><a href="#3-3-2-3-条件声明" class="headerlink" title="3.3.2.3   条件声明"></a>3.3.2.3   条件声明</h4><p>在使用<code>var</code>声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为<code>let</code>的作用域是块，所以不可能检查前面是否已经使用<code>let</code>声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> age = <span class="number">26</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 前面声明过，但可以合并为一个声明</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 前面声明过，会报错</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> age = <span class="number">36</span>; </span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>try</code>/<code>catch</code>语句或<code>typeof</code>操作符也不能解决，因为<code>let</code>声明的作用域仅限于该条件块。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="comment">// let name = &#x27;Nicholas&#x27;;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量，那它可以假设还没有声明过</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> name;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 因为name被限制在if &#123;&#125; 块的作用域内，因此下面这个赋值形同全局赋值</span></span></span><br><span class="line"><span class="javascript">  name = <span class="string">&#x27;Matt&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">//&#x27;Matt&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为此，对于<code>let</code>声明关键字，不能依赖条件声明模式，这是一种反模式，它让程序变得更难理解。</p>
<h4 id="3-3-2-4-for循环中的let声明"><a href="#3-3-2-4-for循环中的let声明" class="headerlink" title="3.3.2.4   for循环中的let声明"></a>3.3.2.4   <code>for</code>循环中的<code>let</code>声明</h4><p>在<code>let</code>出现之前，<code>for</code>循环定义的迭代变量会渗透到循环体外部：改成使用<code>let</code>之后，这个问题就消失了，因为迭代变量的作用域仅限于<code>for</code>循环块内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i没有定义</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>var</code>的时候，最常见的问题是对迭代变量的奇特声明和修改，而在使用<code>let</code>声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个<code>setTimeout</code>引用的都是不同的变量实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5、5、5、5、5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-const声明"><a href="#3-3-3-const声明" class="headerlink" title="3.3.3   const声明"></a>3.3.3   <code>const</code>声明</h3><p><code>const</code>的行为与<code>let</code>基本相同，区别是用它声明变量时必须同时初始化变量，且修改<code>const</code>声明的变量会导致运行时错误。</p>
<p><code>const</code>声明的限制只适用于它指向的变量的引用。如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>不能用<code>const</code>来声明迭代变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>const</code>声明一个不会被修改的<code>for</code>循环变量。这对<code>for-of</code>和<code>for-in</code>循环特别有意义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4　声明风格及最佳实践"></a>3.3.4　声明风格及最佳实践</h3><h4 id="3-3-4-1-不使用var"><a href="#3-3-4-1-不使用var" class="headerlink" title="3.3.4.1   不使用var"></a><strong>3.3.4.1   不使用</strong><code>var</code></h4><p>限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<h4 id="3-3-4-2const优先，let次之"><a href="#3-3-4-2const优先，let次之" class="headerlink" title="3.3.4.2const优先，let次之"></a>3.3.4.2<code>const</code>优先，<code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者发现因意外赋值导致的非预期行为。</p>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4　数据类型"></a>3.4　数据类型</h2><p>ECMAScript有6种简单数据类型，也称为<strong>原始类型</strong>：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。还有一种复杂数据类型叫<code>Object</code>（对象）。</p>
<h3 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1   typeof操作符"></a>3.4.1   <code>typeof</code>操作符</h3><p><code>typeof</code>操作符用来确定任意变量的数据类型。对一个值使用<code>typeof</code>操作符会返回下列字符串之一：</p>
<ul>
<li><code>&quot;undefined&quot;</code>表示值未定义；</li>
<li><code>&quot;boolean&quot;</code>表示值为布尔值；</li>
<li><code>&quot;string&quot;</code>表示值为字符串；</li>
<li><code>&quot;number&quot;</code>表示值为数值；</li>
<li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或<code>null</code>；</li>
<li><code>&quot;function&quot;</code>表示值为函数；</li>
<li><code>&quot;symbol&quot;</code>表示值为符号。</li>
</ul>
<p><code>typeof</code>是一个操作符而不是函数，所以不需要参数，但也可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);    <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message));   <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);         <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>);        <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);       <span class="comment">// &quot;object&quot;,因为特殊值`null`被认为是一个对空对象的引用</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。为此通过<code>typeof</code>操作符来区分函数和其他对象。</p>
</blockquote>
<h3 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2   Undefined类型"></a>3.4.2   <code>Undefined</code>类型</h3><p><code>Undefined</code>类型只有一个值，就是特殊值<code>undefined</code>。当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值。</p>
<p>变量显式地以<code>undefined</code>来初始化是不必要的，<code>undefined</code>主要用于比较，目的是为了明确空对象指针<code>null</code>和未初始化变量的区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>包含<code>undefined</code>值的变量跟未定义变量是有区别的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;    <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>在对未初始化的变量和对未声明的变量调用<code>typeof</code>时，返回的结果都是<code>&quot;undefined&quot;</code>。对未声明的变量调用<code>delete</code>也不会报错，但这个操作没什么用，而且在严格模式下还会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>  建议在声明变量的同时进行初始化。当<code>typeof</code>返回<code>&quot;undefined&quot;</code>时，会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p>
</blockquote>
<p><code>undefined</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// age没有声明</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-Null类型"><a href="#3-4-3-Null类型" class="headerlink" title="3.4.3   Null类型"></a>3.4.3   <code>Null</code>类型</h3><p><code>Null</code>类型同样只有一个值，即特殊值<code>null</code>。逻辑上讲，<code>null</code>值表示一个空对象指针。</p>
<p>在定义将来要保存对象值的变量时，建议使用<code>null</code>来初始化。这样，只要检查这个变量的值是不是<code>null</code>就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p>
<p><code>undefined</code>值是由<code>null</code>值派生而来的，用等于操作符（<code>==</code>）会为了比较而转换它的操作数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>即使<code>null</code>和<code>undefined</code>有关系，但用途完全不一样的。只要变量要保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量。这样就可以保持<code>null</code>是空对象指针的语义，并进一步将其与<code>undefined</code>区分开来。</p>
<p><code>null</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p>
<h3 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4   Boolean类型"></a>3.4.4   <code>Boolean</code>类型</h3><p><code>Boolean</code>（布尔值）类型有两个字面值：<code>true</code>和<code>false</code>。这两个布尔值不同于数值，<code>true</code>不等于1，<code>false</code>不等于0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">1</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>布尔值字面量<code>true</code>和<code>false</code>是区分大小写的，因此<code>True</code>和<code>False</code>是有效的标识符，但不是布尔值。<br>虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。可以调用特定的<code>Boolean()</code>转型函数，将一个其他类型的值转换为布尔值，转换为<code>true</code>或<code>false</code>的规则取决于数据类型和实际的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">转换为true的值</th>
<th align="left">转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="left">true</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">非空字符串</td>
<td align="left">“”（空字符串）</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">非零数值（包括无穷值）</td>
<td align="left">0、NaN</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">任意对象</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">Undefined</td>
<td align="left">N/A（不存在）</td>
<td align="left">undefined</td>
</tr>
</tbody></table>
<p><code>if</code>等流控制语句会自动执行其他类型值到布尔值的转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Value is true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5   Number类型"></a>3.4.5   <code>Number</code>类型</h3><p><code>Number</code>类型使用IEEE 754格式表示整数和浮点值（也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>;  <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure>
<p>用八进制（以8为基数）字面量表示，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。<br>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。ECMAScript 2015或ES6中的八进制值通过前缀<code>0o</code>来表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>;  <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>;  <span class="comment">// 无效的八进制值，当成79处理</span></span><br></pre></td></tr></table></figure>
<p>整数也可以或十六进制（以16为基数）字面量表示。必须让真正的数值前缀<code>0x</code>（区分大小写），然后是十六进制数字（0<del>9以及A</del>F）。十六进制数字中的字母大小写均可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>;   <span class="comment">// 十六进制10</span></span><br></pre></td></tr></table></figure>
<p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<blockquote>
<p><strong>注意</strong>   由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。</p>
</blockquote>
<h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1   浮点值"></a>3.4.5.1   浮点值</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。推荐小数点前面加上整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">.1</span>;   <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">// 小数点后面没有数字，当成整数1处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">// 小数点后面是零，当成整数10处理</span></span><br></pre></td></tr></table></figure>
<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure>
<p>科学记数法也可以用于表示非常小的数值。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为3e-7）。</p>
<blockquote>
<p><strong>注意</strong>   浮点值的精确度最高可达17位小数，但在算术计算中不如整数精确。例如，0.1加0.2得到的不是0.3，之所以存在这种舍入错误，是因为使用了IEEE 754数值。</p>
</blockquote>
<h4 id="3-4-5-2-值的范围"><a href="#3-4-5-2-值的范围" class="headerlink" title="3.4.5.2   值的范围"></a>3.4.5.2   值的范围</h4><p>由于内存的限制，ECMAScript可以表示的最小数值保存在<code>Number.MIN_VALUE</code>中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。</p>
<p>如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为任何无法表示的负数以<code>-Infinity</code>（负无穷大），或者任何无法表示的正数以<code>Infinity</code>（正无穷大），而且该值不能再进一步用于任何计算。因为没有可用于计算的数值表示形式。</p>
<p>要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用<code>isFinite()</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 使用<code>Number.NEGATIVE_INFINITY</code>和<code>Number.POSITIVE_INFINITY</code>也可以获取正、负<code>Infinity</code>。这两个属性包含的值分别就是<code>-Infinity</code>和<code>Infinity</code>。</p>
</blockquote>
<h4 id="3-4-5-3-NaN"><a href="#3-4-5-3-NaN" class="headerlink" title="3.4.5.3   NaN"></a>3.4.5.3   <code>NaN</code></h4><p>有一个特殊的数值叫<code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了，而不是抛出错误。在ECMAScript中，0、+0或-0相除会返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span>/+<span class="number">0</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/-<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<p>任何涉及<code>NaN</code>的操作始终返回<code>NaN</code>（如<code>NaN/10</code>），在连续多步计算时这可能是个问题。其次，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript提供了<code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-5-4-数值转换"><a href="#3-4-5-4-数值转换" class="headerlink" title="3.4.5.4   数值转换"></a>3.4.5.4   数值转换</h4><p>有3个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。</p>
<p><code>Number()</code>函数基于如下规则执行转换。</p>
<ul>
<li>布尔值，<code>true</code>转换为1，<code>false</code>转换为0。</li>
<li>数值，直接返回。</li>
<li><code>null</code>，返回0。</li>
<li><code>undefined</code>，返回<code>NaN</code>。</li>
<li>字符串，应用以下规则。<ul>
<li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，<code>Number(&quot;-1&quot;)</code>返回-1，<code>Number(&quot;123&quot;)</code>返回123，<code>Number(&quot;011&quot;)</code>返回11（忽略前面的零）。</li>
<li>如果字符串包含有效的浮点值格式如<code>&quot;1.1&quot;</code>，则会转换为相应的浮点值（同样，忽略前面的零）。</li>
<li>如果字符串包含有效的十六进制格式如<code>&quot;0xf&quot;</code>，则会转换为与该十六进制值对应的十进制整数值。</li>
<li>如果是空字符串（不包含字符），则返回0。</li>
<li>如果字符串包含除上述情况之外的其他字符，则返回<code>NaN</code>。</li>
</ul>
</li>
<li>对象，调用<code>valueOf()</code>方法，并按照上述规则转换返回的值。如果转换结果是<code>NaN</code>，则调用<code>toString()</code>方法，再按照转换字符串的规则转换。</li>
</ul>
<blockquote>
<p><strong>注意</strong> 一元加操作符与<code>Number()</code>函数遵循相同的转换规则。</p>
</blockquote>
<p>通常在需要得到整数时可以优先使用<code>parseInt()</code>函数。<code>parseInt()</code>函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回<code>NaN</code>。空字符串也会返回<code>NaN</code>。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p>
<p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>);          <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 10，解释为十六进制整数</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);        <span class="comment">// 22 因为小数点不是有效的整数字符</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>);        <span class="comment">// 70，解释为十进制值</span></span><br></pre></td></tr></table></figure>
<p>不同的数值格式很容易混淆，因此<code>parseInt()</code>也接收第二个参数，用于指定底数（进制数）。事实上，如果提供了十六进制参数，那么字符串前面的<code>&quot;0x&quot;</code>可以省掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);  <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>建议始终传给第二个参数，因为不传底数参数相当于让<code>parseInt()</code>自己决定如何解析。</p>
<p><code>parseFloat()</code>函数的工作方式跟<code>parseInt()</code>函数类似，都是从位置0开始检测每个字符。不同在于第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p>
<p><code>parseFloat()</code>函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为<code>parseFloat()</code>只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则<code>parseFloat()</code>返回整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234，按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>);      <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>);   <span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>);    <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>);   <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6   String类型"></a>3.4.6   <code>String</code>类型</h3><p><code>String</code>（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示。</p>
<p>ECMAScript语法中表示字符串的引号没有区别，但以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Nicholas&quot;; // 语法错误：开头和结尾的引号必须是同一种</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-1-字符字面量"><a href="#3-4-6-1-字符字面量" class="headerlink" title="3.4.6.1   字符字面量"></a><strong>3.4.6.1   字符字面量</strong></h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字面量</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
</tr>
<tr>
<td align="left">\|反斜杠（\）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\&#39;</td>
<td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td>
</tr>
<tr>
<td align="left">\“</td>
<td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td>
</tr>
<tr>
<td align="left">\`</td>
<td align="left">反引号（\），在字符串以反引号标示时使用，例如\He said, \`hey.\\</td>
</tr>
<tr>
<td align="left">\xnn</td>
<td align="left">以十六进制编码<code>nn</code>表示的字符（其中<em>n</em>是十六进制数字0~F），例如<code>\x41</code>等于”A”</td>
</tr>
<tr>
<td align="left">\unnnn</td>
<td align="left">以十六进制编码<code>nnnn</code>表示的Unicode字符（其中<code>n</code>是十六进制数字0~F），例如<code>\u03a3</code>等于希腊字符”Σ”</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释,转义序列表示一个字符。字符串的长度可以通过其<code>length</code>属性获取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is the letter sigma: \u03a3.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-2-字符串的特点"><a href="#3-4-6-2-字符串的特点" class="headerlink" title="3.4.6.2   字符串的特点"></a>3.4.6.2   <strong>字符串的特点</strong></h4><p>ECMAScript中的字符串是不可变的（immutable），要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3   转换为字符串"></a><strong>3.4.6.3   转换为字符串</strong></h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的<code>toString()</code>方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString();      <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString();  <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toString()</code>方法可见于数值、布尔值、对象和字符串值。如果字符串值使用<code>toString()</code>方法，就只是返回自身的一个副本。<br>多数情况下，<code>toString()</code>不接收任何参数。但对数值调用这个方法时，可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，以十进制字符串表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());     <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));    <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));    <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));   <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法，所以不确定一个值是不是<code>null</code>或<code>undefined</code>，可以使用<code>String()</code>转型函数。<code>String()</code>函数遵循如下规则。</p>
<ul>
<li>如果值有<code>toString()</code>方法，则调用该方法（不传参数）并返回结果。</li>
<li>如果值是<code>null</code>，返回<code>&quot;null&quot;</code>。</li>
<li>如果值是<code>undefined</code>，返回<code>&quot;undefined&quot;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value1));  <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value2));  <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value3));  <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value4));  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 ** 用加号操作符给一个值加上一个空字符串<code>&quot;&quot;</code>也可以将其转换为字符串。</p>
</blockquote>
<h4 id="3-4-6-4-模板字面量"><a href="#3-4-6-4-模板字面量" class="headerlink" title="3.4.6.4   模板字面量"></a>3.4.6.4   模板字面量</h4><p>ES6新增使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString);</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineTemplateLiteral);</span><br><span class="line"><span class="comment">// 上面都一样</span></span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure>
<p>模板字面量在定义模板时特别有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br></pre></td></tr></table></figure>
<p>由于模板字面量会保持反引号内部的空格，因此看起来缩进不当的模板字符串，格式可能反而正确。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个模板字面量在换行符之后有25个空格符</span></span><br><span class="line"><span class="keyword">let</span> myTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">                         second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myTemplateLiteral.length);  <span class="comment">// 47</span></span><br><span class="line"><span class="comment">// 这个模板字面量以一个换行符开头</span></span><br><span class="line"><span class="keyword">let</span> secondTemplateLiteral = <span class="string">`</span></span><br><span class="line"><span class="string">first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(secondTemplateLiteral[<span class="number">0</span>] === <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-5-字符串插值"><a href="#3-4-6-5-字符串插值" class="headerlink" title="3.4.6.5   字符串插值"></a><strong>3.4.6.5   字符串插值</strong></h4><p>模板字面量的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p>
<p>字符串插值通过在<code>$&#123;&#125;</code>中使用一个JavaScript表达式实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedString = value + <span class="string">&#x27; to the &#x27;</span> + exponent + <span class="string">&#x27; power is &#x27;</span> + (value * value);</span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral = <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>);      <span class="comment">// Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>模板也可以插入自己之前的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">append();  <span class="comment">// abc</span></span><br><span class="line">append();  <span class="comment">// abcabc</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-6-模板字面量标签函数"><a href="#3-4-6-6-模板字面量标签函数" class="headerlink" title="3.4.6.6   模板字面量标签函数"></a><strong>3.4.6.6   模板字面量标签函数</strong></h4><p>模板字面量支持定义<strong>标签函数</strong>（tag function），而通过标签函数可以自定义插值行为。标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。因为表达式参数的数量是可变的，所以通常使用剩余操作符将它们收集到一个数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(expression);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);  <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-7-原始字符串"><a href="#3-4-6-7-原始字符串" class="headerlink" title="3.4.6.7   原始字符串"></a><strong>3.4.6.7   原始字符串</strong></h4><p><code>String.raw</code>标签函数可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);            <span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);  <span class="comment">// \u00A9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但对实际的换行符来说是不行的，因为它们不会被转换成转义序列的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure>
<p>可以通过标签函数的第一个参数，即字符串数组的<code>.raw</code>属性也可取得每个字符串的原始内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Actual characters:&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(string);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Escaped characters;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.raw) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rawString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-7-Symbol类型"><a href="#3-4-7-Symbol类型" class="headerlink" title="3.4.7   Symbol类型"></a>3.4.7   <code>Symbol</code>类型</h3><p><code>Symbol</code>（符号）是ES6新增的数据类型。听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。</p>
<h4 id="3-4-7-1-符号的基本用法"><a href="#3-4-7-1-符号的基本用法" class="headerlink" title="3.4.7.1   符号的基本用法"></a><strong>3.4.7.1   符号的基本用法</strong></h4><p>符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型，所以<code>typeof</code>操作符对符号返回<code>symbol</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p>调用<code>Symbol()</code>函数时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。但是这个字符串参数与符号定义或标识完全无关：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol);          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>符号没有字面量语法。只要创建<code>Symbol()</code>实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol);  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol);      <span class="comment">// Symbol(foo);</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol()</code>函数不能用作构造函数，与<code>new</code>关键字一起使用，这样是为了避免创建符号包装对象，像使用<code>Boolean</code>、<code>String</code>或<code>Number</code>那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>如果确实想使用符号包装对象，可以借用<code>Object()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol);   <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-2-使用全局符号注册表"><a href="#3-4-7-2-使用全局符号注册表" class="headerlink" title="3.4.7.2   使用全局符号注册表"></a><strong>3.4.7.2   使用全局符号注册表</strong></h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用<code>Symbol.for()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，就生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);       <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);  <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用<code>Symbol()</code>定义的符号也不等同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给<code>Symbol.for()</code>的任何值都会被转换为字符串。注册表中使用的键同时也会被用作符号描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(emptyGlobalSymbol);    <span class="comment">// Symbol(undefined)</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>Symbol.keyFor()</code>来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。如果传给<code>Symbol.keyFor()</code>的不是符号，则该方法抛出<code>TypeError</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s));   <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2));  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-3-使用符号作为属性"><a href="#3-4-7-3-使用符号作为属性" class="headerlink" title="3.4.7.3   使用符号作为属性"></a>3.4.7.3   使用符号作为属性</h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code>/<code>Object.definedProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);  <span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);  <span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line">  [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">  [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">//  Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。两个方法的返回值彼此互斥。<code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规和符号属性描述符的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">  qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));  <span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));  <span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(o));  <span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure>
<p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)]: <span class="string">&#x27;bar val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o);  <span class="comment">// &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(o)</span><br><span class="line">              .find(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.toString().match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="built_in">console</span>.log(barSymbol);  <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-4-常用内置符号"><a href="#3-4-7-4-常用内置符号" class="headerlink" title="3.4.7.4   常用内置符号"></a><strong>3.4.7.4   常用内置符号</strong></h4><p><strong>常用内置符号</strong>（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。它们以<code>Symbol</code>工厂函数字符串属性的形式存在。</p>
<p>内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变<code>for-of</code>在迭代该对象时的行为。</p>
<p>这些内置符号就是全局函数<code>Symbol</code>的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>
<blockquote>
<p>**注意 ** 在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为<code>@@</code>。比如，<code>@@iterator</code>指的就是<code>Symbol.iterator</code>。</p>
</blockquote>
<h4 id="3-4-7-5-Symbol-asyncIterator"><a href="#3-4-7-5-Symbol-asyncIterator" class="headerlink" title="3.4.7.5   Symbol.asyncIterator"></a><strong>3.4.7.5</strong>   <code>Symbol.asyncIterator</code></h4><p>这个符号作为一个属性表示：一个方法，该方法返回对象默认的<code>AsyncIterator</code>，由<code>for-await-of</code>语句使用。也就是表示实现异步迭代器API的函数。</p>
<p><code>for-await-of</code>循环会利用这个函数执行异步迭代操作。循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数会返回一个实现迭代器API的对象。大多数返回的对象是实现该API的<code>AsyncGenerator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.asyncIterator]()); <span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个由<code>Symbol.asyncIterator</code>函数生成的对象可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过异步生成器函数返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="built_in">this</span>.asyncIdx++));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount(); <span class="comment">//分别打印0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-6-Symbol-hasInstance"><a href="#3-4-7-6-Symbol-hasInstance" class="headerlink" title="3.4.7.6   Symbol.hasInstance"></a>3.4.7.6   <code>Symbol.hasInstance</code></h4><p>这个符号作为一个属性表示：一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用。<code>instanceof</code>操作符可以用来确定一个对象实例的原型链上是否有原型。以<code>Symbol.hasInstance</code>为键的函数会执行同样的操作，只是操作数对调了一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个属性定义在Function的原型上，因此默认在所有函数和类上都可以调用。由于<code>instanceof</code>操作符会在原型链上寻找这个属性定义，因此可以在继承的类上通过静态方法重新定义这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-7-Symbol-isConcatSpreadable"><a href="#3-4-7-7-Symbol-isConcatSpreadable" class="headerlink" title="3.4.7.7   Symbol.isConcatSpreadable"></a>3.4.7.7   <code>Symbol.isConcatSpreadable</code></h4><p>这个符号作为一个属性表示：一个布尔值，如果是<code>true</code>，则对象应该用<code>Array.prototype.concat()</code>打平其数组元素。ES6中的<code>Array.prototype.concat()</code>方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。</p>
<p>数组对象默认情况下会被打平到已有的数组，<code>false</code>或假值会导致整个对象被追加到数组末尾。相反，类数组对象默认情况下会被追加到数组末尾，<code>true</code>或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在<code>Symbol.isConcatSpreadable</code>被设置为<code>true</code>的情况下将被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line">arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-8-Symbol-iterator"><a href="#3-4-7-8-Symbol-iterator" class="headerlink" title="3.4.7.8   Symbol.iterator"></a>3.4.7.8   <code>Symbol.iterator</code></h4><p>这个符号作为一个属性表示：一个方法，该方法返回对象默认的迭代器。由<code>for-of</code>语句使用。换句话说，这个符号表示实现迭代器API的函数。</p>
<p><code>for-of</code>循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以<code>Symbol.iterator</code>为键的函数，并默认这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>Generator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个由<code>Symbol.iterator</code>函数生成的对象可以通过其<code>next()</code>方法陆续返回值，也可以隐式地通过生成器函数返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.idx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">count(); <span class="comment">//分别打印0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-9-Symbol-match"><a href="#3-4-7-9-Symbol-match" class="headerlink" title="3.4.7.9   Symbol.match"></a>3.4.7.9   <code>Symbol.match</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用。<code>String.prototype.match()</code>方法会使用以<code>Symbol.match</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]);  <span class="comment">// f [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，则可以重新定义<code>Symbol.match</code>函数以取代默认对正则表达式求值的行为，从而让<code>match()</code>方法使用非正则表达式实例。<code>Symbol.match</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMatcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-10-Symbol-replace"><a href="#3-4-7-10-Symbol-replace" class="headerlink" title="3.4.7.10   Symbol.replace"></a>3.4.7.10   <code>Symbol.replace</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>方法使用。<code>String.prototype.replace()</code>方法会使用以<code>Symbol.replace</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]);<span class="comment">//f [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.replace(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，可以重新定义<code>Symbol.replace</code>函数以取代默认对正则表达式求值的行为，从而让<code>replace()</code>方法使用非正则表达式实例。<code>Symbol.replace</code>函数接收两个参数，即调用<code>replace()</code>方法的字符串实例和替换字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReplacer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(<span class="keyword">new</span> StringReplacer(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>));  <span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-11-Symbol-search"><a href="#3-4-7-11-Symbol-search" class="headerlink" title="3.4.7.11   Symbol.search"></a>3.4.7.11   <code>Symbol.search</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用。<code>String.prototype.search()</code>方法会使用以<code>Symbol.search</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]); <span class="comment">// f [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="regexp">/bar/</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，可以重新定义<code>Symbol.search</code>函数以取代默认对正则表达式求值的行为，从而让<code>search()</code>方法使用非正则表达式实例。<code>Symbol.search</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSearcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-12-Symbol-species"><a href="#3-4-7-12-Symbol-species" class="headerlink" title="3.4.7.12   Symbol.species"></a>3.4.7.12   <code>Symbol.species</code></h4><p>这个符号作为一个属性表示：一个函数值，该函数作为创建派生对象的构造函数。这个属性在内置类型中最常用，用<code>Symbol.species</code>定义静态的获取器（getter）方法，当使用 <code>concat()</code> 这样的方法会返回默认的构造函数时，可以覆盖新创建实例的原型定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// true</span></span><br><span class="line">baz = baz.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-13-Symbol-split"><a href="#3-4-7-13-Symbol-split" class="headerlink" title="3.4.7.13   Symbol.split"></a>3.4.7.13   <code>Symbol.split</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用。<code>String.prototype.split()</code>方法会使用以<code>Symbol.split</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]);  <span class="comment">// f [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.split(<span class="regexp">/bar/</span>));  <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，可以重新定义<code>Symbol.split</code>函数以取代默认对正则表达式求值的行为，从而让<code>split()</code>方法使用非正则表达式实例。<code>Symbol.split</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSplitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(<span class="keyword">new</span> StringSplitter(<span class="string">&#x27;foo&#x27;</span>)));  <span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-14-Symbol-toPrimitive"><a href="#3-4-7-14-Symbol-toPrimitive" class="headerlink" title="3.4.7.14   Symbol.toPrimitive"></a>3.4.7.14   <code>Symbol.toPrimitive</code></h4><p>这个符号作为一个属性表示：一个方法，该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的<code>Symbol.toPrimitive</code>属性上定义一个函数可以改变默认行为。</p>
<p>根据提供给这个函数的参数（<code>string</code>、<code>number</code>或<code>default</code>），可以控制返回的原始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));   <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo);       <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo);       <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + bar);     <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - bar);     <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-15-Symbol-toStringTag"><a href="#3-4-7-15-Symbol-toStringTag" class="headerlink" title="3.4.7.15   Symbol.toStringTag"></a>3.4.7.15   <code>Symbol.toStringTag</code></h4><p>这个符号作为一个属性表示：一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用。</p>
<p>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，自定义类实例可以自定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s.toString());           <span class="comment">// [object Set]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Set</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.toString());           <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar.toString());           <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-16-Symbol-unscopables"><a href="#3-4-7-16-Symbol-unscopables" class="headerlink" title="3.4.7.16   Symbol.unscopables"></a>3.4.7.16   <code>Symbol.unscopables</code></h4><p>这个符号作为一个属性表示：一个对象，该对象所有的以及继承的属性，都会从关联对象的<code>with</code>环境绑定中排除。设置这个符号并让其映射对应属性的键值为<code>true</code>，就可以阻止该属性出现在<code>with</code>环境绑定中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">  foo: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 不推荐使用<code>with</code>，因此也不推荐使用<code>Symbol.unscopables</code>。</p>
</blockquote>
<h3 id="3-4-8-Object类型"><a href="#3-4-8-Object类型" class="headerlink" title="3.4.8   Object类型"></a>3.4.8   <code>Object</code>类型</h3><p>对象就是一组数据和功能的集合。对象通过<code>new</code>操作符后跟对象类型的名称来创建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">// 如果没有参数可以省略括号，合法但不推荐</span></span><br></pre></td></tr></table></figure>
<p>每个<code>Object</code>实例都有如下属性和方法。</p>
<ul>
<li><code>constructor</code>：用于创建当前对象的函数。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li>
<li><code>isPrototypeof(object)</code>：用于判断当前对象是否为另一个对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用<code>for-in</code>语句枚举。与<code>hasOwnProperty()</code>一样，属性名必须是字符串。</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li>
</ul>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5　操作符"></a>3.5　操作符</h2><p>ECMAScript中的操作符可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code>valueOf()</code>和<code>/</code>或<code>toString()</code>方法来取得可以计算的值。</p>
<h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1　一元操作符"></a>3.5.1　一元操作符</h3><p>只操作一个值的操作符叫<strong>一元操作符</strong>（unary operator）。</p>
<h4 id="3-5-1-1-递增-递减操作符"><a href="#3-5-1-1-递增-递减操作符" class="headerlink" title="3.5.1.1   递增/递减操作符"></a><strong>3.5.1.1   递增/递减操作符</strong></h4><p>递增和递减操作符有两个版本：</p>
<ul>
<li>前缀版就是位于要操作的变量前头</li>
<li>后缀版就是位于要操作的变量后头。</li>
</ul>
<p>前缀递增操作符会给数值加1，把两个加号（<code>++</code>）放到变量前头即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">++age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br><span class="line"><span class="comment">// 前缀递减操作符也类似 --age</span></span><br></pre></td></tr></table></figure>
<p>使用前缀版，变量的值都会在语句被求值之前改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);         <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>这4个操作符可以作用于任何值，递增和递减操作符遵循如下规则。</p>
<ul>
<li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。如果不是有效的数值形式，则将变量的值设置为<code>NaN</code>。变量类型从字符串变成数值。</li>
<li>对于布尔值，如果是<code>false</code>，则转换为0再应用改变。如果是<code>true</code>，则转换为1再应用改变。变量类型从布尔值变成数值。</li>
<li>对于浮点值，加1或减1。</li>
<li>如果是对象，则调用其<code>valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code>NaN</code>，则调用<code>toString()</code>并再次应用其他规则。变量类型从对象变成数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++;  <span class="comment">// 数值3</span></span><br><span class="line">s2++;  <span class="comment">// NaN</span></span><br><span class="line">b++;   <span class="comment">// 数值1</span></span><br><span class="line">f--;   <span class="comment">// 0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--;   <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-1-2-一元加和减"><a href="#3-5-1-2-一元加和减" class="headerlink" title="3.5.1.2   一元加和减"></a><strong>3.5.1.2   一元加和减</strong></h4><p>一元加放在变量前头，对数值没有任何影响。一元减则把数值变成负值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// -25</span></span><br></pre></td></tr></table></figure>
<p>如果将一元加应用到非数值，则相当于使用<code>Number()</code>转型函数。一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;  <span class="comment">// 值变成数值1</span></span><br><span class="line">s2 = +s2;  <span class="comment">// 值变成数值1.1</span></span><br><span class="line">s3 = +s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = +b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = +f;    <span class="comment">// 不变，还是1.1</span></span><br><span class="line">o = +o;    <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2　位操作符"></a>3.5.2　位操作符</h3><p>ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。但这个转换也导致了，特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0处理。</p>
<p>如果将位操作符应用到非数值，那么首先会自动使用<code>Number()</code>函数将该值转换为数值，然后再应用位操作。最终结果是数值。在处理有符号整数时，无法访问第31位。</p>
<p>在把负值输出为一个二进制字符串时，会得到一个前面加了减号的绝对值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = -<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;-10010&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **默认情况下，ECMAScript中的所有整数都表示为有符号数。但确实存在无符号整数。无符号整数的第32位不表示符号，因为只有正值。</p>
</blockquote>
<h4 id="3-5-2-1-按位非"><a href="#3-5-2-1-按位非" class="headerlink" title="3.5.2.1   按位非"></a>3.5.2.1   按位非</h4><p>按位非操作符用波浪符（<code>~</code>）表示，它的作用是返回数值的反码，最终效果是对数值取反并减1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;      <span class="comment">// 二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1;   <span class="comment">// 二进制11111111111111111111111111100110</span></span><br><span class="line"><span class="built_in">console</span>.log(num2);  <span class="comment">// -26</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-2-按位与"><a href="#3-5-2-2-按位与" class="headerlink" title="3.5.2.2   按位与"></a><strong>3.5.2.2   按位与</strong></h4><p>按位与操作符用和号（<code>&amp;</code>）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p>
<p>|第一个数值的位|第二个数值的位|结果|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|1|1|1|<br>|1|0|0|<br>|0|1|0|<br>|0|0|0|</p>
<p>如果对25和3执行按位与，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-3-按位或"><a href="#3-5-2-3-按位或" class="headerlink" title="3.5.2.3   按位或"></a><strong>3.5.2.3   按位或</strong></h4><p>按位或操作符用管道符（<code>|</code>）表示，同样有两个操作数。按位或遵循如下真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数值的位</th>
<th align="left">第二个数值的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>如果对25和3执行按位或，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27 </span></span><br><span class="line"></span><br><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"> OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>
<p>在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。</p>
<h4 id="3-5-2-4-按位异或"><a href="#3-5-2-4-按位异或" class="headerlink" title="3.5.2.4   按位异或"></a><strong>3.5.2.4   按位异或</strong></h4><p>按位异或用脱字符（<code>^</code>）表示，同样有两个操作数。下面是按位异或的真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数的位</th>
<th align="left">第二个数的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>对数值25和3执行按位异或操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> ^ <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 26</span></span><br><span class="line"></span><br><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">XOR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-5-左移"><a href="#3-5-2-5-左移" class="headerlink" title="3.5.2.5   左移"></a><strong>3.5.2.5   左移</strong></h4><p>左移操作符用两个小于号（<code>&lt;&lt;</code>）表示，会按照指定的位数将数值的所有位向左移动。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;              <span class="comment">// 等于二进制10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;  <span class="comment">// 等于二进制1000000，即十进制64</span></span><br></pre></td></tr></table></figure>
<p>注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值（见图3-2）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Wo1bzsOAa2BZFYH.png"
                      alt="b7qdJi277GnnBKhO__thumbnail.png"
                ></p>
<p>左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。</p>
<h4 id="3-5-2-6-有符号右移"><a href="#3-5-2-6-有符号右移" class="headerlink" title="3.5.2.6   有符号右移"></a><strong>3.5.2.6   有符号右移</strong></h4><p>有符号右移由两个大于号（<code>&gt;&gt;</code>）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;             <span class="comment">// 等于二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;  <span class="comment">// 等于二进制10，即十进制2</span></span><br></pre></td></tr></table></figure>
<p>同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图3-3）。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zdWytfUcQuvbgSJ.png"
                      alt="lfyDtLTtly9xPjgW__thumbnail.png"
                ></p>
<h4 id="3-5-2-7-无符号右移"><a href="#3-5-2-7-无符号右移" class="headerlink" title="3.5.2.7   无符号右移"></a><strong>3.5.2.7   无符号右移</strong></h4><p>无符号右移用3个大于号表示（<code>&gt;&gt;&gt;</code>），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。</p>
<p>对于负数，有时候差异会非常大。右移会给空位补0，而不管符号位是什么。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = -<span class="number">64</span>;              <span class="comment">// 等于二进制11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;   <span class="comment">// 等于十进制134217726</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3　布尔操作符"></a>3.5.3　布尔操作符</h3><p>布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。</p>
<h4 id="3-5-3-1-逻辑非"><a href="#3-5-3-1-逻辑非" class="headerlink" title="3.5.3.1   逻辑非"></a><strong>3.5.3.1   逻辑非</strong></h4><p>逻辑非操作符由一个叹号（<code>!</code>）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。逻辑非操作符会遵循如下规则。</p>
<ul>
<li>如果操作数是对象，则返回<code>false</code>。</li>
<li>如果操作数是空字符串，则返回<code>true</code>。</li>
<li>如果操作数是非空字符串，则返回<code>false</code>。</li>
<li>如果操作数是数值0，则返回<code>true</code>。</li>
<li>如果操作数是非0数值（包括<code>Infinity</code>），则返回<code>false</code>。</li>
<li>如果操作数是<code>null</code>，则返回<code>true</code>。</li>
<li>如果操作数是<code>NaN</code>，则返回<code>true</code>。</li>
<li>如果操作数是<code>undefined</code>，则返回<code>true</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;blue&quot;</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;&quot;</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">12345</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>同时使用两个叹号（<code>!!</code>），相当于调用转型函数<code>Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。</p>
<h4 id="3-5-3-2-逻辑与"><a href="#3-5-3-2-逻辑与" class="headerlink" title="3.5.3.2   逻辑与"></a><strong>3.5.3.2   逻辑与</strong></h4><p>逻辑与操作符由两个和号（<code>&amp;&amp;</code>）表示，应用到两个值。逻辑与操作符是一种短路操作符，如果第一个操作数是假值，返回第一个操作数，如果第一个操作数是真值，返回第二个操作数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; <span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-3-逻辑或"><a href="#3-5-3-3-逻辑或" class="headerlink" title="3.5.3.3   逻辑或"></a><strong>3.5.3.3   逻辑或</strong></h4><p>逻辑或操作符由两个管道符（<code>||</code>）表示。同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数是真值，第二个操作数就不会再被求值了，第一个是假值，则返回第二个操作数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable); <span class="comment">// 不会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure>
<p>利用这个行为，可以避免给变量赋值<code>null</code>或<code>undefined</code>。这种模式在ECMAScript代码中经常用于变量赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = preferredObject || backupObject;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4　乘性操作符"></a>3.5.4　乘性操作符</h3><p>ECMAScript定义了3个乘性操作符：乘法、除法和取模。在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用<code>Number()</code>转型函数转换为数值。这意味着空字符串会被当成0，而布尔值<code>true</code>会被当成1。</p>
<h4 id="3-5-4-1-乘法操作符"><a href="#3-5-4-1-乘法操作符" class="headerlink" title="3.5.4.1   乘法操作符"></a><strong>3.5.4.1   乘法操作符</strong></h4><p>乘法操作符由一个星号（<code>*</code>）表示，可以用于计算两个数值的乘积。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">34</span> * <span class="number">56</span>; <span class="comment">// 1904</span></span><br></pre></td></tr></table></figure>
<p>乘法操作符在处理特殊值时也有一些特殊的行为：</p>
<ul>
<li>如果操作数都是数值，则执行常规的乘法运算，正负符号不同的值相乘得到负值。如果ECMAScript不能表示乘积，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以非0的有限数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>乘以<code>Infinity</code>，则返回<code>Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-2-除法操作符"><a href="#3-5-4-2-除法操作符" class="headerlink" title="3.5.4.2   除法操作符"></a><strong>3.5.4.2   除法操作符</strong></h4></li>
</ul>
<p>除法操作符由一个斜杠（<code>/</code>）表示，用于计算第一个操作数除以第二个操作数的商。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">66</span> / <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>除法操作符针对特殊值也有一些特殊的行为。</p>
<ul>
<li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是0除以0，则返回<code>NaN</code>。</li>
<li>如果是非0的有限值除以0，则根据第一个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>除以任何数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-3-取模操作符-reivew"><a href="#3-5-4-3-取模操作符-reivew" class="headerlink" title="3.5.4.3   取模操作符(reivew)"></a><strong>3.5.4.3   取模操作符(reivew)</strong></h4></li>
</ul>
<p>取模（余数）操作符由一个百分比符号（<code>%</code>）表示，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">26</span> % <span class="number">5</span>; <span class="comment">// 等于1</span></span><br></pre></td></tr></table></figure>
<p>取模操作符对特殊值也有一些特殊的行为。</p>
<ul>
<li>如果操作数是数值，则执行常规除法运算，返回余数。</li>
<li>如果被除数是无限值，除数是有限值，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是无限值，则返回被除数。</li>
<li>如果被除数是0，除数不是0，则返回0。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h3 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5　指数操作符"></a>3.5.5　指数操作符</h3></li>
</ul>
<p>ECMAScript 7新增了指数操作符，和<code>Math.pow()</code>的操作符<code>**</code>是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>);         <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>指数操作符也有自己的指数赋值操作符<code>**=</code>，该操作符执行指数运算和结果的赋值操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared **= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6　加性操作符"></a>3.5.6　加性操作符</h3><p>加性操作符，即加法和减法操作符。在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p>
<h4 id="3-5-6-1-加法操作符（review）"><a href="#3-5-6-1-加法操作符（review）" class="headerlink" title="3.5.6.1   加法操作符（review）"></a><strong>3.5.6.1   加法操作符（review）</strong></h4><p>加法操作符（<code>+</code>）用于求两个数的和，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：</p>
<ul>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>；</li>
<li>如果是<code>Infinity</code>加<code>Infinity</code>，则返回<code>Infinity</code>；</li>
<li>如果是<code>-Infinity</code>加<code>-Infinity</code>，则返回<code>-Infinity</code>；</li>
<li> 如果是<code>Infinity</code>加<code>-Infinity</code>，则返回<code>NaN</code>；</li>
<li>如果是<code>+0</code>加<code>+0</code>，则返回<code>+0</code>；</li>
<li>如果是<code>-0</code>加<code>+0</code>，则返回<code>+0</code>；</li>
<li>如果是<code>-0</code>加<code>-0</code>，则返回<code>-0</code>。</li>
</ul>
<p>不过，如果有一个操作数是字符串，则要应用如下规则：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</li>
</ul>
<p>如果有任一操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法以获取字符串，然后再应用前面的关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则调用<code>String()</code>函数，分别获取<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> + <span class="number">5</span>;        </span><br><span class="line"><span class="built_in">console</span>.log(result1);    <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;      </span><br><span class="line"><span class="built_in">console</span>.log(result2);    <span class="comment">// &quot;55&quot;</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。这是因为每次加法运算都是独立完成的。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let message = &quot;The sum of 5 and 10 is &quot; + (num1 + num2);</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-6-2-减法操作符-review"><a href="#3-5-6-2-减法操作符-review" class="headerlink" title="3.5.6.2   减法操作符(review)"></a><strong>3.5.6.2   减法操作符(review)</strong></h4><p>减法操作符（<code>-</code>）也是使用很频繁的一种操作符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。</p>
<ul>
<li>如果两个操作数都是数值，则执行数学减法运算并返回结果。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>减<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>-Infinity</code>减<code>-Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>减<code>-Infinity</code>，则返回<code>Infinity</code>。</li>
<li>如果是<code>-Infinity</code>减<code>Infinity</code>，则返回<code>-Infinity</code>。</li>
<li>如果是<code>+0</code>减<code>+0</code>，则返回<code>+0</code>。</li>
<li>如果是<code>+0</code>减<code>-0</code>，则返回<code>-0</code>。</li>
<li>如果是<code>-0</code>减<code>-0</code>，则返回<code>+0</code>。</li>
<li>如果有任一操作数是字符串、布尔值、<code>null</code>或<code>undefined</code>，则先在后台使用<code>Number()</code>将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。</li>
<li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法取得表示它的数值。如果该值是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法，然后再将得到的字符串转换为数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> - <span class="literal">true</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> - <span class="number">1</span>;  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> - <span class="number">3</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;   <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7　关系操作符"></a>3.5.7　关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）和大于等于（<code>&gt;=</code>）。这几个操作符都返回布尔值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p>
<ul>
<li>如果操作数都是数值，则执行数值比较。</li>
<li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li>
<li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li>
<li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法，取得结果后再根据前面的规则执行比较。如果没有<code>valueOf()</code>操作符，则调用<code>toString()</code>方法，取得结果后再根据前面的规则执行比较。</li>
<li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
</ul>
<p>事实上，大写字母的编码都小于小写字母的编码，要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式，然后再比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span> &lt; <span class="string">&quot;alphabet&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="string">&quot;Brick&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alphabet&quot;</span>.toLowerCase(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在比较两个数值字符串的时候，因为两个操作数都是字符串，所以会逐个比较它们的字符编码，如果有一个操作数是数值，那么比较的结果就对了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// 因为&quot;a&quot;会转换为NaN，所以结果是false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8　相等操作符"></a>3.5.8　相等操作符</h3><p>ECMAScript提供了两组操作符。第一组是<strong>等于</strong>和<strong>不等于</strong>，它们在比较之前执行转换。第二组是<strong>全等</strong>和<strong>不全等</strong>，它们在比较之前不执行转换。</p>
<h4 id="3-5-8-1-等于和不等于"><a href="#3-5-8-1-等于和不等于" class="headerlink" title="3.5.8.1   等于和不等于"></a><strong>3.5.8.1   等于和不等于</strong></h4><p>ECMAScript中的等于操作符用两个等于号（<code>==</code>）表示，如果操作数相等，则会返回<code>true</code>。不等于操作符用叹号和等于号（<code>!=</code>）表示，如果两个操作数不相等，则会返回<code>true</code>。这两个操作符都会先进行类型转换（通常称为<strong>强制类型转换</strong>）再确定操作数是否相等。</p>
<p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p>
<ul>
<li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。</li>
<li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的<code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较。</li>
</ul>
<p>在进行比较时，这两个操作符会遵循如下规则。</p>
<ul>
<li><code>null</code>和<code>undefined</code>相等。</li>
<li><code>null</code>和<code>undefined</code>不能转换为其他类型的值再进行比较。</li>
<li>如果有任一操作数是<code>NaN</code>，则相等操作符返回<code>false</code>，不相等操作符返回<code>true</code>。记住：即使两个操作数都是<code>NaN</code>，相等操作符也返回<code>false</code>，因为<code>NaN</code>不等于<code>NaN</code>。</li>
<li>如果两个操作数都是对象，且都指向同一个对象，则相等操作符返回<code>true</code>。否则，不相等。</li>
</ul>
<p>下表总结了一些特殊情况及比较的结果。</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null == undefined</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“NaN” == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">5 == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN != NaN</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">false == 0</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 1</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 2</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">undefined == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">null == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">“5” == 5</td>
<td align="left">true</td>
</tr>
</tbody></table>
<h4 id="3-5-8-2-全等和不全等"><a href="#3-5-8-2-全等和不全等" class="headerlink" title="3.5.8.2   全等和不全等"></a><strong>3.5.8.2   全等和不全等</strong></h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3个等于号（<code>===</code>）表示，只有两个操作数在不转换的前提下相等才返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>);  <span class="comment">// true，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<p>不全等操作符用一个叹号和两个等于号（<code>!==</code>）表示，只有两个操作数在不转换的前提下不相等才返回<code>true</code>。</p>
<p>另外虽然<code>null == undefined</code>是<code>true</code>（因为这两个值类似），但<code>null === undefined</code>是<code>false</code>，因为它们不是相同的数据类型。</p>
<blockquote>
<p>**注意 **由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。有助于在代码中保持数据类型的完整性。</p>
</blockquote>
<h3 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9　条件操作符"></a>3.5.9　条件操作符</h3><p>语法跟Java中一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10　赋值操作符"></a>3.5.10　赋值操作符</h3><p>简单赋值用等于号（<code>=</code>）表示，将右手边的值赋给左手边的变量，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值使用乘性、加性或位操作符后跟等于号（<code>=</code>）表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p>
<ul>
<li>乘后赋值（<code>*=</code>）</li>
<li>除后赋值（<code>/=</code>）</li>
<li>取模后赋值（<code>%=</code>）</li>
<li>加后赋值（<code>+=</code>）</li>
<li>减后赋值（<code>-=</code>）</li>
<li>左移后赋值（<code>&lt;&lt;=</code>）</li>
<li>右移后赋值（<code>&gt;&gt;=</code>）</li>
<li>无符号右移后赋值（<code>&gt;&gt;&gt;=</code>）</li>
</ul>
<h3 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11　逗号操作符"></a>3.5.11　逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作。一条语句中同时声明多个变量是逗号操作符最常用的场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure>
<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6　语句"></a>3.6　语句</h2><p>ECMA-262描述了一些语句（也称为<strong>流控制语句</strong>），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p>
<h3 id="3-6-1-if语句"><a href="#3-6-1-if语句" class="headerlink" title="3.6.1   if语句"></a>3.6.1   <code>if</code>语句</h3><p>最佳实践是使用语句块，即使只有一行代码要执行也是如此。这是因为语句块可以避免对什么条件下执行什么产生困惑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-2-do-while语句"><a href="#3-6-2-do-while语句" class="headerlink" title="3.6.2   do-while语句"></a>3.6.2   <code>do-while</code>语句</h3><p><code>do-while</code>语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-3-while语句"><a href="#3-6-3-while语句" class="headerlink" title="3.6.3   while语句"></a>3.6.3   <code>while</code>语句</h3><p><code>while</code>语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code>循环体内的代码有可能不会执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-4-for语句"><a href="#3-6-4-for语句" class="headerlink" title="3.6.4   for语句"></a>3.6.4   <code>for</code>语句</h3><p><code>for</code>语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化、条件表达式和循环后表达式都不是必需的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无穷循环</span></span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只包含条件表达式，那么<code>for</code>循环实际上就变成了<code>while</code>循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; count; ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法通过<code>while</code>循环实现的逻辑，同样也无法使用<code>for</code>循环实现。<code>for</code>循环只是将循环相关的代码封装在一起。</p>
<h3 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5   for-in语句"></a>3.6.5   <code>for-in</code>语句</h3><p><code>for-in</code>语句是一种严格的迭代语句，用于枚举对象中的非符号键属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;<span class="comment">// 推荐使用const，确保这个局部变量不被修改</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript中对象的属性是无序的，因此<code>for-in</code>语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p>
<p>如果<code>for-in</code>循环要迭代的变量是<code>null</code>或<code>undefined</code>，则不执行循环体。</p>
<h3 id="3-6-6-for-of语句"><a href="#3-6-6-for-of语句" class="headerlink" title="3.6.6   for-of语句"></a>3.6.6   <code>for-of</code>语句</h3><p><code>for-of</code>语句是一种严格的迭代语句，用于遍历可迭代对象的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for-of</code>循环会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则<code>for-of</code>语句会抛出错误。</p>
<blockquote>
<p>**注意 **ES2018对<code>for-of</code>语句进行了扩展，增加了<code>for-await-of</code>循环，以支持生成期约（promise）的异步可迭代对象。</p>
</blockquote>
<h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7   标签语句"></a>3.6.7   标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>start</code>是一个标签，可以在后面通过<code>break</code>或<code>continue</code>语句引用。典型应用场景是嵌套循环。</p>
<h3 id="3-6-8-break和continue语句"><a href="#3-6-8-break和continue语句" class="headerlink" title="3.6.8   break和continue语句"></a>3.6.8   <code>break</code>和<code>continue</code>语句</h3><p><code>break</code>语句用于立即退出循环，强制执行循环后的下一条语句。而<code>continue</code>语句也用于立即退出循环，但会再次从循环顶部开始执行。</p>
<p><code>break</code>与标签语句一起使用，返回代码中特定的位置。通常是在嵌套循环中。添加标签不仅让<code>break</code>退出的内部循环，也会退出的外部循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p><code>continue</code>语句也可以使用标签。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p>组合使用标签语句和<code>break</code>、<code>continue</code>能实现复杂的逻辑，但也容易出错。</p>
<h3 id="3-6-9-with语句"><a href="#3-6-9-with语句" class="headerlink" title="3.6.9   with语句"></a>3.6.9   <code>with</code>语句</h3><p><code>with</code>语句的用途是将代码作用域设置为特定的对象，主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>with</code>语句，就可以少写一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>with</code>语句用于连接<code>location</code>对象。在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索<code>location</code>对象，如果它有一个同名的属性，则该变量会被求值为<code>location</code>对象的属性。</p>
<blockquote>
<p><strong>警告</strong> <code>with</code>语句影响性能且难于调试其中的代码，且严格模式不允许使用。通常不推荐使用<code>with</code>语句。</p>
</blockquote>
<h3 id="3-6-10-switch语句"><a href="#3-6-10-switch语句" class="headerlink" title="3.6.10   switch语句"></a>3.6.10   <code>switch</code>语句</h3><p>每个<code>case</code>（条件/分支）相当于：如果表达式等于后面的值，则执行下面的语句。<code>break</code>关键字会导致代码执行跳出<code>switch</code>语句。如果没有<code>break</code>，则代码会继续匹配下一个条件。<code>default</code>关键字用于在任何条件都没有满足时指定默认执行的语句（相当于<code>else</code>语句）。</p>
<p>为避免不必要的条件判断，最好给每个条件后面都加上<code>break</code>语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了<code>break</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="comment">/*跳过*/</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;25 or 35&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ECMAScript中，<code>switch</code>语句可以用于所有数据类型。其次条件的值不需要是常量，也可以是变量或表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 10.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 10 and 20.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;More than 20.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **<code>switch</code>语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>08-对象、类与面向对象编程</title>
    <url>/2021/04/07/note/JavaScript/08-%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>ECMA-262将对象定义为一组属性的无序集合。这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。</p>
<h2 id="8-1-理解对象"><a href="#8-1-理解对象" class="headerlink" title="8.1　理解对象"></a>8.1　理解对象</h2><p>创建自定义对象的通常方式是创建<code>Object</code>的一个新实例，然后再给它添加属性和方法，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>早期JavaScript开发者频繁使用这种方式创建新对象。现在对象字面量创建更流行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-1-属性的类型"><a href="#8-1-1-属性的类型" class="headerlink" title="8.1.1　属性的类型"></a>8.1.1　属性的类型</h3><p>ECMA-262使用一些内部特性来描述属性的特征。这些特性是由为JavaScript实现引擎的规范定义的。因此，开发者不能在JavaScript中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如<code>[[Enumerable]]</code>。</p>
<p>属性分两种：数据属性和访问器属性。</p>
<h4 id="8-1-1-1-数据属性"><a href="#8-1-1-1-数据属性" class="headerlink" title="8.1.1.1   数据属性"></a><strong>8.1.1.1   数据属性</strong></h4><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。</p>
<ol>
<li><code>[[Configurable]]</code>：表示属性是否可以通过<code>delete</code>删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过<code>for-in</code>循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li>
<li><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li>
<li><code>[[Value]]</code>：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为<code>undefined</code>。</li>
</ol>
<p>要修改属性的默认特性，就必须使用<code>Object.defineProperty()</code>方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：<code>configurable</code>、<code>enumerable</code>、<code>writable</code>和<code>value</code>，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。<br>类似的规则也适用于创建不可配置的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>非严格模式下对这个属性调用<code>delete</code>没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用<code>Object.defineProperty()</code>并修改任何非<code>writable</code>属性会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因此，虽然可以对同一个属性多次调用<code>Object.defineProperty()</code>，但在把<code>configurable</code>设置为<code>false</code>之后就会受限制。<br>在调用<code>Object.defineProperty()</code>定义一个新的属性特性，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>的值如果不指定，则都默认为<code>false</code>。多数情况下，可能都不需要<code>Object.defineProperty()</code>提供的这些强大的设置，但要理解JavaScript对象，就要理解这些概念。</p>
<h4 id="8-1-1-2-访问器属性"><a href="#8-1-1-2-访问器属性" class="headerlink" title="8.1.1.2   访问器属性"></a><strong>8.1.1.2   访问器属性</strong></h4><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。</p>
<ol>
<li><code>[[Configurable]]</code>：表示属性是否可以通过<code>delete</code>删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li>
<li><code>[[Enumerable]]</code>：表示属性是否可以通过<code>for-in</code>循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li>
<li><code>[[Get]]</code>：获取函数，在读取属性时调用。默认值为<code>undefined</code>。</li>
<li><code>[[Set]]</code>：设置函数，在写入属性时调用。默认值为<code>undefined</code>。</li>
</ol>
<p>访问器属性是不能直接定义的，必须使用<code>Object.defineProperty()</code>。访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员year_和公共成员edition</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  year_: <span class="number">2017</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">      <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2018</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回<code>undefined</code>，严格模式下会抛出错误。<br>在不支持<code>Object.defineProperty()</code>的浏览器中没有办法修改<code>[[Configurable]]</code>或<code>[[Enumerable]]</code>。</p>
<blockquote>
<p><strong>注意</strong>在ECMAScript 5以前，开发者会使用两个非标准的访问创建访问器属性：<code>__defineGetter__()</code>和<code>__defineSetter__()</code>。</p>
</blockquote>
<h3 id="8-1-2-定义多个属性"><a href="#8-1-2-定义多个属性" class="headerlink" title="8.1.2　定义多个属性"></a>8.1.2　定义多个属性</h3><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript提供了<code>Object.defineProperties()</code>方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  year_: &#123;</span><br><span class="line">    value: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="8-1-3-读取属性的特性"><a href="#8-1-3-读取属性的特性" class="headerlink" title="8.1.3　读取属性的特性"></a>8.1.3　读取属性的特性</h3><p>使用<code>Object.getOwnPropertyDescriptor()</code>方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含<code>configurable</code>、<code>enumerable</code>、<code>get</code>和<code>set</code>属性，对于数据属性包含<code>configurable</code>、<code>enumerable</code>、<code>writable</code>和<code>value</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  year_: &#123;</span><br><span class="line">    value: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);          <span class="comment">// 2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);     <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);          <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);     <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 2017新增了<code>Object.getOwnPropertyDescriptors()</code>静态方法。这个方法实际上会在每个自有属性上调用<code>Object.getOwnPropertyDescriptor()</code>并在一个新对象中返回它们。对于前面的例子，使用这个静态方法会返回如下对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//book属性定义同上</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   edition: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     value: 1,</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   year: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     get: f(),</span></span><br><span class="line"><span class="comment">//     set: f(newValue),</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   year_: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     value: 2017,</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-1-4-合并对象"><a href="#8-1-4-合并对象" class="headerlink" title="8.1.4　合并对象"></a>8.1.4　合并对象</h3><p>“合并”（merge）两个对象就是把源对象所有的本地属性一起复制到目标对象上，这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。</p>
<p>ECMAScript 6专门为合并对象提供了<code>Object.assign()</code>方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（<code>Object.propertyIsEnumerable()</code>返回<code>true</code>）和自有（<code>Object.hasOwnProperty()</code>返回<code>true</code>）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象上的<code>[[Set]]</code>设置属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">&#x27;src&#x27;</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// Object.assign修改目标对象，也会返回修改后的目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dest !== src);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(result);          <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest);            <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Invoked src getter&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 调用src的获取方法</span></span><br><span class="line"><span class="comment">// 调用dest的设置方法并传入参数&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作，所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.assign()</code>实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。也就是说，不能在两个对象间转移获取函数和设置函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&#x27;dest&#x27;</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;src1&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;src2&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// Object.assign会覆盖重复的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: src2, a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖的过程：</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">id</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;first&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;second&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;third&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest);              <span class="comment">// &#123; a :&#123;&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest.a === src.a);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。<code>Object.assign()</code>没有“回滚”之前赋值的概念，因此这个方法可能只会完成部分复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  a: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">b</span>() &#123;</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a: foo &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-1-5-对象标识及相等判定"><a href="#8-1-5-对象标识及相等判定" class="headerlink" title="8.1.5　对象标识及相等判定"></a>8.1.5　对象标识及相等判定</h3><p>在ECMAScript 6之前，有些特殊情况即使是<code>===</code>操作符也无能为力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是===符合预期的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; === &#123;&#125;);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span> === <span class="number">2</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span> === <span class="number">0</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 要确定NaN的相等性，必须使用极为讨厌的isNaN()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>为此，ECMAScript 6规范新增了<code>Object.is()</code>，这个方法与<code>===</code>很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="number">1</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 正确的0、-0、+0相等/不等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 正确的NaN相等判定</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>要检查超过两个值，递归地利用相等性传递即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.is(x, rest[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">         (rest.length &lt; <span class="number">2</span> || recursivelyCheckEqual(...rest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-6-增强的对象语法"><a href="#8-1-6-增强的对象语法" class="headerlink" title="8.1.6　增强的对象语法"></a>8.1.6　增强的对象语法</h3><p>本节介绍的所有对象语法同样适用于ECMAScript 6的类。</p>
<h4 id="8-1-6-1-属性值简写"><a href="#8-1-6-1-属性值简写" class="headerlink" title="8.1.6.1   属性值简写"></a><strong>8.1.6.1   属性值简写</strong></h4><p>在给对象添加变量的时候，经常会发现属性名和变量名是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>而简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出<code>ReferenceError</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = makePerson(<span class="string">&#x27;Matt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>
<p>在这里，即使参数标识符只限定于函数作用域，编译器也会保留初始的<code>name</code>标识符。如果使用Google Closure编译器压缩，那么函数参数会被缩短，而属性名不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: a</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = makePerson(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>
<h4 id="8-1-6-2-可计算属性"><a href="#8-1-6-2-可计算属性" class="headerlink" title="8.1.6.2   可计算属性"></a><strong>8.1.6.2   可计算属性</strong></h4><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。也就是说，不能在对象字面量中直接动态命名属性。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[nameKey] = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JavaScript表达式而不是字符串来求值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [nameKey]: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>因为被当作JavaScript表达式求值，所以可计算属性可以是复杂的表达式，在实例化时再求值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [getUniqueKey(nameKey)]: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  [getUniqueKey(ageKey)]: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name_0: &#x27;Matt&#x27;, age_1: 27 &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>可计算属性表达式中抛出任何错误都会中断对象创建。如果表达式抛出错误，那么之前完成的计算是不能回滚的。</p>
<h4 id="8-1-6-3-简写方法名"><a href="#8-1-6-3-简写方法名" class="headerlink" title="8.1.6.3   简写方法名"></a><strong>8.1.6.3   简写方法名</strong></h4></blockquote>
<p>在给对象定义方法时，之前通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
<p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名（不过给作为方法的函数命名通常没什么用）。相应地，这样也可以明显缩短方法声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
<p>简写方法名对获取函数和设置函数也是适用的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name_: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name_ = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name_&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">person.sayName(); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
<p>简写方法名与可计算属性键相互兼容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&#x27;sayName&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [methodKey](name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName(<span class="string">&#x27;Matt&#x27;</span>); <span class="comment">// My name is Matt</span></span><br></pre></td></tr></table></figure>
<h3 id="8-1-7-对象解构"><a href="#8-1-7-对象解构" class="headerlink" title="8.1.7　对象解构"></a>8.1.7　对象解构</h3><p>对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName = person.name,</span><br><span class="line">    personAge = person.age;</span><br><span class="line"><span class="built_in">console</span>.log(personName); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge);  <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用对象解构</span><br><span class="line">let person &#x3D; &#123;</span><br><span class="line">  name: &#39;Matt&#39;,</span><br><span class="line">  age: 27</span><br><span class="line">&#125;;</span><br><span class="line">let &#123; name: personName, age: personAge &#125; &#x3D; person;</span><br><span class="line">console.log(personName);  &#x2F;&#x2F; Matt</span><br><span class="line">console.log(personAge);   &#x2F;&#x2F; 27</span><br></pre></td></tr></table></figure>
<p>如果想让变量直接使用属性的名称，那么还可以使用简写语法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(age);   <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是<code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, job &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(job);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">&#x27;Software engineer&#x27;</span> &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(job);  <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure>
<p>解构在内部使用函数<code>ToObject()</code>（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据<code>ToObject()</code>的定义），<code>null</code>和<code>undefined</code>不能被解构，否则会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(length);        <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c === <span class="built_in">Number</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>;           <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>;      <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>解构并不要求变量必须在解构表达式中声明。但如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line"><span class="built_in">console</span>.log(personName, personAge); <span class="comment">// Matt, 27</span></span><br></pre></td></tr></table></figure>
<h4 id="8-1-7-1-嵌套解构"><a href="#8-1-7-1-嵌套解构" class="headerlink" title="8.1.7.1   嵌套解构"></a><strong>8.1.7.1   嵌套解构</strong></h4><p>解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line">　</span><br><span class="line">(&#123;</span><br><span class="line">  name: personCopy.name,</span><br><span class="line">  job: personCopy.job</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// 因为一个对象的引用被赋值给personCopy，所以修改person.job对象的属性也会影响personCopy</span></span><br><span class="line">person.job.title = <span class="string">&#x27;Hacker&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personCopy);<span class="comment">//&#123; name: &#x27;Matt&#x27;, job: &#123; title: &#x27;Hacker&#x27; &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>解构赋值可以使用嵌套结构，以匹配嵌套的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明title变量并将person.job.title的值赋给它</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(title); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure>
<p>源对象的外层属性没有定义的情况下不能使用嵌套解构，会抛出错误，而不是赋值为undefined。目标对象的外层属性没有定义也同样会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line"><span class="comment">// foo在源对象上是undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: personCopy.bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;.</span></span><br><span class="line"><span class="comment">// job在目标对象上是undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: personCopy.job.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;title&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="8-1-7-2-部分解构"><a href="#8-1-7-2-部分解构" class="headerlink" title="8.1.7.2   部分解构"></a><strong>8.1.7.2   部分解构</strong></h4><p>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// person.foo是undefined，因此会抛出错误</span></span><br><span class="line">  (&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(personName, personBar, personAge);</span><br><span class="line"><span class="comment">// Matt, undefined, undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="8-1-7-3-参数上下文匹配"><a href="#8-1-7-3-参数上下文匹配" class="headerlink" title="8.1.7.3   参数上下文匹配"></a><strong>8.1.7.3   参数上下文匹配</strong></h4><p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响<code>arguments</code>对象，但可以在函数签名中声明在函数体内使用局部变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span>(<span class="params">foo, &#123;name, age&#125;, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson2</span>(<span class="params">foo, &#123;name: personName, age: personAge&#125;, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(personName, personAge);</span><br><span class="line">&#125;</span><br><span class="line">printPerson(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br><span class="line">printPerson2(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br></pre></td></tr></table></figure>
<h2 id="8-2-创建对象"><a href="#8-2-创建对象" class="headerlink" title="8.2　创建对象"></a>8.2　创建对象</h2><p>虽然使用<code>Object</code>构造函数或对象字面量可以方便地创建对象，但不足在于创建具有同样接口的多个对象需要重复编写很多代码。</p>
<h3 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1　概述"></a>8.2.1　概述</h3><p>ECMAScript 5.1并没有正式支持面向对象的结构，比如类或继承。但是，巧妙地运用原型式继承可以成功地模拟同样的行为。</p>
<p>ECMAScript 6开始正式支持类和继承。不过，ES6的类是封装了ES5.1构造函数加原型继承的语法糖而已。</p>
<blockquote>
<p><strong>注意</strong>在介绍ES6的类之前，下面会循序渐进地介绍被类取代的那些底层概念。当然采用面向对象编程模式的JavaScript代码还是应该使用ECMAScript 6的类。</p>
</blockquote>
<h3 id="8-2-2-工厂模式"><a href="#8-2-2-工厂模式" class="headerlink" title="8.2.2　工厂模式"></a>8.2.2　工厂模式</h3><p>工厂模式是一种设计模式，用于抽象创建特定对象的过程。下面的例子展示了一种按照特定接口创建对象的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure>
<p>这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。</p>
<h3 id="8-2-3-构造函数模式"><a href="#8-2-3-构造函数模式" class="headerlink" title="8.2.3　构造函数模式"></a>8.2.3　构造函数模式</h3><p>ECMAScript中的构造函数是用于创建特定类型对象的。比如像<code>Object</code>和<code>Array</code>这样的原生构造函数。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure>
<p>实际上，<code>Person()</code>内部的代码跟<code>createPerson()</code>基本是一样的，只是有如下区别。</p>
<ul>
<li>没有显式地创建对象。</li>
<li>属性和方法直接赋值给了<code>this</code>。</li>
<li>没有<code>return</code>。</li>
</ul>
<p>按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。有助于区分构造函数和普通函数。</p>
<p>要创建<code>Person</code>的实例，应使用<code>new</code>操作符。以这种方式调用构造函数会执行如下操作。</p>
<ol>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性。</li>
<li>构造函数内部的<code>this</code>被赋值为这个新对象。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ol>
<p><code>person1</code>和<code>person2</code>分别保存着<code>Person</code>的不同实例。这两个对象都有一个<code>constructor</code>属性指向<code>Person</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>constructor</code>本来是用于标识对象类型的。不过，一般将<code>instanceof</code>操作符用于确定对象类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>定义自定义构造函数可以确保实例被标识为特定类型，构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有<code>new</code>操作符，就可以调用相应的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person;</span><br><span class="line">person1.sayName();  <span class="comment">// Jake</span></span><br><span class="line">person2.sayName();  <span class="comment">// Jake</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-3-1-构造函数也是函数"><a href="#8-2-3-1-构造函数也是函数" class="headerlink" title="8.2.3.1   构造函数也是函数"></a><strong>8.2.3.1   构造函数也是函数</strong></h4><p>构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用<code>new</code>操作符调用就是构造函数，而不使用<code>new</code>操作符调用的函数就是普通函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">person.sayName();    <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line">Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);   <span class="comment">// 添加到window对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName();    <span class="comment">// &quot;Greg&quot;</span></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.sayName();   <span class="comment">// &quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure>
<p>在调用一个函数而没有明确设置<code>this</code>值的情况下（即没有作为对象的方法调用，或者没有使用<code>call()</code>/<code>apply()</code>调用），<code>this</code>始终指向<code>Global</code>对象（在浏览器中就是<code>window</code>对象）。<br>通过<code>call()</code>或<code>apply()</code>调用函数，将特定对象指定为作用域。这里的调用将<code>Person()</code>内部的<code>this</code>值指向对象<code>o</code>。</p>
<h4 id="8-2-3-2-构造函数的问题"><a href="#8-2-3-2-构造函数的问题" class="headerlink" title="8.2.3.2   构造函数的问题"></a><strong>8.2.3.2   构造函数的问题</strong></h4><p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，<code>person1</code>和<code>person2</code>都有名为<code>sayName()</code>的方法，但这两个方法不是同一个<code>Function</code>的实例。</p>
<p>ECMAScript中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;console.log(this.name)&quot;</span>); <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样理解这个构造函数可以更清楚地知道，每个<code>Person</code>实例都会有自己的<code>Function</code>实例用于显示<code>name</code>属性。<br>以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新<code>Function</code>实例的机制是一样的。因此不同实例上的函数虽然同名却不相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>但都是做一样的事，所以没必要定义两个不同的<code>Function</code>实例。况且，<code>this</code>对象可以把函数与对象的绑定推迟到运行时。<br>可以把函数定义转移到构造函数外部，来解决这个问题，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure>
<p>在构造函数内部，<code>sayName</code>属性中包含的只是一个指向外部函数的指针，所以<code>person1</code>和<code>person2</code>共享了定义在全局作用域上的<code>sayName()</code>函数。这样解决了相同逻辑的函数重复定义的问题，但因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p>
<h3 id="8-2-4-原型模式"><a href="#8-2-4-原型模式" class="headerlink" title="8.2.4　原型模式"></a>8.2.4　原型模式</h3><p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。这个对象也就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用函数表达式也可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();   <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-4-1-理解原型"><a href="#8-2-4-1-理解原型" class="headerlink" title="8.2.4.1   理解原型"></a><strong>8.2.4.1   理解原型</strong></h4><p>只要创建一个函数，就会按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。<code>Person.prototype.constructor</code>指向<code>Person</code>。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。</p>
<p>在自定义构造函数时，原型对象默认只会获得<code>constructor</code>属性，其他的所有方法都继承自<code>Object</code>。每次调用构造函数创建一个新实例，这个实例的内部<code>[[Prototype]]</code>指针就会被赋值为构造函数的原型对象。脚本中没有访问这个<code>[[Prototype]]</code>特性的标准方式，但大部分会通过在每个对象上暴露<code>__proto__</code>属性来实现，通过这个属性可以访问对象的原型。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数可以是函数表达式,也可以是函数声明，因此以下两种形式都可以：</span></span><br><span class="line"><span class="comment"> *   function Person() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *   let Person = function() &#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明之后，构造函数就有了一个与之关联的原型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype);  <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: f Person(),</span></span><br><span class="line"><span class="comment">//   __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如前所述，构造函数有一个prototype属性,引用其原型对象，而这个原型对象也有一个</span></span><br><span class="line"><span class="comment"> constructor属性，引用这个构造函数，两者循环引用：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正常的原型链都会终止于Object的原型对象</span></span><br><span class="line"><span class="comment"> * Object原型的原型是null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: f Object(),</span></span><br><span class="line"><span class="comment">//   toString: ...</span></span><br><span class="line"><span class="comment">//   hasOwnProperty: ...</span></span><br><span class="line"><span class="comment">//   isPrototypeOf: ...</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">　</span><br><span class="line">　</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数、原型对象和实例</span></span><br><span class="line"><span class="comment"> * 是3个完全不同的对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype !== Person);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实例通过__proto__链接到原型对象，</span></span><br><span class="line"><span class="comment">  * 它实际上指向隐藏特性[[Prototype]]</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 构造函数通过prototype属性链接到原型对象</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype);   <span class="comment">// true</span></span><br><span class="line">conosle.log(person1.__proto__.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例</span></span><br><span class="line"><span class="comment"> * 共享同一个原型对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === person2.__proto__); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * instanceof检查实例的原型链中是否包含指定构造函数的原型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/07/tJNo94D86LqK71p.png"
                      alt="010.png"
                ></p>
<p><strong>图　8-1</strong></p>
<p>虽然不是所有实现都对外暴露了<code>[[Prototype]]</code>，但原型可以使用<code>isPrototypeOf()</code>方法确定一个实例的原型链中指向它。本质上，<code>isPrototypeOf()</code>会在传入参数的<code>[[Prototype]]</code>指向调用它的对象时返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Object</code>类型有一个方法叫<code>Object.getPrototypeOf()</code>，返回参数的内部特性<code>[[Prototype]]</code>的值，可以方便地取得一个对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Obj ect.getPrototypeOf(person1) == Person.prototype);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Object</code>类型还有一个<code>setPrototypeOf()</code>方法，可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line">  numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);                              <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);                           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong><code>Object.setPrototypeOf()</code>可能会严重影响代码性能。</p>
</blockquote>
<p>为避免使用<code>Object.setPrototypeOf()</code>可能造成的性能下降，可以通过<code>Object.create()</code>来创建一个新对象，同时为其指定原型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line">  numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped);</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);                              <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);                           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-4-2-原型层级"><a href="#8-2-4-2-原型层级" class="headerlink" title="8.2.4.2   原型层级"></a><strong>8.2.4.2   原型层级</strong></h4><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身，如果存在则返回对应的值，否则，则搜索会沿着指针进入原型对象，再返回对应的值。这就是原型用于在多个对象实例间共享属性和方法的原理。</p>
<blockquote>
<p><strong>注意</strong>前面提到的<code>constructor</code>属性只存在于原型对象，因此通过实例对象也是可以访问到的。</p>
</blockquote>
<p>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮蔽原型对象上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);  <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure>
<p>只要给对象实例添加一个属性，这个属性就会<strong>遮蔽</strong>（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为<code>null</code>，也不会恢复它和原型的联系。不过，使用<code>delete</code>操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);  <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure>
<p><code>hasOwnProperty()</code>方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自<code>Object</code>的，会在属性存在于调用它的对象实例上时返回<code>true</code>，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>ECMAScript的<code>Object.getOwnPropertyDescriptor()</code>方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>。</p>
<h4 id="8-2-4-3-原型和in操作符"><a href="#8-2-4-3-原型和in操作符" class="headerlink" title="8.2.4.3   原型和in操作符"></a><strong>8.2.4.3   原型和</strong><code>in</code>操作符</h4></blockquote>
<p>有两种方式使用<code>in</code>操作符：单独使用和在<code>for-in</code>循环中使用。在单独使用时，<code>in</code>操作符会在可以通过对象访问指定属性时返回<code>true</code>，无论该属性是在实例上还是在原型上。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用<code>hasOwnProperty()</code>和<code>in</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hasPrototypeProperty()</code>，当属性存在于原型对象上时返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(person, <span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(person, <span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在<code>for-in</code>循环中使用<code>in</code>操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（<code>[[Enumerable]]</code>特性被设置为<code>false</code>）属性的实例属性也会在<code>for-in</code>循环中返回，因为默认情况下开发者定义的属性都是可枚举的。<br>要获得对象上所有可枚举的实例属性，可以使用<code>Object.keys()</code>方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys);   <span class="comment">// [name,age,job,sayName]</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1keys); <span class="comment">// [name,age]</span></span><br></pre></td></tr></table></figure>
<p>如果想列出所有实例属性，无论是否可以枚举，可以使用<code>Object.getOwnPropertyNames()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys);   <span class="comment">// &quot;[constructor,name,age,job,sayName]&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>在适当的时候都可用来代替<code>for-in</code>循环。<br>在新增符号类型之后，因为以符号为键的属性没有名称的概念，所以相应地出现了增加<code>Object.getOwnPropertySymbols()</code>，这个方法与<code>Object.getOwnPropertyNames()</code>类似，只是针对符号而已：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [k1]: <span class="string">&#x27;k1&#x27;</span>,</span><br><span class="line">  [k2]: <span class="string">&#x27;k2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-4-4属性枚举顺序"><a href="#8-2-4-4属性枚举顺序" class="headerlink" title="8.2.4.4属性枚举顺序"></a>8.2.4.4<strong>属性枚举顺序</strong></h4><p><code>for-in</code>循环、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>以及<code>Object.assign()</code>在属性枚举顺序方面有很大区别。<code>for-in</code>循环和<code>Object.keys()</code>的枚举顺序是不确定的，取决于JavaScript引擎，可能因浏览器而异。</p>
<p><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>和<code>Object.assign()</code>的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">  first: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">  [k1]: <span class="string">&#x27;sym2&#x27;</span>,</span><br><span class="line">  second: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.third = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>
<h3 id="8-2-5-对象迭代"><a href="#8-2-5-对象迭代" class="headerlink" title="8.2.5　对象迭代"></a>8.2.5　对象迭代</h3><p>ECMAScript 2017新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法<code>Object.values()</code>和<code>Object.entries()</code>接收一个对象，返回它们内容的数组。<code>Object.values()</code>返回对象值的数组，<code>Object.entries()</code>返回键/值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="number">1</span>,</span><br><span class="line">  qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 1, &#123;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));</span><br><span class="line"><span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure>
<p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)[<span class="number">0</span>] === o.qux);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)[<span class="number">0</span>][<span class="number">1</span>] === o.qux);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>符号属性会被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  [sym]: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));  <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-5-1-其他原型语法"><a href="#8-2-5-1-其他原型语法" class="headerlink" title="8.2.5.1   其他原型语法"></a><strong>8.2.5.1   其他原型语法</strong></h4><p>在前面的例子中，每次定义一个属性或方法都会把<code>Person.prototype</code>重写一遍。为了减少代码冗余，也为了从视觉上更好地封装原型功能，通常直接通过一个包含所有属性和方法的对象字面量来重写原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但上面这样会出现新问题：这样重写之后，<code>Person.prototype</code>的<code>constructor</code>属性就不指向<code>Person</code>了。因为在创建函数时，也会创建它的<code>prototype</code>对象，同时会自动给这个原型的<code>constructor</code>属性赋值。而上面的写法完全重写了默认的<code>prototype</code>对象，因此其<code>constructor</code>属性也指向了完全不同的新对象（<code>Object</code>构造函数），不再指向原来的构造函数。<br>f虽然<code>instanceof</code>操作符还能可靠地返回值，但不能再依靠<code>constructor</code>属性来识别类型了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果<code>constructor</code>的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 29,</span><br><span class="line">  <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">  <span class="title">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但要注意，以这种方式恢复<code>constructor</code>属性会创建一个<code>[[Enumerable]]</code>为<code>true</code>的属性。而原生<code>constructor</code>属性默认是不可枚举的。因此可以改为使用<code>Object.defineProperty()</code>方法来定义<code>constructor</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 恢复constructor属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="8-2-5-2原型的动态性"><a href="#8-2-5-2原型的动态性" class="headerlink" title="8.2.5.2原型的动态性"></a>8.2.5.2<strong>原型的动态性</strong></h4><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来，因为因为实例和原型之间的链接就是简单的指针，而不是保存的副本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();   <span class="comment">// &quot;hi&quot;，没问题！</span></span><br></pre></td></tr></table></figure>
<p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但重写整个原型就不一样了。实例的<code>[[Prototype]]</code>指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。因为实例只有指向原型的指针，没有指向构造函数的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 29,</span><br><span class="line">  <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">  <span class="title">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName();  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/07/cA47BbhJuiXvdQs.png"
                      alt="012.png"
                ></p>
<p><strong>图　8-3</strong></p>
<h4 id="8-2-5-3-原生对象原型"><a href="#8-2-5-3-原生对象原型" class="headerlink" title="8.2.5.3   原生对象原型"></a><strong>8.2.5.3   原生对象原型</strong></h4><p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括<code>Object</code>、<code>Array</code>、<code>String</code>等）都在原型上定义了实例方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);       <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给<code>String</code>原始值包装类型的实例添加了一个<code>startsWith()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.indexOf(text) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">&quot;Hello&quot;</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。</p>
</blockquote>
<h4 id="8-2-5-4原型的问题"><a href="#8-2-5-4原型的问题" class="headerlink" title="8.2.5.4原型的问题"></a>8.2.5.4<strong>原型的问题</strong></h4><p>首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值，其次原型的最大问题源自它的共享特性。</p>
<p>原型上的所有属性是在实例间共享的，虽然可以通过在实例上添加同名属性来简单地遮蔽原型上的属性，但真正的问题来自包含引用值的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 29,</span><br><span class="line">  <span class="title">friends</span>: [&quot;<span class="title">Shelby</span>&quot;, &quot;<span class="title">Court</span>&quot;],</span><br><span class="line">  <span class="title">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);  <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);  <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果这是有意在多个实例间共享数组，没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p>
<h2 id="8-3-继承"><a href="#8-3-继承" class="headerlink" title="8.3　继承"></a>8.3　继承</h2><p>很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的。</p>
<h3 id="8-3-1-原型链"><a href="#8-3-1-原型链" class="headerlink" title="8.3.1　原型链"></a>8.3.1　原型链</h3><p><strong>原型链</strong>定义为ECMAScript的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。每个构造函数都有一个原型对象，原型有一个属性<code>constructor</code>指回构造函数，而实例有一个内部指针<code>[[Prototype]]</code>指向原型。如果原型是另一个类型的实例呢？那这个原型本身也有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个例子中实现继承的关键，是<code>SubType</code>没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是<code>SuperType</code>的实例。这样一来，<code>SubType</code>的实例不仅能从<code>SuperType</code>的实例中继承属性和方法，而且还与<code>SuperType</code>的原型挂上钩。这里<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/07/EXWsTrnYmagNu9c.png"
                      alt="013.png"
                ></p>
<p><strong>图　8-4</strong></p>
<h4 id="8-3-1-1-默认原型"><a href="#8-3-1-1-默认原型" class="headerlink" title="8.3.1.1   默认原型"></a><strong>8.3.1.1   默认原型</strong></h4><p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自<code>Object</code>，这也是通过原型链实现的。任何函数的默认原型都是一个<code>Object</code>的实例，这意味着这个实例有一个内部指针指向<code>Object.prototype</code>。<code>SubType</code>继承<code>SuperType</code>，而<code>SuperType</code>继承<code>Object</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/07/xavmuPejgBVqUib.png"
                      alt="014.png"
                ></p>
<p><strong>图　8-5</strong></p>
<h4 id="8-3-1-2-原型与继承关系"><a href="#8-3-1-2-原型与继承关系" class="headerlink" title="8.3.1.2   原型与继承关系"></a><strong>8.3.1.2   原型与继承关系</strong></h4><p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用<code>instanceof</code>操作符，如果一个实例的原型链中出现过相应的构造函数，则<code>instanceof</code>返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>第二种方式是使用<code>isPrototypeOf()</code>方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="8-3-1-3-关于方法"><a href="#8-3-1-3-关于方法" class="headerlink" title="8.3.1.3   关于方法"></a><strong>8.3.1.3   关于方法</strong></h4><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>重点在于上述两个方法都是在把原型赋值为<code>SuperType</code>的实例之后定义的。<br>如果是以对象字面量方式创建原型方法，会破坏之前的原型链，因为这相当于重写了原型链。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">getSubValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">someOtherMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<h4 id="8-3-1-4-原型链的问题"><a href="#8-3-1-4-原型链的问题" class="headerlink" title="8.3.1.4   原型链的问题"></a><strong>8.3.1.4   原型链的问题</strong></h4><p>前面也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例，这意味着原先的实例属性变成为了原型属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure>
<p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。</p>
<h3 id="8-3-2-盗用构造函数"><a href="#8-3-2-盗用构造函数" class="headerlink" title="8.3.2　盗用构造函数"></a>8.3.2　盗用构造函数</h3><p>为了解决原型包含引用值导致的继承问题，有一种叫作“盗用构造函数”（constructor stealing）的技术（也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用<code>apply()</code>和<code>call()</code>方法以新创建的对象为上下文执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承SuperType</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过使用<code>call()</code>或<code>apply()</code>方法，<code>SuperType</code>构造函数在为<code>SubType</code>的实例创建的新对象的上下文中执行了。这相当于新的<code>SubType</code>对象上运行了<code>SuperType()</code>函数中的所有初始化代码。结果就是每个实例都会有自己的<code>colors</code>属性。</p>
<h4 id="8-3-2-1-传递参数"><a href="#8-3-2-1-传递参数" class="headerlink" title="8.3.2.1   传递参数"></a><strong>8.3.2.1   传递参数</strong></h4><p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承SuperType并传参</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);  <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>因此为确保父类构造函数不会覆盖子类构造函数定义的属性，通常在调用父类构造函数之后再给子类实例添加其他额外的属性。</p>
<h4 id="8-3-2-2-盗用构造函数的问题"><a href="#8-3-2-2-盗用构造函数的问题" class="headerlink" title="8.3.2.2   盗用构造函数的问题"></a><strong>8.3.2.2   盗用构造函数的问题</strong></h4><p>盗用构造函数的主要缺点，同样和构造函数模式自定义类型一样，都必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p>
<h3 id="8-3-3-组合继承"><a href="#8-3-3-组合继承" class="headerlink" title="8.3.3　组合继承"></a>8.3.3　组合继承</h3><p><strong>组合继承</strong>（也叫伪经典继承）综合了原型链和盗用构造函数。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line">instance1.sayName();            <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge();             <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName();            <span class="comment">// &quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge();             <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式。而且组合继承也保留了<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法识别合成对象的能力。</p>
<h3 id="8-3-4-原型式继承"><a href="#8-3-4-原型式继承" class="headerlink" title="8.3.4　原型式继承"></a>8.3.4　原型式继承</h3><p>即使不自定义类型也可以通过原型实现对象之间的信息共享。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>object()</code>函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。此时传入对象是新对象的原型对象。本质上，<code>object()</code>是对传入的对象执行了一次浅复制，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);  <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure>
<p>原型式继承适用于：有一个对象，想在它的基础上再创建一个新对象。需要把这个对象先传给<code>object()</code>，然后再对返回的对象进行适当修改。<br>ECMAScript 5通过增加<code>Object.create()</code>方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，<code>Object.create()</code>与这里的<code>object()</code>方法效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);  <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.create()</code>的第二个参数与<code>Object.defineProperties()</code>的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">&quot;Greg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name);  <span class="comment">// &quot;Greg&quot;</span></span><br></pre></td></tr></table></figure>
<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。</p>
<h3 id="8-3-5-寄生式继承"><a href="#8-3-5-寄生式继承" class="headerlink" title="8.3.5　寄生式继承"></a>8.3.5　寄生式继承</h3><p><strong>寄生式继承</strong>（parasitic inheritance），思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，是对原型式继承的再一次封装。以某种方式增强对象，然后返回这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;   <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>createAnother()</code>函数接收一个参数，就是新对象的基准对象。这个对象<code>original</code>会被传给<code>object()</code>函数，然后将返回的新对象赋值给<code>clone</code>。接着给<code>clone</code>对象添加一个新方法<code>sayHi()</code>。最后返回这个对象。可以像下面这样使用<code>createAnother()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();  <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。<code>object()</code>函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。</p>
<blockquote>
<p><strong>注意</strong>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
</blockquote>
<h3 id="8-3-6-寄生式组合继承"><a href="#8-3-6-寄生式组合继承" class="headerlink" title="8.3.6　寄生式组合继承"></a>8.3.6　寄生式组合继承</h3><p>组合继承也存在效率问题，父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含父类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);   <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();   <span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如图8-6所示，有两组<code>name</code>和<code>colors</code>属性：一组在实例上，另一组在<code>SubType</code>的原型上。这是调用两次<code>SuperType</code>构造函数的结果。寄生式组合继承避免了这个问题。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/04/07/ST5YfHkQLc9s4bd.png"
                      alt="015.png"
                ></p>
<p><strong>图　8-6</strong></p>
<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType;             <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype;               <span class="comment">//赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>inheritPrototype()</code>函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的<code>prototype</code>对象设置<code>constructor</code>属性，解决由于重写原型导致默认<code>constructor</code>丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用<code>inheritPrototype()</code>就可以实现前面例子中的子类型原型赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里只调用了一次<code>SuperType</code>构造函数，避免了<code>SubType.prototype</code>上不必要也用不到的属性，效率更高。而且，原型链仍然保持不变，因此<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法正常有效。寄生式组合继承算是引用类型继承的最佳模式。</p>
<h2 id="8-4-类"><a href="#8-4-类" class="headerlink" title="8.4　类"></a>8.4　类</h2><p>前面讲解了如何只使用ECMAScript 5的特性来模拟类似于类的行为，但各种策略都有自己的问题，也有相应的妥协。</p>
<p>ECMAScript 6新引入的<code>class</code>关键字具有正式定义类的能力。虽然ECMAScript 6类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。</p>
<h3 id="8-4-1-类定义"><a href="#8-4-1-类定义" class="headerlink" title="8.4.1　类定义"></a>8.4.1　类定义</h3><p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用<code>class</code>关键字加大括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  <span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;  <span class="comment">// 类表达式</span></span><br></pre></td></tr></table></figure>
<p>与函数表达式类似，类表达式在它们被求值前也不能引用。不过函数声明可以提升，但类定义不能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(FunctionExpression);   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> FunctionExpression = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionExpression);   <span class="comment">// function() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration);  <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration);  <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression);      <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> ClassExpression = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression);      <span class="comment">// class &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);     <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);     <span class="comment">// class ClassDeclaration &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);    <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-类的构成"><a href="#8-4-2-类的构成" class="headerlink" title="8.4.2   类的构成"></a><strong>8.4.2   类的构成</strong></h3><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。</p>
<p>与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空类定义，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 有构造函数的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有获取函数的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有静态方法的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">myQux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过<code>name</code>属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Person.name, PersonName.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.identify();               <span class="comment">// PersonName PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name);   <span class="comment">// PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(PersonName);    <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-3-类构造函数"><a href="#8-4-3-类构造函数" class="headerlink" title="8.4.3　类构造函数"></a>8.4.3　类构造函数</h3><p><code>constructor</code>关键字用于在类定义块内部创建类的构造函数。方法名<code>constructor</code>会告诉解释器在使用<code>new</code>操作符创建类的新实例时，应该调用这个函数。这不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p>
<h4 id="8-4-3-1-实例化"><a href="#8-4-3-1-实例化" class="headerlink" title="8.4.3.1   实例化"></a><strong>8.4.3.1   实例化</strong></h4><p>使用<code>new</code>操作符实例化<code>Person</code>的操作等于使用<code>new</code>调用其构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使用<code>new</code>和类意味着应该使用<code>constructor</code>函数进行实例化。</p>
<p>使用new调用类的构造函数会执行如下操作。</p>
<p>(1) 在内存中创建一个新对象。</p>
<p>(2) 这个新对象内部的<code>[[Prototype]]</code>指针被赋值为构造函数的<code>prototype</code>属性。</p>
<p>(3) 构造函数内部的<code>this</code>被赋值为这个新对象（即<code>this</code>指向新对象）。</p>
<p>(4) 执行构造函数内部的代码（给新对象添加属性）。</p>
<p>(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;person ctor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();  <span class="comment">// person ctor</span></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vegetable();</span><br><span class="line"><span class="built_in">console</span>.log(v.color);  <span class="comment">// orange</span></span><br></pre></td></tr></table></figure>
<p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person;          <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);         <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jake&#x27;</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name);         <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，类构造函数会在执行之后返回<code>this</code>对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的<code>this</code>对象，那么这个对象会被销毁。不过，如果返回的不是<code>this</code>对象，而是其他对象，那么这个对象不会通过<code>instanceof</code>操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">override</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (override) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        bar: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    p2 = <span class="keyword">new</span> Person(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);                    <span class="comment">// Person&#123; foo: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2);                    <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用<code>new</code>操作符，否则会抛出错误。而普通构造函数如果不使用<code>new</code>调用，那么就会以全局的<code>this</code>（通常是<code>window</code>）作为内部对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 把window作为this来构建实例</span></span><br><span class="line"><span class="keyword">let</span> p = Person();</span><br><span class="line"><span class="keyword">let</span> a = Animal();</span><br><span class="line"><span class="comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>
<p>类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法（但作为类构造函数，仍然要使用<code>new</code>调用）。因此，实例化之后可以在实例上引用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 使用类创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.constructor();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="comment">// 使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.constructor();</span><br></pre></td></tr></table></figure>
<h4 id="8-4-3-2-把类当成特殊函数"><a href="#8-4-3-2-把类当成特殊函数" class="headerlink" title="8.4.3.2   把类当成特殊函数"></a><strong>8.4.3.2   把类当成特殊函数</strong></h4><p>ECMAScript中没有正式的类这个类型。从各方面来看，ECMAScript类就是一种特殊函数。声明一个类之后，通过<code>typeof</code>操作符检测类标识符，表明它是一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person);         <span class="comment">// class Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person);  <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>类标识符有<code>prototype</code>属性，而这个原型也有一个<code>constructor</code>属性指向类自身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);             <span class="comment">// &#123; constructor: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>与普通构造函数一样，可以使用<code>instanceof</code>操作符检查构造函数原型是否存在于实例的原型链中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用<code>new</code>调用时就会被当成构造函数。重点在于，类中定义的<code>constructor</code>方法<strong>不会</strong>被当成构造函数，在对它使用<code>instanceof</code>操作符时会返回<code>false</code>。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么<code>instanceof</code>操作符的返回值会反转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor === Person);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);              <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person.constructor);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person.constructor();</span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);              <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person.constructor);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>类是JavaScript的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类可以像函数一样在任何地方定义，比如在数组中</span></span><br><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line">  <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id_ = id;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`instance <span class="subst">$&#123;<span class="built_in">this</span>.id_&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classDefinition, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> classDefinition(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = createInstance(classList[<span class="number">0</span>], <span class="number">3141</span>);  <span class="comment">// instance 3141</span></span><br></pre></td></tr></table></figure>
<p>与立即调用函数表达式相似，类也可以立即实例化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为是一个类表达式，所以类名是可选的</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;bar&#x27;</span>);        <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(p);  <span class="comment">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-实例、原型和类成员"><a href="#8-4-4-实例、原型和类成员" class="headerlink" title="8.4.4　实例、原型和类成员"></a>8.4.4　实例、原型和类成员</h3><p>类的语法可以方便地去定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。</p>
<h4 id="8-4-4-1-实例成员"><a href="#8-4-4-1-实例成员" class="headerlink" title="8.4.4.1   实例成员"></a><strong>8.4.4.1   实例成员</strong></h4><p>每次通过<code>new</code>调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（<code>this</code>）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。</p>
<p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子先使用对象包装类型定义一个字符串</span></span><br><span class="line">    <span class="comment">// 为的是在下面测试两个对象的相等性</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.sayName(); <span class="comment">// Jack</span></span><br><span class="line">p2.sayName(); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name === p2.name);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.nicknames === p2.nicknames);  <span class="comment">// false</span></span><br><span class="line">p1.name = p1.nicknames[<span class="number">0</span>];</span><br><span class="line">p2.name = p2.nicknames[<span class="number">1</span>];</span><br><span class="line">p1.sayName();  <span class="comment">// Jake</span></span><br><span class="line">p2.sayName();  <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>
<h4 id="8-4-4-2-原型方法与访问器"><a href="#8-4-4-2-原型方法与访问器" class="headerlink" title="8.4.4.2   原型方法与访问器"></a><strong>8.4.4.2   原型方法与访问器</strong></h4><p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">  <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.locate();                 <span class="comment">// instance</span></span><br><span class="line">Person.prototype.locate();  <span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>
<p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token</span></span><br></pre></td></tr></table></figure>
<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;symbolKey&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">stringKey</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;invoked stringKey&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   [symbolKey]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;invoked symbolKey&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   [<span class="string">&#x27;computed&#x27;</span> + <span class="string">&#x27;Key&#x27;</span>]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;invoked computedKey&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.stringKey();    <span class="comment">// invoked stringKey</span></span><br><span class="line">p[symbolKey]();   <span class="comment">// invoked symbolKey</span></span><br><span class="line">p.computedKey();  <span class="comment">// invoked computedKey</span></span><br></pre></td></tr></table></figure>
<p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name_ = newName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure>
<h4 id="8-4-4-3-静态类方法"><a href="#8-4-4-3-静态类方法" class="headerlink" title="*8.4.4.3   静态类方法  **"></a>*<em>8.4.4.3   静态类方法  **</em></h4><p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个，在类定义中使用<code>static</code>关键字作为前缀。在静态成员中，<code>this</code>引用类自身。其他所有约定跟原型成员一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">  <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类本身上</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;class&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.locate();                 <span class="comment">// instance, Person &#123;&#125;</span></span><br><span class="line">Person.prototype.locate();  <span class="comment">// prototype, &#123;constructor: ... &#125;</span></span><br><span class="line">Person.locate();            <span class="comment">// class, class Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>静态类方法非常适合作为实例工厂：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age_ = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用随机年龄创建并返回一个Person实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.create()); <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="8-4-4-4-非函数原型和类成员"><a href="#8-4-4-4-非函数原型和类成员" class="headerlink" title="8.4.4.4   非函数原型和类成员"></a><strong>8.4.4.4   非函数原型和类成员</strong></h4><p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line">Person.greeting = <span class="string">&#x27;My name is&#x27;</span>;</span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.sayName();  <span class="comment">// My name is Jake</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>类定义中之所以没有显式支持添加数据成员，是因为在共享目标（原型和类）上添加可变（可修改）数据成员是一种反模式。一般来说，对象实例应该独自拥有通过<code>this</code>引用的数据。</p>
<h4 id="8-4-4-5-迭代器与生成器方法"><a href="#8-4-4-5-迭代器与生成器方法" class="headerlink" title="8.4.4.5   迭代器与生成器方法"></a><strong>8.4.4.5   迭代器与生成器方法</strong></h4></blockquote>
<p>类定义语法支持在原型和类本身上定义生成器方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">  *<span class="function"><span class="title">createNicknameIterator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">  <span class="keyword">static</span> *<span class="function"><span class="title">createJobIterator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Candlestick maker&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jobIter = Person.createJobIterator();</span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value);  <span class="comment">// Butcher</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value);  <span class="comment">// Baker</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value);  <span class="comment">// Candlestick maker</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.createNicknameIterator();</span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value);  <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value);  <span class="comment">// Jake</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value);  <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>
<p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="built_in">this</span>.nicknames.entries();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>
<p>也可以只返回迭代器实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nicknames.entries();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [idx, nickname] <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// Jake</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-5-继承"><a href="#8-4-5-继承" class="headerlink" title="8.4.5　继承"></a>8.4.5　继承</h3><p>ECMAScript 6新增特性中原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p>
<h4 id="8-4-5-1-继承基础"><a href="#8-4-5-1-继承基础" class="headerlink" title="8.4.5.1   继承基础"></a><strong>8.4.5.1   继承基础</strong></h4><p>ES6类支持单继承。使用<code>extends</code>关键字，就可以继承任何拥有<code>[[Construct]]</code>和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle);  <span class="comment">// true</span></span><br><span class="line">　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> Engineer();</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>派生类都会通过原型链访问到类和原型上定义的方法。<code>this</code>的值会反映调用相应方法的实例或者类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">identifyPrototype</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">identifyClass</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>);       <span class="comment">// bus, Bus &#123;&#125;</span></span><br><span class="line">v.identifyPrototype(<span class="string">&#x27;vehicle&#x27;</span>);   <span class="comment">// vehicle, Vehicle &#123;&#125;</span></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>);         <span class="comment">// bus, class Bus &#123;&#125;</span></span><br><span class="line">Vehicle.identifyClass(<span class="string">&#x27;vehicle&#x27;</span>); <span class="comment">// vehicle, class Vehicle &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>extends</code>关键字也可以在类表达式中使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Bar = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-5-2-构造函数、HomeObject和super"><a href="#8-4-5-2-构造函数、HomeObject和super" class="headerlink" title="8.4.5.2   构造函数、HomeObject和super()"></a><strong>8.4.5.2   构造函数、</strong><code>HomeObject</code>和<code>super()</code></h4><p>派生类的方法可以通过<code>super</code>关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用<code>super</code>可以调用父类构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hasEngine = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 不要在调用super()之前引用this，否则会抛出ReferenceError</span></span><br><span class="line">    <span class="built_in">super</span>(); <span class="comment">// 相当于super.constructor()</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vehicle);  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);                   <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();</span><br></pre></td></tr></table></figure>
<p>在静态方法中可以通过<code>super</code>调用继承的类上定义的静态方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;vehicle&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.identify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bus.identify();  <span class="comment">// vehicle</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>ES6给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在JavaScript引擎内部访问。<code>super</code>始终会定义为<code>[[HomeObject]]</code>的原型。</p>
<h4 id="8-4-5-3-使用super时要注意的问题"><a href="#8-4-5-3-使用super时要注意的问题" class="headerlink" title="8.4.5.3   使用super时要注意的问题"></a>8.4.5.3   使用<code>super</code>时要注意的问题</h4></blockquote>
<ol>
<li><code>super</code>只能在派生类构造函数和静态方法中使用。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不能单独引用<code>super</code>关键字，要么用它调用构造函数，要么用它引用静态方法。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>);</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用<code>super()</code>会调用父类构造函数，并将返回的实例赋值给<code>this</code>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vehicle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>super()</code>的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">licensePlate</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.licensePlate = licensePlate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">licensePlate</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(licensePlate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>如果没有定义类构造函数，在实例化派生类时会调用<code>super()</code>，而且会传入所有传给派生类的参数。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">licensePlate</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.licensePlate = licensePlate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>在类构造函数中，不能在调用<code>super()</code>之前引用<code>this</code>。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class</span></span><br><span class="line"><span class="comment">// before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure></li>
<li>如果在派生类中显式定义了构造函数，则要么必须在其中调用<code>super()</code>，要么必须在其中返回一个对象。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Car());  <span class="comment">// Car &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus());  <span class="comment">// Bus &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Van());  <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="8-4-5-4抽象基类"><a href="#8-4-5-4抽象基类" class="headerlink" title="8.4.5.4抽象基类"></a>8.4.5.4<strong>抽象基类</strong></h4></li>
</ol>
<p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript没有专门支持这种类的语法 ，但通过<code>new.target</code>也很容易实现。<code>new.target</code>保存通过<code>new</code>关键字调用的类或函数。通过在实例化时检测<code>new.target</code>是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();       <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> Vehicle();   <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure>
<p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过<code>this</code>关键字来检查相应的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.foo) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">new</span> Van(); <span class="comment">// Error: Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure>
<h4 id="8-4-5-5继承内置类型"><a href="#8-4-5-5继承内置类型" class="headerlink" title="8.4.5.5继承内置类型"></a>8.4.5.5<strong>继承内置类型</strong></h4><p>ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">shuffle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 洗牌算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">      [<span class="built_in">this</span>[i], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.shuffle();</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// [3, 1, 4, 5, 2]</span></span><br></pre></td></tr></table></figure>
<p>当有些内置类型的方法会返回新实例时，默认情况下，返回实例的类型与原始实例的类型是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// [1, 2, 3, 4, 5]，SuperArray类型</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// [1, 3, 5]，SuperArray类型</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果想覆盖这个默认行为，则可以覆盖<code>Symbol.species</code>访问器，这个访问器决定在创建返回的实例时使用的类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// [1, 2, 3, 4, 5]，SuperArray类型</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="8-4-5-6-类混入"><a href="#8-4-5-6-类混入" class="headerlink" title="*8.4.5.6   类混入   **"></a>*<em>8.4.5.6   类混入   **</em></h4><p>把不同类的行为集中到一个类是一种常见的JavaScript模式。虽然ES6没有显式支持多类继承，但通过现有特性可以模拟这种行为。</p>
<blockquote>
<p><strong>注意</strong><code>Object.assign()</code>方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用<code>Object.assign()</code>就可以了。</p>
</blockquote>
<p>在下面的代码片段中，<code>extends</code>关键字后面是一个JavaScript表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。这个表达式会在求值类定义时被求值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;evaluated expression&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">getParentClass</span>() </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可求值的表达式</span></span><br></pre></td></tr></table></figure>
<p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。如果<code>Person</code>类需要组合A、B、C，则需要某种机制实现B继承A，C继承B，而<code>Person</code>再继承C，从而把A、B、C组合到这个超类中。实现这种模式有不同的策略。<br>一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">FooMixin</span>(<span class="title">BarMixin</span>(<span class="title">BazMixin</span>(<span class="title">Vehicle</span>))) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo();  <span class="comment">// foo</span></span><br><span class="line">b.bar();  <span class="comment">// bar</span></span><br><span class="line">b.baz();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
<p>通过写一个辅助函数，可以把嵌套调用展开：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">BaseClass, ...Mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mixins.reduce(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> current(accumulator), BaseClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Vehicle</span>, <span class="title">FooMixin</span>, <span class="title">BarMixin</span>, <span class="title">BazMixin</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo();  <span class="comment">// foo</span></span><br><span class="line">b.bar();  <span class="comment">// bar</span></span><br><span class="line">b.baz();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>很多JavaScript框架（特别是React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
