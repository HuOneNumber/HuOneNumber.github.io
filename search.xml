<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>02-URL与资源</title>
    <url>/2021/01/22/note/HTTP/02-URL%E4%B8%8E%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="2-1-URL语法"><a href="#2-1-URL语法" class="headerlink" title="2.1 URL语法"></a><strong>2.1 URL语法</strong></h2><p><strong>URI</strong>：统一资源标识符（Uniform Resource Identifier）,它包括了URL（统一资源定位符），它是通过描述资源位置来标识资源，以及URN（统一资源名），它则是通过名字来识别资源。</p>
<table>
    <tr>
    <th>组件</th>
    <th>描述</th>
    <th>默认值</th>
  </tr>
  <tr>
    <td>方案</td>
    <td>用什么协议获取资源，大小写无关，比如http</td>
    <td>无</td>
  </tr>
  <tr>
    <td>用户</td>
    <td>某些方案下访问资源时需要的用户名，比如FTP</td>
    <td>匿名</td>
  </tr>
  <tr>
    <td>密码</td>
    <td>用户名后面可能包含的密码，由冒号（：）分隔</td>
    <td>E-mail地址</td>
  </tr>
  <tr>
    <td>主机</td>
    <td>服务器位置，也就是资源在哪里，可以是域名（会被解析）或IP地址</td>
    <td>无</td>
  </tr>
  <tr>
    <td>端口</td>
    <td>资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80）</td>
    <td>方案特有</td>
  </tr>
  <tr>
    <td>路径</td>
    <td>资源路径，服务器上的本地资源名，由斜杠（/）分隔</td>
    <td>无</td>
  </tr>
  <tr>
    <td>参数</td>
    <td>某些方案会用这个组件来指定输入参数。参数为名/值对。可以包含多个参数字段，它们相互之间以及与路径其余部分用分号（；）分隔</td>
    <td>无</td>
  </tr>
  <tr>
    <td>查询</td>
    <td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用“？”将其与其余部分分隔开来。按照常规，查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&”分隔：</td>
    <td>无</td>
  </tr>
  <tr>
    <td>片段</td>
    <td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td>
    <td>无</td>
  </tr>
</table>

<h2 id="2-2-URL快捷方式"><a href="#2-2-URL快捷方式" class="headerlink" title="2.2 URL快捷方式"></a><strong>2.2 URL快捷方式</strong></h2><p><strong>URL</strong>有两种方式，<strong>绝对URL</strong>（包含访问资源所需的全部信息）以及<strong>相对URL</strong>（不完整，需要对基础URL进行解析）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/nVR0IK7EBcmYWYVR.png"
                      alt="图片"
                ></p>
<p>基础URL是作为相对URL的参考点使用的。来自以下几个地方：</p>
<p><strong>1、在资源中显示提供</strong></p>
<p>有些资源会显式地指定基础URL。比如，HTML文档中可能会包含一个定义了基础URL的HTML标记&#60;BASE&#62;，通过它来转换那个HTML文档中的所有相对URL。</p>
<p><strong>2、封装资源的基础URL</strong></p>
<p>如果在一个没有显式指定基础URL的资源中发现了一个相对URL，可以将它所属资源的URL作为基础。</p>
<p><strong>3、没有基础URL</strong></p>
<p>在某些情况下，没有基础URL，通常意味着你有一个相对URL；但有可能只是一个不完整或损坏了的URL。</p>
<p>要把相对URL转换成绝对URL，首先将他们划分成组件段，这一步称为<strong>分解URL，</strong>接下来的过程如下，<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/V4KlexQcZcfQ12Rf.png"
                      alt="图片"
                ></p>
<p><strong>自动扩展URL：</strong>用户不需要输入完整的URL，浏览器自动扩展。有两种方式：</p>
<p>1、<strong>主机名扩展</strong></p>
<p>在主机名扩展中，只要有些小提示，浏览器通常就可以在没有帮助的情况下，将你输入的主机名扩展为完整的主机名。但是，这些主机名扩展技巧可能会为其他一些HTTP应用程序带来问题，比如代理。</p>
<p><strong>2、历史扩展</strong></p>
<p>浏览器用来节省用户输入URL时间的另一种技巧是，将以前用户访问过的URL历史存储起来。当你输入URL时，它们就可以将你输入的URL与历史记录中URL的前缀进行匹配，并提供–些完整的选项供你选择。注意，与代理共同使用时，URL自动扩展的行为可能会有所不同。6.5.6节将对此进行进-一步讨论。</p>
<h2 id="2-3-URL字符"><a href="#2-3-URL字符" class="headerlink" title="2.3 URL字符"></a><strong>2.3 URL字符</strong></h2><p>URL的特性是<strong>可移植的（portable）</strong>、<strong>可读的</strong>、<strong>完整的</strong>，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符值或数据进行编码，这样就实现了可移植性和完整性。这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数。示例如下,</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/TbL6jXX4SEtdJlWZ.png"
                      alt="图片"
                ></p>
<p><strong>字符限制</strong>，在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCI可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用。</p>
<p>URL的每个组件都会有自己的安全和不安全字符（与方案有关），因此只有从用户那里接收URL的应用程序才能够判断需要对哪些字符进行编码。这个URL就是可在各应用程序之间共享的规范形式；也就无需操心其他应用程序会被字符的任何特殊含义所迷惑了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/bnXzZF9va3GSkGou.png"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>02-URL与资源</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/2021/01/23/categories/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

]]></content>
  </entry>
  <entry>
    <title>02-HTML网页和结构</title>
    <url>/2021/01/21/note/webkit/02-HTML%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>HTML网页是利用HTML语言编写的文档，它是一种半结构化的数据表现方式。它的结构特征可以归纳为三种：树状结构、层次结构和框结构。</p>
<h2 id="2-1-网页构成"><a href="#2-1-网页构成" class="headerlink" title="2.1 网页构成"></a>2.1 网页构成</h2><h3 id="2-1-1-基本元素和树状结构"><a href="#2-1-1-基本元素和树状结构" class="headerlink" title="2.1.1 基本元素和树状结构"></a>2.1.1 基本元素和树状结构</h3><p>现在的网页基本上都是动态网页（Dynamic HTML），这就需要JavaScript代码用来控制网页内部的逻辑，CSS用来描述网页的显示信息。</p>
<p>整个网页可以看成一种树状结构，其树根是html，这是网页的根元素（或称节点）。根下面包含两个子节点head和body。</p>
<h3 id="2-1-2-HTML-5新特性"><a href="#2-1-2-HTML-5新特性" class="headerlink" title="2.1.2 HTML.5新特性"></a>2.1.2 HTML.5新特性</h3><p>HTML5引入的对2D和3D图形以及多媒体方面的支持，将彻底改变网页的渲染方式和复杂度，包括但是不限于：</p>
<ol>
<li><strong>video元素</strong>，支持在网页中播放视频。</li>
<li><strong>Canvas 2D</strong>，Canvas 2D通过定义一个新的“canvas”元素，网页开发者利用该元素的2D绘图上下文（graphics context）调用标准定义的接口，绘制常见的2D图形，例如点、线、矩形、多边形等。</li>
<li><strong>WebGL</strong>（也就是Canvas 3D）。WebGL则是使用“canvas”元素的3D绘图上下文调用标准定义的接口，绘制3D图形，这些接口类似于OpenGL ES的接口。</li>
<li><strong>CSS3 3D变换</strong>（transform）和<strong>转换</strong>（transition）。CSS3 3D的变换和转换则可以作用于HTML的任意可视元素，制造出各种炫丽的3D效果。<h2 id="2-2-网页结构"><a href="#2-2-网页结构" class="headerlink" title="2.2 网页结构"></a>2.2 网页结构</h2></li>
</ol>
<h3 id="2-2-1-框结构"><a href="#2-2-1-框结构" class="headerlink" title="2.2.1 框结构"></a>2.2.1 框结构</h3><p>框结构可以用来对网页的布局进行分割，将网页分成几个框。网页开发者也可以让网页嵌入其他的网页，frameset、frame和iframe可以用来在当前网页中嵌入新的框结构。多框结构的网页非常不适合移动领域，因为该结构对触控操作来说是不方便的。</p>
<h3 id="2-2-2-层次结构"><a href="#2-2-2-层次结构" class="headerlink" title="2.2.2 层次结构"></a>2.2.2 层次结构</h3><p>网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是某些元素可能不同于它的父元素所在的层次，同时CSS部分的代码也会对网页的分层策略产生重要影响。</p>
<p>对于需要复杂变换和处理的元素，WebKit 为它们构建新层其实是为了渲染引擎在处理上的方便和高效。</p>
<h2 id="2-3-WebKit的网页渲染过程"><a href="#2-3-WebKit的网页渲染过程" class="headerlink" title="2.3 WebKit的网页渲染过程"></a>2.3 WebKit的网页渲染过程</h2><h3 id="2-3-1-加载和渲染"><a href="#2-3-1-加载和渲染" class="headerlink" title="2.3.1 加载和渲染"></a>2.3.1 加载和渲染</h3><p>浏览器的主要作用就是将用户输入的“URL”转变成可视化的图像，包含两个过程，一是网页加载过程，就是从“URL”到构建DOM树；二是网页渲染过程，从DOM树到生成可视化图像。这两个过程也会交叉，统称这两个过程为网页的渲染过程。</p>
<p>网页通常比我们的屏幕可视面积要大，当前可见的区域称为<strong>视图</strong>（viewport），浏览器在渲染网页的时候，一般会加入滚动条以帮助翻滚网页。</p>
<h3 id="2-3-2-WebKit的渲染过程"><a href="#2-3-2-WebKit的渲染过程" class="headerlink" title="2.3.2 WebKit的渲染过程"></a>2.3.2 WebKit的渲染过程</h3><p>网页的一般渲染过程中的数据包括网页内容、DOM、内部表示和图像，模块则包括HTML解释器、CSS解释器、JavaScript 引擎以及布局和绘图模块。</p>
<p>根据数据的流向，将渲染过程分成三个阶段，第一个阶段是从网页的URL到构建DOM树，第二个阶段是从DOM树到构建WebKit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。</p>
<h4 id="2-3-2-1-第一个阶段：从网页的URL到构建DOM树"><a href="#2-3-2-1-第一个阶段：从网页的URL到构建DOM树" class="headerlink" title="2.3.2.1 第一个阶段：从网页的URL到构建DOM树"></a>2.3.2.1 第一个阶段：从网页的URL到构建DOM树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/uSXBGLwftTz59OfO__thumbnail.png"
                      alt="图片"
                ></p>
<p>具体的过程如下：</p>
<ol>
<li>当用户输入网页URL的时候，WebKit调用其资源加载器加载该URL对应的网页。</li>
<li>加载器依赖网络模块建立连接，发送请求并接收答复。</li>
<li>WebKit接收到各种网页或者资源的数据，某些资源可能是同步或异步获取的。</li>
<li>网页被交给HTML解释器转变成一系列的词语（Token）。</li>
<li>解释器根据词语构建节点（Node），形成DOM树。</li>
<li>如果节点是JavaScript代码的话，调用JavaScript引擎解释并执行。</li>
<li>JavaScript代码可能会修改DOM树的结构。</li>
<li>如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载它们，但是它们是异步的，不会阻碍当前DOM树的继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。</li>
</ol>
<p>在上述的过程中，网页在加载和渲染过程中会发出“DOMConent”事件和DOM的“onload”事件，分别在DOM树构建完之后，以及DOM树建完并且网页所依赖的资源都加载完之后发生，因为某些资源的加载并不会阻碍DOM树的创建，所以这两个事件多数时候不是同时发生的。</p>
<h4 id="2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文"><a href="#2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文" class="headerlink" title="2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文"></a>2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/5zAmE3T5IrREBagI__thumbnail.png"
                      alt="图片"
                ></p>
<p>这一阶段的具体过程如下。</p>
<ol>
<li>CSS文件被CSS解释器解释成内部表示结构。</li>
<li>CSS解释器工作完之后，在DOM树上附加解释后的样式信息，这就是RenderObject树。</li>
<li>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文，这中间还有复杂的内部过程。</li>
</ol>
<p>RenderObject树的建立并不表示DOM树会被销毁，图中的四个内部表示结构一直存在，直到网页被销毁。</p>
<h4 id="2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。"><a href="#2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。" class="headerlink" title="2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。"></a>2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3oObbcPTpx9gzPCi__thumbnail.png"
                      alt="图片"
                ></p>
<p>图中这一阶段对应的具体过程如下。</p>
<ol>
<li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的绘图具体实现类。</li>
<li>绘图实现类有简单或复杂的实现。在Chromium中，它的实现相当复杂，需要Chromium的合成器来完成复杂的多进程和GPU加速机制。</li>
<li>绘图实现类将 2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来同浏览器界面一起显示。</li>
</ol>
<p>现代浏览器为了绘图上的高效性和安全性，可能会在这一过程中引入复杂的机制。而且，绘图也从之前单纯的软件渲染，到现在的GPU硬件渲染、混合渲染模型等方式。</p>
<p>现代网页很多是动态网页，这意味着在渲染完成之后，由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
        <category>02-HTML网页和结构</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>03-HTTP报文</title>
    <url>/2021/01/23/note/HTTP/03-HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h1 id="3-1-报文流"><a href="#3-1-报文流" class="headerlink" title="3.1 报文流"></a><strong>3.1 报文流</strong></h1><p><strong>HTTP报文</strong>是在HTTP应用程序之间发送的数据块，这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。</p>
<p>HTTP使用术语<strong>流入</strong>（inbound）和<strong>流出</strong>（outbound）来描述<strong>事务处理</strong>（transaction）的方向。报文流人源端服务器，工作完成之后，会流回用户的Agent代理中。</p>
<p>不管是请求报文还是响应报文，所有报文都会向下游（downstream）流动（参见下图）。所有报文的发送者都在接收者的上游（upstream）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/cERK8fMXNtSgncHM.png"
                      alt="图片"
                ></p>
<h1 id="3-2-报文的组成部分"><a href="#3-2-报文的组成部分" class="headerlink" title="3.2 报文的组成部分"></a><strong>3.2 报文的组成部分</strong></h1><p>HTTP报文由三个部分组成：<strong>起始行</strong>（start line）、<strong>首部</strong>（header）、<strong>主体</strong>（body）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/P7vBtkoxgAKyyS5X.png"
                      alt="图片"
                ></p>
<p><strong>起始行</strong>：所有的HTTP报文都以一个起始行作为开始。请求报文的起始行（请求行）说明了要做些什么。响应报文的起始行（响应行）说明发生了什么。</p>
<p><strong>首部：</strong>首部字段向请求/响应报文中添加一些附加信息。本质上来说，它们只是一些名/值对的列表。</p>
<p><strong>主体：</strong>是一个可选的数据块。与起始行和首部不同的是，主体中可以包含文本或二进制数据，也可以为空。</p>
<p><strong>注意：</strong>起始行和首部就是由行分隔的ASCII文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符和一个换行符。这个行终止序列可以写做<strong>CRLF</strong>。尽管HTTP规范中说明应该用CRLF来表示行终止，但稳健的应用程序也应该接受单个换行符作为行的终止。有些老的，或不完整的HTTP应用程序并不总是既发送回车符，又发送换行符。</p>
<p>一组HTTP首部总是应该以一个空行（单个CRLF）结束，甚至即使没有首部和实体的主体部分也应如此。但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误地）省略了最后的CRLF。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个CRLF的报文。</p>
<h1 id="3-3-报文的语法"><a href="#3-3-报文的语法" class="headerlink" title="3.3 报文的语法"></a><strong>3.3 报文的语法</strong></h1><p>所有的HTTP报文都可以分为两类：<strong>请求报文</strong>（request message）和<strong>响应报文</strong>（response message）。请求报文会向Web服务器请求一个动作。响应报文会将请求的结果返回给客户端。</p>
<p><strong>请求报文的格式：</strong></p>
<p>&lt;method&gt;   &lt;request-URL&gt;   &lt;version&gt;</p>
<p>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<p><strong>响应报文的格式</strong>（注意，只有起始行的语法有所不同）：</p>
<p>&lt;version&gt;   &lt;status&gt;   &lt;reason-phrase&gt;</p>
<p>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<table>
<thead>
<tr>
<th align="center">方法（method）</th>
<th align="left">客户端希望服务器对资源执行的动作。比如GET、HEAD或POST。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/JVU6YJ5CStQ6fuwP.png"
                      alt="图片"
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求URL（request-URL）</td>
<td align="left">命名了所请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题一一服务器可以假定自已是URL的主机/端口。</td>
</tr>
<tr>
<td align="center">版本（version）</td>
<td align="left">报文所使用的HTTP版本，其格式看起来是这样的：HTTP/&lt;major&gt;.&lt;minor&gt;&lt;br&gt;其中主要版本号（major）和次要版本号（minor）都是整数。</td>
</tr>
<tr>
<td align="center">状态码（status-code）</td>
<td align="left">这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/cBAdbLFKVflDpijz.png"
                      alt="图片"
                ></td>
</tr>
<tr>
<td align="center">原因短语（reason-phrase）</td>
<td align="left">是状态码的文本解释，包含行终止序列之前的所有文本。原因短语只对人类有意义，因此比如，尽管响应行HTTP/1.0 200 NOT OK和HTTP/1.0 200 OK中原因短语的含义不同，但都被当作成功指示处理。首部类别有<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ikG9ABzA6A0jtwzf.png"
                      alt="图片"
                ></td>
</tr>
<tr>
<td align="center">首部（header）</td>
<td align="left">可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（：），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。</td>
</tr>
<tr>
<td align="center">实体的主体部分（entity-body）</td>
<td align="left">实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时报文只是以一个CRLF结束。</td>
</tr>
</tbody></table>
<h1 id="3-4-方法"><a href="#3-4-方法" class="headerlink" title="3.4 方法"></a>3.4 方法</h1><h2 id="3-4-1-安全方法"><a href="#3-4-1-安全方法" class="headerlink" title="3.4.1 安全方法"></a>3.4.1 安全方法</h2><p>get和head被认为是<strong>安全方法</strong>，使用这个方法的HTTP请求不会产生什么动作，安全方法并不一定什么动作都不执行（这由web开发者决定），安全方法的目的是允许HTTP应用程序开发者通知用户，什么时候会使用某个可能引起某些动作的不安全办法。</p>
<h2 id="3-4-2-GET"><a href="#3-4-2-GET" class="headerlink" title="3.4.2 GET"></a>3.4.2 GET</h2><p>GET是最常用的方法。通常用于请求服务器发送某个资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/vMYdA5h28E8iGYte.png"
                      alt="图片"
                ></p>
<h2 id="3-4-3-HEAD"><a href="#3-4-3-HEAD" class="headerlink" title="3.4.3 HEAD"></a>3.4.3 HEAD</h2><p>HEAD与GET很类似，但服务器<strong>只返回首部</strong>（服务器开发者必须确保HEAD和GET返回的首部相同），不返回主体部分。这就允许客户端在未获取实际资源下，对资源的首部进行检查。比如：</p>
<pre><code>1. 在不获取资源的情况下了解资源的情况（比如，判断其类型）；
2. 通过查看响应中的状态码，看看某个对象是否存在；
3. 通过查看首部，测试资源是否被修改了。</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Com8LDRU94LnZRGT.png"
                      alt="图片"
                ></p>
<h2 id="3-4-4-PUT"><a href="#3-4-4-PUT" class="headerlink" title="3.4.4 PUT"></a>3.4.4 PUT</h2><p>与GET从服务器读取文档相反，PUT方法会向服务器写入文档，让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，如果那个URL已经存在的话，就用这个主体来替代它。</p>
<p>因为PUT允许用户对内容进行修改，所以很多Web服务器都要求在执行PUT之前，用密码登录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/x85Mw4z8E5dy9VE8.png"
                      alt="图片"
                ></p>
<h2 id="3-4-5-POST"><a href="#3-4-5-POST" class="headerlink" title="3.4.5 POST"></a>3.4.5 POST</h2><p>POST方法起初是用来向服务器输入数据的。通常用于HTML的表单,表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mA1PogAoYtDt18l2.png"
                      alt="图片"
                ></p>
<h2 id="3-4-6-TRACE"><a href="#3-4-6-TRACE" class="headerlink" title="3.4.6 TRACE"></a>3.4.6 TRACE</h2><p>客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p>
<p>TRACE请求会在目的服务器端发起一一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改过。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/gaypKsmoMOkPfmZx.png"
                      alt="图片"
                ></p>
<p>TRACE方法主要用于诊断：用于验证请求是否如愿穿过了请求/响应链，也可以用来查看代理和其他应用程序对用户请求所产生效果。</p>
<p>缺点在于，它假定中间应用程序对各种不同类型请求的处理是相同的。很多HTTP应用程序会根据方法的不同做出不同的处理。比如，代理可能会将POST请求直接发送给服务器，而将GET请求发送给另一个HTTP应用程序（比如Web缓存）。TRACE并不提供区分这些方法的机制。通常，中间应用程序会自行决定对TRACE请求的处理方式。</p>
<p>TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<h2 id="3-4-7-OPTIONS"><a href="#3-4-7-OPTIONS" class="headerlink" title="3.4.7 OPTIONS"></a>3.4.7 OPTIONS</h2><p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法，不用实际访问资源就能判定访问各种资源。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/pxQXtSaXDHxS2MDN.png"
                      alt="图片"
                ></p>
<h2 id="3-4-8-DELETE"><a href="#3-4-8-DELETE" class="headerlink" title="3.4.8 DELETE"></a>3.4.8 DELETE</h2><p>DELETE方法使服务器删除请求URL所指定的资源。但客户端应用程序无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/rR3ReKiKi4Jtrp49.png"
                      alt="图片"
                ></p>
<h2 id="3-4-9-扩展方法"><a href="#3-4-9-扩展方法" class="headerlink" title="3.4.9 扩展方法"></a>3.4.9 扩展方法</h2><p>HTTP被设计成字段可扩展的，这样新的特性不会使老的软件失效。<strong>扩展方法</strong>指的就是没有在HTTP/1.1规范中定义的方法。服务器会为它所管理的资源实现一些HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。这些方法是WebDAV HTTP扩展包含的所有方法，这些方法有助于通过HTTP将Web内容发布到Web服务器上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mpgIfTZw1n97EtyM.png"
                      alt="图片"
                ></p>
<p>不是所有的扩展方法都是在正式规范中定义的。如果你定义了一个扩展方法，很可能大部分HTTP应用程序都无法理解。同样，你的HTTP应用程序也可能会遇到一些其他应用程序在用，但并不理解的扩展方法。</p>
<p>如果能够在不破坏端到端行为的情况下，将带有未知方法的报文传递给下游服务器的话，代理会尝试传递这些报文。否则，它们会以501 Not Implemented（无法实现）状态码进行响应。</p>
<h1 id="3-5-状态码"><a href="#3-5-状态码" class="headerlink" title="3.5 状态码"></a>3.5 状态码</h1><h2 id="3-5-1-100-199——信息性状态码"><a href="#3-5-1-100-199——信息性状态码" class="headerlink" title="3.5.1 100~199——信息性状态码"></a>3.5.1 100~199——信息性状态码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/OBMDQjDvnWkV8qEA.png"
                      alt="图片"
                ></p>
<p>100 Continue状态码的目的是对这样的情况进行优化：HTTP客户端应用程序有一个实体的主体部分要发送给服务器，但希望在发送之前查看服务器是否会接受这个实体。</p>
<h2 id="3-5-2-客户端与100-Continue"><a href="#3-5-2-客户端与100-Continue" class="headerlink" title="3.5.2 客户端与100 Continue"></a>3.5.2 客户端与100 Continue</h2><p>如果客户端在向服务器发送一个实体之前，需要发送值为100 Continue的Expect请求首部</p>
<p>客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时，才应该使用100 Continue。有些出错的HTTP应用程序会不合时宜地发送这些代码。</p>
<h2 id="3-5-3-服务端与100-Continue"><a href="#3-5-3-服务端与100-Continue" class="headerlink" title="3.5.3 服务端与100 Continue"></a>3.5.3 服务端与100 Continue</h2><p>如果服务器收到了带有值为100Continue的Expect首部的请求，它会用100Continue响应或错误码来进行响应。</p>
<p>如果服务器在发送100Continue响应之前就收到了部分（或全部）的实体，说明客户端已经决定继续发送数据了，服务器就不需要发送这个状态码了。但服务器读完请求之后，还是应该为请求发送一个最终状态码（它可以跳过100 Continue状态）。</p>
<h2 id="3-5-4-代理与100-Continue"><a href="#3-5-4-代理与100-Continue" class="headerlink" title="3.5.4 代理与100 Continue"></a>3.5.4 代理与100 Continue</h2><p>如果代理从客户端收到了一条带有100 Continue期望的请求。只有在代理明确知道下一跳服务器只能与HTTP/1.1之前的版本兼容下，才以417Expectation Failed错误进行响应。</p>
<h2 id="3-5-5-200-299——成功状态码"><a href="#3-5-5-200-299——成功状态码" class="headerlink" title="3.5.5 200~299——成功状态码"></a>3.5.5 200~299——成功状态码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QBPeIRliYQsYNLuK.png"
                      alt="图片"
                ></p>
<h2 id="3-5-6-300-399——重定向状态码"><a href="#3-5-6-300-399——重定向状态码" class="headerlink" title="3.5.6 300~399——重定向状态码"></a>3.5.6 300~399——重定向状态码</h2><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应。</p>
<p>当客户端发起一个POST请求，并收到302重定向状态码时，它会接受Location首部的重定向URL，并向那个URL发起一个GET请求（而不会像原始请求中那样发起POST请求）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/oGhhDOehHAx00rMn.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/XF0C2S71UASlrXHQ.png"
                      alt="图片"
                ></p>
<h2 id="3-5-7-400-499客户端错误状态码"><a href="#3-5-7-400-499客户端错误状态码" class="headerlink" title="3.5.7 400 ~ 499客户端错误状态码"></a>3.5.7 400 ~ 499客户端错误状态码</h2><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SuFepcMWJ5V5SOwN.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ExnzaZcMsofo4KWN.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/sxIk4IJaPzMS7Ne4.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/rm9ffFKOAEKrqtAt.png"
                      alt="图片"
                ></p>
<h2 id="3-5-8-500-599服务器错误状态码"><a href="#3-5-8-500-599服务器错误状态码" class="headerlink" title="3.5.8 500 ~ 599服务器错误状态码"></a>3.5.8 500 ~ 599服务器错误状态码</h2><p>客户端碰上了服务器的缺陷，或服务器上的子元素，比如某个网关资源出错。代理与服务器进行交流时，经常会出现问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DUHKLkEagQ3ZDgjR.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/VJNKGRtGQtYaylvE.png"
                      alt="图片"
                ></p>
<h1 id="3-6-首部"><a href="#3-6-首部" class="headerlink" title="3.6 首部"></a>3.6 首部</h1><h2 id="3-6-1-通用首部"><a href="#3-6-1-通用首部" class="headerlink" title="3.6.1 通用首部"></a>3.6.1 通用首部</h2><p>这些是客户端和服务器都可以使用的通用首部。</p>
<h3 id="3-6-1-1-通用的信息性首部"><a href="#3-6-1-1-通用的信息性首部" class="headerlink" title="3.6.1.1 通用的信息性首部"></a>3.6.1.1 通用的信息性首部</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/V734hBj5Y6U1RI57.png"
                      alt="图片"
                ></p>
<h3 id="3-6-1-2-通用缓存首部"><a href="#3-6-1-2-通用缓存首部" class="headerlink" title="3.6.1.2 通用缓存首部"></a>3.6.1.2 通用缓存首部</h3><p>通用的缓存首部说明了如何或什么时候进行缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/T71nzrW361shYFJ5.png"
                      alt="图片"
                ></p>
<h2 id="3-6-2-请求首部"><a href="#3-6-2-请求首部" class="headerlink" title="3.6.2 请求首部"></a>3.6.2 请求首部</h2><h3 id="3-6-2-1-请求的信息性首部"><a href="#3-6-2-1-请求的信息性首部" class="headerlink" title="3.6.2.1 请求的信息性首部"></a>3.6.2.1 请求的信息性首部</h3><p>请求首部是请求报文特有的。它们为服务器提供了一些额外信息，服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/KPMKowkYZnhblPBY.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-2-Accept首部"><a href="#3-6-2-2-Accept首部" class="headerlink" title="3.6.2.2 Accept首部"></a>3.6.2.2 Accept首部</h3><p>Accept首部为客户端告知服务器，它们想要什么，可以使用什么以及最重要的，它们不想要什么。服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QudS2T1wJAKUiu3E.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-3-条件请求首部"><a href="#3-6-2-3-条件请求首部" class="headerlink" title="3.6.2.3 条件请求首部"></a>3.6.2.3 条件请求首部</h3><p>客户端希望为请求加上某些限制。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/kARldOx2NxiRp3Yl.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-4-安全请求首部"><a href="#3-6-2-4-安全请求首部" class="headerlink" title="3.6.2.4 安全请求首部"></a>3.6.2.4 安全请求首部</h3><p>HTTP本身支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务更安全。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/qhEP6oHR0Zg4fdkz.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-5-代理请求首部"><a href="#3-6-2-5-代理请求首部" class="headerlink" title="3.6.2.5 代理请求首部"></a>3.6.2.5 代理请求首部</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/lo4882tb0k3K2GqB.png"
                      alt="图片"
                ></p>
<h2 id="3-6-3-响应首部"><a href="#3-6-3-响应首部" class="headerlink" title="3.6.3 响应首部"></a>3.6.3 响应首部</h2><p>响应报文有自己的首部集，以便为客户端提供信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/FJfB5VYZPrChGkOf.png"
                      alt="图片"
                ></p>
<h3 id="3-6-3-1-协商首部"><a href="#3-6-3-1-协商首部" class="headerlink" title="3.6.3.1 协商首部"></a>3.6.3.1 协商首部</h3><p>如果资源有多种表示方法，可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/dPebT46CLDYXaQdJ.png"
                      alt="图片"
                ></p>
<h3 id="3-6-3-2-安全响应首部"><a href="#3-6-3-2-安全响应首部" class="headerlink" title="3.6.3.2 安全响应首部"></a>3.6.3.2 安全响应首部</h3><p>安全请求首部就是HTTP的质询/响应认证机制的响应侧。这里指的是质询首部。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DBM3vYt6qfYjHjQs.png"
                      alt="图片"
                ></p>
<h2 id="3-6-4-实体首部"><a href="#3-6-4-实体首部" class="headerlink" title="3.6.4 实体首部"></a>3.6.4 实体首部</h2><h3 id="3-6-4-1-实体的信息性首部"><a href="#3-6-4-1-实体的信息性首部" class="headerlink" title="3.6.4.1 实体的信息性首部"></a>3.6.4.1 实体的信息性首部</h3><p>实体首部指的是实体主体部分的首部，可以告知报文的接收者它在对什么进行处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/aAXJrr32FXIPhq3H.png"
                      alt="图片"
                ></p>
<h3 id="3-6-4-2-内容首部"><a href="#3-6-4-2-内容首部" class="headerlink" title="3.6.4.2 内容首部"></a>3.6.4.2 内容首部</h3><p>内容首部提供与实体内容有关的特定信息，说明了其类型、尺寸以及处理所需的有用信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/bXPOXXEC81SN4OHC.png"
                      alt="图片"
                ></p>
<h3 id="3-6-4-3-实体缓存首部"><a href="#3-6-4-3-实体缓存首部" class="headerlink" title="3.6.4.3 实体缓存首部"></a>3.6.4.3 实体缓存首部</h3><p>实体的缓存首部提供了与被缓存实体有关的信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/8xWGuWX0sDXFv2m4.png"
                      alt="图片"
                ></p>
<h2 id="3-6-5-扩展首部"><a href="#3-6-5-扩展首部" class="headerlink" title="3.6.5 扩展首部"></a>3.6.5 扩展首部</h2><p>扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP规范中去。即使不知道这些扩展首部的含义，HTTP程序也要接受它们并对其进行转发。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>03-HTTP报文</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>04-资源加载和网络栈</title>
    <url>/2021/01/21/note/webkit/04-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%A0%88/</url>
    <content><![CDATA[<p>使用网络栈下载网页和网页中的资源是渲染引擎工作过程的第一步，也是非常消耗时间的步骤。</p>
<h2 id="4-1-WebKit资源加载机制"><a href="#4-1-WebKit资源加载机制" class="headerlink" title="4.1 WebKit资源加载机制"></a>4.1 WebKit资源加载机制</h2><h3 id="4-1-1资源"><a href="#4-1-1资源" class="headerlink" title="4.1.1资源"></a>4.1.1资源</h3><p>网页本身就是一种资源，而且网页还需要依赖很多其他类型的资源，例如图片、视频等。</p>
<p>HTML支持的资源主要包括以下类型。</p>
<ol>
<li><strong>HTML</strong>：HTML页面，包括各式各样的HTML元素。</li>
<li><strong>JavaScript</strong>：JavaScript 代码，可以内嵌在HTML文件中，也可以以单独的文件存在。</li>
<li><strong>CSS样式表</strong>：CSS样式资源，可以内嵌在HTML文件之外，也可以以单独文件存在。</li>
<li><strong>图片</strong>：各种编码格式的图片资源，还有一些特殊的图片资源，例如SVG中所需的图片资源。</li>
<li><strong>SVG</strong>：用于绘制SVG的2D矢量图形表示。</li>
<li><strong>CSS Shader</strong>：支持CSS Shader文件，目前WebKit支持该功能。</li>
<li><strong>视频、音频和字幕</strong>：多媒体资源及支持音视频的字幕文件（TextTrack）。</li>
<li><strong>字体文件</strong>：CSS支持自定义字体，CSS3引入的自定义字体文件。</li>
<li><strong>XSL样式表</strong>：使用XSLT语言编写的XSLT代码文件。</li>
</ol>
<p>上面这些资源在WebKit 中有不同的类来表示它们，它们的公共基类是<strong>CachedResource</strong>。其中HTML文本的类型叫MainResource类，与其对应的资源类型叫CachedRawResource类。</p>
<p>资源类的前面的Cached字样，是因为效率问题而引入的缓存机制，所有对资源的请求都会先获取缓存中的信息，以决定是否向服务器提出资源请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/0daCvmpdLOgUMBoZl.png"
                      alt="图片"
                ></p>
<h3 id="4-1-2-资源缓存"><a href="#4-1-2-资源缓存" class="headerlink" title="4.1.2 资源缓存"></a>4.1.2 资源缓存</h3><p>资源的缓存机制的基本思想是建立一个资源的缓存池，当WebKit需要请求资源的时候，先从资源池中查找是否存在相应的资源。WebKit从资源池中查找资源的关键字是URL。如果没有，WebKit创建一个新的CachedResource子类的对象，并发送真正的请求给服务器，WebKit收到资源后将其设置到该资源类的对象中去，以便于缓存后下次使用。这里的缓存指的是内存缓存，而不同于在网络栈部分的磁盘缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/DADmcG38TQhFjPbK.png"
                      alt="图片"
                ></p>
<h3 id="4-1-3-资源加载器"><a href="#4-1-3-资源加载器" class="headerlink" title="4.1.3 资源加载器"></a>4.1.3 资源加载器</h3><p>按照加载器的类型来分，WebKit 总共有三种类型的加载器。</p>
<ol>
<li>针对每种资源类型的<strong>特定加载器</strong>，特点是仅加载某一种资源。这些资源加载器没有公共基类，作用就是当需要请求资源时，由资源加载器负责加载并隐藏背后复杂的逻辑。加载器属于它的调用者。例如image元素需要图片资源，对应的特定资源加载器是ImageLoader类。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3IcXzyYa57u2Lz0U.png"
                      alt="图片"
                ></p>
<ol start="2">
<li><strong>资源缓存机制的资源加载器</strong>，特点是所有特定加载器都共享它来查找并插入缓存资源——<strong>CachedResourceLoader类</strong>。特定加载器先是通过缓存机制的资源加载器来查找是否有缓存资源，它属于HTML的文档对象。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/Lql2quYaEeTXRUBf.png"
                      alt="图片"
                ></p>
<ol start="3">
<li><strong>通用的资源加载器</strong>——ResourceLoader类，是在WebKit需要从网络或者文件系统获取资源的时候使用该类只负责获得资源的数据，因此被所有特定资源加载器所共享。它属于CachedResource类，但它同CachedResourceLoader类没有继承关系，这容易混淆。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/yxLtJhDragnUUhta.png"
                      alt="图片"
                ></p>
<h3 id="4-1-4-过程"><a href="#4-1-4-过程" class="headerlink" title="4.1.4 过程"></a>4.1.4 过程</h3><p>下图是一个带有资源缓存机制的资源加载的全过程，包括资源已经在缓存中和不在缓存中两种情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/gVXqqiTMWy0JHXYe.png"
                      alt="图片"
                ></p>
<p>通常一些资源的加载是异步执行的，资源的获取和加载不会阻碍当前WebKit的渲染过程，例如图片、CSS文件。但网页也存在某些特别的资源会阻碍主线程的渲染过程，例如JavaScript代码文件。这会严重影响WebKit下载资源的效率，因为后面可能还有许多需要下载的资源。</p>
<p>webkit的解决方案：当前的主线程被阻碍时，WebKit 会启动另外一个线程去遍历后面的HTML网页，收集需要的资源URL，然后发送请求，避免被阻碍。同时WebKit 能够并发下载这些资源，甚至并发下载JavaScript代码资源。</p>
<h3 id="4-1-5-资源的生命周期"><a href="#4-1-5-资源的生命周期" class="headerlink" title="4.1.5 资源的生命周期"></a>4.1.5 资源的生命周期</h3><p>同CachedResourceLoader对象一样，资源池也属于HTML文档对象。资源池采用LRU（Least Recent Used）算法来替换其中的资源，从而加入新的资源。</p>
<p>另一方面，当一个资源加载后，通常它会被放入资源池，以便之后使用。在HTTP协议的规范中规定，浏览器可以发送消息确认是否需要更新，如果有，浏览器则重新获取该资源；否则就需要利用该资源。</p>
<h2 id="4-2-Chromium多进程资源加载"><a href="#4-2-Chromium多进程资源加载" class="headerlink" title="4.2 Chromium多进程资源加载"></a>4.2 Chromium多进程资源加载</h2><h3 id="4-2-1-多进程"><a href="#4-2-1-多进程" class="headerlink" title="4.2.1 多进程"></a>4.2.1 多进程</h3><p>在带有资源缓存机制的资源加载过程描述中，ResourceHandle类之下的部分，是不同移植对获取资源的不同实现。在Chromium中，获取资源的方式是利用多进程的资源加载架构。下图描述了关于Chromium如何利用多进程架构来完成资源的加载，主要是多个Renderer进程和Browser 进程之间的调用栈涉及的主要类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/sqo0VXyFsDg0m6zY.png"
                      alt="图片"
                ></p>
<p>Renderer进程在网页的加载过程中需要获取资源，但是由于安全性（当沙箱模型打开的时候，Renderer进程是没有权限去获取资源的）和效率上（资源共享等问题）的考虑，Renderer进程的资源获取实际上是通过进程间通信将任务交给Browser进程来完成，Browser 进程有权限从网络或者本地获取资源。</p>
<p>在Chromium架构的Renderer进程中，ResourceHandleInternal 类通过IPCResource-LoaderBridge类同Browser进程通信。IPCResourceL oaderBridge类继承自ResourceL oaderBridge类，其作用是负责发起请求的对象和回复结果的解释工作，实际消息的接收和派发交给ResourceDispatcher类来处理。</p>
<p>在Browser进程中，首先由ResourceMessageFilter类来过滤Renderer进程的消息，如果与资源请求相关，则该过滤类转发请求给ResourceDispatcherHostImpl类，随即ResourceDispatcherHostlmpl类创建Browser进程中的ResourceLoader 对象来处理。</p>
<p>ResourceLoader类是Chromium浏览器实际的资源加载类，它负责管理向网络发起的请求、从网络接收过来的认证请求、请求的回复管理等工作。因为这其中每项都有专门的类来负责，但都是由ResourceLoader 类统一管理。从网络或者本地文件读取信息的是URLRequest类，实际上它承担了建立网络连接、发送请求数据和接受回复数据的任务，URLRequest 之后的工作将在“网络栈”章节中来解读。</p>
<h3 id="4-2-2-工作方式和资源共享"><a href="#4-2-2-工作方式和资源共享" class="headerlink" title="4.2.2 工作方式和资源共享"></a>4.2.2 工作方式和资源共享</h3><p>资源请求有同步和异步两种方式。前面说了ResourceLoader类承担了Browser进程中有关资源的总体管理任务，对于同步和异步两种资源请求方式，ResourceLoader类使用SyncResourceHandle类和AsyncResourceHandle类来向Renderer进程发送状态消息，并接收Renderer进程对这些消息的反馈，下图描述了这些类之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/byBPW6KAwIpeU5mS.png"
                      alt="图片"
                ></p>
<p>图中还有两个ResourceHandle子类，第一个是LayeredResourceHandle类，它同SyncResourceHandle类和AsyncResourceHandle类不一样，自己不直接参与资源的处理，而是将处理转给另一个ResourceHandle对象。LayeredResourceHandle 类没有实际意义，仅是BufferedResourceHandle的父类。该缓冲类用来缓冲网络或者文件传过来的数据，直到数据足够满足需求然后转给设置的另一个ResourceHandle对象。Throttling-ResourceHandle类是在面对很多个资源请求时仅使用一个URLRequest对象来获取资源，这可以有效地减少网络的开销，因为不需要重新建立多个网络连接。</p>
<p>此外，在Chromium中还有很多ResourceHandle的子类，它们的作用各异。</p>
<ol>
<li><strong>RedirectToFileResourceHandler</strong>：继承自LayeredResourceHandle类，在接收到的数据转给另一个ResourceHandler类的同时，转存到文件。</li>
<li><strong>treamResourceHandler</strong>：继承自LayeredResourceHandle 类，在接收到的数据转给另一个ResourceHandler的同时，转存到数据流。</li>
<li><strong>CertificateResourceHandler</strong>：主要处理证书类的资源请求。</li>
</ol>
<p>资源统一交由Browser进程来处理，这使得资源在不同网页间的共享变得很容易。接下来面临一个问题，因为每个Renderer 进程某段时间内可能有多个请求，同时还有多个Renderer进程，Browser进程需要处理大量的资源请求，这就需要一个处理这些请求的调度器，这就是Chromium中的ResourceScheduler.</p>
<h2 id="4-3-网络栈"><a href="#4-3-网络栈" class="headerlink" title="4.3 网络栈"></a>4.3 网络栈</h2><h3 id="4-3-1-WebKit的网络设施"><a href="#4-3-1-WebKit的网络设施" class="headerlink" title="4.3.1 WebKit的网络设施"></a>4.3.1 WebKit的网络设施</h3><p>WebKit的资源加载其实是交由各个移植来实现的，所以WebCore其实并没有什么特别的基础设施，每个移植的网络实现是非常不一样的。</p>
<p>在WebKit的代码结构中，网络部分代码在“WebKit/Source/WebCore/platform/network”中。主要是一些HTTP消息头、MIME消息、状态码等信息的描述和处理，没有实质的网络连接和各种针对网络的优化。</p>
<h3 id="4-3-2-Chromium网络栈"><a href="#4-3-2-Chromium网络栈" class="headerlink" title="4.3.2 Chromium网络栈"></a>4.3.2 Chromium网络栈</h3><p>前面讲到资源加载，描述到URLRequest类的时候戛然而止，这是因为URLRequest类之下的部分是网络栈的内容。</p>
<h4 id="4-3-2-1-网络栈基本组成"><a href="#4-3-2-1-网络栈基本组成" class="headerlink" title="4.3.2.1 网络栈基本组成"></a>4.3.2.1 网络栈基本组成</h4><p>下图是“net”所包括的主要子目录，也是Chromium网络栈的主要模块。这里面除了一些基础的部分，例如HTTP协议、DNS解析等模块，还包含了Chromium为了减少网络时间而引入的新技术，例如SPDY、QUIC等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/i4uSsMXfcjQTaa2X.png"
                      alt="图片"
                ></p>
<h4 id="4-3-2-2-网络栈结构"><a href="#4-3-2-2-网络栈结构" class="headerlink" title="4.3.2.2 网络栈结构"></a>4.3.2.2 网络栈结构</h4><p>下图描述了从URLRequest类到Socket类之间的调用过程。以HTTP协议为例，图中列出建立TCP的socket连接过程中涉及的类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/icP92vja3jnJnFsb.png"
                      alt="图片"
                ></p>
<p>首先是URLRequest类被上层调用并启动请求的时候，它会根据URL的“scheme”来决定需要创建什么类型的请求。“scheme”也就是URL的协议类型，例如“http://”、“fle://”，也可以是自定义的scheme，例如Android系统的“fle://android asset/”。URLRequest对象创建的是一个URLRequestJob子类的一个对象，例如图中的URLRequestHttpJob类。为了支持自定义的scheme：处理方式，Chromium使用工厂模式。URLRequestJob 类和它的工厂类URLRequestJobFactory 的管理工作都由URLRequestJlobManager类负责。基本的思路是，用户可以在该类中注册多个工厂，当有URLRequest请求时，先由工厂检查它是否需要处理该“scheme”，如果没有，工厂管理类继续交给下一个工厂“类来处理。最后，如果没有任何工厂能够处理，Chromium则交给内置的工厂来检查和处理是否为“http://“、“http:/“或者“fle://”</p>
<p>等，图4-15用来描述这些类的关系。.</p>
<p>其次，当URLRequestHttpJob对象被创建后，该对象首先从Cookie管理器中获取与该URL相关联的信息。之后，它同样借助于HttpTransactionFactory对象创建一个HttpTransaction 对象来表示开启一-个 HTTP连接的事务（当然这里的概念不同于数据库中的事务概念）。通常情况下，HtpTransactionFactory 对象对应的是一个它的子类HtpCache对象。HtpCache类使用本地磁盘缓存机制（稍后会介绍），如果该请求对应的回复已经在磁盘缓存中，那么Chromium无需再建立HttpTransaction来发起连接，而是直接从磁盘中获取即可。如果磁盘中没有该URL的缓存，同时如果目前该URL请求对应的HttpTransaction已经建立，那么只要等待它的回复即可。当这些条件都不满足的时候，Chromium 实际上才会真正创建HttpTransaction对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3x9ruL4MGbG59Khg.png"
                      alt="图片"
                ></p>
<p>再次，HttpNetworkTransaction 类使用HttpNetworkSession 类来管理连接会话。</p>
<p>HttpNetworkSession类通过它的成员HttpStreamFactory 对象来建立TCP Socket连接，之后Chromium创建HttpStream对象。HttpStreamFactory对象将和网络之间的数据读写交给自己新创建的一一个HttpStream子类的对象来处理。</p>
<p>最后是套接字的建立。Chromium中与服务器建立连接的套接字是StreamSocket类，它是一一个抽象类，在POSIX系统和Windows系统上有着分别不同的实现。同时，为了支持SSL机制，StreamSocket类还有-一个子类一SSLSocket。图4-16显示了这些类和它们之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/Ssn77qEXGwUk9Sqv.png"
                      alt="图片"
                ></p>
<h4 id="4-3-2-3-代理"><a href="#4-3-2-3-代理" class="headerlink" title="4.3.2.3 代理"></a>4.3.2.3 代理</h4><p>当用户设置代理时，上面的网络栈结构是如何组织的呢？用户代理依赖以下类来处理。</p>
<ol>
<li>ProxyService：对于一个URL，HttpStreamFactory 类使用ProxyService类来获取代理信息。ProxyService类首先会检查当前的代理设置是不是最新的，如果不是，它依赖ProxyConfigService来重新获取代理信息。该类不处理实际任务，而是使用ProxyResolver类来做实际的代理工作。</li>
<li>ProxyConfigService：获取代理信息的类，可获取平台上的代理设置，在Linux、Windows.上有不同的实现。</li>
<li>ProxyScriptFetcher：Chromium 支持代理的JavaScript脚本，该类负责从代理的URL中获取该脚本。</li>
<li>ProxyResolver：实际负责代理的解释和执行，通常启用新的线程来处理，因为当前可能会被域名的解析所阻碍。</li>
<li>ProxyResolverV8：ProxyResolver的子类，使用V8引擎来解析和执行脚本。</li>
</ol>
<p>下图不仅描述上面这些类，也描述了Chromium中获取网络代理的过程。图中数字代表获取网络代理的次序，其中的分支3.1和4.1分别表示简单的代理设置和代理脚本设置的处理过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/Fb9e4AescqSYA2fZ.png"
                      alt="图片"
                ></p>
<h4 id="4-3-2-4-域名解析（DNS）"><a href="#4-3-2-4-域名解析（DNS）" class="headerlink" title="4.3.2.4 域名解析（DNS）"></a>4.3.2.4 域名解析（DNS）</h4><p>通常情况下，用户都是使用域名来访问网络资源的，所以在建立TCP连接前需要解析域名。Chromium中使用HostResolverImpl类来解析域名，具体调用的函数是“getaddrinfo（）”，该函数是一个阻塞式的函数，所以Chromium理所当然使用单独的线程来处理它，这是Chromium的原则之一。因此当调试Chromium的进程时，会看到很多线程被创建然后退出。</p>
<p>为了考虑效率，使用HostCache类来保存解析后的域名，最多时会有多达1000个的域名和地址映射关系会被存储起来。看起来DNS的解析很简单，好像也没有什么值得深究的，其实不然，域名解析也可以有优化的空间，因为优化可以有效的减少用户等待的时间。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
        <category>04-资源加载和网络栈</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>03-WebKit架构和模块</title>
    <url>/2021/01/21/note/webkit/03-WebKit%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="3-1-WebKit-架构及模块"><a href="#3-1-WebKit-架构及模块" class="headerlink" title="3.1 WebKit 架构及模块"></a>3.1 WebKit 架构及模块</h2><h3 id="3-1-1-获取WebKit"><a href="#3-1-1-获取WebKit" class="headerlink" title="3.1.1 获取WebKit"></a>3.1.1 获取WebKit</h3><p>WebKit是一个开源项目，可以从<a class="link"   href="http://www.webkit.org官方网站下载源代码./" >www.webkit.org官方网站下载源代码。<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="3-1-2-WebKit-架构"><a href="#3-1-2-WebKit-架构" class="headerlink" title="3.1.2 WebKit 架构"></a>3.1.2 WebKit 架构</h3><p>WebKit支持不同的浏览器，因为不同浏览器的需求不同，所以在WebKit中，一些代码可以共享，另外一部分不同的被称为WebKit的移植（Ports）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3NEAHZuv3WuglE3I.png"
                      alt="图片"
                ></p>
<p>图中的WebKit架构，虚线框表示该部分模块在不同浏览器使用的WebKit内核中的实现不是普遍共享的，实线框标记的模块表示它们基本上是共享的，但是否共享可以通过不同的编译配置改变它们的行为。</p>
<p>图中最下面的是“<strong>操作系统</strong>”，WebKit可以在不同的操作系统上工作。不同浏览器可能会依赖不同的操作系统，同一个浏览器使用的WebKit也可能依赖不同的操作系统。</p>
<p>在“操作系统”层之上的就是WebKit赖以工作的<strong>第三方库</strong>，这些库是WebKit运行的基础。通常来讲，它们包括<strong>图形库</strong>、<strong>网络库</strong>、<strong>视频库</strong>等。</p>
<p>在它们二者之上的就是WebKit项目，图中把它细分为两层，每层包含很多模块，由于图的大小限制，略去了其中一些次要模块。这些模块支撑网页加载和渲染过程。</p>
<p><strong>WebCore</strong>是加载和渲染网页的基础部分，包括<strong>HTML解释器</strong>、<strong>CSS解释器</strong>、<strong>SVG</strong>、<strong>DOM</strong>、<strong>渲染树</strong>（RenderObject树、RenderLayer树等），以及<strong>Inspector</strong>（Web Inspector、调试网页）。这些共享部分有些是基础框架，其背后的支持也需要各个平台的不同实现。WebCore这些部分主要被加载和渲染过程的第一、二阶段所使用。</p>
<p><strong>JavaScriptCore引擎</strong>是WebKit中的默认JavaScript 引擎，WebKit 中对JavaScript 引擎的调用是独立于引擎的。</p>
<p><strong>WebKit Ports</strong>指的是WebKit中的非共享部分，包括<strong>硬件加速架构</strong>、<strong>网络栈</strong>、<strong>视频解码</strong>、<strong>图片解码</strong>等。这些模块由于平台差异、依赖的第三方库和需求不同等方面原因，就产生了移植部分，导致众多WebKit版本的行为并非一致。</p>
<p>在WebCore和WebKit Ports之上的层主要是提供嵌入式编程接口，是提供给浏览器调用的。图中左右两个部分分别是<strong>狭义WebKit的接口</strong>和<strong>WebKit2的接口</strong>。因为接口与具体的移植有关，所以有一个与浏览器相关的<strong>绑定层，</strong>绑定层上面就是WebKit项目对外暴露的接口层。接口层的定义也是与移植密切相关的。</p>
<p>WebKit还有一个部分<strong>测试用例</strong>在图中没有展现出来，包括<strong>布局测试用例</strong>（Layout Tests）和<strong>性能测试用例</strong>（Performance Tests），这两类测试包含了大量的测试用例和期望结果。总体上来讲WebKit移植还是共享大量的用例。这些用例被用来验证渲染结果的正确性。每个浏览器所用的WebKit必须保证能够编译出来一个可执行程序，称为DumpRenderTree，它被用来运行测试用例并将渲染结果同期望结果对比。</p>
<h2 id="3-2-基于Blink的Chromium浏览器结构"><a href="#3-2-基于Blink的Chromium浏览器结构" class="headerlink" title="3.2 基于Blink的Chromium浏览器结构"></a>3.2 基于Blink的Chromium浏览器结构</h2><h3 id="3-2-1-Chromium浏览器的架构及模块"><a href="#3-2-1-Chromium浏览器的架构及模块" class="headerlink" title="3.2.1 Chromium浏览器的架构及模块"></a>3.2.1 Chromium浏览器的架构及模块</h3><p>Chromium也是基于WebKit（Blink）的。</p>
<h4 id="3-2-1-1-架构和模块"><a href="#3-2-1-1-架构和模块" class="headerlink" title="3.2.1.1 架构和模块"></a>3.2.1.1 架构和模块</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/IinKReweDux5nZou.png"
                      alt="图片"
                ></p>
<p>Chromium的架构和主要的模块中，Blink 只是其中的一块，和它并列的还有众多的Chromium模块，包括<strong>GPU/CommandBuffer</strong>（硬件加速架构）、<strong>V8 JavaScript引擎</strong>、<strong>沙箱模型</strong>、<strong>CC</strong>（Chromium Compositor）、<strong>IPC</strong>、<strong>UI</strong>等。</p>
<p><strong>Content 模块</strong>和<strong>Content API</strong>（接口）是Chromium对渲染网页功能的抽象。Content这里是指用来渲染网页内容的模块，没有Content模块，浏览器的开发者也可以在WebKit的Chromium移植上渲染网页内容，但是却没有办法获得沙箱模型、跨进程的GPU硬件加速机制、众多的HTML5功能，因为这些功能很多是在Content层里实现的。</p>
<p>Content模块和Content API将下面的渲染机制、安全机制和插件机制等隐藏起来，提供一个接口层。该接口目前被上层模块或者其他项目使用，内部调用者包括Chromium浏览器、Content Shell 等，外部包括<strong>CEF</strong>（Chromium Embedded Framework）、Opera 浏览器等。</p>
<p><strong>Chromium浏览器</strong>和<strong>Content Shell</strong>是构建在Content API之上的两个“浏览器”，Chromium具有浏览器完整的功能，而Content Shell是使用Content API来包装的一层简单的“壳”，但也是一个简单的“浏览器”，用户可以使用Content模块来渲染和显示网页内容。Content Shell的作用，其一可以用来测试Content模块很多功能的正确性，例如渲染、硬件加速等；其二是一个参考，可以被很多外部的项目参考来开发基于Content API的浏览器或者各种类型的项目。</p>
<p>在Android系统上，ContentShell的作用更大，这是因为同它并排的左侧的Chromium浏览器的代码没有开源，导致开发者只能依赖Content Shell。</p>
<p><strong>Android WebView</strong>是为了满足Android系统上的WebView而设计的，其思想是利用Chromium的实现来替换原来Android系统默认的WebView。</p>
<h4 id="3-2-1-2-多进程模型"><a href="#3-2-1-2-多进程模型" class="headerlink" title="3.2.1.2 多进程模型"></a>3.2.1.2 多进程模型</h4><p>多进程模型的好处：</p>
<ol>
<li>避免因单个页面的不响应或者崩溃而影响整个浏览器的稳定性，特别是对用户界面的影响；</li>
<li>当第三方插件崩溃时不会影响页面或者浏览器的稳定性，因为第三方插件也被使用单独的进程来运行；</li>
<li>方便了安全模型的实施，也就是沙箱模型是基于多进程架构的。这很大程度上也是WebKit2 产生的原因。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/qT1uN6gND8xF5hwh.png"
                      alt="图片"
                ></p>
<p>Chromium架构设计的灵活性，使用者还可以通过设置来改变它的进程模型方式。图中方框代表进程，连接线代表IPC进程间通信。</p>
<p><strong>Browser进程</strong>：浏览器的主进程，负责浏览器界面的显示、各个页面的管理，是所有其他类型进程的祖先，负责它们的创建和销毁等工作，它有且仅有一个。</p>
<p><strong>Renderer进程</strong>：网页的渲染进程，负责页面的渲染工作，Blink/WebKit 的渲染工作主要在这个进程中完成，可能有多个，但是Renderer 进程的数量与用户打开的网页数量不一定一致。因为Chromium允许用户配置，此外在沙箱模型启动的情况下，该进程可能会发生一些改变。</p>
<p><strong>NPAPI插件进程</strong>：该进程是为NPAPI 类型的插件而创建的。其创建的基本原则是每种类型的插件只会被创建一次，而且仅当使用时才被创建。当多个网页使用同一种类型的插件的时候，进程会为每个使用者创建一个实例，所以插件进程是被共享的。</p>
<p><strong>GPU进程</strong>：最多只有一个，当且仅当GPU硬件加速打开的时候才会被创建，主要用于对3D图形加速调用的实现。</p>
<p><strong>Pepper插件进程</strong>：同NPAPI插件进程，不同的是为Pepper 插件而创建的进程。</p>
<p><strong>其他类型的进程</strong>：图中还有一些其他类型的进程在之后介绍。</p>
<p>对于桌面系统（Windows、Linux、Mac OS）中的Chromium浏览器，它们的进程模型总结后包括以下一些特征：</p>
<ol>
<li>Browser进程和页面的渲染是分开的，页面渲染导致的崩溃不会导致浏览器主界面的崩溃。</li>
<li>每个网页是独立的进程，这保证了页面之间相互不影响。</li>
<li>插件进程也是独立的，插件本身的问题不会影响浏览器主界面和网页。</li>
<li>GPU 硬件加速进程也是独立的。</li>
</ol>
<p>对于Chromium的Android版，主体进程模型大致相同，不同主要指：</p>
<ol>
<li><strong>GPU进程，</strong>GPU进程演变成Browser进程的一个线程，目的之一是节省资源。</li>
<li><strong>Renderer进程，</strong>Android版不支持插件，所以没有插件进程，Renderer也是独立的进程，但是会演变成Android上的服务（service）进程。而且由于Android系统的局限性，Renderer进程的数目会被严格限制，这就涉及到了影子（Phantom）标签的议题。影子标签就是浏览器会将后台的网页所使用的渲染设施都清除，只是原来的一个影子，当用户再次切换的时候，网页需要重新加载和渲染。</li>
</ol>
<p>Chromium允许用户配置Renderer 进程被创建的方式，模型的类型有：</p>
<ol>
<li><strong>Process-per-site-instance</strong>：该类型的含义是为每一个页面都创建一个独立的Render进程，不管这些页面是否来自于同一域。好处是每个页面互不影响，坏处是资源的浪费。</li>
<li><strong>Process-per-site</strong>：该类型的含义是属于同一个域的页面共享同一个进程，而不同属一个域的页面则分属不同的进程。好处是对于相同的域，进程可以共享，内存消耗相对较小，坏处是可能会有特别大的Renderer 进程。</li>
<li><strong>Process-per-tab</strong>：该类型的含义是为每个标签页都创建一个独立的进程，而不管它们是否是不同域不同实例，这也是Chromium的默认行为，但会浪费资源。</li>
<li><strong>Single process</strong>：该类型的含义是不为页面创建任何独立的进程，所有渲染工作都在Browser进程中进行，它们是Browser进程中的多个线程。这个类型在桌面系统上一般不推荐使用，只有在比较单进程和多进程时相对有用，但在Chromium的Android版本上，在Android WebView中，该模式被采用。<h4 id="3-2-1-3-Browser进程和Renderer进程"><a href="#3-2-1-3-Browser进程和Renderer进程" class="headerlink" title="3.2.1.3 Browser进程和Renderer进程"></a>3.2.1.3 Browser进程和Renderer进程</h4></li>
</ol>
<p>Browser进程和Renderer进程都是在WebKit的接口之外由Chromium引入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/CTnRBqgG4ElY7uhV.png"
                      alt="图片"
                ></p>
<p><strong>WebKit接口层</strong>，一般基于WebKit接口层的浏览器直接在上面构建，而没有引入复杂的多进程架构。</p>
<p><strong>WebKit黏附层</strong>，因为Chromium中一些类型和WebKit内部不一致，所以需要一个桥接层。</p>
<p><strong>Renderer</strong>，主要处理进程间通信，接受来自Browser进程的请求，并调用相应的WebKit接口层。同时将WebKit的处理结果发送回去。上面这些层都是在Renderer进程中工作的。</p>
<p><strong>RendererHost</strong>，目的也是处理同Renderer进程之间的通信，不过RendererHost是给Renderer进程发送请求并接收来自Renderer进程的结果。</p>
<p><strong>Web Contents</strong>表示的是网页的内容，它同时包括显示网页内容的子窗口，子窗口最后被嵌入浏览器的用户界面，作为它的一个标签页。</p>
<h4 id="3-2-1-4-多线程模型"><a href="#3-2-1-4-多线程模型" class="headerlink" title="3.2.1.4 多线程模型"></a>3.2.1.4 多线程模型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/vbkdMTBjTVYMog53.png"
                      alt="图片"
                ></p>
<p>网页的加载和渲染过程在图中模型下的基本工作方式如以下步骤：</p>
<ol>
<li>Browser进程收到用户的请求，首先由UI线程处理，而且将相应的任务转给IO线程，它随即将该任务传递给Renderer进程。</li>
<li>Renderer进程的IO线程经过解释后交给渲染线程。渲染线程接受请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。最后Renderer进程将结果由IO线程传递给Browser进程。</li>
<li>最后，Browser进程接收到结果并将结果绘制出来。</li>
</ol>
<p>Chromium为了保持线程间通信和同步，同时避免造成死锁或者资源的竞争冲突等问题，在绝大多数的场景，使用事件和一种Chromium新创建的任务传递机制，仅在非用不可的情况下才使用锁或者线程安全对象。</p>
<h4 id="3-2-1-5-Content接口"><a href="#3-2-1-5-Content接口" class="headerlink" title="3.2.1.5 Content接口"></a>3.2.1.5 Content接口</h4><p>Content接口不仅提供了一层对多进程进行渲染的抽象接口，而且它支持所有的HTML5功能、GPU硬件加速功能和沙箱机制。Content接口按照功能分成六个部分，每个部分的接口一般也可以分成两类，第一类是嵌入者（可以是Chromium浏览器、CEF3和Content Shell）调用的接口，另一类是嵌入者应该实现的回调接口，被Content接口的内部实现所调用，用来参与具体实现的逻辑或者事件的监听等。</p>
<ol>
<li><strong>App</strong>。这部分主要与应用程序或者进程的创建和初始化相关，它被所有的进程使用，用来处理一些进程的公共操作。包括两种类型，第一类主要包括进程创建的初始化函数，也就是Content模块的初始化和关闭动作；第二类主要是各种回调函数，用来告诉嵌入者启动完成，进程启动、退出，沙盒模型初始化开始和结束等。</li>
<li><strong>Browser</strong>。第一类包括对一些HTML5功能和其他高级功能实现的参与。第二类主要是实现部分的逻辑，被Browser进程调用，还有就是一些事件的函数回调。</li>
<li><strong>Common</strong>。主要定义一些公共的接口，这些被Renderer和Browser共享，例如一些进程相关、参数、GPU相关等。</li>
<li><strong>Plugin</strong>。仅有一个接口类，通知嵌入者Plugin进程何时被创建。</li>
<li><strong>Renderer</strong>。第一类包含获取RenderThread的消息循环、注册V8Extension、计算JavaScript表达式等。第二类包括ContentRendererClient，主要是实现部分逻辑，被Browser端（或者进程）调用，还有就是一些事件的函数回调。</li>
<li><strong>Utility</strong>。工具类接口，主要包括让嵌入者参与Content接口中的线程创建和消息的过滤。<h2 id="3-3-WebKit2"><a href="#3-3-WebKit2" class="headerlink" title="3.3 WebKit2"></a>3.3 WebKit2</h2></li>
</ol>
<h3 id="3-3-1-WebKit2架构及模块"><a href="#3-3-1-WebKit2架构及模块" class="headerlink" title="3.3.1 WebKit2架构及模块"></a>3.3.1 WebKit2架构及模块</h3><p>相比于狭义的WebKit，WebKit2是一套全新的结构和接口。它主要目的和思想同Chromium类似，就是将渲染过程放在单独的进程中来完成，独立于用户界面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/DcFsDgQUQEzoXb3W.png"
                      alt="图片"
                ></p>
<p>WebKit2中也引入了插件进程和网络进程。Web进程对应于Chromium中的Renderer进程，主要是渲染网页。UI进程对应于Chromium中的Browser进程。接口就暴露在该进程中，应用程序只需调用该接口即可。应用程序指的是浏览器或者任何使用该接口的程序。</p>
<h3 id="3-3-2-WebKit-和WebKit2嵌入式接口"><a href="#3-3-2-WebKit-和WebKit2嵌入式接口" class="headerlink" title="3.3.2 WebKit 和WebKit2嵌入式接口"></a>3.3.2 WebKit 和WebKit2嵌入式接口</h3><p>WebKit提供嵌入式接口，该接口表示其他程序可以将网页渲染嵌入在程序中作为其中的一部分，或用户界面的一部分。对于WebKit的Chromium移植来说，它的接口主要用于Chromium浏览器，而不是嵌入式的使用方式。</p>
<p>在WebKit项目中，狭义WebKit的接口主要思想是将网页的渲染结果作为用户界面中的一个窗口部件，它用来显示网页的内容。按功能大致可以把所有接口分成六种类型：</p>
<ol>
<li>设置加载网页、获取加载进度、停止加载、重新加载等；</li>
<li>遍历前后浏览记录类，可以前进、后退等；</li>
<li>网页的很多设置，例如缩放、主题、背景、模式、编码等；</li>
<li>查找网页的内容、高亮等；</li>
<li>触控事件、鼠标事件处理；</li>
<li>查看网页源代码、显示调试窗口等与开发者相关的接口，是通常的嵌入式接口提供的功能。</li>
</ol>
<p>WebKit2接口不同于WebKit的接口，它们是不兼容的，但目的都是提供嵌入式的应用接口。WebKit2接口大致可以分为两个大的部分，</p>
<ol>
<li><strong>WebView相关的接口</strong>，表示渲染的设置、渲染过程、界面等，其中大多数跟各个移植紧密相关。有三个主要的类，它们被各个移植所共享。<ol>
<li>WKView[Ref]：表示的是一个与平台相关的视图，例如在Windows上它表示的就是一个窗口的句柄。</li>
<li>WKContextRef：所有页面的上下文，这些被共享的信息包括local storage、设置等。</li>
<li>WKPageRef：表示网页，也就是浏览的基本单位。</li>
</ol>
</li>
<li>上面<strong>接口依赖的基础类</strong>，它们被各个移植所共享，既包括容器、字符串等基础类，也包括跟网页相关的基础类，例如URL、请求、网页设置等。</li>
</ol>
<p>WebKit2还有WebBundle接口，在Web进程里，其目的是让某些移植访问DOM，目前还没有明确的需求。</p>
<h3 id="3-3-3-比较WebKit2和Chromium的多进程模型以及接口"><a href="#3-3-3-比较WebKit2和Chromium的多进程模型以及接口" class="headerlink" title="3.3.3 比较WebKit2和Chromium的多进程模型以及接口"></a>3.3.3 比较WebKit2和Chromium的多进程模型以及接口</h3><p>下图详细描述了WebKit 接口和Chromium的多进程的关系，以及和Content接口的关系。前面笔者也介绍了一些，例如Renderer进程直接调用WebKit接口，以及和Content接口允许应用程序注入并参与Content之下各个进程的内部逻辑。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/IZ9qB9RUHmSwUfSc.png"
                      alt="图片"
                ></p>
<p>首先，Chromium使用的仍然是WebKit接口，而不是WebKit2接口，也就是说Chromium是在WebKit接口之上构建的多进程架构。</p>
<p>其次，WebKit2 的接口希望尽量将多进程结构隐藏起来，但对Chromium来说，它的主要目的是给Chromium提供Content接口以便构建浏览器，其本身目标不是提供嵌入式接口，虽然有CEF项目基于它构建了嵌入式接口。</p>
<p>最后，Chromium中每个进程都是从相同的二进制可执行文件启动，而基于WebKit2的进程则未必如此。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
        <category>03-WebKit架构和模块</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>04-链接管理</title>
    <url>/2021/01/23/note/HTTP/04-%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="4-1-TCP链接"><a href="#4-1-TCP链接" class="headerlink" title="4.1 TCP链接"></a>4.1 TCP链接</h2><h3 id="4-1-1-TCP的可靠数据管道"><a href="#4-1-1-TCP的可靠数据管道" class="headerlink" title="4.1.1 TCP的可靠数据管道"></a>4.1.1 TCP的可靠数据管道</h3><p>HTTP连接实际，上就是TCP连接和一些使用连接的规则，TCP为HTTP提供了一条可靠的比特传输管道。</p>
<h3 id="4-1-2-TCP流、IP分组"><a href="#4-1-2-TCP流、IP分组" class="headerlink" title="4.1.2 TCP流、IP分组"></a>4.1.2 TCP流、IP分组</h3><p>TCP的数据是通过IP分组（IP 数据报）的小数据块来发送的。安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/EcJv4cg2UJABtNpp.png"
                      alt="图片"
                ></p>
<p>TCP段是由IP分组承载。每个IP分组中包括：</p>
<pre><code>    1. 一个IP分组首部，包含源和目的IP地址、长度和其他一些标记（通常为20字节）；
    2. 一个TCP段首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值。（通常为20字节）；
    3. 一个TCP数据块（0个或多个字节）。</code></pre>
<h3 id="4-1-3-TCP连接的正确运行"><a href="#4-1-3-TCP连接的正确运行" class="headerlink" title="4.1.3 TCP连接的正确运行"></a>4.1.3 TCP连接的正确运行</h3><p>计算机随时都有几条TCP连接处于打开状态，TCP 通过端口号来保持连接的正确运行。</p>
<p>TCP连接通过4个值来识别：&lt;<strong>源IP地址、源端口号、目的IP地址、目的端口号</strong>&gt;。这4个值唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/46GDogLOzoqcLen7.png"
                      alt="图片"
                ></p>
<h3 id="4-1-4-TCP套接字编程"><a href="#4-1-4-TCP套接字编程" class="headerlink" title="4.1.4 TCP套接字编程"></a>4.1.4 TCP套接字编程</h3><p>操作系统提供了一些操纵其TCP连接的工具。我们来看一个TCP编程接口。这个套接字API向HTTP程序员隐藏了TCP和IP的所有细节。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/qv4I1NjxFUOC6xh8.png"
                      alt="图片"
                ></p>
<p>套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间的分段和重装细节。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/vAn3ica3x7NtExWZ.png"
                      alt="图片"
                ></p>
<p>从Web服务器等待连接（S4）开始。客户端根据URL判定出IP地址和端口号，并建立一条到服务器的TCP连接（C3）。</p>
<p>建立连接后，客户端就会发送HTTP请求（C5），服务器读取请求（S6）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（S7），并将数据写回客户端。客户端读取数据（C6），并对响应数据进行处理（C7）。</p>
<h2 id="4-2-TCP性能"><a href="#4-2-TCP性能" class="headerlink" title="4.2 TCP性能"></a>4.2 TCP性能</h2><h3 id="4-2-1-HTTP事务的时延"><a href="#4-2-1-HTTP事务的时延" class="headerlink" title="4.2.1 HTTP事务的时延"></a>4.2.1 HTTP事务的时延</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/N1zHevdCojb7owBy.png"
                      alt="图片"
                ></p>
<p>与建立TCP连接、传输请求、响应报文的时间相比，事务处理可能是很短的，除非客户端或服务器超载，或正处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的。</p>
<p>HTTP事务的时延原因：</p>
<p>（1）<strong>DNS解析</strong>，但大多数HTTP客户端都有一个小的DNS缓存，用来保存近期所访问站点的IP地址，可以很快地将主机名解析出来。</p>
<p>（2）客户端会向服务器发送一条TCP连接请求，并等待服务器回送请求接受应答。每条新的<strong>TCP连接的连接建立时延</strong>，最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会很高。</p>
<p>（3）连接建立后，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器从TCP连接中<strong>读取请求报文</strong>，并<strong>处理请求报文</strong>，因特网<strong>传输请求报文</strong>、服务器处理请求报文都需要时间。</p>
<p>（4）Web服务器会<strong>回送HTTP响应</strong>，这些TCP网络时延的大小取决于<strong>硬件速度</strong>、<strong>网络和服务器的负载</strong>，<strong>请求和响应报文的尺寸</strong>，以及客户端和服务器之间的<strong>距离</strong>。<strong>TCP协议的技术复杂性</strong>也会对时延产生巨大的影响。</p>
<h3 id="4-2-2-TCP相关时延"><a href="#4-2-2-TCP相关时延" class="headerlink" title="4.2.2 TCP相关时延"></a>4.2.2 TCP相关时延</h3><pre><code>1. TCP连接建立握手，
2. 用于捎带确认的TCP延迟确认算法
3. TCP慢启动拥塞控制；
4. 数据聚集的Nagle算法；
5. TIME_WAIT时延和端口耗尽。</code></pre>
<h4 id="4-2-2-1-TCP连接的握手时延"><a href="#4-2-2-1-TCP连接的握手时延" class="headerlink" title="4.2.2.1 TCP连接的握手时延"></a>4.2.2.1 TCP连接的握手时延</h4><p>建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接用来传送少量数据，这些交换过程就会降低HTTP的性能。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/McjEXqUcLmE8y4Qe.png"
                      alt="图片"
                ></p>
<p><strong>TCP连接握手步骤:</strong></p>
<pre><code>1. 请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40 ~60个字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求（参见a）。
2. 如果服务器接受连接，会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受（参见b）。
3. 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图c）。现代的TCP栈都允许客户端在这个确认分组中发送数据。</code></pre>
<p>通常HTTP事务不会交换太多数据，SYN/SYN+ACK握手会产生一个可测量的时延。TCP连接的ACK分组通常都足够承载整个HTTP请求报文，而且很多HTTP服务器响应报文都可以放人一个IP分组中去。最后导致小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。</p>
<h4 id="4-2-2-2-延迟确认"><a href="#4-2-2-2-延迟确认" class="headerlink" title="4.2.2.2 延迟确认"></a>4.2.2.2 延迟确认</h4><p>每个TCP段有一个序列号和数据完整性校验和，来确保数据的成功传输。接收者收到完好的段时，会向发送者回送确认分组。如果发送者没有在指定时间内收到确认信息，发送者就认为分组已破坏或损毁，会重发数据。</p>
<p>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“<strong>捎带</strong>”。TCP将返回的确认信息与输出的数据分组结合在一起。</p>
<p>为增加确认报文找到同向传输数据分组的可能，TCP栈实现了一种<strong>“延迟确认”算法，</strong>会在一个特定的窗口时间（通常100 ~ 200毫秒）内将输出确认存放在缓冲区中，以寻找能捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求-应答行为，导致当希望有相反方向回传分组的时候，偏偏没有那么多。</p>
<p>延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<h4 id="4-2-2-3-TCP慢启动"><a href="#4-2-2-3-TCP慢启动" class="headerlink" title="4.2.2.3 TCP慢启动"></a>4.2.2.3 TCP慢启动</h4><p>TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动（slow start），防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。HTTP事务不能一次将所有分组都发送出去，必须发送一个分组，等待确认，才可以发送两个分组，再次被确认，就可以发送四个分组，以此类推。这种方式被称为“打开拥塞窗口”。</p>
<p>由于这种拥塞控制特性，新连接的传输速度会比已经交换过数据的“已调谐”连接慢。</p>
<h4 id="4-2-2-4-Nagle算法与TCP-NODELAY"><a href="#4-2-2-4-Nagle算法与TCP-NODELAY" class="headerlink" title="4.2.2.4 Nagle算法与TCP_NODELAY"></a>4.2.2.4 Nagle算法与TCP_NODELAY</h4><p>TCP有数据流接口，每个TCP段中都至少装载了40个字节的标记和首部，所以如果TCP发送了大量包含少量数据的分组，网络的性能会下降。</p>
<p><strong>Nagle算法</strong>：试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。Nagle算法鼓励发送全尺寸的段，只有当所有其他分组都被确认之后，才发送非全尺寸的分组。如果其他分组仍在传输中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p>
<p><strong>Nagle算法缺陷</strong>：首先，小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题，Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100 ~ 200毫秒。</p>
<p>HTTP应用程序通常设置参数TCP_NODELAY，禁用Nagle算法，这样须确保会向TCP写入大块的数据，不会产生一堆小分组。</p>
<h4 id="4-2-2-5-TIME-WAIT累积与端口耗尽"><a href="#4-2-2-5-TIME-WAIT累积与端口耗尽" class="headerlink" title="4.2.2.5 TIME__WAIT累积与端口耗尽"></a>4.2.2.5 TIME__WAIT累积与端口耗尽</h4><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，维持的时间，是最大分段使用期的两倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。这也防止之前连接的复制分组插入了具有相同连接值的新TCP流，会破坏TCP数据。</p>
<p>但在性能基准测试时，TIME__WAIT 也限制了可用的连接值组合。因为在只有一个客户端和一台Web服务器的情况下，构建一条TCP连接的4个值，只有源端口号可以随意改变，客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限，而且在2MSL秒内连接是无法重用的，连接率就被限制了。</p>
<p>可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</p>
<p>即使没有遇到端口耗尽问题，也要小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会减缓。</p>
<h2 id="4-3-HTTP链接的处理"><a href="#4-3-HTTP链接的处理" class="headerlink" title="4.3 HTTP链接的处理"></a>4.3 HTTP链接的处理</h2><h3 id="4-3-1-connection首部"><a href="#4-3-1-connection首部" class="headerlink" title="4.3.1 connection首部"></a>4.3.1 connection首部</h3><p>Connection首部有3种类型的标签：</p>
<pre><code>1. HTTP 首部字段名，列出了只与此连接有关的首部；
2. 任意标签值，用于描述此连接的非标准选项；
3. 值close，说明操作完成之后需关闭这条持久连接。</code></pre>
<p>如果连接标签中包含了HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发，在将报文转发出去之前，删除Connection所列出的首部字段以及自身。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/MWKLFwHwkjmuqWQY.png"
                      alt="图片"
                ></p>
<h3 id="4-3-2-串行事务处理时延"><a href="#4-3-2-串行事务处理时延" class="headerlink" title="4.3.2 串行事务处理时延"></a>4.3.2 串行事务处理时延</h3><p>串行加载缺点：1、叠加链接时延和慢启动时延。2、有些浏览器需要完全加载后才显示。</p>
<p>新的链接方法：</p>
<pre><code>1. 并行连接：通过多条TCP连接发起并发的HTTP请求。
2. 持久连接：重用TCP连接，以消除连接及关闭时延。
3. 管道化连接：通过共享的TCP连接发起并发的HTTP请求。
4. 复用的连接：交替传送请求和响应报文（实验阶段）。</code></pre>
<h2 id="4-4-并行链接"><a href="#4-4-并行链接" class="headerlink" title="4.4 并行链接"></a>4.4 并行链接</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/E02QnUnHmeOPbogJ.png"
                      alt="图片"
                ></h2><p>并行链接的优点：</p>
<pre><code>1. 每个事务都有自己的连接，装载是并行的，连接的时延也是重叠的。（嵌入的组件不一定都在同一台Web服务器上，可以同多台服务器建立并行的连接）。
2. 可以让用户感觉更快。</code></pre>
<p>并行链接的缺点：</p>
<pre><code>1. 如果并行加载多个对象，每个对象竞争有限的带宽，都会以较慢的速度按比例加载。
2. 打开大量连接会消耗很多内存资源，从造成服务器、代理性能的下降。
3. 由于TCP慢启动特性，每条新连接的性能都会有所降低。</code></pre>
<p>浏览器一般会将并行连接的总数限制为4个。服务器可以随意关闭来自特定客户端的超量连接。</p>
<h2 id="4-5-持久链接"><a href="#4-5-持久链接" class="headerlink" title="4.5 持久链接"></a>4.5 持久链接</h2><p><strong>站点本地性</strong>（site locality）：Web客户端经常打开到同一个站点的连接。因此，初始化了对某服务器HTTP请求的应用程序可能会对那台服务器不久发起更多的请求。</p>
<p><strong>持久连接</strong>：HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接，直到客户端或服务器决定将其关闭为止。</p>
<p>优点：避开缓慢的连接建立阶段；避免慢启动的拥塞适应阶段。</p>
<p>缺点：累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/RUOT3rgreZZqeDQ5.png"
                      alt="图片"
                ></p>
<p>持久连接与并行连接配合使用是高效的方式。通常，Web应用程序打开少量的并行连接，其中的每一个都是持久连接。</p>
<p>持久连接有两种类型：比较老的**”keep-alive”连接<strong>，现代的</strong>“persistent”连接**</p>
<h3 id="4-5-1-HTTP-1-0-keep-alive连接"><a href="#4-5-1-HTTP-1-0-keep-alive连接" class="headerlink" title="4.5.1 HTTP/1.0+   keep-alive连接"></a>4.5.1 HTTP/1.0+   keep-alive连接</h3><p>客户端通过包含Connection：Keep-Alive首部请求，将一条连接保持在打开状态。如果服务器可以，就在响应中包含相同的首部，否则说明服务器不支keep-alive，会在发回响应报文之后关闭连接。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，有多部件媒体类型，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>Keep-Alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的行为：</p>
<pre><code>1. 参数**timeout**在Keep-Alive响应首部发送，服务器希望将连接保持在活跃状态的时间。
2. 参数**max**在Keep-Alive响应首部发送，服务器希望为多少个事务保持此连接的活跃状态。
3. Keep-Alive首部支持任意未经处理的属性，用于诊断和调试。语法为name[=value]。</code></pre>
<h4 id="4-5-1-1-哑代理"><a href="#4-5-1-1-哑代理" class="headerlink" title="4.5.1.1 哑代理"></a>4.5.1.1 哑代理</h4><p>老的或简单的代理都是<strong>盲中继</strong>（blind relay），只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/EBTdTrTeWy3Jfd15.png"
                      alt="图片"
                ></p>
<p>后果：客户端和服务器都认为它们在进行keep-alive对话，但代理等待源端服务器关闭连接，源端服务器认为连接保持在打开状态，所以不会去关闭连接，反而立即转向下一条请求。而代理并不认为同一条连接上会有其他请求，<strong>请求被忽略</strong>。这会使浏览器<strong>一直处于挂起状态</strong>，直到客户端或服务器将连接超时，并将其关闭为止。</p>
<p>有几个不能作为Connection首部值列出，包括Proxy-Authenticate、Proxy-Connection、</p>
<p>Transfer-Encoding和Upgrade。</p>
<h4 id="4-5-1-2-插入Proxy-Connection解决哑代理"><a href="#4-5-1-2-插入Proxy-Connection解决哑代理" class="headerlink" title="4.5.1.2 插入Proxy-Connection解决哑代理"></a>4.5.1.2 插入Proxy-Connection解决哑代理</h4><p>浏览器向代理发送非标准的Proxy-Connection扩展首部，而不是官方支持的Connection首部。如果代理是盲中继，将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部，否则就用Connection首部取代Proxy-Connection首部，然后将其发送给服务器。</p>
<p>对有多层次代理的情况，Proxy-Connection 仍然无法解决问题。</p>
<h3 id="4-5-2-HTTP-1-1-持久连接"><a href="#4-5-2-HTTP-1-1-持久连接" class="headerlink" title="4.5.2 HTTP/1.1  持久连接"></a>4.5.2 HTTP/1.1  持久连接</h3><p><strong>持久连接（</strong>persistent connection），在默认情况下是激活的。除非向报文中显式地添加一个Connection：close首部。但客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。</p>
<h2 id="4-6-管道化连接"><a href="#4-6-管道化连接" class="headerlink" title="4.6 管道化连接"></a>4.6 管道化连接</h2><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>。在响应到达之前，可以将多条请求放入队列。当第一条请求流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SmB3DWYPPxzXolFI.png"
                      alt="图片"
                ></p>
<p>管道化连接的限制：</p>
<ol>
<li>HTTP客户端确认是持久连接，才能使用管道。</li>
<li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li>
<li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。<h2 id="4-7-关闭连接"><a href="#4-7-关闭连接" class="headerlink" title="4.7 关闭连接"></a>4.7 关闭连接</h2></li>
</ol>
<h3 id="4-7-1-任意解除连接"><a href="#4-7-1-任意解除连接" class="headerlink" title="4.7.1 任意解除连接"></a>4.7.1 任意解除连接</h3><p>所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接，但也有可能出错，对管道化持久连接来说，这种情形是很常见的。</p>
<h3 id="4-7-2-Content-Length及截尾操作"><a href="#4-7-2-Content-Length及截尾操作" class="headerlink" title="4.7.2 Content-Length及截尾操作"></a>4.7.2 Content-Length及截尾操作</h3><p>每条HTTP响应都应该有Content-Length首部。一些老的HTTP服务器会省略或者包含错误的长度指示，这就要依赖服务器发出的连接关闭来说明数据的真实末尾。</p>
<p>客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与Content-Length并不匹配或没有Content-Length时，接收端应该质疑长度的正确性。</p>
<p>如果接收端是个缓存代理，不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能），而是原封不动地转发出去，以维护语义的透明性。</p>
<h3 id="4-7-3-连接关闭容限、重试、幂等性"><a href="#4-7-3-连接关闭容限、重试、幂等性" class="headerlink" title="4.7.3 连接关闭容限、重试、幂等性"></a>4.7.3 连接关闭容限、重试、幂等性</h3><p>如果在客户端执行事务的过程中，传输连接关闭了，除非事务处理会带来副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，源端服务器关闭连接，就会留下大量未处理的请求，需要重新调度。</p>
<p>如果一个事务，不管是执行几次，得到的结果都相同，这个事务就是<strong>幂等</strong>的。要发送一条非幂等请求，需要等待来自前一条请求的响应状态。</p>
<p>用户Agent代理一定不能自动重试非幂等方法或序列。比如post订单，大多数浏览器都会提供一个对话框，询问用户是否希望再次发起事务处理。</p>
<h3 id="4-7-4-正常关闭连接"><a href="#4-7-4-正常关闭连接" class="headerlink" title="4.7.4 正常关闭连接"></a>4.7.4 正常关闭连接</h3><h4 id="4-7-4-1-完全关闭与半关闭"><a href="#4-7-4-1-完全关闭与半关闭" class="headerlink" title="4.7.4.1 完全关闭与半关闭"></a>4.7.4.1 完全关闭与半关闭</h4><p>应用程序可以关闭TCP输入和输出信道中的任意一个或两者。</p>
<p>套接字调用<strong>close（）</strong>将TCP连接的输入输出信道都关闭了，称作“<strong>完全关闭</strong>”，如图a所示。</p>
<p>套接字调用<strong>shutdown（）</strong>单独关闭输入或输出信道，这被称为<strong>“半关闭”</strong>，如图b所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/HqfJNF2eliisLFNQ.png"
                      alt="图片"
                ></p>
<h4 id="4-7-4-2-TCP关闭及重置错误"><a href="#4-7-4-2-TCP关闭及重置错误" class="headerlink" title="4.7.4.2 TCP关闭及重置错误"></a>4.7.4.2 TCP关闭及重置错误</h4><p>当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误。</p>
<p>关闭连接的输出信道总是安全的。连接另一端的对等实体会在从其缓冲区中读出所有数据之后收到一条通知，说明流结束了，知道连接关闭了。</p>
<p>关闭连接的输入信道比较危险，除非知道另一端不再发送数据。如果向已关闭的输入信道发送数据，操作系统会回送一条TCP“<strong>连接被对端重置</strong>”报文，删除对端还未读取的所有缓存数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DZvhKCeOgaAwmwKW.png"
                      alt="图片"
                ></p>
<h4 id="4-7-4-3-正常关闭"><a href="#4-7-4-3-正常关闭" class="headerlink" title="4.7.4.3 正常关闭"></a>4.7.4.3 正常关闭</h4><p>应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都知道不再发送数据（比如关闭输出信道）后，连接就会被完全关闭，不会有重置的危险。</p>
<p>但不无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>04-链接管理</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Web服务器</title>
    <url>/2021/01/23/note/HTTP/05-Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Web服务器会对HTTP请求进行处理并提供响应。“<strong>Web服务器</strong>”可以用来表示Web服务器的软件，也可以用来表示提供Web页面的特定设备或计算机。</p>
<p>Web服务器有着不同的风格、形状和尺寸。有普通的10行Perl脚本的Web服务器、50MB的安全商用引擎以及极小的卡上服务器。</p>
<h1 id="5-1-Web服务器的实现"><a href="#5-1-Web服务器的实现" class="headerlink" title="5.1 Web服务器的实现"></a>5.1 Web服务器的实现</h1><p>Web服务器逻辑实现了HTTP协议、管理着Web资源，并负责提供Web服务器的管理功能。Web服务器逻辑和操作系统共同负责管理TCP连接。底层操作系统负责管理底层计算机系统的硬件细节，并提供了TCP/IP网络支持、负责装载Web资源的文件系统以及控制当前计算活动的进程管理功能。</p>
<p>Web服务器的不同的形式：通用软件Web服务器；Web服务器设备；嵌入式Web服务器。</p>
<h1 id="5-2-通用软件Web服务器"><a href="#5-2-通用软件Web服务器" class="headerlink" title="5.2 通用软件Web服务器"></a>5.2 通用软件Web服务器</h1><p>通用软件Web服务器都运行在标准的、有网络功能的计算机系统上。可以选择开源软件（比如Apache或W3C的Jigsaw）或者商业软件（比如微软和iPlanet的Web服务器）。基本上所有的计算机和操作系统中都有可用的Web服务器软件。</p>
<h1 id="5-3-Web服务器设备"><a href="#5-3-Web服务器设备" class="headerlink" title="5.3 Web服务器设备"></a>5.3 Web服务器设备</h1><p>Web服务器设备（Web server appliance）是预先打包好的软硬件解决方案。厂商会在他们选择的计算机平台上预先安装好软件服务器，并将软件配置好。</p>
<p>这样不再需要安装及配置软件，可以极大地简化管理工作。但Web服务器通常不太灵活，特性不太丰富，而且服务器硬件也不太容易重用或升级。</p>
<h1 id="5-4-嵌入式Web服务器"><a href="#5-4-嵌入式Web服务器" class="headerlink" title="5.4 嵌入式Web服务器"></a>5.4 嵌入式Web服务器</h1><p>嵌入式服务器（embededserver）是嵌入到消费类产品（比如打印机或家用设备中去的小型Web服务器。嵌入式Web服务器允许用户通过便捷的Web浏览器接口来管理其消费者设备。嵌入式Web服务器通常只能提供最小特性功能集。</p>
<h1 id="5-5-Web服务器操作"><a href="#5-5-Web服务器操作" class="headerlink" title="5.5 Web服务器操作"></a>5.5 Web服务器操作</h1><p>（1）建立连接——接受一个客户端连接，如果不希望与这个客户端建立连接，就将其关闭。</p>
<p>（2）接收请求——从网络中读取一条HTTP请求报文。</p>
<p>（3）处理请求——对请求报文进行解释，并采取行动。</p>
<p>（4）访问资源——访问报文中指定的资源。</p>
<p>（5）构建响应——创建带有正确首部的HTTP响应报文。</p>
<p>（6）发送响应——将响应回送给客户端。</p>
<p>（7）记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/pzJLam8z7mPDhlLa__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="5-5-1-第一步——接受客户端连接"><a href="#5-5-1-第一步——接受客户端连接" class="headerlink" title="5.5.1 第一步——接受客户端连接"></a>5.5.1 第一步——接受客户端连接</h2><p>如果客户端已经打开了一条到服务器的持久连接，可以使用那条连接来发送它的请求。否则，客户端需要打开一条新的到服务器的连接。</p>
<h3 id="5-5-1-1-处理新连接"><a href="#5-5-1-1-处理新连接" class="headerlink" title="5.5.1.1 处理新连接"></a>5.5.1.1 处理新连接</h3><p>客户端请求一条到Web服务器的TCP连接时，Web服务器会建立连接，判断连接的另一端是哪个客户端，从TCP连接中将IP地址解析出来。一旦新连接建立起来并被接受，服务器就会将新连接添加到其现存Web服务器连接列表中，做好监视连接上数据传输的准备。</p>
<p>Web服务器可以随意拒绝或立即关闭任意一条连接。有些Web服务器会因为客户端IP地址或主机名是未认证的，或者因为它是已知的恶意客户端而关闭连接。</p>
<h3 id="5-5-1-2-客户端主机名识别"><a href="#5-5-1-2-客户端主机名识别" class="headerlink" title="5.5.1.2 客户端主机名识别"></a>5.5.1.2 客户端主机名识别</h3><p>可以用“反向DNS”对大部分Web服务器进行配置，以便将客户端IP地址转换成客户端主机名。Web服务器可以将客户端主机名用于详细的访问控制和日志记录。但主机名查找会花费很长时间，降低Web事务处理的速度。大容量Web服务器要么会禁止主机名解析，要么只允许对特定内容进行解析。</p>
<h3 id="5-5-1-3-通过ident确定客户端用户"><a href="#5-5-1-3-通过ident确定客户端用户" class="headerlink" title="5.5.1.3 通过ident确定客户端用户"></a>5.5.1.3 通过ident确定客户端用户</h3><p>有些Web服务器支持IETF的ident协议，通过ident协议找到发起HTTP连接的用户名。<strong>通用日志格式</strong>（Common Log Format）的第二个字段中就包含了每条HTTP请求的ident用户名。如果客户端支持ident协议，就在TCP端口113上监听ident请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/HnlHkh82fRKut68j__thumbnail.png"
                      alt="图片"
                ></p>
<p>ident在公共因特网上并不能很好地工作，原因包括：</p>
<pre><code>1. 很多客户端PC没有运行ident识别协议守护进程软件；
2. ident协议会使HTTP事务处理产生严重的时延；
3. 很多防火墙不允许ident流量进入；
4. ident协议不安全，容易被伪造；
5. ident协议不支持虚拟IP地址；
6. 暴露客户端的用户名涉及隐私问题。</code></pre>
<p>告知ApacheWeb服务器通过<strong>IdentityCheck  on</strong>指令使用ident查找功能。如果没有ident信息，用连字符（-）来填充ident日志字段。由于通常没有ident信息，在使用通用日志格式的日志文件中，第二个字段通常都是连字符。</p>
<h2 id="5-5-2-第二步——接收请求报文"><a href="#5-5-2-第二步——接收请求报文" class="headerlink" title="5.5.2 第二步——接收请求报文"></a>5.5.2 第二步——接收请求报文</h2><p>连接上有数据到达时，Web服务器会从网络连接中读取数据，并将请求报文中的内容解析出来。</p>
<p>解析请求报文时，Web服务器操作：</p>
<pre><code>1. 解析请求行，查找请求方法、指定的资源标识符（URI）以及版本号，各项之间由一个空格分隔，并以CRLF作为行的结束；
2. 读取以CRLF结尾的报文首部；
3. 检测到以CRLF结尾的、标识首部结束的空行（如果有的话）；
4. 如果有的话（长度由Content-Length首部指定），读取请求主体。</code></pre>
<p>解析请求报文时，Web服务器会不定期地从网络上接收输入数据。网络连接可能出现延迟，所以将部分报文数据临时存储在内存中，直到收到足以进行解析的数据并理解其意义为止。</p>
<h3 id="5-5-2-1-报文的内部表示法"><a href="#5-5-2-1-报文的内部表示法" class="headerlink" title="5.5.2.1 报文的内部表示法"></a>5.5.2.1 报文的内部表示法</h3><p>有些Web服务器会用，便于进行报文操作的内部数据结构来存储请求报文。比如，数据结构中可能包含有指向请求报文中各个片段的指针及其长度，将这些首部存放在一个快速查询表中，以便快速访问特定首部的具体值了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/6J2aJFF37Qfi51H7__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="5-5-2-2-连接的输入-输出处理结构"><a href="#5-5-2-2-连接的输入-输出处理结构" class="headerlink" title="5.5.2.2 连接的输入/输出处理结构"></a>5.5.2.2 连接的输入/输出处理结构</h3><p>高性能的Web服务器能够同时支持数千条连接。连接可能在快速地或者慢速向Web服务器发送请求甚至空闲着。因为请求可能会在任意时刻到达，所以Web服务器会不停地观察有无新的Web请求。不同的Web服务器结构会以不同的方式为请求服务。</p>
<ol>
<li>单线程Web服务器（参见a）</li>
</ol>
<p>一次只处理一个请求，直到完成为止。这种结构易于实现，但所有其他连接都会被忽略。这样会造成严重的性能问题，只适用于低负荷的服务器，以及type-o-serve这样的诊断工具。</p>
<ol start="2">
<li>多进程及多线程Web服务器（参见b）</li>
</ol>
<p>用多个进程，或更高效的线程同时对请求进行处理。可以根据需要或预先创建线程/进程。有些服务器会为每条连接分配一个线程/进程，但当同时处理过多连接时，会消耗太多的内存或系统资源，因此通常都会对线程/进程的最大数量进行限制。</p>
<ol start="3">
<li>复用I/O的服务器（参见c）</li>
</ol>
<p>在复用结构中，同时监视所有连接上的活动。当连接的状态发生变化时（有数据可用，或出现错误时），就对那条连接进行少量的处理；处理结束之后，将连接返回到开放连接列表中，等待下一次状态变化。</p>
<ol start="4">
<li>复用的多线程Web服务器（参见d）</li>
</ol>
<p>多个线程中的每一个都在观察打开的连接，并对每条连接执行少量的任务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/2mA4SsoOK7nSD7FP__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="5-5-3-第三步——处理请求"><a href="#5-5-3-第三步——处理请求" class="headerlink" title="5.5.3 第三步——处理请求"></a>5.5.3 第三步——处理请求</h2><p>一旦Web服务器收到了请求，就可以根据方法、资源、首部和可选的主体部分来对请求进行处理了。比如POST要求请求报文中必须带有实体主体部分的数据；比如OPTIONS允许有也可以没有请求的主体部分。比如GET禁止在请求报文中包含实体的主体数据。</p>
<h2 id="5-5-4-第四步——对资源的映射及访问"><a href="#5-5-4-第四步——对资源的映射及访问" class="headerlink" title="5.5.4 第四步——对资源的映射及访问"></a>5.5.4 第四步——对资源的映射及访问</h2><p>Web服务器是资源服务器。它们负责发送预先创建好的内容，比如HTML页面或图片，以及运行在服务器上的资源生成程序所产生的动态内容。将内容传送给客户端之前，要将请求报文中的URI映射为Web服务器上适当的内容或内容生成器，以识别出内容的源头。</p>
<h3 id="5-5-4-1-docroot"><a href="#5-5-4-1-docroot" class="headerlink" title="5.5.4.1 docroot"></a>5.5.4.1 docroot</h3><p>Web服务器支持各种不同类型的资源映射，最简单的形式就是用请求URI作为名字来访问Web服务器文件系统中的文件。通常，Web服务器的文件系统中会有特殊的文件夹专门用于存放Web内容。这个文件夹被称为文档的根目录（documentroot或docroot）。Web服务器从请求报文中获取URI，并将其附加在文档根目录的后面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/YjRu2XQ3AOUZMPxL__thumbnail.png"
                      alt="图片"
                ></p>
<p>在配置文件httpd.conf中添加<strong>DocumentRoot行</strong>为Apache Web服务器设置文档的根目录：DocumentRoot/usr/local/httpd/files</p>
<p>服务器不能让相对URL退到docroot之外，将文件系统的其余部分暴露出来。</p>
<h4 id="5-5-4-1-1-虚拟托管的docroot"><a href="#5-5-4-1-1-虚拟托管的docroot" class="headerlink" title="5.5.4.1.1 虚拟托管的docroot"></a>5.5.4.1.1 虚拟托管的docroot</h4><p>虚拟托管的Web服务器会在同一台Web服务器上提供多个Web站点，每个站点都有自己独有的文档根目录。虚拟托管Web服务器会根据URI或Host首部的IP地址或主机名来识别要使用的正确文档根目录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/h2lrUmLfCt6WWhJe__thumbnail.png"
                      alt="图片"
                ></p>
<p>对ApacheWeb服务器来说，为每个虛拟Web站点配置一个VirtualHost块，每个虚拟服务器都要包含DocumentRoot。</p>
<h4 id="5-5-4-1-2-用户的主目录docroot"><a href="#5-5-4-1-2-用户的主目录docroot" class="headerlink" title="5.5.4.1.2 用户的主目录docroot"></a>5.5.4.1.2 用户的主目录docroot</h4><p>Docroot的另一种常见应用是在Web服务器上为人们提供私有的Web站点。通常把以斜杠和波浪号（/~）开始，后面跟着用户名的URI映射为此用户的私有文档根目录。私有docroot通常是用户主目录下那个名为public_html 的目录，也可将其配置为其他值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mzxmQqltivIgO2q9__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="5-5-4-2-目录列表"><a href="#5-5-4-2-目录列表" class="headerlink" title="5.5.4.2 目录列表"></a>5.5.4.2 目录列表</h3><p>Web服务器可以接收对目录URL的请求，其路径可以解析为一个目录，而不是文件。对大多数Web服务器对目录URL的请求采取不同的动作：</p>
<ol>
<li>返回一个错误。</li>
<li>不返回目录，返回一个特殊的默认‘索引文件”。多数Web服务器会去查找目录中名为index.html或index.htm的文件来代表此目录，并返回这个文件的内容。在Apache Web服务器上，可以用配置指令<strong>DirectoryIndex</strong>配置要作为默认目录文件使用的文件名集合，指令按照优先顺序列出所有可以作为目录索引文件使用的文件名。</li>
</ol>
<p>例如：    DirectoryIndex  index.html  index.htm  home.html  home.htm  index.cgi</p>
<ol>
<li>扫描目录，返回一个包含目录内容的HTML页面。如果用户请求目录URI时，没有提供默认的索引文件，且没有禁止使用目录索引，很多Web服务器都会自动返回一个HTML文件，文件中会列出目录里的文件名和每个文件的大小和修改日期，还包括到每个文件的URI链接。</li>
</ol>
<p>可以通过以下Apache指令禁止自动生成目录索引文件：Options-Indexes</p>
<h3 id="5-5-4-3-动态内容资源的映射"><a href="#5-5-4-3-动态内容资源的映射" class="headerlink" title="5.5.4.3 动态内容资源的映射"></a>5.5.4.3 动态内容资源的映射</h3><p>Web服务器可以将URI映射为动态资源，也就是映射到按需动态生成内容的程序上。多数Web服务器都提供了一些机制以识别和映射动态资源，能够分辨资源什么时候是动态的，动态内容生成程序位于何处，以及如何运行那个程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QX5bpDmH8lbf0JpV__thumbnail.png"
                      alt="图片"
                ></p>
<p>Apache允许用户将URI路径名组件映射为可执行文件目录，服务器会试着去执行目录中的程序。</p>
<p>Apache允许用户用一个特殊的文件扩展名来标识可执行文件。这种方式就可以将可执行脚本放在任意目录中了。e.g.  AddHandler cgi-script.cgi （执行所有以.cgi结尾的Web资源）。</p>
<h3 id="5-5-4-4-服务器端包含项"><a href="#5-5-4-4-服务器端包含项" class="headerlink" title="5.5.4.4 服务器端包含项"></a>5.5.4.4 服务器端包含项</h3><p>很多Web服务器提供了对<strong>服务器端包含项</strong>（SSI）的支持，这是创建动态内容的一种方式。如果资源被标识为存在服务器端包含项，服务器就会发送前对资源内容进行扫描，以查找特定的模板（可以是变量名或嵌入式脚本）。可以用变量的值或可执行脚本的输出来取代特定的模板。</p>
<h3 id="5-5-4-5-访问控制"><a href="#5-5-4-5-访问控制" class="headerlink" title="5.5.4.5 访问控制"></a>5.5.4.5 访问控制</h3><p>Web服务器还可以为特定资源进行访问控制。Web服务器可以根据客户端的IP地址进行访问控制，也可以要求输入密码来访问资源。</p>
<h2 id="5-5-5-第五步——构建响应"><a href="#5-5-5-第五步——构建响应" class="headerlink" title="5.5.5 第五步——构建响应"></a>5.5.5 第五步——构建响应</h2><p>Web服务器识别出了资源，就执行请求方法中描述的动作，并返回响应报文，包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体。</p>
<h3 id="5-5-5-1-响应实体"><a href="#5-5-5-1-响应实体" class="headerlink" title="5.5.5.1 响应实体"></a>5.5.5.1 响应实体</h3><p>如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。如果有响应主体的话，响应报文中通常包括：</p>
<ol>
<li>描述响应主体MIME类型的Content-Type首部；</li>
<li>描述响应主体长度的Content-Length首部；</li>
<li>实际报文的主体内容。<h3 id="5-5-5-2-MIME类型"><a href="#5-5-5-2-MIME类型" class="headerlink" title="5.5.5.2 MIME类型"></a>5.5.5.2 MIME类型</h3></li>
</ol>
<p>Web服务器要确定响应主体的MIME类型。</p>
<ol>
<li><strong>MIME 类型</strong>（mime.types）</li>
</ol>
<p>Web服务器可用文件的扩展名来说明MIME类型。Web服务器会为每个资源扫描一个包含了所有扩展名的MIME类型的文件，以确定其MIME类型。这种最常见。</p>
<ol start="2">
<li><strong>魔法分类</strong>（Magic typing）</li>
</ol>
<p>ApacheWeb服务器可以扫描每个资源的内容，并将其与一个已知模式表（魔法文件）进行匹配，以决定每个文件的MIME类型。适用于文件没有标准扩展名的时候。</p>
<ol start="3">
<li><strong>显式分类</strong>（Explicit typing）</li>
</ol>
<p>可对Web服务器进行配置，不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型。</p>
<ol start="4">
<li><strong>类型协商</strong></li>
</ol>
<p>有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式（及相关的MIME类型）“最好”。</p>
<p>还可以通过配置Web服务器，将特定的文件与MIME类型相关联。</p>
<h3 id="5-5-5-3-重定向"><a href="#5-5-5-3-重定向" class="headerlink" title="5.5.5.3 重定向"></a>5.5.5.3 重定向</h3><p>Web服务器有时会返回重定向响应而不是成功的报文，将浏览器重定向到其他地方来执行请求。Location响应首部包含了内容的新地址或优选地址的URI。重定向可用于下列情况：</p>
<ol>
<li><strong>永久删除的资源</strong></li>
</ol>
<p>资源被移动到了新的位置，或被重新命名，有了新的URL。Web服务器可以告诉客户端资源已经被重命名了，让其可以在从新地址获取资源之前，更新书签之类的信息。状态码301 Moved Permanently就用于此类重定向。</p>
<ol start="2">
<li><strong>临时删除的资源</strong></li>
</ol>
<p>如果资源被临时移走或重命名了，服务器将客户端重定向到新的位置上去。由于重命名是临时的，所以服务器希望客户端不必对书签进行更新。状态码303 See Other以及状态码307 Temporary Redirect用于此类重定向。</p>
<ol start="3">
<li><strong>URL增强</strong></li>
</ol>
<p>服务器通常用重定向来重写URL，常用于嵌入上下文。服务器会生成一个新的包含了嵌入式状态信息的URL，并将用户重定向到这个新的URL上。客户端会跟随这个重定向信息，重新发起请求。状态码303 See Other和307 Temporary Redirect用于此类重定向。</p>
<ol start="4">
<li><strong>负载均衡</strong></li>
</ol>
<p>如果一个超载的服务器收到一条请求，可以将客户端重定向到一个负载不重的服务器上去。状态码303 See Other和307 Temporary Redirect可用于此类重定向。</p>
<ol start="5">
<li><strong>服务器关联</strong></li>
</ol>
<p>Web服务器上可能有某些用户的本地信息，可以将客户端重定向到包含了那个客户端信息的服务器上去。状态码303 See Other和307 Temporary Redirect可用于此类重定向。</p>
<ol start="6">
<li><strong>规范目录名称</strong></li>
</ol>
<p>客户端请求的URI是一个不带尾部斜线的目录名时，多数Web服务器都会将客户端重定向到一个加了斜线的URI上，这样相对链接就可以正常工作。</p>
<h2 id="5-5-6-第六步——发送响应"><a href="#5-5-6-第六步——发送响应" class="headerlink" title="5.5.6 第六步——发送响应"></a>5.5.6 第六步——发送响应</h2><p>服务器可能有很多条到各个客户端的连接，有空闲的，有向服务器发送数据，还有正在向客户端回送响应数据。</p>
<p>服务器要记录连接的状态，<strong>对非持久连接而言</strong>，服务器应该在发送了整条报文之后，关闭自己这一端的连接；<strong>对持久连接来说</strong>，连接可能仍保持打开状态，服务器要正确地计算Content-Length首部，客户端才会知道响应什么时候结束。</p>
<h2 id="5-5-7-第七步——记录日志"><a href="#5-5-7-第七步——记录日志" class="headerlink" title="5.5.7 第七步——记录日志"></a>5.5.7 第七步——记录日志</h2><p>最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务。大多数Web服务器都提供了几种日志配置格式。更多细节请参见第21章。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>05-Web服务器</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
