<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>03-HTTP报文</title>
    <url>/2021/01/23/note/HTTP/03-HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h1 id="3-1-报文流"><a href="#3-1-报文流" class="headerlink" title="3.1 报文流"></a><strong>3.1 报文流</strong></h1><p><strong>HTTP报文</strong>是在HTTP应用程序之间发送的数据块，这些数据块以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。</p>
<p>HTTP使用术语<strong>流入</strong>（inbound）和<strong>流出</strong>（outbound）来描述<strong>事务处理</strong>（transaction）的方向。报文流人源端服务器，工作完成之后，会流回用户的Agent代理中。</p>
<p>不管是请求报文还是响应报文，所有报文都会向下游（downstream）流动（参见下图）。所有报文的发送者都在接收者的上游（upstream）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/cERK8fMXNtSgncHM.png"
                      alt="图片"
                ></p>
<h1 id="3-2-报文的组成部分"><a href="#3-2-报文的组成部分" class="headerlink" title="3.2 报文的组成部分"></a><strong>3.2 报文的组成部分</strong></h1><p>HTTP报文由三个部分组成：<strong>起始行</strong>（start line）、<strong>首部</strong>（header）、<strong>主体</strong>（body）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/P7vBtkoxgAKyyS5X.png"
                      alt="图片"
                ></p>
<p><strong>起始行</strong>：所有的HTTP报文都以一个起始行作为开始。请求报文的起始行（请求行）说明了要做些什么。响应报文的起始行（响应行）说明发生了什么。</p>
<p><strong>首部：</strong>首部字段向请求/响应报文中添加一些附加信息。本质上来说，它们只是一些名/值对的列表。</p>
<p><strong>主体：</strong>是一个可选的数据块。与起始行和首部不同的是，主体中可以包含文本或二进制数据，也可以为空。</p>
<p><strong>注意：</strong>起始行和首部就是由行分隔的ASCII文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符和一个换行符。这个行终止序列可以写做<strong>CRLF</strong>。尽管HTTP规范中说明应该用CRLF来表示行终止，但稳健的应用程序也应该接受单个换行符作为行的终止。有些老的，或不完整的HTTP应用程序并不总是既发送回车符，又发送换行符。</p>
<p>一组HTTP首部总是应该以一个空行（单个CRLF）结束，甚至即使没有首部和实体的主体部分也应如此。但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误地）省略了最后的CRLF。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个CRLF的报文。</p>
<h1 id="3-3-报文的语法"><a href="#3-3-报文的语法" class="headerlink" title="3.3 报文的语法"></a><strong>3.3 报文的语法</strong></h1><p>所有的HTTP报文都可以分为两类：<strong>请求报文</strong>（request message）和<strong>响应报文</strong>（response message）。请求报文会向Web服务器请求一个动作。响应报文会将请求的结果返回给客户端。</p>
<p><strong>请求报文的格式：</strong></p>
<p>&lt;method&gt;   &lt;request-URL&gt;   &lt;version&gt;</p>
<p>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<p><strong>响应报文的格式</strong>（注意，只有起始行的语法有所不同）：</p>
<p>&lt;version&gt;   &lt;status&gt;   &lt;reason-phrase&gt;</p>
<p>&lt;headers&gt;</p>
<p>&lt;entity-body&gt;</p>
<table>
<thead>
<tr>
<th align="center">方法（method）</th>
<th align="left">客户端希望服务器对资源执行的动作。比如GET、HEAD或POST。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/JVU6YJ5CStQ6fuwP.png"
                      alt="图片"
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求URL（request-URL）</td>
<td align="left">命名了所请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题一一服务器可以假定自已是URL的主机/端口。</td>
</tr>
<tr>
<td align="center">版本（version）</td>
<td align="left">报文所使用的HTTP版本，其格式看起来是这样的：HTTP/&lt;major&gt;.&lt;minor&gt;&lt;br&gt;其中主要版本号（major）和次要版本号（minor）都是整数。</td>
</tr>
<tr>
<td align="center">状态码（status-code）</td>
<td align="left">这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/cBAdbLFKVflDpijz.png"
                      alt="图片"
                ></td>
</tr>
<tr>
<td align="center">原因短语（reason-phrase）</td>
<td align="left">是状态码的文本解释，包含行终止序列之前的所有文本。原因短语只对人类有意义，因此比如，尽管响应行HTTP/1.0 200 NOT OK和HTTP/1.0 200 OK中原因短语的含义不同，但都被当作成功指示处理。首部类别有<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ikG9ABzA6A0jtwzf.png"
                      alt="图片"
                ></td>
</tr>
<tr>
<td align="center">首部（header）</td>
<td align="left">可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（：），然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些HTTP版本，比如HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。</td>
</tr>
<tr>
<td align="center">实体的主体部分（entity-body）</td>
<td align="left">实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时报文只是以一个CRLF结束。</td>
</tr>
</tbody></table>
<h1 id="3-4-方法"><a href="#3-4-方法" class="headerlink" title="3.4 方法"></a>3.4 方法</h1><h2 id="3-4-1-安全方法"><a href="#3-4-1-安全方法" class="headerlink" title="3.4.1 安全方法"></a>3.4.1 安全方法</h2><p>get和head被认为是<strong>安全方法</strong>，使用这个方法的HTTP请求不会产生什么动作，安全方法并不一定什么动作都不执行（这由web开发者决定），安全方法的目的是允许HTTP应用程序开发者通知用户，什么时候会使用某个可能引起某些动作的不安全办法。</p>
<h2 id="3-4-2-GET"><a href="#3-4-2-GET" class="headerlink" title="3.4.2 GET"></a>3.4.2 GET</h2><p>GET是最常用的方法。通常用于请求服务器发送某个资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/vMYdA5h28E8iGYte.png"
                      alt="图片"
                ></p>
<h2 id="3-4-3-HEAD"><a href="#3-4-3-HEAD" class="headerlink" title="3.4.3 HEAD"></a>3.4.3 HEAD</h2><p>HEAD与GET很类似，但服务器<strong>只返回首部</strong>（服务器开发者必须确保HEAD和GET返回的首部相同），不返回主体部分。这就允许客户端在未获取实际资源下，对资源的首部进行检查。比如：</p>
<pre><code>1. 在不获取资源的情况下了解资源的情况（比如，判断其类型）；
2. 通过查看响应中的状态码，看看某个对象是否存在；
3. 通过查看首部，测试资源是否被修改了。</code></pre>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Com8LDRU94LnZRGT.png"
                      alt="图片"
                ></p>
<h2 id="3-4-4-PUT"><a href="#3-4-4-PUT" class="headerlink" title="3.4.4 PUT"></a>3.4.4 PUT</h2><p>与GET从服务器读取文档相反，PUT方法会向服务器写入文档，让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，如果那个URL已经存在的话，就用这个主体来替代它。</p>
<p>因为PUT允许用户对内容进行修改，所以很多Web服务器都要求在执行PUT之前，用密码登录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/x85Mw4z8E5dy9VE8.png"
                      alt="图片"
                ></p>
<h2 id="3-4-5-POST"><a href="#3-4-5-POST" class="headerlink" title="3.4.5 POST"></a>3.4.5 POST</h2><p>POST方法起初是用来向服务器输入数据的。通常用于HTML的表单,表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mA1PogAoYtDt18l2.png"
                      alt="图片"
                ></p>
<h2 id="3-4-6-TRACE"><a href="#3-4-6-TRACE" class="headerlink" title="3.4.6 TRACE"></a>3.4.6 TRACE</h2><p>客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p>
<p>TRACE请求会在目的服务器端发起一一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改过。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/gaypKsmoMOkPfmZx.png"
                      alt="图片"
                ></p>
<p>TRACE方法主要用于诊断：用于验证请求是否如愿穿过了请求/响应链，也可以用来查看代理和其他应用程序对用户请求所产生效果。</p>
<p>缺点在于，它假定中间应用程序对各种不同类型请求的处理是相同的。很多HTTP应用程序会根据方法的不同做出不同的处理。比如，代理可能会将POST请求直接发送给服务器，而将GET请求发送给另一个HTTP应用程序（比如Web缓存）。TRACE并不提供区分这些方法的机制。通常，中间应用程序会自行决定对TRACE请求的处理方式。</p>
<p>TRACE请求中不能带有实体的主体部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。</p>
<h2 id="3-4-7-OPTIONS"><a href="#3-4-7-OPTIONS" class="headerlink" title="3.4.7 OPTIONS"></a>3.4.7 OPTIONS</h2><p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法，不用实际访问资源就能判定访问各种资源。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/pxQXtSaXDHxS2MDN.png"
                      alt="图片"
                ></p>
<h2 id="3-4-8-DELETE"><a href="#3-4-8-DELETE" class="headerlink" title="3.4.8 DELETE"></a>3.4.8 DELETE</h2><p>DELETE方法使服务器删除请求URL所指定的资源。但客户端应用程序无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/rR3ReKiKi4Jtrp49.png"
                      alt="图片"
                ></p>
<h2 id="3-4-9-扩展方法"><a href="#3-4-9-扩展方法" class="headerlink" title="3.4.9 扩展方法"></a>3.4.9 扩展方法</h2><p>HTTP被设计成字段可扩展的，这样新的特性不会使老的软件失效。<strong>扩展方法</strong>指的就是没有在HTTP/1.1规范中定义的方法。服务器会为它所管理的资源实现一些HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。这些方法是WebDAV HTTP扩展包含的所有方法，这些方法有助于通过HTTP将Web内容发布到Web服务器上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mpgIfTZw1n97EtyM.png"
                      alt="图片"
                ></p>
<p>不是所有的扩展方法都是在正式规范中定义的。如果你定义了一个扩展方法，很可能大部分HTTP应用程序都无法理解。同样，你的HTTP应用程序也可能会遇到一些其他应用程序在用，但并不理解的扩展方法。</p>
<p>如果能够在不破坏端到端行为的情况下，将带有未知方法的报文传递给下游服务器的话，代理会尝试传递这些报文。否则，它们会以501 Not Implemented（无法实现）状态码进行响应。</p>
<h1 id="3-5-状态码"><a href="#3-5-状态码" class="headerlink" title="3.5 状态码"></a>3.5 状态码</h1><h2 id="3-5-1-100-199——信息性状态码"><a href="#3-5-1-100-199——信息性状态码" class="headerlink" title="3.5.1 100~199——信息性状态码"></a>3.5.1 100~199——信息性状态码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/OBMDQjDvnWkV8qEA.png"
                      alt="图片"
                ></p>
<p>100 Continue状态码的目的是对这样的情况进行优化：HTTP客户端应用程序有一个实体的主体部分要发送给服务器，但希望在发送之前查看服务器是否会接受这个实体。</p>
<h2 id="3-5-2-客户端与100-Continue"><a href="#3-5-2-客户端与100-Continue" class="headerlink" title="3.5.2 客户端与100 Continue"></a>3.5.2 客户端与100 Continue</h2><p>如果客户端在向服务器发送一个实体之前，需要发送值为100 Continue的Expect请求首部</p>
<p>客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时，才应该使用100 Continue。有些出错的HTTP应用程序会不合时宜地发送这些代码。</p>
<h2 id="3-5-3-服务端与100-Continue"><a href="#3-5-3-服务端与100-Continue" class="headerlink" title="3.5.3 服务端与100 Continue"></a>3.5.3 服务端与100 Continue</h2><p>如果服务器收到了带有值为100Continue的Expect首部的请求，它会用100Continue响应或错误码来进行响应。</p>
<p>如果服务器在发送100Continue响应之前就收到了部分（或全部）的实体，说明客户端已经决定继续发送数据了，服务器就不需要发送这个状态码了。但服务器读完请求之后，还是应该为请求发送一个最终状态码（它可以跳过100 Continue状态）。</p>
<h2 id="3-5-4-代理与100-Continue"><a href="#3-5-4-代理与100-Continue" class="headerlink" title="3.5.4 代理与100 Continue"></a>3.5.4 代理与100 Continue</h2><p>如果代理从客户端收到了一条带有100 Continue期望的请求。只有在代理明确知道下一跳服务器只能与HTTP/1.1之前的版本兼容下，才以417Expectation Failed错误进行响应。</p>
<h2 id="3-5-5-200-299——成功状态码"><a href="#3-5-5-200-299——成功状态码" class="headerlink" title="3.5.5 200~299——成功状态码"></a>3.5.5 200~299——成功状态码</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QBPeIRliYQsYNLuK.png"
                      alt="图片"
                ></p>
<h2 id="3-5-6-300-399——重定向状态码"><a href="#3-5-6-300-399——重定向状态码" class="headerlink" title="3.5.6 300~399——重定向状态码"></a>3.5.6 300~399——重定向状态码</h2><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应。</p>
<p>当客户端发起一个POST请求，并收到302重定向状态码时，它会接受Location首部的重定向URL，并向那个URL发起一个GET请求（而不会像原始请求中那样发起POST请求）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/oGhhDOehHAx00rMn.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/XF0C2S71UASlrXHQ.png"
                      alt="图片"
                ></p>
<h2 id="3-5-7-400-499客户端错误状态码"><a href="#3-5-7-400-499客户端错误状态码" class="headerlink" title="3.5.7 400 ~ 499客户端错误状态码"></a>3.5.7 400 ~ 499客户端错误状态码</h2><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SuFepcMWJ5V5SOwN.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ExnzaZcMsofo4KWN.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/sxIk4IJaPzMS7Ne4.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/rm9ffFKOAEKrqtAt.png"
                      alt="图片"
                ></p>
<h2 id="3-5-8-500-599服务器错误状态码"><a href="#3-5-8-500-599服务器错误状态码" class="headerlink" title="3.5.8 500 ~ 599服务器错误状态码"></a>3.5.8 500 ~ 599服务器错误状态码</h2><p>客户端碰上了服务器的缺陷，或服务器上的子元素，比如某个网关资源出错。代理与服务器进行交流时，经常会出现问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DUHKLkEagQ3ZDgjR.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/VJNKGRtGQtYaylvE.png"
                      alt="图片"
                ></p>
<h1 id="3-6-首部"><a href="#3-6-首部" class="headerlink" title="3.6 首部"></a>3.6 首部</h1><h2 id="3-6-1-通用首部"><a href="#3-6-1-通用首部" class="headerlink" title="3.6.1 通用首部"></a>3.6.1 通用首部</h2><p>这些是客户端和服务器都可以使用的通用首部。</p>
<h3 id="3-6-1-1-通用的信息性首部"><a href="#3-6-1-1-通用的信息性首部" class="headerlink" title="3.6.1.1 通用的信息性首部"></a>3.6.1.1 通用的信息性首部</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/V734hBj5Y6U1RI57.png"
                      alt="图片"
                ></p>
<h3 id="3-6-1-2-通用缓存首部"><a href="#3-6-1-2-通用缓存首部" class="headerlink" title="3.6.1.2 通用缓存首部"></a>3.6.1.2 通用缓存首部</h3><p>通用的缓存首部说明了如何或什么时候进行缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/T71nzrW361shYFJ5.png"
                      alt="图片"
                ></p>
<h2 id="3-6-2-请求首部"><a href="#3-6-2-请求首部" class="headerlink" title="3.6.2 请求首部"></a>3.6.2 请求首部</h2><h3 id="3-6-2-1-请求的信息性首部"><a href="#3-6-2-1-请求的信息性首部" class="headerlink" title="3.6.2.1 请求的信息性首部"></a>3.6.2.1 请求的信息性首部</h3><p>请求首部是请求报文特有的。它们为服务器提供了一些额外信息，服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/KPMKowkYZnhblPBY.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-2-Accept首部"><a href="#3-6-2-2-Accept首部" class="headerlink" title="3.6.2.2 Accept首部"></a>3.6.2.2 Accept首部</h3><p>Accept首部为客户端告知服务器，它们想要什么，可以使用什么以及最重要的，它们不想要什么。服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QudS2T1wJAKUiu3E.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-3-条件请求首部"><a href="#3-6-2-3-条件请求首部" class="headerlink" title="3.6.2.3 条件请求首部"></a>3.6.2.3 条件请求首部</h3><p>客户端希望为请求加上某些限制。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/kARldOx2NxiRp3Yl.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-4-安全请求首部"><a href="#3-6-2-4-安全请求首部" class="headerlink" title="3.6.2.4 安全请求首部"></a>3.6.2.4 安全请求首部</h3><p>HTTP本身支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务更安全。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/qhEP6oHR0Zg4fdkz.png"
                      alt="图片"
                ></p>
<h3 id="3-6-2-5-代理请求首部"><a href="#3-6-2-5-代理请求首部" class="headerlink" title="3.6.2.5 代理请求首部"></a>3.6.2.5 代理请求首部</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/lo4882tb0k3K2GqB.png"
                      alt="图片"
                ></p>
<h2 id="3-6-3-响应首部"><a href="#3-6-3-响应首部" class="headerlink" title="3.6.3 响应首部"></a>3.6.3 响应首部</h2><p>响应报文有自己的首部集，以便为客户端提供信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/FJfB5VYZPrChGkOf.png"
                      alt="图片"
                ></p>
<h3 id="3-6-3-1-协商首部"><a href="#3-6-3-1-协商首部" class="headerlink" title="3.6.3.1 协商首部"></a>3.6.3.1 协商首部</h3><p>如果资源有多种表示方法，可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/dPebT46CLDYXaQdJ.png"
                      alt="图片"
                ></p>
<h3 id="3-6-3-2-安全响应首部"><a href="#3-6-3-2-安全响应首部" class="headerlink" title="3.6.3.2 安全响应首部"></a>3.6.3.2 安全响应首部</h3><p>安全请求首部就是HTTP的质询/响应认证机制的响应侧。这里指的是质询首部。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DBM3vYt6qfYjHjQs.png"
                      alt="图片"
                ></p>
<h2 id="3-6-4-实体首部"><a href="#3-6-4-实体首部" class="headerlink" title="3.6.4 实体首部"></a>3.6.4 实体首部</h2><h3 id="3-6-4-1-实体的信息性首部"><a href="#3-6-4-1-实体的信息性首部" class="headerlink" title="3.6.4.1 实体的信息性首部"></a>3.6.4.1 实体的信息性首部</h3><p>实体首部指的是实体主体部分的首部，可以告知报文的接收者它在对什么进行处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/aAXJrr32FXIPhq3H.png"
                      alt="图片"
                ></p>
<h3 id="3-6-4-2-内容首部"><a href="#3-6-4-2-内容首部" class="headerlink" title="3.6.4.2 内容首部"></a>3.6.4.2 内容首部</h3><p>内容首部提供与实体内容有关的特定信息，说明了其类型、尺寸以及处理所需的有用信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/bXPOXXEC81SN4OHC.png"
                      alt="图片"
                ></p>
<h3 id="3-6-4-3-实体缓存首部"><a href="#3-6-4-3-实体缓存首部" class="headerlink" title="3.6.4.3 实体缓存首部"></a>3.6.4.3 实体缓存首部</h3><p>实体的缓存首部提供了与被缓存实体有关的信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/8xWGuWX0sDXFv2m4.png"
                      alt="图片"
                ></p>
<h2 id="3-6-5-扩展首部"><a href="#3-6-5-扩展首部" class="headerlink" title="3.6.5 扩展首部"></a>3.6.5 扩展首部</h2><p>扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP规范中去。即使不知道这些扩展首部的含义，HTTP程序也要接受它们并对其进行转发。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>03-HTTP报文</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>02-URL与资源</title>
    <url>/2021/01/22/note/HTTP/02-URL%E4%B8%8E%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h2 id="2-1-URL语法"><a href="#2-1-URL语法" class="headerlink" title="2.1 URL语法"></a><strong>2.1 URL语法</strong></h2><p><strong>URI</strong>：统一资源标识符（Uniform Resource Identifier）,它包括了URL（统一资源定位符），它是通过描述资源位置来标识资源，以及URN（统一资源名），它则是通过名字来识别资源。</p>
<table>
    <tr>
    <th>组件</th>
    <th>描述</th>
    <th>默认值</th>
  </tr>
  <tr>
    <td>方案</td>
    <td>用什么协议获取资源，大小写无关，比如http</td>
    <td>无</td>
  </tr>
  <tr>
    <td>用户</td>
    <td>某些方案下访问资源时需要的用户名，比如FTP</td>
    <td>匿名</td>
  </tr>
  <tr>
    <td>密码</td>
    <td>用户名后面可能包含的密码，由冒号（：）分隔</td>
    <td>E-mail地址</td>
  </tr>
  <tr>
    <td>主机</td>
    <td>服务器位置，也就是资源在哪里，可以是域名（会被解析）或IP地址</td>
    <td>无</td>
  </tr>
  <tr>
    <td>端口</td>
    <td>资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80）</td>
    <td>方案特有</td>
  </tr>
  <tr>
    <td>路径</td>
    <td>资源路径，服务器上的本地资源名，由斜杠（/）分隔</td>
    <td>无</td>
  </tr>
  <tr>
    <td>参数</td>
    <td>某些方案会用这个组件来指定输入参数。参数为名/值对。可以包含多个参数字段，它们相互之间以及与路径其余部分用分号（；）分隔</td>
    <td>无</td>
  </tr>
  <tr>
    <td>查询</td>
    <td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用“？”将其与其余部分分隔开来。按照常规，查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&”分隔：</td>
    <td>无</td>
  </tr>
  <tr>
    <td>片段</td>
    <td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td>
    <td>无</td>
  </tr>
</table>

<h2 id="2-2-URL快捷方式"><a href="#2-2-URL快捷方式" class="headerlink" title="2.2 URL快捷方式"></a><strong>2.2 URL快捷方式</strong></h2><p><strong>URL</strong>有两种方式，<strong>绝对URL</strong>（包含访问资源所需的全部信息）以及<strong>相对URL</strong>（不完整，需要对基础URL进行解析）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/nVR0IK7EBcmYWYVR.png"
                      alt="图片"
                ></p>
<p>基础URL是作为相对URL的参考点使用的。来自以下几个地方：</p>
<p><strong>1、在资源中显示提供</strong></p>
<p>有些资源会显式地指定基础URL。比如，HTML文档中可能会包含一个定义了基础URL的HTML标记&#60;BASE&#62;，通过它来转换那个HTML文档中的所有相对URL。</p>
<p><strong>2、封装资源的基础URL</strong></p>
<p>如果在一个没有显式指定基础URL的资源中发现了一个相对URL，可以将它所属资源的URL作为基础。</p>
<p><strong>3、没有基础URL</strong></p>
<p>在某些情况下，没有基础URL，通常意味着你有一个相对URL；但有可能只是一个不完整或损坏了的URL。</p>
<p>要把相对URL转换成绝对URL，首先将他们划分成组件段，这一步称为<strong>分解URL，</strong>接下来的过程如下，<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/V4KlexQcZcfQ12Rf.png"
                      alt="图片"
                ></p>
<p><strong>自动扩展URL：</strong>用户不需要输入完整的URL，浏览器自动扩展。有两种方式：</p>
<p>1、<strong>主机名扩展</strong></p>
<p>在主机名扩展中，只要有些小提示，浏览器通常就可以在没有帮助的情况下，将你输入的主机名扩展为完整的主机名。但是，这些主机名扩展技巧可能会为其他一些HTTP应用程序带来问题，比如代理。</p>
<p><strong>2、历史扩展</strong></p>
<p>浏览器用来节省用户输入URL时间的另一种技巧是，将以前用户访问过的URL历史存储起来。当你输入URL时，它们就可以将你输入的URL与历史记录中URL的前缀进行匹配，并提供–些完整的选项供你选择。注意，与代理共同使用时，URL自动扩展的行为可能会有所不同。6.5.6节将对此进行进-一步讨论。</p>
<h2 id="2-3-URL字符"><a href="#2-3-URL字符" class="headerlink" title="2.3 URL字符"></a><strong>2.3 URL字符</strong></h2><p>URL的特性是<strong>可移植的（portable）</strong>、<strong>可读的</strong>、<strong>完整的</strong>，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符值或数据进行编码，这样就实现了可移植性和完整性。这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数。示例如下,</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/TbL6jXX4SEtdJlWZ.png"
                      alt="图片"
                ></p>
<p><strong>字符限制</strong>，在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCI可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用。</p>
<p>URL的每个组件都会有自己的安全和不安全字符（与方案有关），因此只有从用户那里接收URL的应用程序才能够判断需要对哪些字符进行编码。这个URL就是可在各应用程序之间共享的规范形式；也就无需操心其他应用程序会被字符的任何特殊含义所迷惑了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/bnXzZF9va3GSkGou.png"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>02-URL与资源</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>07-缓存</title>
    <url>/2021/01/23/note/HTTP/07-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Web缓存是可以自动保存常见文档副本的HTTP设备。优点如下：</p>
<ol>
<li><strong>减少冗余的数据传输，节省网络费用。</strong></li>
<li><strong>缓解网络瓶颈问题。</strong>很多网络为本地网络客户端提供的带宽比远程服务器提供的带宽要宽。</li>
<li><strong>降低对原始服务器的要求。</strong>服务器可以更快地响应，避免过载的出现。</li>
<li><strong>减少距离时延</strong>。<h2 id="7-1-命中和未命中的"><a href="#7-1-命中和未命中的" class="headerlink" title="7.1 命中和未命中的"></a>7.1 命中和未命中的</h2></li>
</ol>
<p><strong>缓存命中</strong>（cache hit）：已有的副本为某些到达缓存的请求提供服务。</p>
<p><strong>缓存未命中</strong>（cache miss）：到达缓存的请求由于没有副本可用，被转发给原始服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/JqEmbyfnLqujDvh3__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="7-1-1-再验证"><a href="#7-1-1-再验证" class="headerlink" title="7.1.1 再验证"></a>7.1.1 再验证</h3><p><strong>HTTP再验证</strong>（revalidation）：原始服务器的内容可能会发生变化，缓存要对其进行检测，查看保存的副本是否仍是服务器上最新的副本。</p>
<p>大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。常用的<strong>If-Modified-since</strong>首部来对已缓存对象进行再验证。将其添加到GET请求中去，服务器就会只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。</p>
<p>服务器收到GET If-Modified-Since请求时会发生的情况：</p>
<ol>
<li><strong>再验证命中</strong>（revalidate hit）或<strong>缓慢命中</strong>（slow hit）：缓存对副本进行再验证时，会向原始服务器发送再验证请求。如果内容没有变化，服务器会以304 NotModified进行响应，只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端。这种方式比缓存命中要慢，但比缓存未命中快，因为它没有从服务器中获取对象数据。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/cY8dGPCXn8wtoLKV__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="2">
<li><strong>再验证未命中</strong></li>
</ol>
<p>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/yIucryfnFQtd0k4c__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="3">
<li><strong>对象被删除</strong></li>
</ol>
<p>如果服务器对象已经被删除了，服务器就回送404 Not Found响应，缓存也会将其副本删除。</p>
<h3 id="7-1-2-命中率"><a href="#7-1-2-命中率" class="headerlink" title="7.1.2 命中率"></a>7.1.2 命中率</h3><p><strong>缓存命中率</strong>（cache hit rate，或<strong>缓存命中比例</strong>），或<strong>文档命中率</strong>（document hit rate）：由缓存提供服务的请求所占的比例被称为。</p>
<p>实际的命中率与缓存的大小、缓存用户兴趣点的相似性、缓存数据的变化或个性化频率，以及如何配置缓存有关。对中等规模的Web缓存来说，40%的命中率是合理的。</p>
<h3 id="7-1-3-字节命中率"><a href="#7-1-3-字节命中率" class="headerlink" title="7.1.3 字节命中率"></a>7.1.3 字节命中率</h3><p><strong>字节命中率</strong>（byte hit rate）：缓存提供的字节在传输的所有字节中所占的比例。通过这种度量方式，可以得知节省流量的程度。</p>
<p>文档命中率说明阻止了多少通往外部网络的Web事务。事务有一一个通常都很大的固定时间成分，提高文档命中率利于降低整体时延。</p>
<p>字节命中率说明阻止了多少字节传向因特网。提高字节命中率利于节省带宽。</p>
<h3 id="7-1-4-区分命中和未命中的情况"><a href="#7-1-4-区分命中和未命中的情况" class="headerlink" title="7.1.4 区分命中和未命中的情况"></a>7.1.4 区分命中和未命中的情况</h3><p>缓存命中和访问原始服务器得到的响应，响应码都是200 OK，说明响应有主体部分。区分方法：</p>
<ol>
<li>有些商业代理缓存会在Via首部附加一些额外信息，以描述缓存中发生的情况。</li>
<li>客户端使用Date首部。将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，就可以认为这是一条缓存的响应。</li>
<li>客户端通过Age首部可以分辨出这条响应的使用期。<h2 id="7-2-缓存的拓扑结构"><a href="#7-2-缓存的拓扑结构" class="headerlink" title="7.2 缓存的拓扑结构"></a>7.2 缓存的拓扑结构</h2></li>
</ol>
<p><strong>私有缓存</strong>（private cache）：个人的缓存，包含了单个用户最常用的页面。</p>
<p><strong>公有缓存</strong>（public cache）：共享的缓存，包含了某个用户团体的常用页面。</p>
<h3 id="7-2-1-私有缓存"><a href="#7-2-1-私有缓存" class="headerlink" title="7.2.1 私有缓存"></a>7.2.1 私有缓存</h3><p>私有缓存不需要很大的动力或存储空间，这样就可以将其做的很小，很便宜。多数浏览器都会将常用文档缓存在你个人电脑的磁盘和内存中，并且允许用户去配置缓存的大小和各种设置，还可以去看看浏览器的缓存中有些什么内容。</p>
<h3 id="7-2-2-公有缓存"><a href="#7-2-2-公有缓存" class="headerlink" title="7.2.2 公有缓存"></a>7.2.2 公有缓存</h3><p>公有缓存是特殊的共享代理服务器，被称为<strong>缓存代理服务器</strong>（caching proxy server）或者<strong>代理缓存</strong>（proxy cache）。代理缓存可以通过指定手工代理，或者通过代理自动配置文件，将浏览器配置为使用代理缓存，还可以在不配置浏览器的情况下，通过使用拦截代理，强制HTTP请求经过缓存传输。</p>
<h3 id="7-2-3-代理缓存的层次结构"><a href="#7-2-3-代理缓存的层次结构" class="headerlink" title="7.2.3 代理缓存的层次结构"></a>7.2.3 代理缓存的层次结构</h3><h4 id="7-2-3-1-层次化缓存结构"><a href="#7-2-3-1-层次化缓存结构" class="headerlink" title="7.2.3.1 层次化缓存结构"></a>7.2.3.1 层次化缓存结构</h4><p>较小缓存中未命中的请求会被导向较大的<strong>父缓存</strong>（parent cache），由它来为剩下的那些流量提供服务。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Co7dnjntrFDvuHrm__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="7-2-3-2-网状缓存结构"><a href="#7-2-3-2-网状缓存结构" class="headerlink" title="7.2.3.2 网状缓存结构"></a>7.2.3.2 网状缓存结构</h4><p>网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为<strong>内容路由器</strong>（content router）。</p>
<p>网状缓存中为内容路由设计的缓存要完成的功能：</p>
<ol>
<li>根据URL在父缓存或原始服务器之间进行动态选择。</li>
<li>根据URL动态地选择一个特定的父缓存。</li>
<li>前往父缓存之前，在本地缓存中搜索已缓存的副本。</li>
<li>允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。</li>
</ol>
<p>缓存之间更为复杂的关系允许不同的组织互为对等（peer）实体，将它们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存（sibling cache）。HTTP并不支持兄弟缓存，所以通过一些协议对HTTP进行了扩展，比如<strong>因特网缓存协议</strong>（Internet Cache Protocol，ICP）和<strong>超文本缓存协议</strong>（HyperText Caching Protocol，HTCP）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/iKZZ0KjuHsCngdjY__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="7-3-缓存的处理步骤"><a href="#7-3-缓存的处理步骤" class="headerlink" title="7.3 缓存的处理步骤"></a>7.3 缓存的处理步骤</h2><p>对一条HTTP GET报文的基本缓存处理过程包括7个步骤。</p>
<ol>
<li>接收——缓存从网络中读取抵达的请求报文。</li>
<li>解析——缓存对报文进行解析，提取出URL和各种首部。</li>
<li>查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本并将其保存在本地。专业级的缓存会使用快速算法来确定本地缓存中是否有某个对象。已缓存对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。已缓存对象中还包含了一些元数据（metadata）。</li>
<li>新鲜度检测——缓存查看已缓存副本是否新鲜，如果不是，就询问服务器是否有任何更新。</li>
<li>创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。缓存负责对这些首部进行改造，以便与客户端的要求相匹配。缓存会插入新鲜度信息（Cache-Control、Age以及Expires首部），通常会包含一个Via首部。缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对象的日期。.</li>
<li>发送——缓存通过网络将响应发回给客户端。</li>
<li>日志——缓存可选地创建一个日志文件条目来描述这个事务。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/sPL9fez6Q5GM0Kew__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="7-4-保持副本的新鲜"><a href="#7-4-保持副本的新鲜" class="headerlink" title="7.4 保持副本的新鲜"></a>7.4 保持副本的新鲜</h2><p>HTTP有一些机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些机制称为<strong>文档过期</strong>（document expiration）和<strong>服务器再验证</strong>（server revalidation）。</p>
<h3 id="7-4-1-文档过期"><a href="#7-4-1-文档过期" class="headerlink" title="7.4.1 文档过期"></a>7.4.1 文档过期</h3><p>通过HTTP Cache-Control和Expires首部，让原始服务器向每个文档附加了一个“过期日期”，这些首部说明了在多长时间内可以将这些内容视为新鲜的。</p>
<p>在过期之前，缓存可以任意使用这些副本，无需与服务器联系，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。</p>
<p>一旦文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜（带有新的过期日期）的副本。</p>
<p>很多发布者都不会使用很长的过期日期。而且，很多发布者甚至都不使用过期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mvA0UnLjL6rYmQLQ__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="7-4-2-服务器再验证"><a href="#7-4-2-服务器再验证" class="headerlink" title="7.4.2 服务器再验证"></a>7.4.2 服务器再验证</h3><p>缓存并不一定要为每条请求验证文档的有效性，只有在文档过期时才需要与服务器进行再验证。缓存文档过期了并不一定和原始服务器上的文档有实际的区别：只是意味着到了要进行核对的时间。这种情况被称为“<strong>服务器再验证</strong>”，说明缓存需要询问原始服务器文档是否发生了变化。</p>
<ol>
<li>如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。</li>
<li>如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新。</li>
</ol>
<p>缓存返回的内容有以下几种情况：</p>
<ol>
<li>“足够新鲜”的已缓存副本；</li>
<li>与服务器进行过再验证，确认其仍然新鲜的已缓存副本；</li>
<li>如果需要与之进行再验证的原始服务器出故障了，就返回一条错误报文；</li>
<li>附有警告信息说明内容可能不正确的已缓存副本。<h3 id="7-4-3-用条件方法进行再验证"><a href="#7-4-3-用条件方法进行再验证" class="headerlink" title="7.4.3 用条件方法进行再验证"></a>7.4.3 用条件方法进行再验证</h3></li>
</ol>
<p>缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。对缓存再验证来说最有用是<strong>If-Modi fied-Since</strong>和<strong>If-None-Match</strong>首部<strong>。</strong></p>
<h4 id="7-4-3-1-If-Modified-Since-Date再验证"><a href="#7-4-3-1-If-Modified-Since-Date再验证" class="headerlink" title="7.4.3.1 If-Modified-Since:Date再验证"></a>7.4.3.1 If-Modified-Since:Date再验证</h4><p>If-Modified-since再验证请求通常被称为<strong>IMS请求</strong>。只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求：</p>
<ol>
<li>如果自指定日期后，文档被修改了，通常GET就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。</li>
<li>如果自指定日期后，文档没被修改过，会向客户端返回一个小的304 Not Modified响应报文，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。一般会发送一个新的过期日期。</li>
</ol>
<p>If-Modified-Since首部可以与Last-Modified服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行再验证时，就会包含一个If-Modified-Since首部，其中携带有最后修改已缓存副本的日期：</p>
<p>If-Modified-Since：&lt;cached last-modified date&gt;</p>
<p>如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送新的文档。否则，最后修改日期相符，会返回一个304 Not Modified响应。</p>
<h4 id="7-4-3-2-If-None-Match：实体标签再验证"><a href="#7-4-3-2-If-None-Match：实体标签再验证" class="headerlink" title="7.4.3.2 If-None-Match：实体标签再验证"></a>7.4.3.2 If-None-Match：实体标签再验证</h4><p>有些情况下仅使用最后修改日期进行再验证是不够的。比如：</p>
<ol>
<li>有些文档被周期性地重写，但数据是一样的。即便内容没有变化，但修改日期会发生变化。</li>
<li>有些文档被修改了，但所做修改并不重要，不需要让缓存都重装数据。</li>
<li>有些服务器无法准确地判定其页面的最后修改日期。</li>
<li>有些服务器提供的文档会在亚秒间隙发生变化（比如实时监视器），以一秒为粒度的修改日期就不够用。</li>
</ol>
<p>因此HTTP允许用户对被称为<strong>实体标签</strong>（ETag）的“版本标识符”进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。</p>
<p>当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。如果服务器上的实体标签已经发生了变化，服务器会在一个200 OK响应中返回新的内容以及相应的新Etag.</p>
<p>可以在If-None-Match首部包含几个实体标签，告诉服务器，带有这些实体标签的对象副本在缓存上都有。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/erfxAVVZ74Xb8xhr__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="7-4-4-强弱验证器"><a href="#7-4-4-强弱验证器" class="headerlink" title="7.4.4 强弱验证器"></a>7.4.4 强弱验证器</h3><p>实体标签和最近修改日期都是<strong>缓存验证器</strong>（cache validator）。有时，服务器希望在对文档进行不重要的修改时，不使所有的已缓存副本都失效。HTTP/1.1 支持“<strong>弱验证器</strong>”，如果只对内容进行了少量修改，就允许服务器声明那是“足够好”的等价体。</p>
<p>有些操作不能用弱验证器来实现（比如有条件地获取部分内容），所以服务器用前缀“WI”来标识弱验证器。ETag: W/“v2.6”    If- None-Match: W/ “v2.6”</p>
<p>原始服务器不能为两个不同的实体重用一个强实体标签值，或为两个语义不同的实体重用一个弱实体标签值。</p>
<h2 id="7-5-控制缓存的能力"><a href="#7-5-控制缓存的能力" class="headerlink" title="7.5 控制缓存的能力"></a>7.5 控制缓存的能力</h2><p>服务器可以指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序：</p>
<ol>
<li>附加<strong>Cache-Control：no-store</strong>首部到响应中，禁止缓存对响应进行复制，缓存通常会向客户端转发一条no-store响应，然后删除对象。</li>
<li>附加<strong>Cache-Control：no-cache</strong>首部到响应中。可以存储在本地缓存区，只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。</li>
<li>附加<strong>Cache-Control：must-revalidate</strong>首部到响应中。缓存可以通过配置，提供一些过期的对象，以提高性能，因此通过Cache-Control：must-revalidate首部让缓存严格遵守过期信息，在没有进行再验证的情况下，不能提供这个对象的陈旧副本。如果缓存在进行must-revalidate新鲜度检查时，服务器不可用，缓存就返回一条504 Gateway Timeout错误。</li>
<li>附加<strong>Cache-Control：max-age</strong>首部到响应中。还有一个s-maxage首部仅适用公有缓存。</li>
<li>附加<strong>Expires</strong>日期首部到响应中。不推荐使用Expires首部，因为服务器的时钟可能不同步，或不正确。其中Expires:0响应首部，试图将文档置于永远过期的状态，但这种语法是非法的，可能给某些软件带来问题。</li>
<li>不附加过期信息，让缓存确定自己的过期日期。<h3 id="7-5-1-试探性过期"><a href="#7-5-1-试探性过期" class="headerlink" title="7.5.1 试探性过期"></a>7.5.1 试探性过期</h3></li>
</ol>
<p>缓存通过算法计算出一个试探性最大使用期。但如果最大使用期大于24小时，就向响应首部添加Heuristic Expiration Warning（试探性过期警告，警告13）首部，但很少有浏览器提供。</p>
<p>如果文档中包含了最后修改日期，就可以使用LM-Factor算法，通过计算缓存与服务器对话的时间跟服务器声明文档最后被修改的时间之间的差值，取这个间隔时间的一部分，将其作为缓存中的新鲜度持续时间。通常会为试探性新鲜周期设置上限，一般设置为一周。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/bT1QqO3hyhVyT1Rm__thumbnail.png"
                      alt="图片"
                ></p>
<p>如果最后修改日期也没有，缓存通常会为文档分配一个默认的新鲜周期（通常是一个小时或一天）。</p>
<h3 id="7-5-2-客户端的新鲜度限制"><a href="#7-5-2-客户端的新鲜度限制" class="headerlink" title="7.5.2 客户端的新鲜度限制"></a>7.5.2 客户端的新鲜度限制</h3><p>Web浏览器都有Refresh（刷新）或Reload（重载）按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。</p>
<p>Refresh按钮会发布附加了Cache-Control请求首部的GET请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。Refresh 的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。客户端可以用Cache-Control请求首部来强化或放松对过期时间的限制。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/c66vSOYHG3viCCN0__thumbnail.png"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>07-缓存</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>11-客户端识别与cookie机制</title>
    <url>/2021/01/23/note/HTTP/11-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%86%E5%88%AB%E4%B8%8Ecookie%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="11-1-个性化接触"><a href="#11-1-个性化接触" class="headerlink" title="11.1 个性化接触"></a>11.1 个性化接触</h2><p>现代的Web站点希望能够提供个性化的接触，希望对连接另一端的用户有更多的了解，并且能在用户浏览页面时对其进行跟踪。用户的识别机制：</p>
<ol>
<li><strong>HTTP首部</strong>，承载了用户身份信息。</li>
<li><strong>客户端IP地址跟踪</strong>，通过用户的IP地址对其进行识别。</li>
<li><strong>用户登录</strong>，用认证方式来识别用户。</li>
<li><strong>胖URL</strong>，在URL中嵌人识别信息的技术。</li>
<li><strong>cookie</strong>，持久身份识别技术。<h2 id="11-2-HTTP首部"><a href="#11-2-HTTP首部" class="headerlink" title="11.2 HTTP首部"></a>11.2 HTTP首部</h2></li>
</ol>
<p>七种常见的用来承载用户相关信息的HTTP请求首部，后四个首部用于更高级的识别技术。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/OGLHbPyUzYspa9X1__thumbnail.png"
                      alt="图片"
                ></p>
<p>由于有些服务器会搜集E-mail地址，用于垃圾邮件的散发，所以很少有浏览器会发送From首部。实际上，From首部是由自动化的机器人或蜘蛛发送的。</p>
<p>User-Agent首部包括浏览器的名称和版本，操作系统的相关信息。用于实现定制内容与特定的浏览器及其属性间的良好互操作，但并没有为识别特定的用户提供太多帮助。</p>
<p>Referer首部提供了用户来源页面的URL。Referer首部自身并不能完全标识用户，但它说明了用户之前访问过哪个页面。通过它可以更好地理解用户的浏览行为，以及用户的兴趣所在。</p>
<p>From、User-Agent和Referer首部都不足以实现可靠的识别。</p>
<h2 id="11-3-客户端IP地址"><a href="#11-3-客户端IP地址" class="headerlink" title="11.3 客户端IP地址"></a>11.3 客户端IP地址</h2><p>通常HTTP首部并不提供客户端的IP地址（有些代理会舔加Client-IP首部），但Web服务器可以找到承载HTTP请求的TCP连接另一端的IP地址。</p>
<p>使用客户端IP地址来识别用户存在着很多缺点，限制了将其作为用户识别技术的效能：</p>
<ol>
<li>客户端IP地址描述的是所用的机器，而不是用户。如果多个用户共享同一台计算机，就无法对其进行区分。</li>
<li>很多因特网服务提供商都会在用户登录时为其动态分配IP地址。用户每次登录时，都会得到一个不同的地址。</li>
<li>为了提高安全性，并对稀缺的地址资源进行管理，很多用户通过<strong>网络地址转换</strong>（Network Address Translation，NAT）防火墙来浏览网络内容的。NAT设备将了防火墙后面的实际客户端的IP地址转换成了一个共享的防火墙IP地址（和不同的端口号）。</li>
<li>HTTP代理和网关通常会打开一些新的到原始服务器的TCP连接。Web服务器看到的将是代理服务器的IP地址，而不是客户端的。但个别代理会添加特殊的Client-IP或x-Forwarded-For扩展首部来保存原始的IP地址。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/UtHMnCSRoPNvPQj9__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="11-4-用户登录"><a href="#11-4-用户登录" class="headerlink" title="11.4 用户登录"></a>11.4 用户登录</h2><p>Web服务器可以要求用户通过用户名和密码进行认证（登录）来显式地询问用户是谁。HTTP中包含了一种内建机制，可以用WWW-Authenticate首部和Authorization首部向Web站点传送用户的相关信息。</p>
<p>如果服务器希望在为用户提供对站点的访问之前登录，可以向浏览器回送一条HTTP响应代码401 Login Required，然后浏览器显示一个登录对话框，一旦登录，浏览器就可以不断地在每条发往这个站点的请求甚至没有要求中，向服务器发送Authorization首部作为一种身份的标识。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/UtY4a0FC6TRmjhdo__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="11-5-胖URL"><a href="#11-5-胖URL" class="headerlink" title="11.5 胖URL"></a>11.5 胖URL</h2><p>有些Web站点会为每个用户生成特定版本的URL来追踪用户的身份。通常对真正的URL路径开始或结束的地方添加一些状态信息。用户浏览站点时，Web服务器会动态生成一些超链，继续维护URL中的状态信息。改动后包含了用户状态信息的URL被称为胖URL（fat URL）。</p>
<p>但这种技术存在几个很严重的问题：</p>
<ol>
<li><strong>丑陋的URL</strong>。浏览器中显示的胖URL会给新用户带来困扰。</li>
<li><strong>无法共享URL。</strong>胖URL中包含了与特定用户和会话有关的状态信息。如果将其发送给其他人，可能就在无意中将你积累的个人信息都共享出去了。</li>
<li><strong>破坏缓存</strong>。为每个URL生成用户特有的版本意味着不再有可供公共访问的URL需要缓存。</li>
<li><strong>额外的服务器负荷</strong>。服务器需要重写HTML页面使URL变胖。</li>
<li><strong>逃逸口</strong>。用户跳转到其他站点或者请求一个特定的URL时，就很容易在无意中“逃离”胖URL会话。只有当用户严格地追随预先修改过的链接时，胖URL才能工作。如果用户逃离此链接，就会丢失其进展信息，重新开始。</li>
<li><strong>在会话间是非持久的</strong>。除非用户收藏了特定的胖URL，否则用户退出登录时，所有的信息都会丢失。<h2 id="11-6-cookie"><a href="#11-6-cookie" class="headerlink" title="11.6 cookie"></a>11.6 cookie</h2></li>
</ol>
<p>cookie是当前识别用户，实现持久会话的最好方式。它们定义了一些新的HTTP首部。cookie的存在也影响了缓存，大多数缓存和浏览器都不允许对任何cookie的内容进行缓存。</p>
<h3 id="11-6-1-cookie的类型"><a href="#11-6-1-cookie的类型" class="headerlink" title="11.6.1 cookie的类型"></a>11.6.1 cookie的类型</h3><p>cookie可以笼统地分为两类：<strong>会话cookie</strong>和<strong>持久cookie</strong>。</p>
<p>会话cookie是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话cookie就被删除。如果设置了Discard参数，或者没有设置Expires或Max-Age参数来说明扩展的过期时间，这个cookie就是一个 会话cookie.</p>
<p>持久cookie的生存时间更长，它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie维护某个用户会周期性访问的站点的配置文件或登录名。</p>
<h3 id="11-6-2-cookie是如何工作的"><a href="#11-6-2-cookie是如何工作的" class="headerlink" title="11.6.2 cookie是如何工作的"></a>11.6.2 cookie是如何工作的</h3><p>用户首次访问Web站点时，Web服务器给这个用户“拍上”一个独有的cookie，这样以后就可以识别出这个用户。cookie中包含了一个由（name=value）这样的信息构成的任意列表。</p>
<p>cookie并不仅限于ID号，很多Web服务器会将信息直接保存在cookie中，并通过set-cookie或set-cookie2 HTTP响应（扩展）首部将其贴到用户身上去。浏览器会记住从服务器返回的cookie内容，并将cookie集存储在浏览器的cookie数据库中。将来用户返回同一站点时，浏览器会挑中那个服务器贴到用户上的那些cookie，并在一个cookie请求首部中将其传回去。</p>
<h3 id="11-6-3-cookie罐：客户端的状态"><a href="#11-6-3-cookie罐：客户端的状态" class="headerlink" title="11.6.3 cookie罐：客户端的状态"></a>11.6.3 cookie罐：客户端的状态</h3><p>因为浏览器负责存储cookie信息，所以系统被称为<strong>客户端侧状态</strong>（client-sidestate）。cookie规范的正式名称为<strong>HTTP状态管理机制</strong>（HTTP state management mechanism）。不同的浏览器会以不同的方式来存储cookie。</p>
<h3 id="11-6-4-不同站点使用不同的cookie"><a href="#11-6-4-不同站点使用不同的cookie" class="headerlink" title="11.6.4 不同站点使用不同的cookie"></a>11.6.4 不同站点使用不同的cookie</h3><p>浏览器内部的cookie罐中可以有很多cookie，但浏览器通常只向每个站点发送2 ~ 3个cookie，浏览器只向服务器发送服务器产生的那些cookie。原因如下：</p>
<ol>
<li>对所有cookie字节进行传输会严重降低性能。浏览器实际传输的cookie字节数要比实际的内容字节数多；</li>
<li>cookie中包含的是服务器特有的名值对，所以对大部分站点来说，大多数cookie都只是无法识别的无用数据；</li>
<li>将所有的cookie发送给所有站点会引发潜在的隐私问题。<h3 id="11-6-5-cookie成分"><a href="#11-6-5-cookie成分" class="headerlink" title="11.6.5 cookie成分"></a>11.6.5 cookie成分</h3></li>
</ol>
<p>现在使用的cookie规范有两个不同的版本：<strong>cookies版本0</strong>（也叫Netscape cookies）和<strong>cookies版本1</strong>（RFC 2965）。cookies 版本1是对cookies版本0的扩展，应用不如后者广泛。</p>
<p>cookie规范版本0和版本1都不是作为HTTP/1.1规范的一部分提供的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Jq2YLdpVHtY6PfRA__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="11-6-6-cookies版本0（Netscape）"><a href="#11-6-6-cookies版本0（Netscape）" class="headerlink" title="11.6.6 cookies版本0（Netscape）"></a>11.6.6 cookies版本0（Netscape）</h3><p>最初的cookie规范是由网景公司定义的。这些“版本0”的cookie定义了Set-Coookie响应首部、cookie请求首部以及用于控制cookie的字段。</p>
<h4 id="11-6-6-1-版本0的set-Cookie首部"><a href="#11-6-6-1-版本0的set-Cookie首部" class="headerlink" title="11.6.6.1 版本0的set-Cookie首部"></a>11.6.6.1 版本0的set-Cookie首部</h4><p>set-Cookie首部有一个强制性的cookie名和cookie 值。后面跟着可选的cookie属性，中间由分号分隔。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/qdonImiSjvneeOvw__thumbnail.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/GBdOJLwCMpYc0S2p__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="11-6-6-2-版本0的Cookie首部"><a href="#11-6-6-2-版本0的Cookie首部" class="headerlink" title="11.6.6.2 版本0的Cookie首部"></a>11.6.6.2 版本0的Cookie首部</h4><p>客户端发送请求时，会将所有与域、路径和安全过滤器相匹配的未过期cookie都发送给这个站点。所有cookie都被组合到一个Cookie首部中。</p>
<h3 id="11-6-7-cookies版本1（RFC-2965）"><a href="#11-6-7-cookies版本1（RFC-2965）" class="headerlink" title="11.6.7 cookies版本1（RFC 2965）"></a>11.6.7 cookies版本1（RFC 2965）</h3><p>这个版本1标准引入了Set-Cookie2首部和Cookie2首部，但也能与版本0系统进行互操作。</p>
<p>RFC 2965 cookie的主要改动包括下列内容：</p>
<ol>
<li>为每个cookie关联上解释性文本，对其目的进行解释。</li>
<li>允许在浏览器退出时，不考虑过期时间，将cookie强制销毁。</li>
<li>用相对秒数，而不是绝对日期来表示cookie的Max-Age.</li>
<li>通过URL端口号，而不仅仅是域和路径来控制cookie的能力。</li>
<li>通过Cookie首部回送域、端口和路径过滤器（如果有的话）。</li>
<li>为实现互操作性使用的版本号。</li>
<li>在Cookie首部从名字中区分出附加关键字的$前缀。<h4 id="11-6-7-1-版本1的set-Cookie2首部"><a href="#11-6-7-1-版本1的set-Cookie2首部" class="headerlink" title="11.6.7.1 版本1的set-Cookie2首部"></a>11.6.7.1 版本1的set-Cookie2首部</h4></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/5a2SbBmAsu83S7yy__thumbnail.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mtVJtcN1kr8hhsQp__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="11-6-7-2-版本1的Cookie首部"><a href="#11-6-7-2-版本1的Cookie首部" class="headerlink" title="11.6.7.2 版本1的Cookie首部"></a>11.6.7.2 版本1的Cookie首部</h4><p>版本1的cookie会带回与传送的每个cookie相关的附加信息，用来描述每个cookie途径的过滤器。每个匹配的cookie都必须包含来自相应set-cookie2首部的所有Domain、Port 或Path属性。所有匹配cookie都是和它们的Set-Cookie2过滤器一同传输的，而且保留关键字都是以美元符号（$）开头的。</p>
<h4 id="11-6-7-3-版本1的Cookie2首部和版本协商"><a href="#11-6-7-3-版本1的Cookie2首部和版本协商" class="headerlink" title="11.6.7.3 版本1的Cookie2首部和版本协商"></a>11.6.7.3 版本1的Cookie2首部和版本协商</h4><p>Cookie2请求首部负责在能够理解不同cookie规范版本的客户端和服务器之间进行互操作性的协商。</p>
<p>如果服务器理解新形式的cookie，就能够识别出Cookie2首部，并在响应首部发送set-Cookie2（而不是Set-Cookie）。如果客户端从同一个响应中获得set-Cookie和Set-Cookie2首部，忽略Set-Cookie首部。</p>
<p>如果客户端既支持版本0又支持版本1的cookie，但从服务器获得的是版本0的Set-Cookie首部，就应该带着版本0的Cookie首部发送cookie。但客户端还应该发送Cookie2：$Version=“1”来告知服务器它是可以升级的。</p>
<h3 id="11-6-8-cookie与会话跟踪"><a href="#11-6-8-cookie与会话跟踪" class="headerlink" title="11.6.8 cookie与会话跟踪"></a>11.6.8 cookie与会话跟踪</h3><p>可以用cookie在用户与某个站点进行多项事务处理时对用户进行跟踪，启动一个事务链，在这些事务中Web服务器会通过一系列的重定向、URL重写以及cookie设置来附加标识信息。</p>
<h3 id="11-6-9-cookie与缓存"><a href="#11-6-9-cookie与缓存" class="headerlink" title="11.6.9 cookie与缓存"></a>11.6.9 cookie与缓存</h3><p>缓存与cookie事务有关的文档时需要注意，cookie和缓存的规则并没有很好地建立起来。下 面是处理缓存时的一些指导性规则：</p>
<ol>
<li><strong>标示无法缓存的文档</strong></li>
</ol>
<p>如果除了Set-Cookie首部之外文档是可缓存的，就使用Cache-Control：no-cache=”Set-Cookie”，或者为可缓存文档使用Cache-Control：public，这样利于节省Web中的带宽。</p>
<ol start="2">
<li><strong>缓存Set-Cookie首部</strong></li>
</ol>
<p>如果向多个用户发送了相同的Set-Cookie首部，可能会破坏用户的定位。</p>
<p>有些缓存在将响应缓存起来之前会删除set-Cookie首部，但这样由缓存提供服务的客户端就不会有cookie了。强制缓存与原始服务器重新验证每条请求，并将返回的所有Set-Cookie首部都合并到客户端的响应中去，就可以解决。原始服务器可以通过向缓存的副本中添加这个首部来要求进行这种再验证：Cache-Control：must-revalidate，max-age=0</p>
<p>即便内容实际上是可以缓存的，一些缓存可能也会拒绝缓存所有包含Set-Cookie首部的响应。有些缓存允许使用缓存Set-Cookie图片，但不缓存文本的模式。</p>
<ol start="3">
<li><strong>处理带有Cookie首部的请求</strong></li>
</ol>
<p>带有Cookie首部的请求到达时，就在提示我们，得到的结果可能是私有的。一定要将私有内容标识为不可缓存的，但有些服务器可能会犯错，没有将此内容标记为不可缓存的。</p>
<p>有些响应文档对应于携带Cookie首部的请求，一些缓存可能会不去缓存。有些缓存允许使用缓存cookie图片，而不缓存文本的模式。更广泛接受的方案是缓存带有Cookie首部的图片，将过期时间设置为零，强制每次都进行再验证。</p>
<h3 id="11-6-10-cookie-安全性和隐私"><a href="#11-6-10-cookie-安全性和隐私" class="headerlink" title="11.6.10 cookie.安全性和隐私"></a>11.6.10 cookie.安全性和隐私</h3><p>第三方Web站点使用持久cookie来跟踪用户就是一种最大的滥用。将这种做法与IP地址和Referer首部信息结合在一起，营销公司就可以构建起相当精确的用户档案和浏览模式信息。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>11-客户端识别与cookie机制</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>08-集成点：网关、隧道及中继</title>
    <url>/2021/01/23/note/HTTP/08-%E9%9B%86%E6%88%90%E7%82%B9%EF%BC%9A%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93%E5%8F%8A%E4%B8%AD%E7%BB%A7/</url>
    <content><![CDATA[<h2 id="8-1-网关"><a href="#8-1-网关" class="headerlink" title="8.1 网关"></a>8.1 网关</h2><p>HTTP扩展和接口的发展是由用户需求驱动的。单个应用程序无法处理复杂资源的需求。网关（gateway）抽象出一种能够到达资源的方法，网关是资源和应用程序之间的粘合剂。应用程序可以（通过HTTP或其他已定义的接口）请求网关来处理某条请求，网关可以提供响应。</p>
<p>常见网关类型：服务器协议转换器、服务器端安全网关、客户端安全网关、应用程序服务器。</p>
<h2 id="8-2-协议网关"><a href="#8-2-协议网关" class="headerlink" title="8.2 协议网关"></a>8.2 协议网关</h2><p><strong>客户端和服务器端网关</strong>：Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。用一个斜杠来分隔客户端和服务器端协议，并以此对网关进行描述：&lt;客户端协议&gt;/&lt;服务器端协议&gt;</p>
<p>将HTTP流量导向网关时所使用的方式与将流量导向代理的方式相同。最常见的方式是，显式地配置浏览器使用网关，对流量进行透明的拦截，或者将网关配置为替代者（反向代理）。</p>
<h3 id="8-2-1-HTTP-：服务器端Web网关"><a href="#8-2-1-HTTP-：服务器端Web网关" class="headerlink" title="8.2.1 HTTP/*：服务器端Web网关"></a>8.2.1 HTTP/*：服务器端Web网关</h3><p>请求流入原始服务器时，服务器端Web网关会将客户端HTTP请求转换为其他协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/h5rMSRFnKAI0fo2a__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="8-2-2-HTTP-HTTPS：服务器端安全网关"><a href="#8-2-2-HTTP-HTTPS：服务器端安全网关" class="headerlink" title="8.2.2 HTTP/HTTPS：服务器端安全网关"></a>8.2.2 HTTP/HTTPS：服务器端安全网关</h3><p>可以通过网关对所有的输入Web请求加密，以提供额外的隐私和安全性保护。客户端可以用普通的HTTP浏览Web内容，但网关会自动加密用户的对话。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/XsHGngySl0b7vnU1__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="8-2-3-HTTPS-HTTP客户端安全加速器网关"><a href="#8-2-3-HTTPS-HTTP客户端安全加速器网关" class="headerlink" title="8.2.3 HTTPS/HTTP客户端安全加速器网关"></a>8.2.3 HTTPS/HTTP客户端安全加速器网关</h3><p>HTTPS/HTTP网关位于Web服务器之前，通常作为不可见的拦截网关或反向代理使用。它们接收安全的HTTPS流量，对安全流量进行解密，并向Web服务器发送普通的HTTP请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/wt2ibTUjzYWa44Kf__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="8-3-资源网关"><a href="#8-3-资源网关" class="headerlink" title="8.3 资源网关"></a>8.3 资源网关</h2><p>最常见的网关是<strong>应用程序服务器</strong>，它会将目标服务器与网关结合在一个服务器中实现，它是服务器端网关，与服务器端的应用程序相连，并与客户端通过HTTP进行通信。</p>
<p>客户端通过HTTP连接到应用程序服务器，应用程序服务器将请求通过网关<strong>应用程序编程接口</strong>（Application Programming Interface，API）发送给运行在服务器上的应用程序，然后它向服务器返回响应或响应数据，服务器将其转发给客户端。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SW60nADbd4fHQVhN__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="8-3-1-CGI"><a href="#8-3-1-CGI" class="headerlink" title="8.3.1 CGI"></a>8.3.1 CGI</h3><p>第一个流行的应用程序网关API就是<strong>通用网关接口</strong>（Common Gateway Interface，CGI）。CGI是一个标准接口集，Web服务器可以用它来装载程序以响应对特定URL的HTTP请求，并收集程序的输出数据，将其放在HTTP响应中回送。</p>
<p>CGI的处理对用户来说是不可见的，但可见的是URL中出现字符cgi和可能出现的“？”。</p>
<p>CGI广泛用于动态HTML、信用卡处理、数据库查询等。CGI应用程序是独立于服务器的，所以几乎可以用任意语言来实现。它能很好地保护服务器，防止糟糕的扩展对服务器造成破坏。</p>
<p>但是这种分离会造成性能的耗费。为每条CGI请求引发一个新进程的开销很高，会限制使用CGI的服务器的性能，并且会加重服务端机器资源的负担。</p>
<p>一种新型CGI（快速CGI）解决了这个问题。这个接口模拟了CGI，但它是作为持久守护进程运行的，消除了为每个请求建立或拆除新进程所带来的性能损耗。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/lMjXhzVkWBBSUTH4__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="8-3-2-服务器扩展API"><a href="#8-3-2-服务器扩展API" class="headerlink" title="8.3.2 服务器扩展API"></a>8.3.2 服务器扩展API</h3><p>多数服务器都会为开发者提供一个或多个扩展API，这些扩展通常都会绑定在服务器自身的结构上，为Web开发者提供了强大的接口，以便将自己的模块与HTTP服务器直接相连，它允许程序员将自己的代码嫁接到服务器上，或者用自己的代码将服务器的一个组件完整地替换出来。</p>
<h2 id="8-4-应用程序接口和Web服务"><a href="#8-4-应用程序接口和Web服务" class="headerlink" title="8.4 应用程序接口和Web服务"></a>8.4 应用程序接口和Web服务</h2><p>HTTP可以作为连接应用程序的基础软件来使用，在将应用程序连接起来的过程中，通过web服务标准解决两个应用程序之间进行协议接口的协商，以便应用程序可以进行数据的交换。</p>
<p>Web服务是构建在标准的Web技术（比如HTTP）之上的。Web服务可以用XML通过SOAP来交换信息。XML提供了一种创建数据对象的定制信息，并对其进行解释的方法<strong>SOAP</strong>（Simple Object Access Protocol，简单对象访问协议）是向HTTP报文中添加XML信息的标准方式。</p>
<h2 id="8-5-隧道"><a href="#8-5-隧道" class="headerlink" title="8.5 隧道"></a>8.5 隧道</h2><p>通过<strong>Web 隧道</strong>（Web tunnel）可以通过HTTP应用程序访问使用非HTTP协议的应用程序。使用Web隧道最常见的原因就是要在HTTP连接中嵌入非HTTP流量，这样这类流量就可以穿过只允许Web流量通过的防火墙了。</p>
<h3 id="8-5-1-用CONNECT建立HTTP隧道"><a href="#8-5-1-用CONNECT建立HTTP隧道" class="headerlink" title="8.5.1 用CONNECT建立HTTP隧道"></a>8.5.1 用CONNECT建立HTTP隧道</h3><p>Web隧道是用HTTP的CONNECT方法建立起来的。CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/eW9jkF1kxuU5siZD__thumbnail.png"
                      alt="图片"
                ></p>
<ol>
<li><strong>CONNECT请求</strong></li>
</ol>
<p>除了起始行之外，CONNECT的语法与其他HTTP方法类似。一个后面跟着冒号和端口号的主机名取代了请求URI。主机和端口都必须指定。</p>
<ol start="2">
<li><strong>CONNECT响应</strong></li>
</ol>
<p>发送请求之后，客户端会等待来自网关的响应。响应码200表示成功。通常响应中的原因短语通常被设置为“Conection Established”，这个响应并不需要包含Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。</p>
<h3 id="8-5-2-数据隧道、定时及连接管理"><a href="#8-5-2-数据隧道、定时及连接管理" class="headerlink" title="8.5.2 数据隧道、定时及连接管理"></a>8.5.2 数据隧道、定时及连接管理</h3><p>管道化数据对网关是不透明的，所以网关不能改变分组的顺序和分组流。一旦隧道建立起来了，数据就可以在任意时间流向任意方向了。</p>
<p>客户端可以在发送了CONNECT请求之后，接收响应之前，发送隧道数据，这样可以更快地将数据发送给服务器。但网关必须能够正确处理跟在请求之后的数据，尤其是网关不能假设网络I/O请求只会返回首部数据，网关必须确保在连接准备就绪时，将与首部一同读进来的数据发送给服务器。如果客户端发现回送的响应是认证请求，或其他非200但不致命的错误状态，就必须做好重发请求数据的准备。</p>
<p>如果隧道的任意一个端点断开了连接，那个端点发出的所有未传输数据都会被传送给另一个端点，之后到另一个端点的连接也会被代理终止。如果还有数据要传输给关闭连接的端点，数据会被丢弃。</p>
<h3 id="8-5-3-SSL隧道"><a href="#8-5-3-SSL隧道" class="headerlink" title="8.5.3 SSL隧道"></a>8.5.3 SSL隧道</h3><p>最初Web隧道是为了通过防火墙来传输加密的SSL流量。将所有流量通过分组过滤路由器和代理服务器以隧道方式传输，以提升安全性。但有些协议如加密SSL，其信息是加密的，无法通过传统的代理服务器转发。</p>
<p>HTTP中添加一项隧道特性，可以将原始的加密数据放在HTTP报文中，通过普通的HTTP信道传送。但是，这项特性可能会被滥用，使得恶意协议通过HTTP隧道流入某个组织内部。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SdlL3tBsyFZEL7Vt__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="8-5-4SSL隧道与HTTP-HTTPS网关的对比"><a href="#8-5-4SSL隧道与HTTP-HTTPS网关的对比" class="headerlink" title="8.5.4SSL隧道与HTTP/HTTPS网关的对比"></a>8.5.4SSL隧道与HTTP/HTTPS网关的对比</h3><p>HTTPS协议（SSL上的HTTP）进行网关的操作：由网关（而不是客户端）初始化与远端HTTPS服务器的SSL会话，然后代表客户端执行HTTPS事务。响应会由代理接收并解密，然后通过（不安全的）HTTP传送给客户端。这种方式有几个缺点：</p>
<ol>
<li>客户端到网关之间的连接是普通的非安全HTTP；</li>
<li>虽然代理是已认证主体，但客户端无法对远端服务器执行SSL客户端认证；</li>
<li>网关要支持完整的SSL实现。</li>
</ol>
<p>对于SSL隧道机制来说，无需在代理中实现SSL。SSL 会话是建立在产生请求的客户端和目的（安全的）Web服务器之间的，中间的代理服务器只是将加密数据经过隧道传输，并不会在安全事务中扮演其他的角色。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/cITItirpNAmBAC8F__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="8-5-5-隧道认证"><a href="#8-5-5-隧道认证" class="headerlink" title="8.5.5 隧道认证"></a>8.5.5 隧道认证</h3><p>在适当的情况下，可以将HTTP的其他特性与隧道配合使用。比如将代理的认证支持与隧道配合使用，对客户端使用隧道的权利进行认证。</p>
<h3 id="8-5-6-隧道的安全性考虑"><a href="#8-5-6-隧道的安全性考虑" class="headerlink" title="8.5.6 隧道的安全性考虑"></a>8.5.6 隧道的安全性考虑</h3><p>隧道网关无法验证目前使用的协议是否是它原本打算经过隧道传输的协议。因此一些用户可能会通过本打算用于SSL的隧道，越过公司防火墙传递因特网游戏流量，甚至恶意用户可能会用隧道打开Telnet会话，或用隧道绕过公司的E-mail扫描器来发送E-mail。</p>
<p>为了降低对隧道的滥用，网关应该只为特定的知名端口，如HTTPS的端口443，打开隧道。</p>
<h2 id="8-6-中继"><a href="#8-6-中继" class="headerlink" title="8.6 中继"></a>8.6 中继</h2><p><strong>HTTP中继</strong>（relay）是没有完全遵循HTTP规范的简单HTTP代理，它负责处理HTTP中建立连接的部分，然后对字节进行盲转发。</p>
<p>盲中继不执行任何首部和方法逻辑，有时是很有用的，有时会提供简单的过滤、诊断或内容转换功能。但这种方式可能潜在严重的互操作问题。</p>
<p>某些简单盲中继实现中存在的问题是，由于它们无法正确处理Connection首部，所以有潜在的挂起keep-alive连接的可能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/IULgh1VsZyxKgPpy__thumbnail.png"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>08-集成点：网关、隧道及中继</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>12-基本认证机制</title>
    <url>/2021/01/23/note/HTTP/12-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="12-1-认证"><a href="#12-1-认证" class="headerlink" title="12.1 认证"></a>12.1 认证</h2><p>服务器需要通过某种方式来了解用户身份，从而判定用户可以访问的事务和资源。认证就意味着要证明你是谁。通常是通过提供用户名和密码来进行认证的。</p>
<p>HTTP为认证提供了一种原生工具。尽管可以在HTTP的认证形式和cookie基础之上“运行自己的”认证工具，但在很多情况下，HTTP的原生认证功能就可以很好地满足要求。</p>
<p>最常见的HTTP认证形式，<strong>基本认证</strong>（basic authentication），<strong>摘要认证</strong>（digest authentication）。</p>
<h3 id="12-1-1-认证协议与首部"><a href="#12-1-1-认证协议与首部" class="headerlink" title="12.1.1  认证协议与首部"></a>12.1.1  认证协议与首部</h3><p>HTTP通过一组可定制的控制首部，为不同的认证协议提供了一个可扩展框架。认证协议也是在HTTP认证首部中指定的。可以随意设计一些使用HTTP质询/响应框架的新协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/3I1T0Sqn0vGxXzWp__thumbnail.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/rkRrBdeZ0ZR0sz8V__thumbnail.png"
                      alt="图片"
                ></p>
<p>Web服务器会将受保护的文档组织成一个<strong>安全域</strong>（security realm）。每个安全域都可以有不同的授权用户集，不同的用户对各个安全域的访问权限是不同的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/hOOl1LLNsJNi4Al7__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="12-2-基本认证"><a href="#12-2-基本认证" class="headerlink" title="12.2 基本认证"></a>12.2 基本认证</h2><p>在基本认证中，Web服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。服务器会返回401状态码，而不是200状态码来初始化认证质询，并用WWW-Authent icate响应首部指定要访问的安全域。浏览器收到质询时，会打开一个对话框，请求用户输人这个域的用户名和密码。然后将用户名和密码稍加扰码，再用Authorization请求首部回送给服务器。基本认证协议没有使用Authentication-Info首部。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/qlzDftADKFeS3vHH__thumbnail.png"
                      alt="图片"
                ></h3><h3 id="12-2-1-Base-64用户名-密码编码"><a href="#12-2-1-Base-64用户名-密码编码" class="headerlink" title="12.2.1 Base-64用户名/密码编码"></a>12.2.1 Base-64用户名/密码编码</h3><p>HTTP基本认证将（由冒号分隔的）用户名和密码打包在一起，并用Base 64编码方式对其进行编码。简单来说，Base-64 编码会将一个8位字节序列划分为一些6位的块。用每个6位的块在由64个字符组成的特殊的字母表中选择一个字符，这个字母表中包含了大部分字母和数字。</p>
<h3 id="12-2-2-代理认证"><a href="#12-2-2-代理认证" class="headerlink" title="12.2.2 代理认证"></a>12.2.2 代理认证</h3><p>中间的代理服务器也可以实现认证功能，通过代理服务器提供对某组织内部资源的统一访问控制。代理认证的步骤与Web服务器身份验证的步骤相同，但首部和状态码都有所不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/9TuJb1meuUYlSwAR__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="12-3-基本认证的安全缺陷"><a href="#12-3-基本认证的安全缺陷" class="headerlink" title="12.3 基本认证的安全缺陷"></a>12.3 基本认证的安全缺陷</h2><p>基本认证只能用它来防止非恶意用户无意间进行的访问，或将其与SSL这样的加密技术配合使用。基本认证存在下列安全缺陷：</p>
<ol>
<li>虽然Base-64编码通过隐藏用户名和密码，可以很轻易地通过反向编码过程进行解码。</li>
<li>即使第三方用户可以捕获被修改过的用户名和密码，并将修改过的用户名和密码重放给原始服务器，以获得对服务器的访问权。</li>
<li>很多用户会在这些服务间使用相同的用户名和密码。可能被恶意先捕获明文形式的用户名和密码，然后访问重要的网站。</li>
<li>没有针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，但却修改了报文的其余部分。</li>
<li>假冒服务器很容易骗过基本认证。如果在用户实际连接到一台恶意服务器或网关的时候，攻击者请求用户输入密码，将其存储起来以备未来使用，然后捏造错误信息传送给用户。</li>
</ol>
<p>通常基本认证来提供便捷且不重要的文档个性化服务或访问控制保护，可以防止用户不小心对文档进行访问。更安全的方案是，将基本认证与加密数据传输（比如SSL）配合使用，向恶意用户隐藏用户名和密码，或使用摘要认证。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>12-基本认证机制</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>14-安全HTTP</title>
    <url>/2021/01/23/note/HTTP/14-%E5%AE%89%E5%85%A8HTTP/</url>
    <content><![CDATA[<h2 id="14-1-保护HTTP的安全"><a href="#14-1-保护HTTP的安全" class="headerlink" title="14.1 保护HTTP的安全"></a>14.1 保护HTTP的安全</h2><p>HTTP安全技术能够提供下列功能:</p>
<ol>
<li><strong>服务器认证</strong>（客户端知道它们是在与真正的而不是伪造的服务器通话）。</li>
<li><strong>客户端认证</strong>（服务器知道它们是在与真的而不是伪造的客户端通话）。</li>
<li><strong>完整性</strong>（客户端和服务器的数据不会被修改）。</li>
<li><strong>加密</strong>（客户端和服务器的对话是私密的，无需担心被窃听）。</li>
<li><strong>效率</strong>（一个运行的足够快的算法，以便低端的客户端和服务器使用）。</li>
<li><strong>普适性</strong>（基本上所有的客户端和服务器都支持这些协议）。</li>
<li><strong>管理的可扩展性</strong>（在任何地方的任何人都可以立即进行安全通信）。</li>
<li><strong>适应性</strong>（能够支持当前最知名的安全方法）。</li>
<li><strong>可行性</strong>（满足社会的政治文化需要）。</li>
</ol>
<p><strong>HTTPS</strong>就是最流行的HTTP安全形式。HTTPS方案的URL以https://，而不是http://开头，据此就可以分辨某个Web页面是通过HTTPS还是HTTP访问的。</p>
<p>使用HTTPS时，所有的HTTP请求和响应数据在发送到网络之前，都要进行加密。HTTPS在HTTP下面提供了一个传输级的密码安全层<strong>SSL</strong>，也可以使用传输层安全（Transport Layer Security，<strong>TLS</strong>）。SSL和TLS类似，可以用SSL来表示SSL和TLS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mIJdG4CNy1xhnqon__thumbnail.png"
                      alt="图片"
                ></p>
<p>大部分编码解码工作都在SSL库中完成的，Web客户端和服务器在使用安全HTTP时无需过多地修改其协议处理逻辑。在大多数情况下，只需要用SSL的输入/输出调用取代TCP的调用，再增加几个其他调用来配置和管理安全信息。</p>
<h2 id="14-2-数字加密"><a href="#14-2-数字加密" class="headerlink" title="14.2 数字加密"></a>14.2 数字加密</h2><ol>
<li><strong>密码</strong>，对文本进行编码，使偷窥者无法识别的算法。</li>
<li><strong>密钥</strong>，改变密码行为的数字化参数。</li>
<li><strong>对称密钥加密系统</strong>，编/解码使用相同密钥的算法。</li>
<li><strong>不对称密钥加密系统</strong>，编/解码使用不同密钥的算法。</li>
<li><strong>公开密钥加密系统</strong>，一种能够使数百万计算机便捷地发送机密报文的系统。</li>
<li><strong>数字签名</strong>，用来验证报文未被伪造或篡改的校验和。</li>
<li><strong>数字证书</strong>，由一个可信的组织验证和签发的识别信息。<h3 id="14-2-1-密码"><a href="#14-2-1-密码" class="headerlink" title="14.2.1 密码"></a>14.2.1 密码</h3></li>
</ol>
<p>密码学基于一种名为密码（cipher）的秘密代码。密码是一套编码方案，一种特殊的报文编码方式和一种稍后使用的相应解码方式的结合体。加密之前的原始报文通常被称为<strong>明文</strong>（plaintext 或cleartext）。使用了密码之后的编码报文通常被称作<strong>密文</strong>（ciphertext）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/TKPj2auk0Ick7iCq__thumbnail.png"
                      alt="图片"
                ></p>
<p>起初密码是相当简单的算法。比如字符旋转密码，报文中的每个字符都由字母表中三个位置之后的字符来取代。“A”由“D”来取代，“B”由“E”来取代，以此类推。而密码机可以用复杂得多的密码来快速、精确地对报文进行编解码，使代码的破解更加困难。</p>
<h3 id="14-2-2-使用密钥的密码"><a href="#14-2-2-使用密钥的密码" class="headerlink" title="14.2.2 使用密钥的密码"></a>14.2.2 使用密钥的密码</h3><p>大部分机器上都有一些号盘，可以将其设置为大量不同的值以改变密码的工作方式。没有正确的号盘设置（密钥值），解码器无法工作。同一条输入报文通过同一台编码机进行传输，会随密钥值的不同产生不同的输出。这些密码参数被称为<strong>密钥</strong>（key）。</p>
<h3 id="14-2-3-数字密码"><a href="#14-2-3-数字密码" class="headerlink" title="14.2.3 数字密码"></a>14.2.3 数字密码</h3><p>与金属钥匙或机械设备中的号盘设置相比，数字密钥只是一些数字。数字密钥值是编/解码算法的输入。编码算法就是会读取数据的函数，函数根据算法和密钥值对其进行编/解码。</p>
<p>给定一段明文报文P、一个编码函数E和一个数字编码密钥e，就可以生成一段经过编码的密文C。通过解码函数D和解码密钥d，可以将密文C解码为原始的明文P。编/解码函数都是互为反函数的，对P的编码进行解码就会回到原始报文P上去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/6y06i9T1LHudkYmQ__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="14-3-对称密钥加密技术"><a href="#14-3-对称密钥加密技术" class="headerlink" title="14.3 对称密钥加密技术"></a>14.3 对称密钥加密技术</h2><p>很多数字加密算法都是<strong>对称密钥</strong>（symmetric-key）加密技术，因为编码时使用的密钥值和解码时一样（e=d），统称为密钥k。</p>
<p>发送端和接收端要共享相同的密钥k才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文。流行的对称密钥加密算法有：DES、Triple-DES、RC2 、RC4。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/b4QoZX7deFh2BTZr__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="14-3-1-密钥长度与枚举攻击；"><a href="#14-3-1-密钥长度与枚举攻击；" class="headerlink" title="14.3.1 密钥长度与枚举攻击；"></a>14.3.1 密钥长度与枚举攻击；</h3><p>在很多情况下，编/解码算法都是众所周知的，因此密钥是唯一保密的东西。</p>
<p>用暴力去尝试所有的密钥值称为<strong>枚举攻击</strong>（enumeration attack）。好的加密算法会迫使攻击者试遍每一个可能的密钥，才能破解代码。</p>
<p>可用密钥值的数量取决于密钥中的位数，以及可能的密钥中有多少是有效的。通常对称密钥加密技术所有的密钥值都是有效的，有些加密技术只有部分秘钥值有效。</p>
<p>在传统的对称密钥加密技术中，对小型的、不太重要的事务来说，40位的密钥就足够安全了。但现在可能需要128 位的密钥。</p>
<h3 id="14-3-2-建立共享密钥"><a href="#14-3-2-建立共享密钥" class="headerlink" title="14.3.2 建立共享密钥"></a>14.3.2 建立共享密钥</h3><p>对称密钥加密技术的缺点之一就是发送者和接收者在互相对话之前，要有一个共享的保密密钥。</p>
<p>每对通信实体都需要自己的私有密钥。如果有N个节点，每个节点都要和其他所有N-1个节点进行安全对话，总共大概会有N^2个保密密钥。</p>
<h2 id="14-4-公开密钥加密技术"><a href="#14-4-公开密钥加密技术" class="headerlink" title="14.4 公开密钥加密技术"></a>14.4 公开密钥加密技术</h2><p>公开密钥加密技术使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文解码。编码密钥是公开，但解密密钥只有主机才知道。但解码密钥是保密的，因此只有接收端才能对发送给它的报文进行解码。</p>
<p>这样解决了对称秘钥技术的缺点，无须为了进行安全的通信而先交换私有密钥，使得密钥的建立变得更加简单。节点X可以将其加密密钥ex公开。任何想向节点X发送报文的人都可以使用相同的公开密钥了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/R3C0ZWtLpOZaLWpA__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="14-4-1-RSA"><a href="#14-4-1-RSA" class="headerlink" title="14.4.1 RSA"></a>14.4.1 RSA</h3><p>所有公开密钥非对称加密系统所面临的共同挑战是，要确保即便有人拥有了下面所有的线索，也无法计算出保密的私有密钥：</p>
<ol>
<li>公开密钥（是公有的，所有人都可以获得）；</li>
<li>一小片拦截下来的密文（可通过对网络的嗅探获取）；</li>
<li>一条报文及与之相关的密文（对任意一段文本运行加密器就可以得到）。</li>
</ol>
<p>RSA算法就是一个满足了以上这些条件的流行的公开密钥加密系统，它使得破解代码找到相应的私有密钥的难度仍相当于对一个极大的数进行质因数分解的困难程度。</p>
<h3 id="14-4-2-混合加密系统和会话密钥"><a href="#14-4-2-混合加密系统和会话密钥" class="headerlink" title="14.4.2 混合加密系统和会话密钥"></a>14.4.2 混合加密系统和会话密钥</h3><p>公开密钥加密算法的计算可能会很慢，因为它混合使用了对称和非对称策略。常见的做法是在两节点间通过便捷的公开密钥加密技术建立起安全通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。</p>
<h2 id="14-5-数字签名"><a href="#14-5-数字签名" class="headerlink" title="14.5 数字签名"></a>14.5 数字签名</h2><p>除了加/解密报文之外，还可以用加密系统对报文进行签名（sign），签名是加了密的校验和，数字签名是附加在报文上的特殊加密校验码。因为只有作者保密的私有密钥才能产生校验和，收到报文后用公钥能对数字签名解密，可以证明没有被冒充，同时再次进行摘要运算进行标胶，证明报文是否被篡改过。</p>
<p>数字签名通常是用非对称公开密钥技术产生的。它解决了对私钥加密整个文件以及之后的解密的开销问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Tke6UEV6jKnzqPSN__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="14-6-数字证书"><a href="#14-6-数字证书" class="headerlink" title="14.6 数字证书"></a>14.6 数字证书</h2><h3 id="14-6-1-证书的主要内容"><a href="#14-6-1-证书的主要内容" class="headerlink" title="14.6.1 证书的主要内容"></a>14.6.1 证书的主要内容</h3><p>数字证书（certs）包含了由某个受信任组织担保的用户或公司（比如CA证书授权中心）的相关信息。CA证书中心用自己的私钥，对发送端的公钥和其他信息一起加密，生成”数字证书”。因为接受端只有用CA机构的公钥解密这份数字证书，才能拿到发送者的公钥，CA机构是绝对权威可信的，然后继续验证数字签名。这解决了发送端和接收端的公钥同时被替换的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/fFoOZEhjrhEeQgdN__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="14-6-2-X-509-v3证书"><a href="#14-6-2-X-509-v3证书" class="headerlink" title="14.6.2 X.509 v3证书"></a>14.6.2 X.509 v3证书</h3><p>大多数证书都以X.509 v3标准格式来存储它们的信息。X.509 v3证书提供了一种标准的方式，将证书信息规范至一些可解析字段中。基于X.509证书的签名有：Web服务器证书、客户端电子邮件证书、软件代码签名证书和证书颁发机构证书。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/hspZDgv7mPLSk21u__thumbnail.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/zPbm4kXgLajyitzJ__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="14-6-3-用证书对服务器进行认证"><a href="#14-6-3-用证书对服务器进行认证" class="headerlink" title="14.6.3 用证书对服务器进行认证"></a>14.6.3 用证书对服务器进行认证</h3><p>通过HTTPS建立一个安全Web事务之后，浏览器会自动获取所连接服务器的数字证书。如果服务器没有证书，安全连接就会失败。浏览器收到证书时会对签名颁发机构进行检查。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SD8nb5zOtht8Okfl__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="14-7-HTTPS细节介绍"><a href="#14-7-HTTPS细节介绍" class="headerlink" title="14.7 HTTPS细节介绍"></a>14.7 HTTPS细节介绍</h2><p>HTTPS是最常见的HTTP安全版本。HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起。</p>
<h3 id="14-7-1-HTTPS概述"><a href="#14-7-1-HTTPS概述" class="headerlink" title="14.7.1 HTTPS概述"></a>14.7.1 HTTPS概述</h3><p>HTTPS就是在安全的传输层上发送的HTTP。HTTPS没有将未加密的HTTP报文发送给TCP，而是先将其发送给了一个安全层，对其进行加密。HTTP安全层是通过SSL及其现代替代协议TLS来实现的。术语SSL同时来表示SSL或者TLS。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Dcf7PaKFNvsZgcjI__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="14-7-2-HTTPS方案"><a href="#14-7-2-HTTPS方案" class="headerlink" title="14.7.2 HTTPS方案"></a>14.7.2 HTTPS方案</h3><p>安全HTTP是可选的。因此，对Web服务器发起请求时，会去检查URL的方案前缀。因为SSL是个二进制协议，与HTTP完全不同， 如果SSL从端口80到达，Web服务器会将二进制SSL流量理解为错误的HTTP并关闭连接。</p>
<h3 id="14-7-3-建立安全传输"><a href="#14-7-3-建立安全传输" class="headerlink" title="14.7.3 建立安全传输"></a>14.7.3 建立安全传输</h3><p>在HTTPS中，客户端首先打开一条到Web服务器端口443的连接。一旦建立了TCP连接，客户端和服务器就会初始化SSL层，对加密参数进行沟通，并交换密钥。握手完成之后，客户端就将请求报文发送给安全层。在将这些报文发送给TCP之前，都要先对其进行加密。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/wELgIlWVSdCcZivr__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="14-7-3-1-SSL握手"><a href="#14-7-3-1-SSL握手" class="headerlink" title="14.7.3.1 SSL握手"></a>14.7.3.1 SSL握手</h4><p>在发送已加密的HTTP报文前，客户端和服务器进行一次SSL握手，它们要完成以下工作：</p>
<ol>
<li>交换协议版本号；</li>
<li>选择一个两端都了解的密码；</li>
<li>对两端的身份进行认证；</li>
<li>生成临时的会话密钥，以便加密信道。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/GzOgAMKnHN1Dx72w__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="14-7-4-服务器证书"><a href="#14-7-4-服务器证书" class="headerlink" title="14.7.4 服务器证书"></a>14.7.4 服务器证书</h3><p>SSL支持双向认证，将服务器证书承载回客户端，再将客户端的证书回送给服务器。但实际中很少出现服务器要求使用客户端证书，安全HTTPS事务总是要求使用服务器证书的。</p>
<h4 id="14-7-4-1-站点证书的有效性"><a href="#14-7-4-1-站点证书的有效性" class="headerlink" title="14.7.4 .1 站点证书的有效性"></a>14.7.4 .1 站点证书的有效性</h4><p>SSL自身不要求用户检查Web服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进行进一步彻查的手段。验证步骤如下所述：</p>
<ol>
<li><strong>日期检测</strong></li>
</ol>
<p>首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果过期，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息。</p>
<ol start="2">
<li><strong>签名颁发者可信度检测</strong></li>
</ol>
<p>每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。浏览器会附带一个签名颁发机构的受信列表。如果浏览器收到了某未知甚至恶意的颁发机构签发的证书，那它通常会显示一条警告信息。</p>
<ol start="3">
<li><strong>签名检测</strong></li>
</ol>
<p>一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性。</p>
<ol start="4">
<li><strong>站点身份检测</strong></li>
</ol>
<p>为防止服务器复制其他人的证书，或拦截其他人的流量，浏览器会验证证书中的域名与所对话的服务器的域名是否匹配，有些CA会为一组服务器创建包含服务器名称列表或通配域名的证书。如果主机名与证书中的标识符不匹配，客户端要么通知用户，要么就以表示证书不正确的差错报文来终止连接。</p>
<h4 id="14-7-4-2-虚拟主机与证书"><a href="#14-7-4-2-虚拟主机与证书" class="headerlink" title="14.7.4 .2 虚拟主机与证书"></a>14.7.4 .2 虚拟主机与证书</h4><p>有些流行的Web服务器程序只支持一个证书。如果用户请求的是虚拟主机名（一台服务器上有多个主机名），与证书名称并不严格匹配，浏览器就会显示警告框。可以在开始处理安全事务时，通过重定向解决。</p>
<h2 id="14-8-通过代理以隧道形式传输安全流量"><a href="#14-8-通过代理以隧道形式传输安全流量" class="headerlink" title="14.8 通过代理以隧道形式传输安全流量"></a>14.8 通过代理以隧道形式传输安全流量</h2><p>客户端通常会用Web代理服务器代表它们来访问Web服务器。代理是防火墙路由器唯一允许 进行HTTP流量交换的设备，它可能会进行病毒检测或其他的内容控制工作。但只要客户端用服务器的公钥对发往服务器的数据进行加密，代理就不能读取HTTP首部，也就无法知道应该将请求转向何处。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ioF0MOUNikHKQnIO__thumbnail.png"
                      alt="图片"
                ></p>
<p>解决方案：<strong>HTTPS SSL 隧道协议</strong>。客户端在开始加密之前，通过CONNECT的扩展方法发送以明文形式的要连接的安全主机和端口信息，告知给代理，客户端会等待来自代理的响应。e.g.  CONNECT home.netscape.com:443   HTTP/1. 0</p>
<p>代理会对请求进行评估，确保它有效且用户有权请求这样一条连接。如果正常，代理会建立到目标服务器的连接。如果成功，就向客户端发送条200 Connection Established响应。之后直接在客户端和服务器之间以隧道形式传输数据。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>14-安全HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>02-HTML网页和结构</title>
    <url>/2021/01/21/note/webkit/02-HTML%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>HTML网页是利用HTML语言编写的文档，它是一种半结构化的数据表现方式。它的结构特征可以归纳为三种：树状结构、层次结构和框结构。</p>
<h2 id="2-1-网页构成"><a href="#2-1-网页构成" class="headerlink" title="2.1 网页构成"></a>2.1 网页构成</h2><h3 id="2-1-1-基本元素和树状结构"><a href="#2-1-1-基本元素和树状结构" class="headerlink" title="2.1.1 基本元素和树状结构"></a>2.1.1 基本元素和树状结构</h3><p>现在的网页基本上都是动态网页（Dynamic HTML），这就需要JavaScript代码用来控制网页内部的逻辑，CSS用来描述网页的显示信息。</p>
<p>整个网页可以看成一种树状结构，其树根是html，这是网页的根元素（或称节点）。根下面包含两个子节点head和body。</p>
<h3 id="2-1-2-HTML-5新特性"><a href="#2-1-2-HTML-5新特性" class="headerlink" title="2.1.2 HTML.5新特性"></a>2.1.2 HTML.5新特性</h3><p>HTML5引入的对2D和3D图形以及多媒体方面的支持，将彻底改变网页的渲染方式和复杂度，包括但是不限于：</p>
<ol>
<li><strong>video元素</strong>，支持在网页中播放视频。</li>
<li><strong>Canvas 2D</strong>，Canvas 2D通过定义一个新的“canvas”元素，网页开发者利用该元素的2D绘图上下文（graphics context）调用标准定义的接口，绘制常见的2D图形，例如点、线、矩形、多边形等。</li>
<li><strong>WebGL</strong>（也就是Canvas 3D）。WebGL则是使用“canvas”元素的3D绘图上下文调用标准定义的接口，绘制3D图形，这些接口类似于OpenGL ES的接口。</li>
<li><strong>CSS3 3D变换</strong>（transform）和<strong>转换</strong>（transition）。CSS3 3D的变换和转换则可以作用于HTML的任意可视元素，制造出各种炫丽的3D效果。<h2 id="2-2-网页结构"><a href="#2-2-网页结构" class="headerlink" title="2.2 网页结构"></a>2.2 网页结构</h2></li>
</ol>
<h3 id="2-2-1-框结构"><a href="#2-2-1-框结构" class="headerlink" title="2.2.1 框结构"></a>2.2.1 框结构</h3><p>框结构可以用来对网页的布局进行分割，将网页分成几个框。网页开发者也可以让网页嵌入其他的网页，frameset、frame和iframe可以用来在当前网页中嵌入新的框结构。多框结构的网页非常不适合移动领域，因为该结构对触控操作来说是不方便的。</p>
<h3 id="2-2-2-层次结构"><a href="#2-2-2-层次结构" class="headerlink" title="2.2.2 层次结构"></a>2.2.2 层次结构</h3><p>网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是某些元素可能不同于它的父元素所在的层次，同时CSS部分的代码也会对网页的分层策略产生重要影响。</p>
<p>对于需要复杂变换和处理的元素，WebKit 为它们构建新层其实是为了渲染引擎在处理上的方便和高效。</p>
<h2 id="2-3-WebKit的网页渲染过程"><a href="#2-3-WebKit的网页渲染过程" class="headerlink" title="2.3 WebKit的网页渲染过程"></a>2.3 WebKit的网页渲染过程</h2><h3 id="2-3-1-加载和渲染"><a href="#2-3-1-加载和渲染" class="headerlink" title="2.3.1 加载和渲染"></a>2.3.1 加载和渲染</h3><p>浏览器的主要作用就是将用户输入的“URL”转变成可视化的图像，包含两个过程，一是网页加载过程，就是从“URL”到构建DOM树；二是网页渲染过程，从DOM树到生成可视化图像。这两个过程也会交叉，统称这两个过程为网页的渲染过程。</p>
<p>网页通常比我们的屏幕可视面积要大，当前可见的区域称为<strong>视图</strong>（viewport），浏览器在渲染网页的时候，一般会加入滚动条以帮助翻滚网页。</p>
<h3 id="2-3-2-WebKit的渲染过程"><a href="#2-3-2-WebKit的渲染过程" class="headerlink" title="2.3.2 WebKit的渲染过程"></a>2.3.2 WebKit的渲染过程</h3><p>网页的一般渲染过程中的数据包括网页内容、DOM、内部表示和图像，模块则包括HTML解释器、CSS解释器、JavaScript 引擎以及布局和绘图模块。</p>
<p>根据数据的流向，将渲染过程分成三个阶段，第一个阶段是从网页的URL到构建DOM树，第二个阶段是从DOM树到构建WebKit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。</p>
<h4 id="2-3-2-1-第一个阶段：从网页的URL到构建DOM树"><a href="#2-3-2-1-第一个阶段：从网页的URL到构建DOM树" class="headerlink" title="2.3.2.1 第一个阶段：从网页的URL到构建DOM树"></a>2.3.2.1 第一个阶段：从网页的URL到构建DOM树</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/uSXBGLwftTz59OfO__thumbnail.png"
                      alt="图片"
                ></p>
<p>具体的过程如下：</p>
<ol>
<li>当用户输入网页URL的时候，WebKit调用其资源加载器加载该URL对应的网页。</li>
<li>加载器依赖网络模块建立连接，发送请求并接收答复。</li>
<li>WebKit接收到各种网页或者资源的数据，某些资源可能是同步或异步获取的。</li>
<li>网页被交给HTML解释器转变成一系列的词语（Token）。</li>
<li>解释器根据词语构建节点（Node），形成DOM树。</li>
<li>如果节点是JavaScript代码的话，调用JavaScript引擎解释并执行。</li>
<li>JavaScript代码可能会修改DOM树的结构。</li>
<li>如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载它们，但是它们是异步的，不会阻碍当前DOM树的继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。</li>
</ol>
<p>在上述的过程中，网页在加载和渲染过程中会发出“DOMConent”事件和DOM的“onload”事件，分别在DOM树构建完之后，以及DOM树建完并且网页所依赖的资源都加载完之后发生，因为某些资源的加载并不会阻碍DOM树的创建，所以这两个事件多数时候不是同时发生的。</p>
<h4 id="2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文"><a href="#2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文" class="headerlink" title="2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文"></a>2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/5zAmE3T5IrREBagI__thumbnail.png"
                      alt="图片"
                ></p>
<p>这一阶段的具体过程如下。</p>
<ol>
<li>CSS文件被CSS解释器解释成内部表示结构。</li>
<li>CSS解释器工作完之后，在DOM树上附加解释后的样式信息，这就是RenderObject树。</li>
<li>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文，这中间还有复杂的内部过程。</li>
</ol>
<p>RenderObject树的建立并不表示DOM树会被销毁，图中的四个内部表示结构一直存在，直到网页被销毁。</p>
<h4 id="2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。"><a href="#2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。" class="headerlink" title="2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。"></a>2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3oObbcPTpx9gzPCi__thumbnail.png"
                      alt="图片"
                ></p>
<p>图中这一阶段对应的具体过程如下。</p>
<ol>
<li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的绘图具体实现类。</li>
<li>绘图实现类有简单或复杂的实现。在Chromium中，它的实现相当复杂，需要Chromium的合成器来完成复杂的多进程和GPU加速机制。</li>
<li>绘图实现类将 2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来同浏览器界面一起显示。</li>
</ol>
<p>现代浏览器为了绘图上的高效性和安全性，可能会在这一过程中引入复杂的机制。而且，绘图也从之前单纯的软件渲染，到现在的GPU硬件渲染、混合渲染模型等方式。</p>
<p>现代网页很多是动态网页，这意味着在渲染完成之后，由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
        <category>02-HTML网页和结构</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>04-资源加载和网络栈</title>
    <url>/2021/01/21/note/webkit/04-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%A0%88/</url>
    <content><![CDATA[<p>使用网络栈下载网页和网页中的资源是渲染引擎工作过程的第一步，也是非常消耗时间的步骤。</p>
<h2 id="4-1-WebKit资源加载机制"><a href="#4-1-WebKit资源加载机制" class="headerlink" title="4.1 WebKit资源加载机制"></a>4.1 WebKit资源加载机制</h2><h3 id="4-1-1资源"><a href="#4-1-1资源" class="headerlink" title="4.1.1资源"></a>4.1.1资源</h3><p>网页本身就是一种资源，而且网页还需要依赖很多其他类型的资源，例如图片、视频等。</p>
<p>HTML支持的资源主要包括以下类型。</p>
<ol>
<li><strong>HTML</strong>：HTML页面，包括各式各样的HTML元素。</li>
<li><strong>JavaScript</strong>：JavaScript 代码，可以内嵌在HTML文件中，也可以以单独的文件存在。</li>
<li><strong>CSS样式表</strong>：CSS样式资源，可以内嵌在HTML文件之外，也可以以单独文件存在。</li>
<li><strong>图片</strong>：各种编码格式的图片资源，还有一些特殊的图片资源，例如SVG中所需的图片资源。</li>
<li><strong>SVG</strong>：用于绘制SVG的2D矢量图形表示。</li>
<li><strong>CSS Shader</strong>：支持CSS Shader文件，目前WebKit支持该功能。</li>
<li><strong>视频、音频和字幕</strong>：多媒体资源及支持音视频的字幕文件（TextTrack）。</li>
<li><strong>字体文件</strong>：CSS支持自定义字体，CSS3引入的自定义字体文件。</li>
<li><strong>XSL样式表</strong>：使用XSLT语言编写的XSLT代码文件。</li>
</ol>
<p>上面这些资源在WebKit 中有不同的类来表示它们，它们的公共基类是<strong>CachedResource</strong>。其中HTML文本的类型叫MainResource类，与其对应的资源类型叫CachedRawResource类。</p>
<p>资源类的前面的Cached字样，是因为效率问题而引入的缓存机制，所有对资源的请求都会先获取缓存中的信息，以决定是否向服务器提出资源请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/0daCvmpdLOgUMBoZl.png"
                      alt="图片"
                ></p>
<h3 id="4-1-2-资源缓存"><a href="#4-1-2-资源缓存" class="headerlink" title="4.1.2 资源缓存"></a>4.1.2 资源缓存</h3><p>资源的缓存机制的基本思想是建立一个资源的缓存池，当WebKit需要请求资源的时候，先从资源池中查找是否存在相应的资源。WebKit从资源池中查找资源的关键字是URL。如果没有，WebKit创建一个新的CachedResource子类的对象，并发送真正的请求给服务器，WebKit收到资源后将其设置到该资源类的对象中去，以便于缓存后下次使用。这里的缓存指的是内存缓存，而不同于在网络栈部分的磁盘缓存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/DADmcG38TQhFjPbK.png"
                      alt="图片"
                ></p>
<h3 id="4-1-3-资源加载器"><a href="#4-1-3-资源加载器" class="headerlink" title="4.1.3 资源加载器"></a>4.1.3 资源加载器</h3><p>按照加载器的类型来分，WebKit 总共有三种类型的加载器。</p>
<ol>
<li>针对每种资源类型的<strong>特定加载器</strong>，特点是仅加载某一种资源。这些资源加载器没有公共基类，作用就是当需要请求资源时，由资源加载器负责加载并隐藏背后复杂的逻辑。加载器属于它的调用者。例如image元素需要图片资源，对应的特定资源加载器是ImageLoader类。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3IcXzyYa57u2Lz0U.png"
                      alt="图片"
                ></p>
<ol start="2">
<li><strong>资源缓存机制的资源加载器</strong>，特点是所有特定加载器都共享它来查找并插入缓存资源——<strong>CachedResourceLoader类</strong>。特定加载器先是通过缓存机制的资源加载器来查找是否有缓存资源，它属于HTML的文档对象。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/Lql2quYaEeTXRUBf.png"
                      alt="图片"
                ></p>
<ol start="3">
<li><strong>通用的资源加载器</strong>——ResourceLoader类，是在WebKit需要从网络或者文件系统获取资源的时候使用该类只负责获得资源的数据，因此被所有特定资源加载器所共享。它属于CachedResource类，但它同CachedResourceLoader类没有继承关系，这容易混淆。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/yxLtJhDragnUUhta.png"
                      alt="图片"
                ></p>
<h3 id="4-1-4-过程"><a href="#4-1-4-过程" class="headerlink" title="4.1.4 过程"></a>4.1.4 过程</h3><p>下图是一个带有资源缓存机制的资源加载的全过程，包括资源已经在缓存中和不在缓存中两种情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/gVXqqiTMWy0JHXYe.png"
                      alt="图片"
                ></p>
<p>通常一些资源的加载是异步执行的，资源的获取和加载不会阻碍当前WebKit的渲染过程，例如图片、CSS文件。但网页也存在某些特别的资源会阻碍主线程的渲染过程，例如JavaScript代码文件。这会严重影响WebKit下载资源的效率，因为后面可能还有许多需要下载的资源。</p>
<p>webkit的解决方案：当前的主线程被阻碍时，WebKit 会启动另外一个线程去遍历后面的HTML网页，收集需要的资源URL，然后发送请求，避免被阻碍。同时WebKit 能够并发下载这些资源，甚至并发下载JavaScript代码资源。</p>
<h3 id="4-1-5-资源的生命周期"><a href="#4-1-5-资源的生命周期" class="headerlink" title="4.1.5 资源的生命周期"></a>4.1.5 资源的生命周期</h3><p>同CachedResourceLoader对象一样，资源池也属于HTML文档对象。资源池采用LRU（Least Recent Used）算法来替换其中的资源，从而加入新的资源。</p>
<p>另一方面，当一个资源加载后，通常它会被放入资源池，以便之后使用。在HTTP协议的规范中规定，浏览器可以发送消息确认是否需要更新，如果有，浏览器则重新获取该资源；否则就需要利用该资源。</p>
<h2 id="4-2-Chromium多进程资源加载"><a href="#4-2-Chromium多进程资源加载" class="headerlink" title="4.2 Chromium多进程资源加载"></a>4.2 Chromium多进程资源加载</h2><h3 id="4-2-1-多进程"><a href="#4-2-1-多进程" class="headerlink" title="4.2.1 多进程"></a>4.2.1 多进程</h3><p>在带有资源缓存机制的资源加载过程描述中，ResourceHandle类之下的部分，是不同移植对获取资源的不同实现。在Chromium中，获取资源的方式是利用多进程的资源加载架构。下图描述了关于Chromium如何利用多进程架构来完成资源的加载，主要是多个Renderer进程和Browser 进程之间的调用栈涉及的主要类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/sqo0VXyFsDg0m6zY.png"
                      alt="图片"
                ></p>
<p>Renderer进程在网页的加载过程中需要获取资源，但是由于安全性（当沙箱模型打开的时候，Renderer进程是没有权限去获取资源的）和效率上（资源共享等问题）的考虑，Renderer进程的资源获取实际上是通过进程间通信将任务交给Browser进程来完成，Browser 进程有权限从网络或者本地获取资源。</p>
<p>在Chromium架构的Renderer进程中，ResourceHandleInternal 类通过IPCResource-LoaderBridge类同Browser进程通信。IPCResourceL oaderBridge类继承自ResourceL oaderBridge类，其作用是负责发起请求的对象和回复结果的解释工作，实际消息的接收和派发交给ResourceDispatcher类来处理。</p>
<p>在Browser进程中，首先由ResourceMessageFilter类来过滤Renderer进程的消息，如果与资源请求相关，则该过滤类转发请求给ResourceDispatcherHostImpl类，随即ResourceDispatcherHostlmpl类创建Browser进程中的ResourceLoader 对象来处理。</p>
<p>ResourceLoader类是Chromium浏览器实际的资源加载类，它负责管理向网络发起的请求、从网络接收过来的认证请求、请求的回复管理等工作。因为这其中每项都有专门的类来负责，但都是由ResourceLoader 类统一管理。从网络或者本地文件读取信息的是URLRequest类，实际上它承担了建立网络连接、发送请求数据和接受回复数据的任务，URLRequest 之后的工作将在“网络栈”章节中来解读。</p>
<h3 id="4-2-2-工作方式和资源共享"><a href="#4-2-2-工作方式和资源共享" class="headerlink" title="4.2.2 工作方式和资源共享"></a>4.2.2 工作方式和资源共享</h3><p>资源请求有同步和异步两种方式。前面说了ResourceLoader类承担了Browser进程中有关资源的总体管理任务，对于同步和异步两种资源请求方式，ResourceLoader类使用SyncResourceHandle类和AsyncResourceHandle类来向Renderer进程发送状态消息，并接收Renderer进程对这些消息的反馈，下图描述了这些类之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/byBPW6KAwIpeU5mS.png"
                      alt="图片"
                ></p>
<p>图中还有两个ResourceHandle子类，第一个是LayeredResourceHandle类，它同SyncResourceHandle类和AsyncResourceHandle类不一样，自己不直接参与资源的处理，而是将处理转给另一个ResourceHandle对象。LayeredResourceHandle 类没有实际意义，仅是BufferedResourceHandle的父类。该缓冲类用来缓冲网络或者文件传过来的数据，直到数据足够满足需求然后转给设置的另一个ResourceHandle对象。Throttling-ResourceHandle类是在面对很多个资源请求时仅使用一个URLRequest对象来获取资源，这可以有效地减少网络的开销，因为不需要重新建立多个网络连接。</p>
<p>此外，在Chromium中还有很多ResourceHandle的子类，它们的作用各异。</p>
<ol>
<li><strong>RedirectToFileResourceHandler</strong>：继承自LayeredResourceHandle类，在接收到的数据转给另一个ResourceHandler类的同时，转存到文件。</li>
<li><strong>treamResourceHandler</strong>：继承自LayeredResourceHandle 类，在接收到的数据转给另一个ResourceHandler的同时，转存到数据流。</li>
<li><strong>CertificateResourceHandler</strong>：主要处理证书类的资源请求。</li>
</ol>
<p>资源统一交由Browser进程来处理，这使得资源在不同网页间的共享变得很容易。接下来面临一个问题，因为每个Renderer 进程某段时间内可能有多个请求，同时还有多个Renderer进程，Browser进程需要处理大量的资源请求，这就需要一个处理这些请求的调度器，这就是Chromium中的ResourceScheduler.</p>
<h2 id="4-3-网络栈"><a href="#4-3-网络栈" class="headerlink" title="4.3 网络栈"></a>4.3 网络栈</h2><h3 id="4-3-1-WebKit的网络设施"><a href="#4-3-1-WebKit的网络设施" class="headerlink" title="4.3.1 WebKit的网络设施"></a>4.3.1 WebKit的网络设施</h3><p>WebKit的资源加载其实是交由各个移植来实现的，所以WebCore其实并没有什么特别的基础设施，每个移植的网络实现是非常不一样的。</p>
<p>在WebKit的代码结构中，网络部分代码在“WebKit/Source/WebCore/platform/network”中。主要是一些HTTP消息头、MIME消息、状态码等信息的描述和处理，没有实质的网络连接和各种针对网络的优化。</p>
<h3 id="4-3-2-Chromium网络栈"><a href="#4-3-2-Chromium网络栈" class="headerlink" title="4.3.2 Chromium网络栈"></a>4.3.2 Chromium网络栈</h3><p>前面讲到资源加载，描述到URLRequest类的时候戛然而止，这是因为URLRequest类之下的部分是网络栈的内容。</p>
<h4 id="4-3-2-1-网络栈基本组成"><a href="#4-3-2-1-网络栈基本组成" class="headerlink" title="4.3.2.1 网络栈基本组成"></a>4.3.2.1 网络栈基本组成</h4><p>下图是“net”所包括的主要子目录，也是Chromium网络栈的主要模块。这里面除了一些基础的部分，例如HTTP协议、DNS解析等模块，还包含了Chromium为了减少网络时间而引入的新技术，例如SPDY、QUIC等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/i4uSsMXfcjQTaa2X.png"
                      alt="图片"
                ></p>
<h4 id="4-3-2-2-网络栈结构"><a href="#4-3-2-2-网络栈结构" class="headerlink" title="4.3.2.2 网络栈结构"></a>4.3.2.2 网络栈结构</h4><p>下图描述了从URLRequest类到Socket类之间的调用过程。以HTTP协议为例，图中列出建立TCP的socket连接过程中涉及的类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/icP92vja3jnJnFsb.png"
                      alt="图片"
                ></p>
<p>首先是URLRequest类被上层调用并启动请求的时候，它会根据URL的“scheme”来决定需要创建什么类型的请求。“scheme”也就是URL的协议类型，例如“http://”、“fle://”，也可以是自定义的scheme，例如Android系统的“fle://android asset/”。URLRequest对象创建的是一个URLRequestJob子类的一个对象，例如图中的URLRequestHttpJob类。为了支持自定义的scheme：处理方式，Chromium使用工厂模式。URLRequestJob 类和它的工厂类URLRequestJobFactory 的管理工作都由URLRequestJlobManager类负责。基本的思路是，用户可以在该类中注册多个工厂，当有URLRequest请求时，先由工厂检查它是否需要处理该“scheme”，如果没有，工厂管理类继续交给下一个工厂“类来处理。最后，如果没有任何工厂能够处理，Chromium则交给内置的工厂来检查和处理是否为“http://“、“http:/“或者“fle://”</p>
<p>等，图4-15用来描述这些类的关系。.</p>
<p>其次，当URLRequestHttpJob对象被创建后，该对象首先从Cookie管理器中获取与该URL相关联的信息。之后，它同样借助于HttpTransactionFactory对象创建一个HttpTransaction 对象来表示开启一-个 HTTP连接的事务（当然这里的概念不同于数据库中的事务概念）。通常情况下，HtpTransactionFactory 对象对应的是一个它的子类HtpCache对象。HtpCache类使用本地磁盘缓存机制（稍后会介绍），如果该请求对应的回复已经在磁盘缓存中，那么Chromium无需再建立HttpTransaction来发起连接，而是直接从磁盘中获取即可。如果磁盘中没有该URL的缓存，同时如果目前该URL请求对应的HttpTransaction已经建立，那么只要等待它的回复即可。当这些条件都不满足的时候，Chromium 实际上才会真正创建HttpTransaction对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3x9ruL4MGbG59Khg.png"
                      alt="图片"
                ></p>
<p>再次，HttpNetworkTransaction 类使用HttpNetworkSession 类来管理连接会话。</p>
<p>HttpNetworkSession类通过它的成员HttpStreamFactory 对象来建立TCP Socket连接，之后Chromium创建HttpStream对象。HttpStreamFactory对象将和网络之间的数据读写交给自己新创建的一一个HttpStream子类的对象来处理。</p>
<p>最后是套接字的建立。Chromium中与服务器建立连接的套接字是StreamSocket类，它是一一个抽象类，在POSIX系统和Windows系统上有着分别不同的实现。同时，为了支持SSL机制，StreamSocket类还有-一个子类一SSLSocket。图4-16显示了这些类和它们之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/Ssn77qEXGwUk9Sqv.png"
                      alt="图片"
                ></p>
<h4 id="4-3-2-3-代理"><a href="#4-3-2-3-代理" class="headerlink" title="4.3.2.3 代理"></a>4.3.2.3 代理</h4><p>当用户设置代理时，上面的网络栈结构是如何组织的呢？用户代理依赖以下类来处理。</p>
<ol>
<li>ProxyService：对于一个URL，HttpStreamFactory 类使用ProxyService类来获取代理信息。ProxyService类首先会检查当前的代理设置是不是最新的，如果不是，它依赖ProxyConfigService来重新获取代理信息。该类不处理实际任务，而是使用ProxyResolver类来做实际的代理工作。</li>
<li>ProxyConfigService：获取代理信息的类，可获取平台上的代理设置，在Linux、Windows.上有不同的实现。</li>
<li>ProxyScriptFetcher：Chromium 支持代理的JavaScript脚本，该类负责从代理的URL中获取该脚本。</li>
<li>ProxyResolver：实际负责代理的解释和执行，通常启用新的线程来处理，因为当前可能会被域名的解析所阻碍。</li>
<li>ProxyResolverV8：ProxyResolver的子类，使用V8引擎来解析和执行脚本。</li>
</ol>
<p>下图不仅描述上面这些类，也描述了Chromium中获取网络代理的过程。图中数字代表获取网络代理的次序，其中的分支3.1和4.1分别表示简单的代理设置和代理脚本设置的处理过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/Fb9e4AescqSYA2fZ.png"
                      alt="图片"
                ></p>
<h4 id="4-3-2-4-域名解析（DNS）"><a href="#4-3-2-4-域名解析（DNS）" class="headerlink" title="4.3.2.4 域名解析（DNS）"></a>4.3.2.4 域名解析（DNS）</h4><p>通常情况下，用户都是使用域名来访问网络资源的，所以在建立TCP连接前需要解析域名。Chromium中使用HostResolverImpl类来解析域名，具体调用的函数是“getaddrinfo（）”，该函数是一个阻塞式的函数，所以Chromium理所当然使用单独的线程来处理它，这是Chromium的原则之一。因此当调试Chromium的进程时，会看到很多线程被创建然后退出。</p>
<p>为了考虑效率，使用HostCache类来保存解析后的域名，最多时会有多达1000个的域名和地址映射关系会被存储起来。看起来DNS的解析很简单，好像也没有什么值得深究的，其实不然，域名解析也可以有优化的空间，因为优化可以有效的减少用户等待的时间。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
        <category>04-资源加载和网络栈</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Web服务器</title>
    <url>/2021/01/23/note/HTTP/05-Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Web服务器会对HTTP请求进行处理并提供响应。“<strong>Web服务器</strong>”可以用来表示Web服务器的软件，也可以用来表示提供Web页面的特定设备或计算机。</p>
<p>Web服务器有着不同的风格、形状和尺寸。有普通的10行Perl脚本的Web服务器、50MB的安全商用引擎以及极小的卡上服务器。</p>
<h1 id="5-1-Web服务器的实现"><a href="#5-1-Web服务器的实现" class="headerlink" title="5.1 Web服务器的实现"></a>5.1 Web服务器的实现</h1><p>Web服务器逻辑实现了HTTP协议、管理着Web资源，并负责提供Web服务器的管理功能。Web服务器逻辑和操作系统共同负责管理TCP连接。底层操作系统负责管理底层计算机系统的硬件细节，并提供了TCP/IP网络支持、负责装载Web资源的文件系统以及控制当前计算活动的进程管理功能。</p>
<p>Web服务器的不同的形式：通用软件Web服务器；Web服务器设备；嵌入式Web服务器。</p>
<h1 id="5-2-通用软件Web服务器"><a href="#5-2-通用软件Web服务器" class="headerlink" title="5.2 通用软件Web服务器"></a>5.2 通用软件Web服务器</h1><p>通用软件Web服务器都运行在标准的、有网络功能的计算机系统上。可以选择开源软件（比如Apache或W3C的Jigsaw）或者商业软件（比如微软和iPlanet的Web服务器）。基本上所有的计算机和操作系统中都有可用的Web服务器软件。</p>
<h1 id="5-3-Web服务器设备"><a href="#5-3-Web服务器设备" class="headerlink" title="5.3 Web服务器设备"></a>5.3 Web服务器设备</h1><p>Web服务器设备（Web server appliance）是预先打包好的软硬件解决方案。厂商会在他们选择的计算机平台上预先安装好软件服务器，并将软件配置好。</p>
<p>这样不再需要安装及配置软件，可以极大地简化管理工作。但Web服务器通常不太灵活，特性不太丰富，而且服务器硬件也不太容易重用或升级。</p>
<h1 id="5-4-嵌入式Web服务器"><a href="#5-4-嵌入式Web服务器" class="headerlink" title="5.4 嵌入式Web服务器"></a>5.4 嵌入式Web服务器</h1><p>嵌入式服务器（embededserver）是嵌入到消费类产品（比如打印机或家用设备中去的小型Web服务器。嵌入式Web服务器允许用户通过便捷的Web浏览器接口来管理其消费者设备。嵌入式Web服务器通常只能提供最小特性功能集。</p>
<h1 id="5-5-Web服务器操作"><a href="#5-5-Web服务器操作" class="headerlink" title="5.5 Web服务器操作"></a>5.5 Web服务器操作</h1><p>（1）建立连接——接受一个客户端连接，如果不希望与这个客户端建立连接，就将其关闭。</p>
<p>（2）接收请求——从网络中读取一条HTTP请求报文。</p>
<p>（3）处理请求——对请求报文进行解释，并采取行动。</p>
<p>（4）访问资源——访问报文中指定的资源。</p>
<p>（5）构建响应——创建带有正确首部的HTTP响应报文。</p>
<p>（6）发送响应——将响应回送给客户端。</p>
<p>（7）记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/pzJLam8z7mPDhlLa__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="5-5-1-第一步——接受客户端连接"><a href="#5-5-1-第一步——接受客户端连接" class="headerlink" title="5.5.1 第一步——接受客户端连接"></a>5.5.1 第一步——接受客户端连接</h2><p>如果客户端已经打开了一条到服务器的持久连接，可以使用那条连接来发送它的请求。否则，客户端需要打开一条新的到服务器的连接。</p>
<h3 id="5-5-1-1-处理新连接"><a href="#5-5-1-1-处理新连接" class="headerlink" title="5.5.1.1 处理新连接"></a>5.5.1.1 处理新连接</h3><p>客户端请求一条到Web服务器的TCP连接时，Web服务器会建立连接，判断连接的另一端是哪个客户端，从TCP连接中将IP地址解析出来。一旦新连接建立起来并被接受，服务器就会将新连接添加到其现存Web服务器连接列表中，做好监视连接上数据传输的准备。</p>
<p>Web服务器可以随意拒绝或立即关闭任意一条连接。有些Web服务器会因为客户端IP地址或主机名是未认证的，或者因为它是已知的恶意客户端而关闭连接。</p>
<h3 id="5-5-1-2-客户端主机名识别"><a href="#5-5-1-2-客户端主机名识别" class="headerlink" title="5.5.1.2 客户端主机名识别"></a>5.5.1.2 客户端主机名识别</h3><p>可以用“反向DNS”对大部分Web服务器进行配置，以便将客户端IP地址转换成客户端主机名。Web服务器可以将客户端主机名用于详细的访问控制和日志记录。但主机名查找会花费很长时间，降低Web事务处理的速度。大容量Web服务器要么会禁止主机名解析，要么只允许对特定内容进行解析。</p>
<h3 id="5-5-1-3-通过ident确定客户端用户"><a href="#5-5-1-3-通过ident确定客户端用户" class="headerlink" title="5.5.1.3 通过ident确定客户端用户"></a>5.5.1.3 通过ident确定客户端用户</h3><p>有些Web服务器支持IETF的ident协议，通过ident协议找到发起HTTP连接的用户名。<strong>通用日志格式</strong>（Common Log Format）的第二个字段中就包含了每条HTTP请求的ident用户名。如果客户端支持ident协议，就在TCP端口113上监听ident请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/HnlHkh82fRKut68j__thumbnail.png"
                      alt="图片"
                ></p>
<p>ident在公共因特网上并不能很好地工作，原因包括：</p>
<pre><code>1. 很多客户端PC没有运行ident识别协议守护进程软件；
2. ident协议会使HTTP事务处理产生严重的时延；
3. 很多防火墙不允许ident流量进入；
4. ident协议不安全，容易被伪造；
5. ident协议不支持虚拟IP地址；
6. 暴露客户端的用户名涉及隐私问题。</code></pre>
<p>告知ApacheWeb服务器通过<strong>IdentityCheck  on</strong>指令使用ident查找功能。如果没有ident信息，用连字符（-）来填充ident日志字段。由于通常没有ident信息，在使用通用日志格式的日志文件中，第二个字段通常都是连字符。</p>
<h2 id="5-5-2-第二步——接收请求报文"><a href="#5-5-2-第二步——接收请求报文" class="headerlink" title="5.5.2 第二步——接收请求报文"></a>5.5.2 第二步——接收请求报文</h2><p>连接上有数据到达时，Web服务器会从网络连接中读取数据，并将请求报文中的内容解析出来。</p>
<p>解析请求报文时，Web服务器操作：</p>
<pre><code>1. 解析请求行，查找请求方法、指定的资源标识符（URI）以及版本号，各项之间由一个空格分隔，并以CRLF作为行的结束；
2. 读取以CRLF结尾的报文首部；
3. 检测到以CRLF结尾的、标识首部结束的空行（如果有的话）；
4. 如果有的话（长度由Content-Length首部指定），读取请求主体。</code></pre>
<p>解析请求报文时，Web服务器会不定期地从网络上接收输入数据。网络连接可能出现延迟，所以将部分报文数据临时存储在内存中，直到收到足以进行解析的数据并理解其意义为止。</p>
<h3 id="5-5-2-1-报文的内部表示法"><a href="#5-5-2-1-报文的内部表示法" class="headerlink" title="5.5.2.1 报文的内部表示法"></a>5.5.2.1 报文的内部表示法</h3><p>有些Web服务器会用，便于进行报文操作的内部数据结构来存储请求报文。比如，数据结构中可能包含有指向请求报文中各个片段的指针及其长度，将这些首部存放在一个快速查询表中，以便快速访问特定首部的具体值了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/6J2aJFF37Qfi51H7__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="5-5-2-2-连接的输入-输出处理结构"><a href="#5-5-2-2-连接的输入-输出处理结构" class="headerlink" title="5.5.2.2 连接的输入/输出处理结构"></a>5.5.2.2 连接的输入/输出处理结构</h3><p>高性能的Web服务器能够同时支持数千条连接。连接可能在快速地或者慢速向Web服务器发送请求甚至空闲着。因为请求可能会在任意时刻到达，所以Web服务器会不停地观察有无新的Web请求。不同的Web服务器结构会以不同的方式为请求服务。</p>
<ol>
<li>单线程Web服务器（参见a）</li>
</ol>
<p>一次只处理一个请求，直到完成为止。这种结构易于实现，但所有其他连接都会被忽略。这样会造成严重的性能问题，只适用于低负荷的服务器，以及type-o-serve这样的诊断工具。</p>
<ol start="2">
<li>多进程及多线程Web服务器（参见b）</li>
</ol>
<p>用多个进程，或更高效的线程同时对请求进行处理。可以根据需要或预先创建线程/进程。有些服务器会为每条连接分配一个线程/进程，但当同时处理过多连接时，会消耗太多的内存或系统资源，因此通常都会对线程/进程的最大数量进行限制。</p>
<ol start="3">
<li>复用I/O的服务器（参见c）</li>
</ol>
<p>在复用结构中，同时监视所有连接上的活动。当连接的状态发生变化时（有数据可用，或出现错误时），就对那条连接进行少量的处理；处理结束之后，将连接返回到开放连接列表中，等待下一次状态变化。</p>
<ol start="4">
<li>复用的多线程Web服务器（参见d）</li>
</ol>
<p>多个线程中的每一个都在观察打开的连接，并对每条连接执行少量的任务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/2mA4SsoOK7nSD7FP__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="5-5-3-第三步——处理请求"><a href="#5-5-3-第三步——处理请求" class="headerlink" title="5.5.3 第三步——处理请求"></a>5.5.3 第三步——处理请求</h2><p>一旦Web服务器收到了请求，就可以根据方法、资源、首部和可选的主体部分来对请求进行处理了。比如POST要求请求报文中必须带有实体主体部分的数据；比如OPTIONS允许有也可以没有请求的主体部分。比如GET禁止在请求报文中包含实体的主体数据。</p>
<h2 id="5-5-4-第四步——对资源的映射及访问"><a href="#5-5-4-第四步——对资源的映射及访问" class="headerlink" title="5.5.4 第四步——对资源的映射及访问"></a>5.5.4 第四步——对资源的映射及访问</h2><p>Web服务器是资源服务器。它们负责发送预先创建好的内容，比如HTML页面或图片，以及运行在服务器上的资源生成程序所产生的动态内容。将内容传送给客户端之前，要将请求报文中的URI映射为Web服务器上适当的内容或内容生成器，以识别出内容的源头。</p>
<h3 id="5-5-4-1-docroot"><a href="#5-5-4-1-docroot" class="headerlink" title="5.5.4.1 docroot"></a>5.5.4.1 docroot</h3><p>Web服务器支持各种不同类型的资源映射，最简单的形式就是用请求URI作为名字来访问Web服务器文件系统中的文件。通常，Web服务器的文件系统中会有特殊的文件夹专门用于存放Web内容。这个文件夹被称为文档的根目录（documentroot或docroot）。Web服务器从请求报文中获取URI，并将其附加在文档根目录的后面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/YjRu2XQ3AOUZMPxL__thumbnail.png"
                      alt="图片"
                ></p>
<p>在配置文件httpd.conf中添加<strong>DocumentRoot行</strong>为Apache Web服务器设置文档的根目录：DocumentRoot/usr/local/httpd/files</p>
<p>服务器不能让相对URL退到docroot之外，将文件系统的其余部分暴露出来。</p>
<h4 id="5-5-4-1-1-虚拟托管的docroot"><a href="#5-5-4-1-1-虚拟托管的docroot" class="headerlink" title="5.5.4.1.1 虚拟托管的docroot"></a>5.5.4.1.1 虚拟托管的docroot</h4><p>虚拟托管的Web服务器会在同一台Web服务器上提供多个Web站点，每个站点都有自己独有的文档根目录。虚拟托管Web服务器会根据URI或Host首部的IP地址或主机名来识别要使用的正确文档根目录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/h2lrUmLfCt6WWhJe__thumbnail.png"
                      alt="图片"
                ></p>
<p>对ApacheWeb服务器来说，为每个虛拟Web站点配置一个VirtualHost块，每个虚拟服务器都要包含DocumentRoot。</p>
<h4 id="5-5-4-1-2-用户的主目录docroot"><a href="#5-5-4-1-2-用户的主目录docroot" class="headerlink" title="5.5.4.1.2 用户的主目录docroot"></a>5.5.4.1.2 用户的主目录docroot</h4><p>Docroot的另一种常见应用是在Web服务器上为人们提供私有的Web站点。通常把以斜杠和波浪号（/~）开始，后面跟着用户名的URI映射为此用户的私有文档根目录。私有docroot通常是用户主目录下那个名为public_html 的目录，也可将其配置为其他值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/mzxmQqltivIgO2q9__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="5-5-4-2-目录列表"><a href="#5-5-4-2-目录列表" class="headerlink" title="5.5.4.2 目录列表"></a>5.5.4.2 目录列表</h3><p>Web服务器可以接收对目录URL的请求，其路径可以解析为一个目录，而不是文件。对大多数Web服务器对目录URL的请求采取不同的动作：</p>
<ol>
<li>返回一个错误。</li>
<li>不返回目录，返回一个特殊的默认‘索引文件”。多数Web服务器会去查找目录中名为index.html或index.htm的文件来代表此目录，并返回这个文件的内容。在Apache Web服务器上，可以用配置指令<strong>DirectoryIndex</strong>配置要作为默认目录文件使用的文件名集合，指令按照优先顺序列出所有可以作为目录索引文件使用的文件名。</li>
</ol>
<p>例如：    DirectoryIndex  index.html  index.htm  home.html  home.htm  index.cgi</p>
<ol>
<li>扫描目录，返回一个包含目录内容的HTML页面。如果用户请求目录URI时，没有提供默认的索引文件，且没有禁止使用目录索引，很多Web服务器都会自动返回一个HTML文件，文件中会列出目录里的文件名和每个文件的大小和修改日期，还包括到每个文件的URI链接。</li>
</ol>
<p>可以通过以下Apache指令禁止自动生成目录索引文件：Options-Indexes</p>
<h3 id="5-5-4-3-动态内容资源的映射"><a href="#5-5-4-3-动态内容资源的映射" class="headerlink" title="5.5.4.3 动态内容资源的映射"></a>5.5.4.3 动态内容资源的映射</h3><p>Web服务器可以将URI映射为动态资源，也就是映射到按需动态生成内容的程序上。多数Web服务器都提供了一些机制以识别和映射动态资源，能够分辨资源什么时候是动态的，动态内容生成程序位于何处，以及如何运行那个程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QX5bpDmH8lbf0JpV__thumbnail.png"
                      alt="图片"
                ></p>
<p>Apache允许用户将URI路径名组件映射为可执行文件目录，服务器会试着去执行目录中的程序。</p>
<p>Apache允许用户用一个特殊的文件扩展名来标识可执行文件。这种方式就可以将可执行脚本放在任意目录中了。e.g.  AddHandler cgi-script.cgi （执行所有以.cgi结尾的Web资源）。</p>
<h3 id="5-5-4-4-服务器端包含项"><a href="#5-5-4-4-服务器端包含项" class="headerlink" title="5.5.4.4 服务器端包含项"></a>5.5.4.4 服务器端包含项</h3><p>很多Web服务器提供了对<strong>服务器端包含项</strong>（SSI）的支持，这是创建动态内容的一种方式。如果资源被标识为存在服务器端包含项，服务器就会发送前对资源内容进行扫描，以查找特定的模板（可以是变量名或嵌入式脚本）。可以用变量的值或可执行脚本的输出来取代特定的模板。</p>
<h3 id="5-5-4-5-访问控制"><a href="#5-5-4-5-访问控制" class="headerlink" title="5.5.4.5 访问控制"></a>5.5.4.5 访问控制</h3><p>Web服务器还可以为特定资源进行访问控制。Web服务器可以根据客户端的IP地址进行访问控制，也可以要求输入密码来访问资源。</p>
<h2 id="5-5-5-第五步——构建响应"><a href="#5-5-5-第五步——构建响应" class="headerlink" title="5.5.5 第五步——构建响应"></a>5.5.5 第五步——构建响应</h2><p>Web服务器识别出了资源，就执行请求方法中描述的动作，并返回响应报文，包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体。</p>
<h3 id="5-5-5-1-响应实体"><a href="#5-5-5-1-响应实体" class="headerlink" title="5.5.5.1 响应实体"></a>5.5.5.1 响应实体</h3><p>如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。如果有响应主体的话，响应报文中通常包括：</p>
<ol>
<li>描述响应主体MIME类型的Content-Type首部；</li>
<li>描述响应主体长度的Content-Length首部；</li>
<li>实际报文的主体内容。<h3 id="5-5-5-2-MIME类型"><a href="#5-5-5-2-MIME类型" class="headerlink" title="5.5.5.2 MIME类型"></a>5.5.5.2 MIME类型</h3></li>
</ol>
<p>Web服务器要确定响应主体的MIME类型。</p>
<ol>
<li><strong>MIME 类型</strong>（mime.types）</li>
</ol>
<p>Web服务器可用文件的扩展名来说明MIME类型。Web服务器会为每个资源扫描一个包含了所有扩展名的MIME类型的文件，以确定其MIME类型。这种最常见。</p>
<ol start="2">
<li><strong>魔法分类</strong>（Magic typing）</li>
</ol>
<p>ApacheWeb服务器可以扫描每个资源的内容，并将其与一个已知模式表（魔法文件）进行匹配，以决定每个文件的MIME类型。适用于文件没有标准扩展名的时候。</p>
<ol start="3">
<li><strong>显式分类</strong>（Explicit typing）</li>
</ol>
<p>可对Web服务器进行配置，不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型。</p>
<ol start="4">
<li><strong>类型协商</strong></li>
</ol>
<p>有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式（及相关的MIME类型）“最好”。</p>
<p>还可以通过配置Web服务器，将特定的文件与MIME类型相关联。</p>
<h3 id="5-5-5-3-重定向"><a href="#5-5-5-3-重定向" class="headerlink" title="5.5.5.3 重定向"></a>5.5.5.3 重定向</h3><p>Web服务器有时会返回重定向响应而不是成功的报文，将浏览器重定向到其他地方来执行请求。Location响应首部包含了内容的新地址或优选地址的URI。重定向可用于下列情况：</p>
<ol>
<li><strong>永久删除的资源</strong></li>
</ol>
<p>资源被移动到了新的位置，或被重新命名，有了新的URL。Web服务器可以告诉客户端资源已经被重命名了，让其可以在从新地址获取资源之前，更新书签之类的信息。状态码301 Moved Permanently就用于此类重定向。</p>
<ol start="2">
<li><strong>临时删除的资源</strong></li>
</ol>
<p>如果资源被临时移走或重命名了，服务器将客户端重定向到新的位置上去。由于重命名是临时的，所以服务器希望客户端不必对书签进行更新。状态码303 See Other以及状态码307 Temporary Redirect用于此类重定向。</p>
<ol start="3">
<li><strong>URL增强</strong></li>
</ol>
<p>服务器通常用重定向来重写URL，常用于嵌入上下文。服务器会生成一个新的包含了嵌入式状态信息的URL，并将用户重定向到这个新的URL上。客户端会跟随这个重定向信息，重新发起请求。状态码303 See Other和307 Temporary Redirect用于此类重定向。</p>
<ol start="4">
<li><strong>负载均衡</strong></li>
</ol>
<p>如果一个超载的服务器收到一条请求，可以将客户端重定向到一个负载不重的服务器上去。状态码303 See Other和307 Temporary Redirect可用于此类重定向。</p>
<ol start="5">
<li><strong>服务器关联</strong></li>
</ol>
<p>Web服务器上可能有某些用户的本地信息，可以将客户端重定向到包含了那个客户端信息的服务器上去。状态码303 See Other和307 Temporary Redirect可用于此类重定向。</p>
<ol start="6">
<li><strong>规范目录名称</strong></li>
</ol>
<p>客户端请求的URI是一个不带尾部斜线的目录名时，多数Web服务器都会将客户端重定向到一个加了斜线的URI上，这样相对链接就可以正常工作。</p>
<h2 id="5-5-6-第六步——发送响应"><a href="#5-5-6-第六步——发送响应" class="headerlink" title="5.5.6 第六步——发送响应"></a>5.5.6 第六步——发送响应</h2><p>服务器可能有很多条到各个客户端的连接，有空闲的，有向服务器发送数据，还有正在向客户端回送响应数据。</p>
<p>服务器要记录连接的状态，<strong>对非持久连接而言</strong>，服务器应该在发送了整条报文之后，关闭自己这一端的连接；<strong>对持久连接来说</strong>，连接可能仍保持打开状态，服务器要正确地计算Content-Length首部，客户端才会知道响应什么时候结束。</p>
<h2 id="5-5-7-第七步——记录日志"><a href="#5-5-7-第七步——记录日志" class="headerlink" title="5.5.7 第七步——记录日志"></a>5.5.7 第七步——记录日志</h2><p>最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务。大多数Web服务器都提供了几种日志配置格式。更多细节请参见第21章。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>05-Web服务器</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>04-链接管理</title>
    <url>/2021/01/23/note/HTTP/04-%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="4-1-TCP链接"><a href="#4-1-TCP链接" class="headerlink" title="4.1 TCP链接"></a>4.1 TCP链接</h2><h3 id="4-1-1-TCP的可靠数据管道"><a href="#4-1-1-TCP的可靠数据管道" class="headerlink" title="4.1.1 TCP的可靠数据管道"></a>4.1.1 TCP的可靠数据管道</h3><p>HTTP连接实际，上就是TCP连接和一些使用连接的规则，TCP为HTTP提供了一条可靠的比特传输管道。</p>
<h3 id="4-1-2-TCP流、IP分组"><a href="#4-1-2-TCP流、IP分组" class="headerlink" title="4.1.2 TCP流、IP分组"></a>4.1.2 TCP流、IP分组</h3><p>TCP的数据是通过IP分组（IP 数据报）的小数据块来发送的。安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/EcJv4cg2UJABtNpp.png"
                      alt="图片"
                ></p>
<p>TCP段是由IP分组承载。每个IP分组中包括：</p>
<pre><code>    1. 一个IP分组首部，包含源和目的IP地址、长度和其他一些标记（通常为20字节）；
    2. 一个TCP段首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值。（通常为20字节）；
    3. 一个TCP数据块（0个或多个字节）。</code></pre>
<h3 id="4-1-3-TCP连接的正确运行"><a href="#4-1-3-TCP连接的正确运行" class="headerlink" title="4.1.3 TCP连接的正确运行"></a>4.1.3 TCP连接的正确运行</h3><p>计算机随时都有几条TCP连接处于打开状态，TCP 通过端口号来保持连接的正确运行。</p>
<p>TCP连接通过4个值来识别：&lt;<strong>源IP地址、源端口号、目的IP地址、目的端口号</strong>&gt;。这4个值唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/46GDogLOzoqcLen7.png"
                      alt="图片"
                ></p>
<h3 id="4-1-4-TCP套接字编程"><a href="#4-1-4-TCP套接字编程" class="headerlink" title="4.1.4 TCP套接字编程"></a>4.1.4 TCP套接字编程</h3><p>操作系统提供了一些操纵其TCP连接的工具。我们来看一个TCP编程接口。这个套接字API向HTTP程序员隐藏了TCP和IP的所有细节。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/qv4I1NjxFUOC6xh8.png"
                      alt="图片"
                ></p>
<p>套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间的分段和重装细节。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/vAn3ica3x7NtExWZ.png"
                      alt="图片"
                ></p>
<p>从Web服务器等待连接（S4）开始。客户端根据URL判定出IP地址和端口号，并建立一条到服务器的TCP连接（C3）。</p>
<p>建立连接后，客户端就会发送HTTP请求（C5），服务器读取请求（S6）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（S7），并将数据写回客户端。客户端读取数据（C6），并对响应数据进行处理（C7）。</p>
<h2 id="4-2-TCP性能"><a href="#4-2-TCP性能" class="headerlink" title="4.2 TCP性能"></a>4.2 TCP性能</h2><h3 id="4-2-1-HTTP事务的时延"><a href="#4-2-1-HTTP事务的时延" class="headerlink" title="4.2.1 HTTP事务的时延"></a>4.2.1 HTTP事务的时延</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/N1zHevdCojb7owBy.png"
                      alt="图片"
                ></p>
<p>与建立TCP连接、传输请求、响应报文的时间相比，事务处理可能是很短的，除非客户端或服务器超载，或正处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的。</p>
<p>HTTP事务的时延原因：</p>
<p>（1）<strong>DNS解析</strong>，但大多数HTTP客户端都有一个小的DNS缓存，用来保存近期所访问站点的IP地址，可以很快地将主机名解析出来。</p>
<p>（2）客户端会向服务器发送一条TCP连接请求，并等待服务器回送请求接受应答。每条新的<strong>TCP连接的连接建立时延</strong>，最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会很高。</p>
<p>（3）连接建立后，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器从TCP连接中<strong>读取请求报文</strong>，并<strong>处理请求报文</strong>，因特网<strong>传输请求报文</strong>、服务器处理请求报文都需要时间。</p>
<p>（4）Web服务器会<strong>回送HTTP响应</strong>，这些TCP网络时延的大小取决于<strong>硬件速度</strong>、<strong>网络和服务器的负载</strong>，<strong>请求和响应报文的尺寸</strong>，以及客户端和服务器之间的<strong>距离</strong>。<strong>TCP协议的技术复杂性</strong>也会对时延产生巨大的影响。</p>
<h3 id="4-2-2-TCP相关时延"><a href="#4-2-2-TCP相关时延" class="headerlink" title="4.2.2 TCP相关时延"></a>4.2.2 TCP相关时延</h3><pre><code>1. TCP连接建立握手，
2. 用于捎带确认的TCP延迟确认算法
3. TCP慢启动拥塞控制；
4. 数据聚集的Nagle算法；
5. TIME_WAIT时延和端口耗尽。</code></pre>
<h4 id="4-2-2-1-TCP连接的握手时延"><a href="#4-2-2-1-TCP连接的握手时延" class="headerlink" title="4.2.2.1 TCP连接的握手时延"></a>4.2.2.1 TCP连接的握手时延</h4><p>建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接用来传送少量数据，这些交换过程就会降低HTTP的性能。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/McjEXqUcLmE8y4Qe.png"
                      alt="图片"
                ></p>
<p><strong>TCP连接握手步骤:</strong></p>
<pre><code>1. 请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40 ~60个字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求（参见a）。
2. 如果服务器接受连接，会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受（参见b）。
3. 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图c）。现代的TCP栈都允许客户端在这个确认分组中发送数据。</code></pre>
<p>通常HTTP事务不会交换太多数据，SYN/SYN+ACK握手会产生一个可测量的时延。TCP连接的ACK分组通常都足够承载整个HTTP请求报文，而且很多HTTP服务器响应报文都可以放人一个IP分组中去。最后导致小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。</p>
<h4 id="4-2-2-2-延迟确认"><a href="#4-2-2-2-延迟确认" class="headerlink" title="4.2.2.2 延迟确认"></a>4.2.2.2 延迟确认</h4><p>每个TCP段有一个序列号和数据完整性校验和，来确保数据的成功传输。接收者收到完好的段时，会向发送者回送确认分组。如果发送者没有在指定时间内收到确认信息，发送者就认为分组已破坏或损毁，会重发数据。</p>
<p>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“<strong>捎带</strong>”。TCP将返回的确认信息与输出的数据分组结合在一起。</p>
<p>为增加确认报文找到同向传输数据分组的可能，TCP栈实现了一种<strong>“延迟确认”算法，</strong>会在一个特定的窗口时间（通常100 ~ 200毫秒）内将输出确认存放在缓冲区中，以寻找能捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求-应答行为，导致当希望有相反方向回传分组的时候，偏偏没有那么多。</p>
<p>延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<h4 id="4-2-2-3-TCP慢启动"><a href="#4-2-2-3-TCP慢启动" class="headerlink" title="4.2.2.3 TCP慢启动"></a>4.2.2.3 TCP慢启动</h4><p>TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动（slow start），防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。HTTP事务不能一次将所有分组都发送出去，必须发送一个分组，等待确认，才可以发送两个分组，再次被确认，就可以发送四个分组，以此类推。这种方式被称为“打开拥塞窗口”。</p>
<p>由于这种拥塞控制特性，新连接的传输速度会比已经交换过数据的“已调谐”连接慢。</p>
<h4 id="4-2-2-4-Nagle算法与TCP-NODELAY"><a href="#4-2-2-4-Nagle算法与TCP-NODELAY" class="headerlink" title="4.2.2.4 Nagle算法与TCP_NODELAY"></a>4.2.2.4 Nagle算法与TCP_NODELAY</h4><p>TCP有数据流接口，每个TCP段中都至少装载了40个字节的标记和首部，所以如果TCP发送了大量包含少量数据的分组，网络的性能会下降。</p>
<p><strong>Nagle算法</strong>：试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。Nagle算法鼓励发送全尺寸的段，只有当所有其他分组都被确认之后，才发送非全尺寸的分组。如果其他分组仍在传输中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p>
<p><strong>Nagle算法缺陷</strong>：首先，小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题，Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100 ~ 200毫秒。</p>
<p>HTTP应用程序通常设置参数TCP_NODELAY，禁用Nagle算法，这样须确保会向TCP写入大块的数据，不会产生一堆小分组。</p>
<h4 id="4-2-2-5-TIME-WAIT累积与端口耗尽"><a href="#4-2-2-5-TIME-WAIT累积与端口耗尽" class="headerlink" title="4.2.2.5 TIME__WAIT累积与端口耗尽"></a>4.2.2.5 TIME__WAIT累积与端口耗尽</h4><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，维持的时间，是最大分段使用期的两倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。这也防止之前连接的复制分组插入了具有相同连接值的新TCP流，会破坏TCP数据。</p>
<p>但在性能基准测试时，TIME__WAIT 也限制了可用的连接值组合。因为在只有一个客户端和一台Web服务器的情况下，构建一条TCP连接的4个值，只有源端口号可以随意改变，客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限，而且在2MSL秒内连接是无法重用的，连接率就被限制了。</p>
<p>可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</p>
<p>即使没有遇到端口耗尽问题，也要小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会减缓。</p>
<h2 id="4-3-HTTP链接的处理"><a href="#4-3-HTTP链接的处理" class="headerlink" title="4.3 HTTP链接的处理"></a>4.3 HTTP链接的处理</h2><h3 id="4-3-1-connection首部"><a href="#4-3-1-connection首部" class="headerlink" title="4.3.1 connection首部"></a>4.3.1 connection首部</h3><p>Connection首部有3种类型的标签：</p>
<pre><code>1. HTTP 首部字段名，列出了只与此连接有关的首部；
2. 任意标签值，用于描述此连接的非标准选项；
3. 值close，说明操作完成之后需关闭这条持久连接。</code></pre>
<p>如果连接标签中包含了HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发，在将报文转发出去之前，删除Connection所列出的首部字段以及自身。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/MWKLFwHwkjmuqWQY.png"
                      alt="图片"
                ></p>
<h3 id="4-3-2-串行事务处理时延"><a href="#4-3-2-串行事务处理时延" class="headerlink" title="4.3.2 串行事务处理时延"></a>4.3.2 串行事务处理时延</h3><p>串行加载缺点：1、叠加链接时延和慢启动时延。2、有些浏览器需要完全加载后才显示。</p>
<p>新的链接方法：</p>
<pre><code>1. 并行连接：通过多条TCP连接发起并发的HTTP请求。
2. 持久连接：重用TCP连接，以消除连接及关闭时延。
3. 管道化连接：通过共享的TCP连接发起并发的HTTP请求。
4. 复用的连接：交替传送请求和响应报文（实验阶段）。</code></pre>
<h2 id="4-4-并行链接"><a href="#4-4-并行链接" class="headerlink" title="4.4 并行链接"></a>4.4 并行链接</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/E02QnUnHmeOPbogJ.png"
                      alt="图片"
                ></h2><p>并行链接的优点：</p>
<pre><code>1. 每个事务都有自己的连接，装载是并行的，连接的时延也是重叠的。（嵌入的组件不一定都在同一台Web服务器上，可以同多台服务器建立并行的连接）。
2. 可以让用户感觉更快。</code></pre>
<p>并行链接的缺点：</p>
<pre><code>1. 如果并行加载多个对象，每个对象竞争有限的带宽，都会以较慢的速度按比例加载。
2. 打开大量连接会消耗很多内存资源，从造成服务器、代理性能的下降。
3. 由于TCP慢启动特性，每条新连接的性能都会有所降低。</code></pre>
<p>浏览器一般会将并行连接的总数限制为4个。服务器可以随意关闭来自特定客户端的超量连接。</p>
<h2 id="4-5-持久链接"><a href="#4-5-持久链接" class="headerlink" title="4.5 持久链接"></a>4.5 持久链接</h2><p><strong>站点本地性</strong>（site locality）：Web客户端经常打开到同一个站点的连接。因此，初始化了对某服务器HTTP请求的应用程序可能会对那台服务器不久发起更多的请求。</p>
<p><strong>持久连接</strong>：HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接，直到客户端或服务器决定将其关闭为止。</p>
<p>优点：避开缓慢的连接建立阶段；避免慢启动的拥塞适应阶段。</p>
<p>缺点：累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/RUOT3rgreZZqeDQ5.png"
                      alt="图片"
                ></p>
<p>持久连接与并行连接配合使用是高效的方式。通常，Web应用程序打开少量的并行连接，其中的每一个都是持久连接。</p>
<p>持久连接有两种类型：比较老的**”keep-alive”连接<strong>，现代的</strong>“persistent”连接**</p>
<h3 id="4-5-1-HTTP-1-0-keep-alive连接"><a href="#4-5-1-HTTP-1-0-keep-alive连接" class="headerlink" title="4.5.1 HTTP/1.0+   keep-alive连接"></a>4.5.1 HTTP/1.0+   keep-alive连接</h3><p>客户端通过包含Connection：Keep-Alive首部请求，将一条连接保持在打开状态。如果服务器可以，就在响应中包含相同的首部，否则说明服务器不支keep-alive，会在发回响应报文之后关闭连接。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，有多部件媒体类型，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>Keep-Alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的行为：</p>
<pre><code>1. 参数**timeout**在Keep-Alive响应首部发送，服务器希望将连接保持在活跃状态的时间。
2. 参数**max**在Keep-Alive响应首部发送，服务器希望为多少个事务保持此连接的活跃状态。
3. Keep-Alive首部支持任意未经处理的属性，用于诊断和调试。语法为name[=value]。</code></pre>
<h4 id="4-5-1-1-哑代理"><a href="#4-5-1-1-哑代理" class="headerlink" title="4.5.1.1 哑代理"></a>4.5.1.1 哑代理</h4><p>老的或简单的代理都是<strong>盲中继</strong>（blind relay），只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/EBTdTrTeWy3Jfd15.png"
                      alt="图片"
                ></p>
<p>后果：客户端和服务器都认为它们在进行keep-alive对话，但代理等待源端服务器关闭连接，源端服务器认为连接保持在打开状态，所以不会去关闭连接，反而立即转向下一条请求。而代理并不认为同一条连接上会有其他请求，<strong>请求被忽略</strong>。这会使浏览器<strong>一直处于挂起状态</strong>，直到客户端或服务器将连接超时，并将其关闭为止。</p>
<p>有几个不能作为Connection首部值列出，包括Proxy-Authenticate、Proxy-Connection、</p>
<p>Transfer-Encoding和Upgrade。</p>
<h4 id="4-5-1-2-插入Proxy-Connection解决哑代理"><a href="#4-5-1-2-插入Proxy-Connection解决哑代理" class="headerlink" title="4.5.1.2 插入Proxy-Connection解决哑代理"></a>4.5.1.2 插入Proxy-Connection解决哑代理</h4><p>浏览器向代理发送非标准的Proxy-Connection扩展首部，而不是官方支持的Connection首部。如果代理是盲中继，将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部，否则就用Connection首部取代Proxy-Connection首部，然后将其发送给服务器。</p>
<p>对有多层次代理的情况，Proxy-Connection 仍然无法解决问题。</p>
<h3 id="4-5-2-HTTP-1-1-持久连接"><a href="#4-5-2-HTTP-1-1-持久连接" class="headerlink" title="4.5.2 HTTP/1.1  持久连接"></a>4.5.2 HTTP/1.1  持久连接</h3><p><strong>持久连接（</strong>persistent connection），在默认情况下是激活的。除非向报文中显式地添加一个Connection：close首部。但客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。</p>
<h2 id="4-6-管道化连接"><a href="#4-6-管道化连接" class="headerlink" title="4.6 管道化连接"></a>4.6 管道化连接</h2><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>。在响应到达之前，可以将多条请求放入队列。当第一条请求流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/SmB3DWYPPxzXolFI.png"
                      alt="图片"
                ></p>
<p>管道化连接的限制：</p>
<ol>
<li>HTTP客户端确认是持久连接，才能使用管道。</li>
<li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li>
<li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。<h2 id="4-7-关闭连接"><a href="#4-7-关闭连接" class="headerlink" title="4.7 关闭连接"></a>4.7 关闭连接</h2></li>
</ol>
<h3 id="4-7-1-任意解除连接"><a href="#4-7-1-任意解除连接" class="headerlink" title="4.7.1 任意解除连接"></a>4.7.1 任意解除连接</h3><p>所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接，但也有可能出错，对管道化持久连接来说，这种情形是很常见的。</p>
<h3 id="4-7-2-Content-Length及截尾操作"><a href="#4-7-2-Content-Length及截尾操作" class="headerlink" title="4.7.2 Content-Length及截尾操作"></a>4.7.2 Content-Length及截尾操作</h3><p>每条HTTP响应都应该有Content-Length首部。一些老的HTTP服务器会省略或者包含错误的长度指示，这就要依赖服务器发出的连接关闭来说明数据的真实末尾。</p>
<p>客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与Content-Length并不匹配或没有Content-Length时，接收端应该质疑长度的正确性。</p>
<p>如果接收端是个缓存代理，不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能），而是原封不动地转发出去，以维护语义的透明性。</p>
<h3 id="4-7-3-连接关闭容限、重试、幂等性"><a href="#4-7-3-连接关闭容限、重试、幂等性" class="headerlink" title="4.7.3 连接关闭容限、重试、幂等性"></a>4.7.3 连接关闭容限、重试、幂等性</h3><p>如果在客户端执行事务的过程中，传输连接关闭了，除非事务处理会带来副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，源端服务器关闭连接，就会留下大量未处理的请求，需要重新调度。</p>
<p>如果一个事务，不管是执行几次，得到的结果都相同，这个事务就是<strong>幂等</strong>的。要发送一条非幂等请求，需要等待来自前一条请求的响应状态。</p>
<p>用户Agent代理一定不能自动重试非幂等方法或序列。比如post订单，大多数浏览器都会提供一个对话框，询问用户是否希望再次发起事务处理。</p>
<h3 id="4-7-4-正常关闭连接"><a href="#4-7-4-正常关闭连接" class="headerlink" title="4.7.4 正常关闭连接"></a>4.7.4 正常关闭连接</h3><h4 id="4-7-4-1-完全关闭与半关闭"><a href="#4-7-4-1-完全关闭与半关闭" class="headerlink" title="4.7.4.1 完全关闭与半关闭"></a>4.7.4.1 完全关闭与半关闭</h4><p>应用程序可以关闭TCP输入和输出信道中的任意一个或两者。</p>
<p>套接字调用<strong>close（）</strong>将TCP连接的输入输出信道都关闭了，称作“<strong>完全关闭</strong>”，如图a所示。</p>
<p>套接字调用<strong>shutdown（）</strong>单独关闭输入或输出信道，这被称为<strong>“半关闭”</strong>，如图b所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/HqfJNF2eliisLFNQ.png"
                      alt="图片"
                ></p>
<h4 id="4-7-4-2-TCP关闭及重置错误"><a href="#4-7-4-2-TCP关闭及重置错误" class="headerlink" title="4.7.4.2 TCP关闭及重置错误"></a>4.7.4.2 TCP关闭及重置错误</h4><p>当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误。</p>
<p>关闭连接的输出信道总是安全的。连接另一端的对等实体会在从其缓冲区中读出所有数据之后收到一条通知，说明流结束了，知道连接关闭了。</p>
<p>关闭连接的输入信道比较危险，除非知道另一端不再发送数据。如果向已关闭的输入信道发送数据，操作系统会回送一条TCP“<strong>连接被对端重置</strong>”报文，删除对端还未读取的所有缓存数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DZvhKCeOgaAwmwKW.png"
                      alt="图片"
                ></p>
<h4 id="4-7-4-3-正常关闭"><a href="#4-7-4-3-正常关闭" class="headerlink" title="4.7.4.3 正常关闭"></a>4.7.4.3 正常关闭</h4><p>应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都知道不再发送数据（比如关闭输出信道）后，连接就会被完全关闭，不会有重置的危险。</p>
<p>但不无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>04-链接管理</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>06-代理</title>
    <url>/2021/01/23/note/HTTP/06-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="6-1-Web的-中间实体"><a href="#6-1-Web的-中间实体" class="headerlink" title="6.1 Web的 中间实体"></a>6.1 Web的 中间实体</h1><p>Web上的代理服务器是代表客户端完成事务处理的中间人。HTTP的代理服务器既是Web服务器又是Web客户端。</p>
<h1 id="6-2-私有和共享代理"><a href="#6-2-私有和共享代理" class="headerlink" title="6.2 私有和共享代理"></a>6.2 私有和共享代理</h1><ol>
<li><strong>公共代理</strong></li>
</ol>
<p>多数代理都是公共的共享代理。集中式代理的费效比更高，容易管理。某些代理应用，如高速缓存代理服务器，会利用用户间共同的请求，汇入同一个代理服务器的用户越多，就越有用。</p>
<ol start="2">
<li><strong>私有代理</strong></li>
</ol>
<p>单个客户端专用的代理被称为私有代理。并不常见，常用于直接运行在客户端计算机上的时候。有些浏览器辅助产品或一些ISP服务，会在用户的PC上直接运行一些小型的代理，以便扩展浏览器特性，提高性能，或为免费ISP服务提供主机广告。</p>
<h1 id="6-3-代理与网关的对比"><a href="#6-3-代理与网关的对比" class="headerlink" title="6.3 代理与网关的对比"></a>6.3 代理与网关的对比</h1><p>代理连接的是两个或多个使用相同协议的应用程序，而网关连接的则是两个或多个使用不同协议的端点，客户端同样可以通过它完成与服务器之间的事务处理。</p>
<p>实际上，代理和网关之间的区别很模糊。由于浏览器和服务器实现的是不同版本的HTTP，代理也经常要做一些协议转换工作。而商业化的代理服务器也会实现网关的功能来支持SSL安全协议、SOCKS防火墙、FTP访问，以及基于Web的应用程序。</p>
<h1 id="6-4-代理的作用"><a href="#6-4-代理的作用" class="headerlink" title="6.4 代理的作用"></a>6.4 代理的作用</h1><p>代理服务器可以改善安全性，提高性能，节省费用，可以看到并接触到所有流过的HTTP流量，所以代理可以监视流量并对其进行修改，以实现很多有用的增值Web服务。比如：</p>
<ol>
<li><strong>儿童过滤器</strong></li>
</ol>
<p>可以利用过滤器代理来阻止学生访问成人内容。</p>
<ol start="2">
<li><strong>文档访问控制</strong></li>
</ol>
<p>可以用代理服务器在大量Web服务器和Web资源之间实现统一的访问控制策略，创建审核跟踪机制。这在大型企业环境或其他分布式机构中是很有用的。</p>
<p>在集中式代理服务器上可以对所有访问控制功能进行配置，而无需在众多由不同组织管理、不同厂商制造、使用不同模式的Web服务器上进行经常性的访问控制升级。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/pqBy6kmLeBWZV7aG__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="3">
<li><strong>安全防火墙</strong></li>
</ol>
<p>使用代理服务器来提高安全性。代理服务器会在网络中的单一安全节点上限制应用层协议的数据流入或流出一个组织，还可以提供用来消除病毒的Web和E-mail代理使用的那种挂钩程序，以便对流量进行详细的检查。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/tDT5ij0kvoywHIjQ__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="4">
<li><strong>Web缓存</strong></li>
</ol>
<p>Web代理缓存维护了常用文档的本地副本，并按需提供，以减少慢且贵的因特网通信。</p>
<ol start="5">
<li><strong>反向代理</strong></li>
</ol>
<p>被称为替代物（surrogate）或反向代理（re-verseproxy）的代理接收发给Web服务器的真实请求，但不同的是，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。</p>
<p>反向代理能提高访问慢速Web服务器上公共内容时的性能。在这种配置中，反向代理称为服务器加速器（server accelerator）。还可以将替代物与内容路由功能配合使用，以创建按需复制内容的分布式网络。</p>
<ol start="6">
<li><strong>内容路由器</strong></li>
</ol>
<p>内容路由器可以根据因特网流量状况以及内容类型将请求导向特定的Web服务器。也可以用来实现各种服务级的请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/MavD3X6KgAr6iSp7__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="7">
<li><strong>转码器</strong></li>
</ol>
<p>代理服务器在将内容发送给客户端之前，可以修改内容的主体格式。在这些数据表示法之间进行的透明转换被称为<strong>转码</strong>（transcoding）。</p>
<ol start="8">
<li><strong>匿名者</strong></li>
</ol>
<p>匿名者代理会主动从HTTP报文中删除身份特性（比如客户端IP地址、From首部、Referer首部、cookie、URI的会话ID），从而提供高度的私密性和匿名性。</p>
<h1 id="6-5-代理会去往何处"><a href="#6-5-代理会去往何处" class="headerlink" title="6.5 代理会去往何处"></a>6.5 代理会去往何处</h1><h2 id="6-5-1-代理服务器的部署"><a href="#6-5-1-代理服务器的部署" class="headerlink" title="6.5.1 代理服务器的部署"></a>6.5.1 代理服务器的部署</h2><p>根据其目标用途，将代理放在任意位置。部署代理服务器的几种方式：</p>
<ol>
<li><strong>出口代理</strong></li>
</ol>
<p>将代理固定在本地网络的出口点，以便控制本地网络与大型因特网之间的流量。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/C514fsJkpTUSr3Mj__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="2">
<li><strong>访问（入口）代理</strong></li>
</ol>
<p>常被放在ISP访问点上，用以处理来自客户的聚合请求。ISP 使用缓存代理来存储常用文档的副本，以提高用户的下载速度，降低因特网带宽耗费。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/FkNHex993CoqIdQy__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="3">
<li><strong>反向代理</strong></li>
</ol>
<p>通常被部署在网络边缘，在Web服务器之前，在那里可以处理所有传送给Web服务器的请求，并只在必要时向Web服务器请求资源。可以提高Web服务器的安全特性，或者将快速的Web服务器缓存放在较慢的服务器之前，以提高性能。反向代理通常会直接冒用Web服务器的名字和IP地址，请求就会被发送给代理而不是服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/gaArfFB4Cn2B7FQL__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="4">
<li><strong>网络交换代理</strong></li>
</ol>
<p>可以将具有足够处理能力的代理放在网络之间的因特网对等交换点上，通过缓存来减轻因特网节点的拥塞，并对流量进行监视。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/pXAesc94BLzDz3HV__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="6-5-2-代理的层次结构"><a href="#6-5-2-代理的层次结构" class="headerlink" title="6.5.2 代理的层次结构"></a>6.5.2 代理的层次结构</h2><p>通过<strong>代理层次结构</strong>（proxy hierarchy）将代理级联起来。在代理的层次结构中，会将报文从一个代理传给另一个代理，直到最终抵达原始服务器为止（然后通过代理传回给客户端）。</p>
<p>下一个入口（inbound）代理（靠近服务器）被称为父代理，下一个出口（outbound）代理（靠近客户端）被称为子代理。</p>
<h4 id="6-5-2-1-代理层次结构的内容路由"><a href="#6-5-2-1-代理层次结构的内容路由" class="headerlink" title="6.5.2.1 代理层次结构的内容路由"></a>6.5.2.1 代理层次结构的内容路由</h4><p>层次不一定是静态的。代理服务器可以根据众多因素，将报文转发给一个不断变化的代理服务器和原始服务器集。</p>
<ol>
<li><strong>负载均衡</strong></li>
</ol>
<p>子代理可能会根据当前父代理上的工作负载级别来决定如何选择一个父代理，以均衡负载。</p>
<ol start="2">
<li><strong>地理位置附近的路由</strong></li>
</ol>
<p>子代理可能会选择负责原始服务器所在物理区域的父代理。</p>
<ol start="3">
<li><strong>协议/类型路由</strong></li>
</ol>
<p>子代理可能会根据URI将报文转发到不同的父代理和原始服务器上去。某些特定类型的URI可能要通过一些特殊的代理服务器转发请求，以便进行特殊的协议处理。</p>
<ol start="4">
<li><strong>基于订购的路由</strong></li>
</ol>
<p>如果发布者为高性能服务额外付费了，它们的URI就会被转发到大型缓存或压缩引擎上去，以提高性能。</p>
<h2 id="6-5-3-代理是如何获取流量的"><a href="#6-5-3-代理是如何获取流量的" class="headerlink" title="6.5.3 代理是如何获取流量的"></a>6.5.3 代理是如何获取流量的</h2><p>客户端通常会直接与Web服务器进行通信，有四种常见方式可以使客户端流量流向代理：</p>
<ol>
<li><strong>修改客户端（下一节）</strong></li>
</ol>
<p>很多Web客户端，都支持手工和自动的代理配置。如果将客户端配置为使用代理服务器，客户端就会将HTTP请求有意地直接发送给代理，而不是原始服务器。</p>
<ol start="2">
<li><strong>修改网络</strong></li>
</ol>
<p>在客户端不知道或没有参与的情况下，拦截网络流量并将其导人代理。这种拦截通常都依赖于监视HTTP流量的交换设备及路由设备。这种代理被称为拦截（intercepting）代理。</p>
<ol start="3">
<li><strong>修改DNS的命名空间</strong></li>
</ol>
<p>放在Web服务器之前的代理服务器替代物，会直接假扮Web服务器的名字和IP地址。通过手工编辑DNS名称列表，或用特殊的动态DNS服务器根据需要来确定适当的代理或服务器。有时在安装过程中，真实服务器的IP地址和名称被修改了，替代物得到的会是之前的地址和名称。</p>
<ol start="4">
<li><strong>修改Web服务器</strong></li>
</ol>
<p>将某些Web服务器配置为向客户端发送一条HTTP重定向命令（响应码305），将客户端请求重定向到一个代理上去。收到重定向命令后，客户端会与代理进行通信。</p>
<h1 id="6-6-客户端的代理设置"><a href="#6-6-客户端的代理设置" class="headerlink" title="6.6 客户端的代理设置"></a>6.6 客户端的代理设置</h1><p>所有现代的Web浏览器都允许用户对代理的使用进行配置，其中包括以下几种：</p>
<ol>
<li><strong>手工配置</strong></li>
</ol>
<p>显式地设置要使用的代理。不同浏览器都有不同的方式来进行手工配置的修改，但其思想是一样的：为代理指定主机和端口。</p>
<p>手工代理配置很简单但有些死板。只能为所有内容指定唯一一个代理服务器，且不支持故障转移，还会给大型组织带来管理问题。如果配置过的浏览器基数很大，那么需要进行修改的时候，重新配置每个浏览器是非常困难，甚至不可能。</p>
<ol start="2">
<li><strong>预先配置浏览器</strong></li>
</ol>
<p>浏览器厂商或发行商会在将浏览器发送给其客户之前预先对浏览器（或所有其他Web客户端）的代理设置进行手工配置。</p>
<ol start="3">
<li><strong>代理的自动配置</strong>（Proxy Auto-Configuration，PAC）</li>
</ol>
<p>提供一个 URI，指向一个代理自动配置文件（PAC），客户端取回这个JavaScript文件，文件都必须定义一个名为FindProxyForURL（url，host）的函数，用来计算访问URI时使用的适当的代理服务器。函数的返回值可以是表6-1列出的任意值。</p>
<p>PAC文件的后缀通常是.pac，MIME类型通常是application/x-ns-proxy-autoconfig。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/AAivIeKbOTQBj2Rk__thumbnail.png"
                      alt="图片"
                ></p>
<ol start="4">
<li><strong>WPAD的代理发现</strong></li>
</ol>
<p>有些浏览器支持<strong>Web代理自动发现协议</strong>（Web Proxy Autodiscovery Protocol，WPAD），WPAD协议的算法会使用发现机制的逐级上升策略自动地为浏览器查找合适的PAC文件。</p>
<p>WPAD会使用一系列的资源发现技术来判定适当的PAC文件。WPAD会一个接一个地对每种技术进行尝试，直到成功为止。当前的WPAD协议规范按顺序定义了下列技术：</p>
<ol>
<li>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）；</li>
<li>服务定位协议（Service Location Protocol，SLP）；</li>
<li>DNS知名主机名；</li>
<li>DNS SRV记录；</li>
<li>TXT记录中的DNS服务URI。<h1 id="6-7-代理请求的问题"><a href="#6-7-代理请求的问题" class="headerlink" title="6.7 代理请求的问题"></a>6.7 代理请求的问题</h1></li>
</ol>
<h2 id="6-7-1-代理URI与服务器URI的不同"><a href="#6-7-1-代理URI与服务器URI的不同" class="headerlink" title="6.7.1 代理URI与服务器URI的不同"></a>6.7.1 代理URI与服务器URI的不同</h2><p>客户端向Web服务器发送请求时，请求行中只包含部分URI（没有方案、主机或端口），向代理发送请求时，请求行中则包含完整的URI。</p>
<p>因为在原始的HTTP设计中，客户端直接与单个服务器进行对话，不存在虚拟主机，也没有为代理制定什么规则，服务器知道自己的主机名和端口，从而为了避免发送冗余信息。</p>
<p>代理出现之后，需要知道目标服务器的名称。基于代理的网关要知道URI的方案才能连接到FTP资源和其他方案上。因此HTTP/1.0要求代理请求发送完整的URI，但它为服务器请求保留部分URI的形式。</p>
<p>在显式地配置客户端代理设置的情况下，客户端知道将部分URI发送给服务器，将完整URI发送给代理。</p>
<h2 id="6-7-2-虚拟主机的问题"><a href="#6-7-2-虚拟主机的问题" class="headerlink" title="6.7.2 虚拟主机的问题"></a>6.7.2 虚拟主机的问题</h2><p>虚拟主机Web服务器会在很多Web站点间共享同一个物理Web服务器。和代理缺少方案/主机/端口出现的问题相似，但解决方法却有所不同：</p>
<ol>
<li>显式的代理要求在请求报文中使用完整URI来解决题；</li>
<li>虚拟主机Web服务器要求使用Host首部来承载主机和端口信息。<h2 id="6-7-3-拦截代理会收到部分URI"><a href="#6-7-3-拦截代理会收到部分URI" class="headerlink" title="6.7.3 拦截代理会收到部分URI"></a>6.7.3 拦截代理会收到部分URI</h2></li>
</ol>
<p>只要客户端正确地实现了HTTP，它们就会在请求中包含完整的URI，发送给经过显式配置的代理。这样解决了部分问题，</p>
<p>但客户端并不总是知道它是在和代理进行对话，因为有些代理对客户端可能是不可见的。在这两种情况下，客户端都会认为它在与Web服务器进行对话，不会发送完整的URI:</p>
<ol>
<li><strong>反向代理</strong>。通过假扮服务器的主机名或IP地址来做到这一点,客户端无法区分反向代理和Web服务器，因此它会发送部分URI。</li>
<li><strong>拦截代理</strong>。它会拦截从客户端发往服务器的请求，并提供一个缓存响应，或对其进行转发。拦截代理拦截了从客户端到服务器的流量，所以它会收到发送给Web服务器的部分URI。拦截代理可能也会拦截客户端到代理的流量，在这种情况下，可能会收到完整URI，需要对其进行处理。由于显式代理的通信端口通常与HTTP使用的端口有所不同（通常是8080而不是80），而且拦截代理通常只对端口80进行拦截，所以这种情况并不会经常发生。<h2 id="6-7-4-代理既可以处理代理请求，也可以处理服务器请求"><a href="#6-7-4-代理既可以处理代理请求，也可以处理服务器请求" class="headerlink" title="6.7.4 代理既可以处理代理请求，也可以处理服务器请求"></a>6.7.4 代理既可以处理代理请求，也可以处理服务器请求</h2></li>
</ol>
<p>由于将流量重定向到代理服务器的方式有所不同，通用的代理服务器既应该支持请求报文中的完整URI，也应该支持部分URI。如果是显式的代理请求，代理就应该使用完整URI，如果是Web服务器请求，就应该使用部分URI和虚拟Host首部。使用完整和部分URI的规则如下所示:</p>
<ol>
<li>如果提供的是完整URI，代理就应该使用这个完整URI。</li>
<li>如果提供的是部分URI，但有Host首部，就用Host首部来确定原始服务器的名字和端口号。</li>
<li>如果提供的是部分URI，且没有Host首部，就要用其他方法来确定原始服务器：<ol>
<li>如果代理是代表原始服务器的替代物，用真实服务器的地址和端口号来配置代理；</li>
<li>如果流量被拦截了，且拦截者也可以提供原始的IP地址和端口，就用拦截技术提供的；</li>
<li>如果所有方法都失败了，就必须返回一条错误报文（通常是建议用户升级到支持Host首部的现代浏览器）。<h2 id="6-7-5-转发过程中对URI的修改"><a href="#6-7-5-转发过程中对URI的修改" class="headerlink" title="6.7.5 转发过程中对URI的修改"></a>6.7.5 转发过程中对URI的修改</h2></li>
</ol>
</li>
</ol>
<p>代理服务器要在转发报文时修改请求URI，可能造成互操作性问题。代理服务器不能强制实现严格协议一致性，HTTP规范禁止一般的拦截代理在转发URI时重写其绝对路径部分。唯一的例外是可以用“/”来取代空路径。</p>
<h2 id="6-7-6-没有显式代理时URI的解析"><a href="#6-7-6-没有显式代理时URI的解析" class="headerlink" title="6.7.6 没有显式代理时URI的解析"></a>6.7.6 没有显式代理时URI的解析</h2><p>没有代理时，浏览器会获取输入的URI，尝试着寻找相应的IP地址。</p>
<p>如果找到主机名，浏览器会尝试相应的IP地址直到获得成功的连接为止。如果没有找到主机，很多浏览器会尝试着提供某种主机名自动“扩展”机制：</p>
<ol>
<li>很多浏览器尝试加入前缀www.和后缀.com，以防用户只输入了Web站点名的中间部分。</li>
<li>有些浏览器甚至会将未解析出来的URI传递给第三方站点，让其尝试着校正拼写错误，并给出一些用户可能希望访问的URI建议。</li>
<li>大多数系统中的DNS配置允许用户只输入主机名的前缀，然后DNS会自动搜索域名。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ASP6klb0KO6R2sNA__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="6-7-7-有显式代理时URI的解析"><a href="#6-7-7-有显式代理时URI的解析" class="headerlink" title="6.7.7 有显式代理时URI的解析"></a>6.7.7 有显式代理时URI的解析</h2><p>使用显式代理时，用户的URI会被直接发送给代理，浏览器对不完整的主机名不会进行自动扩展。（浏览器会添加了默认方案和路径，但主机名和输入的一样）。有些代理会尽力尝试着去模仿浏览器的便捷服务，包括www..com自动扩展，以及添加本地域名后缀。</p>
<h2 id="6-7-8-有拦截代理时URI的解析"><a href="#6-7-8-有拦截代理时URI的解析" class="headerlink" title="6.7.8 有拦截代理时URI的解析"></a>6.7.8 有拦截代理时URI的解析</h2><p>使用拦截代理时，对客户端来说，是没有代理的。这种情况下与使用服务器的情形类似，浏览器会自动扩展主机名，直到DNS成功为止。但建立到服务器的连接时，有一个重要的区别。</p>
<p>客户端在尝试着连接每个IP地址时，对拦截代理来说，第一次连接请求就会被代理服务器拦截成功，不会连接到原始服务器上去。客户端认为它在与Web服务器进行成功的对话，但那个Web服务器可能不活跃或停用。</p>
<p>所以提供了与浏览器相同级别的容错机制，代理可以通过解析Host首部的主机名，也可以通过对IP地址的反向DNS查找来尝试其他IP地址。</p>
<h1 id="6-8-追踪报文"><a href="#6-8-追踪报文" class="headerlink" title="6.8 追踪报文"></a>6.8 追踪报文</h1><p>在将Web请求从客户端传送到服务器的路径上，经过多个代理很常见，所以需要追踪经过代理的报文流，以检测出各种问题。</p>
<h2 id="6-8-1-Via首部"><a href="#6-8-1-Via首部" class="headerlink" title="6.8.1 Via首部"></a>6.8.1 Via首部</h2><p>Via首部字段列出了与报文途经的每个中间节点（代理或网关）有关的信息。报文每经过一个节点，都必须将这个中间节点添加到Via列表的末尾。</p>
<p>Via首部字段记录报文的转发，诊断报文循环，标识请求/响应链上所有发送者的协议能力。</p>
<p>代理也可以用Via首部检测网络中的路由循环。代理在发送请求之前，在Via首部插入与其自身有关的独特字符串，并在输入的请求中查找这个字符串，以检测网络中是否存在路由循环。</p>
<h3 id="6-8-1-1-Via的语法"><a href="#6-8-1-1-Via的语法" class="headerlink" title="6.8.1.1 Via的语法"></a>6.8.1.1 Via的语法</h3><p>Via首部字段包含一个由逗号分隔的路标（waypoint）。每个路标都表示一个独立的代理服务器或网关，且包含与那个中间节点的协议和地址有关的信息。Via首部的正规语法如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/FVuc9ckHkakOalBe__thumbnail.png"
                      alt="图片"
                >注每个Via路标中最多包含4个组件：一个可选的协议名（默认为HTTP）、一个必选的协议版本、一个必选的节点名和一个可选的描述性注释。</p>
<ol>
<li><strong>协议名</strong></li>
</ol>
<p>如果协议为HTTP的话，协议名是可选的。否则要在版本之前加上协议名，中间用“/”分隔。</p>
<ol start="2">
<li><strong>协议版本</strong></li>
</ol>
<p>HTTP使用的是（1.0、1.1等），之后的应用程序就能知道前面所有中间节点的协议能力。</p>
<ol start="3">
<li><strong>节点名</strong></li>
</ol>
<p>中间节点的主机和可选端口号（如果没有，可以假定使用协议的默认端口号）。在某些情况下，出于隐私方面的考虑，可以用一个假名来代替。</p>
<ol start="4">
<li><strong>节点注释</strong></li>
</ol>
<p>进一步描述这个中间节点的可选注释。通常会在这里包含厂商和版本信息，有些代理服务器还会在注释字段中包含一些与此设备上所发生事件有关的诊断信息。</p>
<h3 id="6-8-1-2-Via的请求和响应路径"><a href="#6-8-1-2-Via的请求和响应路径" class="headerlink" title="6.8.1.2 Via的请求和响应路径"></a>6.8.1.2 Via的请求和响应路径</h3><p>请求和响应通常都是通过同一条TCP连接传送的，所以响应报文会沿着与请求报文相同的路径回传。因此，响应的via首部基本上总是与请求的via首部相反。</p>
<h3 id="6-8-1-3-Via与网关"><a href="#6-8-1-3-Via与网关" class="headerlink" title="6.8.1.3 Via与网关"></a>6.8.1.3 Via与网关</h3><p>有些代理会为不使用HTTP协议的服务器提供网关的功能。Via首部记录这些协议转换，HTTP应用程序就会了解代理链上各点的协议处理能力以及所做的协议转换。</p>
<h3 id="6-8-1-4-Server和Via首部"><a href="#6-8-1-4-Server和Via首部" class="headerlink" title="6.8.1.4 Server和Via首部"></a>6.8.1.4 Server和Via首部</h3><p>Server响应首部字段对原始服务器使用的软件进行描述。如果响应报文是通过代理转发的，要确保代理没有修改server首部。server首部是用于原始服务器的，代理应该添加的是Via条目。</p>
<h3 id="6-8-1-5-Via的隐私和安全问题"><a href="#6-8-1-5-Via的隐私和安全问题" class="headerlink" title="6.8.1.5 Via的隐私和安全问题"></a>6.8.1.5 Via的隐私和安全问题</h3><p>如果不允许进行Via节点名转发，比如作为安全防线的一部分使用的代理就应该用适当的假名来取代。（恶意用户可以通过计算机名字和版本号来了解安全防线之后的网络结构。）</p>
<p>一般来说，即使隐藏真实名称，代理也应该尝试为每台代理服务器保留一个Via路标条目。</p>
<p>对需要隐藏内部网络设计和拓扑结构的组织，代理应该将一个（接收协议值相同的）有序Via路标条目序列合并成一个联合条目。除非这些条目都在同一个组织的控制之下，而且已经用假名取代了主机名，否则就不能将其合并起来。接收协议值不同的条目也不能合并起来。</p>
<h2 id="6-8-2-TRACE方法"><a href="#6-8-2-TRACE方法" class="headerlink" title="6.8.2 TRACE方法"></a>6.8.2 TRACE方法</h2><p>代理服务器可以在转发报文时对其进行修改。可以添加、修改或删除首部，也可以将主体部分转换成不同的格式。</p>
<p>通过HTTP/1.1的TRACE方法，用户可以跟踪经代理链传输的请求报文，观察报文经过了哪些代理，以及每个代理是如何对请求报文进行修改的。TRACE对代理流的调试非常有用。</p>
<p>当TRACE请求到达目的服务器时（也可以是第一个收到了Max-Forwards值为零的请求的代理或网关），整条请求报文都会被封装在一条HTTP响应的主体中回送给发送端。当TRACE响应到达时，客户端可以检查服务器收到的确切报文，以及它所经过的代理列表（在Via首部）。TRACE响应的Content-Type为message/http，状态为200 OK。</p>
<h3 id="6-8-2-1-Max-Forwards"><a href="#6-8-2-1-Max-Forwards" class="headerlink" title="6.8.2.1 Max-Forwards"></a>6.8.2.1 Max-Forwards</h3><p>可以使用Max-Forwards（最大转发次数）首部来限制TRACE和OPTIONS请求所经过的代理跳数，在测试代理链是否是在无限循环中转发报文，或查看链中特定代理服务器的效果。</p>
<p>如果Max-Forwards的值为零（Max-Forwards：0），那么即使接收者不是原始服务器，它也必须将TRACE报文回送给客户端，而不应该继续转发。</p>
<h1 id="6-9-代理认证"><a href="#6-9-代理认证" class="headerlink" title="6.9 代理认证"></a>6.9 代理认证</h1><p>代理可以作为访问控制设备使用。HTTP定义了一种名为代理认证（proxy authentication</p>
<p>）的机制，这种机制可以阻止对内容的请求，直到用户向代理提供了有效的访问权限证书为止。</p>
<p>对受限内容的请求到达一台代理服务器时，代理服务器可以返回要求使用访问证书的<strong>407</strong>Proxy Authorization Required状态码，以及用于描述怎样提供这些证书的<strong>Proxy-Authenticate</strong>首部字段。客户端收到407响应时，会尝试从本地数据库中，或通过提示用户来搜集所需要的证书。获得了证书，客户端就会重新发送请求，在Proxy-Authorization首部字段中提供所要求的证书。如果证书有效，代理就会将原始请求沿着传输链路向下传送，否则就发送另一条407应答。</p>
<p>若传输链路中有多个代理，且每个代理都要进行认证时，代理认证通常无法很好地工作。</p>
<h1 id="6-10-代理的互操作性"><a href="#6-10-代理的互操作性" class="headerlink" title="6.10 代理的互操作性"></a>6.10 代理的互操作性</h1><p>客户端、服务器和代理是由不同厂商构建的，实现的是不同版本的HTTP规范。它们支持的特性各不相同，也存在着不同的问题。代理服务器位于客户端和服务器设备之间，这些设备实现的协议可能有所不同，可能存在着很棘手的问题。</p>
<h2 id="6-10-1-处理代理不支持的首部和方法"><a href="#6-10-1-处理代理不支持的首部和方法" class="headerlink" title="6.10.1 处理代理不支持的首部和方法"></a>6.10.1 处理代理不支持的首部和方法</h2><p>代理服务器可能无法理解所有经其传输的首部字段，有些可能是特定应用程序独有的定制首部。代理必须对不认识的首部字段进行转发，将其等价地合并为由逗号分隔的列表，且必须维持同名首部字段的相对顺序。如果代理不熟悉某个方法，应该尝试将报文转发到下一跳节点上去。</p>
<h2 id="6-10-2-OPTIONS与Allow首部"><a href="#6-10-2-OPTIONS与Allow首部" class="headerlink" title="6.10.2 OPTIONS与Allow首部"></a>6.10.2 OPTIONS与Allow首部</h2><p>通过HTTP OPTIONS方法，客户端（或代理）可以发现Web服务器或者其上某个特定资源所支持的功能。在进行交互之前，确定服务器的能力，这样它就可以更方便地与具备不同特性的代理和服务器进行互操作了。</p>
<p>如果OPTIONS请求的URI是个星号（*），请求的就是整个服务器所支持的功能。</p>
<p>如果URI是个实际资源地址，OPTIONS请求就是在查询那个特定资源的可用特性。</p>
<p>Allow实体首部字段列出了请求URI标识的资源所支持的方法列表，可以将Allow首部作为请求首部，建议在新的资源上支持某些方法，并不要求服务器支持这些方法，但应该在相应的响应中包含一个Allow首部，列出它实际支持的方法。</p>
<p>即使代理无法理解指定的所有方法，也不能对Allow首部字段进行修改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/hgRKHELPa0FxVZOO__thumbnail.png"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>06-代理</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>13-摘要认证</title>
    <url>/2021/01/23/note/HTTP/13-%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h2 id="13-1-摘要认证的改进"><a href="#13-1-摘要认证的改进" class="headerlink" title="13.1 摘要认证的改进"></a>13.1 摘要认证的改进</h2><p>摘要认证相比于基本认证协议进行了如下改进：</p>
<ol>
<li>不会以明文方式在网络上发送密码。</li>
<li>可以防止恶意用户捕获并重放认证的握手过程。</li>
<li>可以有选择地防止对报文内容的篡改。</li>
<li>防范其他几种常见的攻击方式。</li>
</ol>
<p>但摘要认证并不能满足安全HTTP事务的很多需求。对这些需求来说，使用<strong>传输层安全</strong>（Transport Layer Security，TLS）和<strong>安全HTTP</strong>（Secure HTTP，HTTPS）协议更为合适。</p>
<h2 id="13-2-用摘要保护密码"><a href="#13-2-用摘要保护密码" class="headerlink" title="13.2 用摘要保护密码"></a>13.2 用摘要保护密码</h2><p>客户端不发送密码，而是会发送一个“指纹”或密码的“摘要”，这是密码的不可逆扰码。客户端和服务器都知道这个密码，因此服务器验证所提供的摘要是否与密码相匹配。</p>
<h3 id="13-2-1-单向摘要"><a href="#13-2-1-单向摘要" class="headerlink" title="13.2.1 单向摘要"></a>13.2.1 单向摘要</h3><p>摘要是“对信息主体的浓缩”。摘要是一种单向函数，有时也称为加密的校验和、单向散列函数或指纹函数。主要用于将无限的输入值转换为有限的浓缩输出值。常见的摘要函数MD5，会将任意长度的字节序列转换为一个128位的摘要，输出的128位的摘要通常会被写成32个十六进制的字符，每个字符表示4位。</p>
<h3 id="13-2-2-用随机数防止重放攻击"><a href="#13-2-2-用随机数防止重放攻击" class="headerlink" title="13.2.2 用随机数防止重放攻击"></a>13.2.2 用随机数防止重放攻击</h3><p>仅仅隐藏密码并不能避免危险，因为即便不知道密码，也可以截获摘要，并一遍遍地重放给服务器。解决办法：服务器在www-Authenticate质询中传送给客户端一个称为<strong>随机数</strong>（nonce）的特殊令牌，这个数会经常发生变化。客户端在计算摘要之前要先将这个随机数令牌附加到密码上去。</p>
<p>在密码中加入随机数就会使摘要随着随机数的每–次变化而变化。记录下的密码摘要只对特定的随机值有效，而没有密码的话，攻击者就无法计算出正确的摘要，这样就可以防止重放攻击的发生。</p>
<h3 id="13-2-3-摘要认证的握手机制"><a href="#13-2-3-摘要认证的握手机制" class="headerlink" title="13.2.3 摘要认证的握手机制"></a>13.2.3 摘要认证的握手机制</h3><p>HTTP摘要认证协议所用首部与基本认证类似。它在传统首部中添加了一个新的可选首部Authorization-Info。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/LKKAx2TPmRP22yYG__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="13-3-摘要的计算"><a href="#13-3-摘要的计算" class="headerlink" title="13.3 摘要的计算"></a>13.3 摘要的计算</h2><p>摘要认证的核心是对公共信息、保密信息和有时限的随机值这个组合的单向摘要。摘要是根据以下三个组件计算出来的：</p>
<ol>
<li>由<strong>单向散列函数H（d）</strong>和<strong>摘要KD（s，d）</strong>组成的一对函数，其中s表示密码，d表示数据。</li>
<li><strong>A1的数据块</strong>。它是密码和受保护信息的产物，包含用户名、密码、保护域和随机数等内容，A1只涉及安全信息，与底层报文自身无关。</li>
<li><strong>数据块A2</strong>。它是与报文自身有关的信息，比如URL、请求方法和报文实体的主体部分。A2有助于防止方法、资源或报文被篡改。</li>
</ol>
<p>摘要认证支持对各种摘要算法的选择，有两种算法：<strong>MD5</strong>和<strong>MD5-sess</strong>（“sess”表示会话），默认算法为MD5。两种算法都是用函数H来计算数据的MD5，用摘要函数KD来计算以冒号连接的密码和非保密数据的MD5。H和KD处理两块数据A1和A2，A2与H、KD和A1一起用于摘要的计算。</p>
<h3 id="13-2-1-与安全性相关的数据（A1）"><a href="#13-2-1-与安全性相关的数据（A1）" class="headerlink" title="13.2.1 与安全性相关的数据（A1）"></a>13.2.1 与安全性相关的数据（A1）</h3><p>根据选择的算法定义了两种计算A1的方式:</p>
<ol>
<li>MD5为每条请求运行单向散列函数。A1是由冒号连接起来的用户名、域以及密码三元组。</li>
<li>MD5-sess只在第一次www-Authenticate握手时运行一次散列函数。对用户名、域和密码进行一次CPU密集型散列，并将其放在当前随机数和客户端随机数（cnonce）的前面。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/wds6DoVwtCD0ntzK__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="13-2-2-与报文有关的数据（A2）"><a href="#13-2-2-与报文有关的数据（A2）" class="headerlink" title="13.2.2 与报文有关的数据（A2）"></a>13.2.2 与报文有关的数据（A2）</h3><p>根据所选择的保护质量（qop），为A2定义了两种策略:</p>
<ol>
<li>第一种策略只包含HTTP请求方法和URL。当qop=”auth”时使用这种策略，也是默认情况。</li>
<li>第二种策略添加了报文实体的主体部分，以提供一定程度的报文完整性检测。qop=”auth-int”时使用。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/wDzTpT57Nsji2JHp__thumbnail.png"
                      alt="图片"
                ></p>
<p>request-method是HTTP的请求方法。uri-directive-value 是请求行中的请求URI。可能是个”*”、absoluteURL或者abs_path，但它必须与请求URI一致。如果请求URI是absoluteURL，它必须是个绝对URL。</p>
<h3 id="13-2-3-摘要算法总述"><a href="#13-2-3-摘要算法总述" class="headerlink" title="13.2.3 摘要算法总述"></a>13.2.3 摘要算法总述</h3><p>得到了两种给定了H、KD、A1和A2之后，计算摘要的方式：</p>
<ol>
<li>第一种没有qop选项的时候，它是用保密信息和随机报文数据的散列值来计算摘要的。</li>
<li>第二种是现在推荐使用的方式，包含了对随机数计算和对称认证的支持。只要qop为auth或auth-int，就要使用这种方式。它向摘要中添加了随机计数、qop 和cnonce数据。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/g0aHLWSGVCRuUveg__thumbnail.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/DRNNnrURitHX377G__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="13-2-4-预授权"><a href="#13-2-4-预授权" class="headerlink" title="13.2.4 预授权"></a>13.2.4 预授权</h3><p>预授权对基本认证来说并不重要，因为一旦用户与某站点进行了认证，浏览器通常会为后继对那个URL的请求发送正确的Authorization首部。</p>
<p>对摘要认证来说，服务器会产生任意的随机数，所以在客户端收到质询之前，不一定能判定应该发送什么样的Authorization首部。</p>
<p>如如果客户端能在服务器要求它计算Authorization首部之前将其计算出来，就可以预先将Authorization首部发送给服务器，而不用再次进行请求/质询了。</p>
<p>三种可选的方式，通过这些方式，客户端无需等待新的WWW-Authenticate质询，就可以获得正确的随机数：</p>
<ol>
<li>服务器预先在Authentication-Info成功首部中发送下一个随机数。但破坏了对同一台服务器的多条请求进行管道化的功能，而管道化能避免延迟的，所以可能会造成很大的性能损失。</li>
<li>服务器允许在一小段时间内使用同一个随机数。随机数过期时，服务器要向客户端发送401 Unauthorized质询，并设置WWW Authenticate:stale=true指令：</li>
<li>客户端和服务器使用同步的、可预测的随机数生成算法。客户端和服务器可根据共享的密钥，生成第三方无法轻易预测的、相同的随机数序列（比如安全ID卡）。<h3 id="13-2-5-随机数的选择"><a href="#13-2-5-随机数的选择" class="headerlink" title="13.2.5 随机数的选择"></a>13.2.5 随机数的选择</h3></li>
</ol>
<p>随机数公式：BASE64（time-stamp H（time-stamp”：”ETag“：”private-key））</p>
<pre><code>1. **time-stamp**:服务器产生的时间或其他不会重复的值。可以通过这种方式来限制随机数的有效持续时间，
2. **ETag**：所请求实体有关的HTTP ETag首部的值。能防止对已更新资源版本的重放请求。
3. **private-key：**只有服务器知道的数据。</code></pre>
<h3 id="13-2-6-对称认证"><a href="#13-2-6-对称认证" class="headerlink" title="13.2.6 对称认证"></a>13.2.6 对称认证</h3><p>通过提供客户端随机值来实现客户端对服务器的认证，服务器会根据它对共享保密信息的正确了解生成正确的响应摘要。然后，服务器在Authorization-Info首部中将此摘要返回给客户端。只要提供了qop指令，就要求执行对称认证，而没有qop指令时则不要求执行对称认证。</p>
<p>响应摘要的计算方法与请求摘要类似，但由于响应中没有方法，而且报文实体数据有所不同，所以只有报文主体信息A2不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/FpD971kcIakNiitO__thumbnail.png"
                      alt="图片"
                ></p>
<p>cnonce值和nc值必须是本报文所响应的客户端请求中的相应值。如果指定了qop=”auth”或qop=”auth-int”，就必须提供响应auth、cnonce 和nonce计数指令。</p>
<h2 id="13-4-增强保护质量"><a href="#13-4-增强保护质量" class="headerlink" title="13.4 增强保护质量"></a>13.4 增强保护质量</h2><p>在三种摘要首部中提供qop字段：WWW-Authenticate、Authorization 和Authentication-Info可以实现客户端和服务器对不同类型及质量的保护进行协商。</p>
<p>服务器首先在www-Authenticate首部输出由逗号分隔的qop选项列表。然后客户端从中选择一个它支持且满足其需求的选项，并将其放在Authorization的qop字段中回送给服务器。</p>
<p>两种保护质量的初始值：表示认证的auth，带有报文完整性保护的认证auth-int。</p>
<h3 id="13-4-1-报文完整性保护"><a href="#13-4-1-报文完整性保护" class="headerlink" title="13.4.1 报文完整性保护"></a>13.4.1 报文完整性保护</h3><p>如果使用了完整性保护（qop=”auth-int”），H（实体的主体部分）就是对实体主体部分，而不是报文主体部分的散列。对于发送者，要在应用任意传输编码方式之前计算；而对于接收者，则应在去除所有传输编码之后计算。对于任何含有多部分的内容类型来说，多部分的边界和每部分中嵌入的首部都要包含在内。</p>
<h2 id="13-5-摘要认证实际问题"><a href="#13-5-摘要认证实际问题" class="headerlink" title="13.5 摘要认证实际问题"></a>13.5 摘要认证实际问题</h2><h3 id="13-5-1-差错处理"><a href="#13-5-1-差错处理" class="headerlink" title="13.5.1 差错处理"></a>13.5.1 差错处理</h3><p>在摘要认证中，如果某个指令或其值使用不当，或者缺少某个必要指令，就应该使用响应400 Bad Request。</p>
<p>如果请求的摘要不匹配，应该记录登录失败。因为多次失败说明可能有攻击者在猜测密码。</p>
<p>认证服务器一定要确保URI指令指定的资源与请求行中指定的资源相同。如果不同，服务器就应该返回400 Bad Request错误，因为这可能是一种攻击的迹象，也用来应对中间代理可能对客户端请求进行的修改，修改的请求计算后得到的摘要可能会与客户端计算出的摘要有所不同。</p>
<h3 id="13-5-2-保护空间"><a href="#13-5-2-保护空间" class="headerlink" title="13.5.2 保护空间"></a>13.5.2 保护空间</h3><p>域值与被访问服务器的标准根URL结合在一起，定义了保护空间。域值是一个字符串，通常由原始服务器分配，可能会有认证方案特有的附加语义。</p>
<p>可能会有多个授权方案相同，而域不同的质询。保护空间确定了可以自动应用证书的区域。如果前面的某条请求已被授权，在一段时间内，该保护空间中所有其他请求都可以重用同一个证书，时间的长短由认证方案、参数和/或用户喜好来决定。除非认证方案进行了其他定义，否则单个保护空间是不能扩展到其服务器范围之外的。</p>
<p>对保护空间的具体计算取决于认证机制：</p>
<ol>
<li>在基本认证中，客户端会假定请求URI中或其下的所有路径都与当前的质询处于同一个保护空间内。客户端可以预先提交对此空间中资源的认证，无需等待来自服务器的另一条质询。</li>
<li>在摘要认证中，质询的WWW-Authenticate：domain字段对保护空间作了更精确的定义。通常domain列表中的所有URI和逻辑上处于这些前缀之下的所有URI，都位于同一个保护空间中。如果没有domain字段，或此字段为空，质询服务器上的所有URI就都在保护空间内。</li>
</ol>
<p>认证客户端应该记住用户名、密码、随机数、随机数计数以及一些与认证会话有关的隐晦值，以便将来在此保护空间中构建请求的Authorization首部时使用。</p>
<p>即便老的Authorization首部所包含的随机数不再新鲜了，服务器可以接受其中的信息，也可以返回一个带有新随机数的401响应，让客户端重试请求，这需要指定这个响应为stale=true，表示服务器在告知客户端用新的随机数来重试，而无须提示输人新的用户名和密码。</p>
<h3 id="13-5-3-重写URI"><a href="#13-5-3-重写URI" class="headerlink" title="13.5.3 重写URI"></a>13.5.3 重写URI</h3><p>代理可以通过改变URI语法，而不改变所描述的实际资源的方式来重写URI，比如：</p>
<ol>
<li>可以对主机名进行标准化，或用IP地址来取代；</li>
<li>可以用“%”转义形式来取代嵌入的字符；</li>
<li>如果某类型的一些附加属性不会影响从特定原始服务器上获取资源，就可以将其附加或插入到URI中。</li>
</ol>
<p>代理可修改URI，而且摘要认证会检查URI值的完整性，所以如果进行了修改，摘要认证就会被破坏。</p>
<h3 id="13-5-4-缓存"><a href="#13-5-4-缓存" class="headerlink" title="13.5.4 缓存"></a>13.5.4 缓存</h3><p>共享的缓存收到包含Authorization首部的请求和转接那条请求产生的响应时，不能将那条响应作为对任何其他请求的应答使用，除非响应中提供了下列两种Cache-Control指令之一：</p>
<ol>
<li>如果原始响应中包含有Cache-Control指令must-revalidate，缓存可以在应答后继请求时使用那条响应的实体部分。但它首先要用新请求的请求首部，与原始服务器再次进行验证，这样原始服务器就可以对新请求进行认证。</li>
<li>如果原始响应中包含有Cache-Control指令public，在对任意后继请求的应答中都可以返回响应的实体部分。<h2 id="13-6-安全性考虑"><a href="#13-6-安全性考虑" class="headerlink" title="13.6 安全性考虑"></a>13.6 安全性考虑</h2></li>
</ol>
<h3 id="13-6-1-首部篡改"><a href="#13-6-1-首部篡改" class="headerlink" title="13.6.1 首部篡改"></a>13.6.1 首部篡改</h3><p>为了提供一个简单明了的防首部篡改系统，要么就得进行端到端的加密，要么就得对首部进行数字签名一最好是两者的结合！摘要认证的重点在于提供一种防篡改认证机制，但并不一定要将这种保护扩展到数据上去。具有一定保护级别的首部只有www-Authenticate和Authorization.</p>
<h3 id="13-6-2-重放攻击"><a href="#13-6-2-重放攻击" class="headerlink" title="13.6.2 重放攻击"></a>13.6.2 重放攻击</h3><p>重放攻击指的就是有人将从某个事务中窃取的认证证书用于另一个事务。缓解方法：让服务器产生的随机数包含根据客户端IP地址、时间戳、资源Etag和私有服务器密钥算出的摘要。</p>
<p>但缺点在于随机数中包含客户端的IP地址，会破坏代理集群的工作。来自单个用户的多条请求通常会经过不同的代理进行传输，而且还可以通过IP地址欺骗实现。</p>
<p>另外一种方法：服务器为每个事务发布唯一的随机数和超时值，发布的随机数只对指定的事务有效，而且只在超时值的持续区间内有效。虽然增加服务器的负担，但可忽略不计。</p>
<h3 id="13-6-3-多重认证机制"><a href="#13-6-3-多重认证机制" class="headerlink" title="13.6.3 多重认证机制"></a>13.6.3 多重认证机制</h3><p>服务器支持多重认证机制时，通常会在WWW-Authenticate首部提供选项。同时需要让客户端总是去选择可用认证方案中功能最强的那个。如果无法实现，就只有使用只维护最强认证方案的代理服务器。但只有在已知所有客户端都支持所选认证方案的区域中才能采用这种方式。</p>
<h3 id="13-6-4-词典攻击"><a href="#13-6-4-词典攻击" class="headerlink" title="13.6.4 词典攻击"></a>13.6.4 词典攻击</h3><p>词典攻击是典型的密码猜测型攻击方式。恶意用户对某个事务进行窃听，并对<strong>随机数/响应对</strong>使用标准的密码猜测程序。如果没有密码过期策略，就容易搜集到足够多的密码，造成破坏。</p>
<h3 id="13-6-5-恶意代理攻击和中间人攻击"><a href="#13-6-5-恶意代理攻击和中间人攻击" class="headerlink" title="13.6.5 恶意代理攻击和中间人攻击"></a>13.6.5 恶意代理攻击和中间人攻击</h3><p>入侵受信代理的方式之一是使用其扩展接口，因为有时代理会提供复杂的编程接口，可以为这类代理编写一个扩展来拦截流量并对其进行修改。</p>
<p>攻击方式：</p>
<ol>
<li>采用窃听的形式；</li>
<li>删除提供的所有选项；</li>
<li>用最薄弱的认证策略来取代现有的认证机制。</li>
</ol>
<p>可行的解决方案：</p>
<ol>
<li>由客户端提供与认证功能有关的可见线索；</li>
<li>对客户端进行配置使其总是使用可用认证策略中功能最强的那一种；</li>
<li>最简单的方式使用SSL。<h3 id="13-6-6-选择明文攻击"><a href="#13-6-6-选择明文攻击" class="headerlink" title="13.6.6 选择明文攻击"></a>13.6.6 选择明文攻击</h3></li>
</ol>
<p>如果中间有被入侵的或恶意的代理甚至服务器在拦截流量，就可以为客户端的响应计算提供随机数。使用已知密钥来计算响应可以简化响应的密码分析过程。这种方式被称为<strong>选择明文攻击</strong>（chosen plaintext attack）。选择明文攻击有以下几种变体形式:</p>
<ol>
<li><strong>预先计算的词典攻击。</strong>词典攻击和选择明文攻击的组合。首先发起攻击的服务器会用预先确定的随机数和常见密码的变化形式产生一组响应，创建一个词典。一旦规模可观，攻击者从客户端得到一个响应时，会搜索生成的词典，寻找匹配项。如果有匹配项，攻击者就捕获了这个用户的密码。</li>
<li><strong>批量暴力型攻击。</strong>它没有匹配预先计算出来的摘要，而是用一组机器枚举了指定空间内所有可能的密码。</li>
</ol>
<p>防止这些攻击的方法：配置客户端使用可选的cnonce指令，这样响应就是基于客户端的判断产生的，而不是用服务器提供的随机数（因为随机数可能会被攻击者人侵）产生的。，再结合强制使用合理强密码的策略，以及密码过期策略，就可以完全消除选择明文攻击的威胁。</p>
<h3 id="13-6-7-存储密码"><a href="#13-6-7-存储密码" class="headerlink" title="13.6.7 存储密码"></a>13.6.7 存储密码</h3><p>摘要认证机制将对比用户的响应与服务器内部存储的内容，通常就是用户名和H（A1）元组对。如果摘要认证密码文件被入侵，攻击者马上就能够使用域中所有文件，不需要再进行解码。</p>
<p>消除这个问题的方法包括：</p>
<ol>
<li>就像密码文件中包含的是明文密码一样来保护它；</li>
<li>确保域名在所有域中是唯一的。如果密码文件被入侵，所造成的破坏也只局限于特定的域中。包含主机和domain的全路径域名就可以满足这个要求。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>13-摘要认证</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>15-实体和编码</title>
    <url>/2021/01/23/note/HTTP/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="15-1-报文是箱子，实体是货物"><a href="#15-1-报文是箱子，实体是货物" class="headerlink" title="15.1 报文是箱子，实体是货物"></a>15.1 报文是箱子，实体是货物</h2><p>报文实体由实体首部和实体主体组成的。首部字段以一个空白的CRLF行结束，随后就是实体主体的原始内容。任何其他描述性的信息都包含在实体首部中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/YuTjZHTRjDigxdVP__thumbnail.png"
                      alt="图片"
                ></p>
<h2 id="15-2-Content-Length：实体的大小"><a href="#15-2-Content-Length：实体的大小" class="headerlink" title="15.2 Content-Length：实体的大小"></a>15.2 Content-Length：实体的大小</h2><p>Content-Length首部指示出报文中实体主体的字节大小，包含了所有内容编码的。Content-Length首部就是带有实体主体的报文必须使用的，除非使用了分块编码。使用Content-Length首部能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段。</p>
<h3 id="15-2-1-检测截尾"><a href="#15-2-1-检测截尾" class="headerlink" title="15.2.1 检测截尾"></a>15.2.1 检测截尾</h3><p>HTTP的早期版本采用关闭连接的办法来划定报文的结束。但客户端无法区分是正常的连接关闭，还是由于服务器崩溃而导致的连接关闭。</p>
<p>客户端需要通过Content-Length来检测报文截尾。尤其对缓存代理服务器来说，如果收到被截尾的报文却没有识别出截尾的话，它可能会存储不完整的内容并多次使用它来提供服务。</p>
<p>缓存代理服务器通常不会为没有显式Content-Length首部的HTTP主体做缓存，以此来减小缓存已截尾报文的风险。</p>
<h3 id="15-2-2-错误的Content-Length"><a href="#15-2-2-错误的Content-Length" class="headerlink" title="15.2.2 错误的Content-Length"></a>15.2.2 错误的Content-Length</h3><p>错误的Content-Length比缺少Content-Length还要糟糕。因此有些客户端、服务器以及代理中就包含特别的算法，用来检测和纠正与有缺陷服务器的交互过程。HTTP/1.1规定用户Agent代理应该在接收且检测到无效长度时通知用户。</p>
<h3 id="15-2-3-Content-Length与持久连接"><a href="#15-2-3-Content-Length与持久连接" class="headerlink" title="15.2.3 Content-Length与持久连接"></a>15.2.3 Content-Length与持久连接</h3><p>因为如果响应通过持久连接传送，客户端无法依赖连接关闭来判别报文的结束，因此客户端通过Content-Length首部知道报文在何处结束，下一 条报文从何处开始。</p>
<p>采用<strong>分块编码</strong>（chunked encoding），使用持久连接时可以没有Content-Length首部。在分块编码的情况下，数据是分为一系列的块来发送的，每块都有大小说明。</p>
<h3 id="15-2-4-内容编码"><a href="#15-2-4-内容编码" class="headerlink" title="15.2.4 内容编码"></a>15.2.4 内容编码</h3><p>HTTP允许对实体主体的内容进行编码，可以使之更安全或进行压缩以节省空间。如果主体进行了内容编码，Content-Length说明的就是编码后主体的字节长度，而不是原始主体的长度。</p>
<h3 id="15-2-5-确定实体主体长度的规则"><a href="#15-2-5-确定实体主体长度的规则" class="headerlink" title="15.2.5 确定实体主体长度的规则"></a>15.2.5 确定实体主体长度的规则</h3><p>下面列出的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置，规则按顺序应用，谁先匹配就用谁：</p>
<ol>
<li>如果特定的HTTP报文类型中不允许带有主体，就忽略Content-Length首部，它是对实际上没有发送出来的主体进行计算的。这种情况下，Content-Length首部是提示性的，并不说明实际的主体长度。</li>
<li>如果报文中有描述传输编码的Transfer-Encoding首部（不采用默认的HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）的特殊模式结束，除非报文已经因连接关闭而结束。</li>
<li>如果报文中有Content-Length首部且报文类型允许有实体主体，而且没有非恒等的Transfer-Encoding首部字段，那么Content-Length的值就是主体的长度。如果收到的报文中Content-Length和Transfer-Encoding首部字段都有，就必须忽略Content-Length，因为传输编码会改变实体主体的表示和传输方式。从而可能就会改变传输的字节数。</li>
<li>如果报文使用了multipart/byteranges（多部分/字节范围）媒体类型，并且没有用Content-Length首部指出实体主体的长度，那么多部分报文中的每个部分都要说明自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。</li>
<li>如果上面的规则都不匹配，实体就在连接关闭的时候结束。只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应。</li>
</ol>
<p>为了和使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的Content-Length首部字段，除非知道服务器兼容HTTP/1.1。对于带有主体但没有Content-Length首部的请求，服务器就应当发送400 Bad Request响应或411 Length Required响应。.</p>
<h2 id="15-3-实体摘要"><a href="#15-3-实体摘要" class="headerlink" title="15.3 实体摘要"></a>15.3 实体摘要</h2><p>发送方可以在生成初始的主体时，生成一个数据的校验和，接收方就可以通过检查这个校验和来检测实体主体的数据是否被修改。</p>
<p>Content-MD5首部是发送对实体主体运行MD5算法的结果，只有产生响应的原始服务器可以计算并发送。中间代理和缓存不应当修改或添加这个首部，否则就会与验证端到端完整性的这个最终目的相冲突。</p>
<p>Content-MD5首部是在对内容做了所有需要的内容编码之后，还没有做传输编码前，计算出来的。为了验证报文的完整性，客户端必须先进行传输编码的解码，然后计算所得到的未进行传输编码的实体主体的MD5。</p>
<p>除了检查报文的完整性之外，MD5还可以当作散列表的关键字，用来快速定位文档并消除不必要的重复内容存储。</p>
<p>作为对HTTP的扩展，增加新的Want-Digest首部，它允许客户端说明期望响应中使用的摘要类型，并使用质量值来建议多种摘要算法并说明优先顺序。</p>
<h2 id="15-4-媒体类型和字符集"><a href="#15-4-媒体类型和字符集" class="headerlink" title="15.4 媒体类型和字符集"></a>15.4 媒体类型和字符集</h2><p>Content-Type首部字段说明实体主体的MIME类型。MIME类型是标准化的名字，用以说明运载实体的基本媒体类型。客户端应用程序使用MIME类型来解释和处理其内容。Content-Type的值是标准化的MIME类型，在互联网号码分配机构（Internet Assigned Numbers Authority，简称IANA）中注册。</p>
<p>MIME类型由一个主媒体类型后面跟一条斜线以及一个子类型组成，子类型用于进一步描述媒体类型。</p>
<p>Content-Type首部说明的是原始实体主体的媒体类型。实体经过内容编码的话，Content-Type首部说明的仍是编码之前的实体主体的类型。，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Hgvet3LTBs7pzFpx__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="15-4-1-文本的字符编码"><a href="#15-4-1-文本的字符编码" class="headerlink" title="15.4.1 文本的字符编码"></a>15.4.1 文本的字符编码</h3><p>Content-Type首部还支持可选的参数来进一步说明内容的类型。比如charset（字符集）参数，说明把实体中的比特转换为文本文件中的字符的方法：Content-Type：text/html；</p>
<h3 id="15-4-2-多部分媒体类型"><a href="#15-4-2-多部分媒体类型" class="headerlink" title="15.4.2 多部分媒体类型"></a>15.4.2 多部分媒体类型</h3><p>MIME中的multipart（多部分）电子邮件报文中包含多个报文，它们一起作为复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同的部分之间用分界字符串连接。</p>
<p>HTTP也支持多部分主体。通常只用在下列两种情形之一：</p>
<ol>
<li>多部分表格提交，HTTP使用<strong>Content-Type：multipart/form-data</strong>或<strong>Content-Type：multipart/mixed</strong>首部以及多部分主体来发送这种请求，e.g. Content-Type：multipart/form-data；boundary=[abc]，其中的boundary参数说明了分割主体中不同部分所用的字符串。</li>
<li>作为承载若干文档片段的范围响应。HTTP对范围请求的响应也可以是多部分的，这样的响应中有<strong>Content-Type：multipart/byteranges</strong>首部和带有不同范围的多部分主体。<h2 id="15-5-内容编码"><a href="#15-5-内容编码" class="headerlink" title="15.5 内容编码"></a>15.5 内容编码</h2></li>
</ol>
<p>HTTP应用程序有时在发送之前对内容进行编码，有助于减少传输实体的时间，还可以把内容搅乱或加密，以此来防止未经授权的第三方看到文档的内容。这种类型的编码是在发送方应用到内容之上的。</p>
<h3 id="15-5-1-内容编码过程"><a href="#15-5-1-内容编码过程" class="headerlink" title="15.5.1 内容编码过程"></a>15.5.1 内容编码过程</h3><p>内容编码的过程如下所述：</p>
<ol>
<li>网站服务器生成原始响应报文，其中有原始的Content-Type和Content-Length首部。</li>
<li>内容编码服务器（也可能就是原始的服务器或下行的代理）创建编码后的报文。编码后的报文有同样的Content-Type，但Content-Length可能不同，在编码后的报文中增加Content-Encoding首部，这样接收的应用程序就可以进行解码。</li>
<li>接收程序得到编码后的报文，进行解码，获得原始报文。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/wfXRqxnk1BEU33wW__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="15-5-2-内容编码类型"><a href="#15-5-2-内容编码类型" class="headerlink" title="15.5.2 内容编码类型"></a>15.5.2 内容编码类型</h3><p>HTTP定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联网号码分配机构（IANA）对各种编码进行标准化，它给每个内容编码算法分配了唯一的代号。Content-Encoding首部就用这些标准化的代号来说明编码时使用的算法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Bd5Wji9r83iXfpN0__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="15-5-3-Accept-Encoding首部"><a href="#15-5-3-Accept-Encoding首部" class="headerlink" title="15.5.3 Accept-Encoding首部"></a>15.5.3 Accept-Encoding首部</h3><p>为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放在请求的Accept-Encoding首部里发出去。如果HTTP请求中没有包含Accept-Encoding首部，服务器就可以假设客户端能够接受任何编码方式。</p>
<p>客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q值范围从0.0到1.0，0.0说明客户端不想接受所说明的编码，1.0则表明最希望使用的编码。*表示“任何其他方法”。</p>
<p>identity编码代号只能在Accept-Encoding首部中出现，客户端用它来说明相对于其他内容编码算法的优先级。</p>
<h2 id="15-6-传输编码和分块编码"><a href="#15-6-传输编码和分块编码" class="headerlink" title="15.6 传输编码和分块编码"></a>15.6 传输编码和分块编码</h2><p>传输编码也是作用在实体主体上的可逆变换，使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/KmJHDOGZldzZmjDu__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="15-6-1-可靠传输"><a href="#15-6-1-可靠传输" class="headerlink" title="15.6.1 可靠传输"></a>15.6.1 可靠传输</h3><p>在HTTP协议中，底层的传输设施已经标准化且容错性好，只有少数情况下，所传输的报文主体可能会引发问题：</p>
<ol>
<li><strong>未知的尺寸</strong>。如果不先生成内容，某些网关应用程序和内容编码器无法确定报文主体的最终大小，所以它们希望在知道大小前就开始传输数据。因为HTTP协议要求Content-Length首部必须在数据之前，所以使用传输编码来发送数据，并用特别的结束脚注表明数据结束。</li>
<li><strong>安全性</strong>。可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。但由于像SSL这样的传输层安全体系，很少需要靠传输编码来实现安全性。<h3 id="15-6-2-Transfer-Encoding首部"><a href="#15-6-2-Transfer-Encoding首部" class="headerlink" title="15.6.2 Transfer-Encoding首部"></a>15.6.2 Transfer-Encoding首部</h3></li>
</ol>
<p>用来描述和控制传输编码的两个首部:</p>
<ol>
<li>Transfer-Encoding。告知接收方为了可靠地传输报文，已经对其进行了何种编码。</li>
<li>TE。用在请求首部中，告知服务器可以使用哪些传输编码扩展。</li>
</ol>
<p>HTTP规范只定义了一种传输编码，就是分块编码（chunked）。TE首部也可以使用Q值来说明传输编码的优先顺序，但禁止设为0.0。</p>
<h3 id="15-6-3-分块编码"><a href="#15-6-3-分块编码" class="headerlink" title="15.6.3 分块编码"></a>15.6.3 分块编码</h3><p>分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。</p>
<p>分块编码是一种传输编码，因此是报文的属性，而不是主体的属性。而多部分编码，是主体的属性，它和分块编码是完全独立的。</p>
<h4 id="15-6-3-1-分块与持久连接"><a href="#15-6-3-1-分块与持久连接" class="headerlink" title="15.6.3.1 分块与持久连接"></a>15.6.3.1 分块与持久连接</h4><p>若客户端和服务器之间不是持久连接，客户端就不需要知道主体的长度，而只需要读到服务器关闭主体连接为止。否则必须加上Content-Length首部发送。</p>
<p>但如果服务器动态创建内容，就可能在发送之前无法知道主体的长度，于是通过分块编码解决。服务器可以用大小为0的块作为主体结束的信号，来继续保持连接，为下一个响应做准备。</p>
<p>客户端也可以发送分块的数据给服务器。因为客户端事先不知道服务器是否接受分块编码（因为客户端才会发送TE首部），所以客户端必须做好服务器用411 Length Required响应来拒绝分块请求的准备。</p>
<p>分块编码报文的基本结构：它由起始的HTTP响应首部块开始，随后是一系列分块。每个分块包含一个长度值和该分块的数据。长度值是十六进制形式并将CRLF与数据分隔开。分块中数据的大小以字节计算，不包括长度值与数据之间的CRLF序列以及分块结尾的CRLF序列。最后一个块长度值为0，表示“主体结束”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/QefkJBLxwkzvePyF__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="15-6-3-2-分块报文的拖挂"><a href="#15-6-3-2-分块报文的拖挂" class="headerlink" title="15.6.3.2 分块报文的拖挂"></a>15.6.3.2 分块报文的拖挂</h4><p>只有客户端的TE首部中说明可以接受拖挂，才在分块的报文最后加上。产生原始响应的服务器也可以在分块的报文最后加上拖挂。</p>
<p>拖挂的内容是可选的元数据，客户端不一定需要理解和使用（甚至可以忽略并丢弃拖挂中的内容）。拖挂中可以包含附带的首部字段，它们的值在报文开始的时候可能是无法确定的。比如Content-MD5 ，在文档生成之前很难算出它的MD5。</p>
<p>报文首部中包含一个Trailer首部，列出了跟在分块报文之后的首部列表，除了Transfer-Encoding、Trailer 以及Content-Length首部之外，其他HTTP首部都可以作为拖挂发送，这些首部紧接在最后一个分块之后。</p>
<h3 id="15-6-4-内容编码与传输编码的结合"><a href="#15-6-4-内容编码与传输编码的结合" class="headerlink" title="15.6.4 内容编码与传输编码的结合"></a>15.6.4 内容编码与传输编码的结合</h3><p>内容编码与传输编码可以同时使用。接收方“重构”主体的过程和发送方相反。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/R2V1NNz6yChk86Tq__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="15-6-5-传输编码的规则"><a href="#15-6-5-传输编码的规则" class="headerlink" title="15.6.5 传输编码的规则"></a>15.6.5 传输编码的规则</h3><p>对报文主体使用传输编码时，必须遵守以下规则，使得接收方能够确定报文的传输长度：</p>
<ol>
<li>传输编码集合中必须包括“分块”，唯一例外是使用关闭连接来结束报文。</li>
<li>当使用分块传输编码时，它必须是最后一个作用到报文主体之上的。</li>
<li>分块传输编码不能多次作用到一个报文主体上。</li>
</ol>
<p>实现传输编码的服务器必须意不把经传输编码后的报文发送给非HTTP/1.1的应用程序。否则如果服务器收到无法理解的经过传输编码的报文，用501 Unimplemented状态码来回复。</p>
<h2 id="15-7-随时间变化的实例"><a href="#15-7-随时间变化的实例" class="headerlink" title="15.7 随时间变化的实例"></a>15.7 随时间变化的实例</h2><p>网站对象并不是静态的。同样的URL会随着时间变化而指向对象的不同版，也就是实例。</p>
<p>HTTP协议规定了称为<strong>实例操控</strong>（instance manipulations）的一系列请求和响应操作，用以操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两种方法都要求客户端能够标识它所拥有（如果有的话）的资源的特定副本，并在一定的条件下请求新的实例。</p>
<h2 id="15-8-验证码和新鲜度"><a href="#15-8-验证码和新鲜度" class="headerlink" title="15.8 验证码和新鲜度"></a>15.8 验证码和新鲜度</h2><p>当文档在客户端“过期”之后（客户端不认为该副本有效），客户端须从服务器请求一份新副本。如果该文档在服务器上并未改变，客户端也就不需要再接收，继续使用缓存的副本即可。</p>
<p>这种特殊的请求，称为<strong>有条件的请求</strong>（conditional request），要求客户端使用验证码</p>
<p>（validator）来告知服务器它当前拥有的版本号，并仅当它当前副本无效才要求发送新的副本。</p>
<h3 id="15-8-1-新鲜度"><a href="#15-8-1-新鲜度" class="headerlink" title="15.8.1 新鲜度"></a>15.8.1 新鲜度</h3><p>服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。服务器可以用Expires（过期）和Cache-Control（缓存控制）来提供这种信息。</p>
<p>同时服务器和客户端不仅都可以用Cache-Control来说明新鲜度，并且除了使用期或过期时间之外，还有很多指令可用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/m7VrGBnCBAIpGjwd__thumbnail.png"
                      alt="图片"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/27woIO882zhDrUbJ__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="15-8-2-有条件的请求与验证码"><a href="#15-8-2-有条件的请求与验证码" class="headerlink" title="15.8.2 有条件的请求与验证码"></a>15.8.2 有条件的请求与验证码</h3><p>当原始服务器上的文档与缓存中已过期的副本相同，而缓存服务器还是要从原始服务器上取文档的话，那缓存服务器就是在浪费网络带宽，给缓存服务器和原始服务器增加不必要的负载。</p>
<p>解决方案：仅当资源改变时才请求副本，这种特殊请求称为有条件的请求，仅当某个特定条件为真时才执行，如果条件不满足，服务器就发回一个HTTP错误码。</p>
<p>每个有条件的请求都通过特定的验证码来发挥作用。验证码是文档实例的特殊属性，用它来测试条件是否为真。可以把验证码看作文件的序列号、版本号，或者最后发生改变的日期时间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/ZOLwYk7M1G3NhugX__thumbnail.png"
                      alt="图片"
                ></p>
<p>HTTP把验证码分为两类：<strong>弱验证码</strong>（weak validators）和<strong>强验证码</strong>（strong validators）。</p>
<p>弱验证码不一定能唯一标识资源的一个实例，而强验证码可以。</p>
<p>弱验证码：</p>
<ol>
<li>字节计数验证码，可能资源的内容改变了，而大小还保持不变，资源内容的加密校验和就是强验证码，文档改变时总是会变。</li>
<li>最后修改时间，因为它的描述精度最大就是1秒。资源可能在1秒内可以改变很多次。</li>
</ol>
<p>强验证码：ETag首部被当作强验证码，因为每当资源内容改变时，服务器都可以在ETag首部放置不同的值。ETag首部很灵活，它可以带上任意的文本值，这样就可以设计出各种各样的客户端和服务器验证策略。版本号和摘要校验是很好的ETag首部候选，但不能带有任意的文本。</p>
<p>有时候，不想在缓存服务器再验证时产生很大的传输流量，就需要采用不那么精确的实体标记验证方法。服务器可以在标记前加上”W/“前缀来广播一个“弱”实体标记。对于弱实体标记来说，只有当关联的实体在语义上发生了重大改变时，标记才变化。而强实体标记只要内容变化，标记都一定会改变。</p>
<h2 id="15-9-范围请求"><a href="#15-9-范围请求" class="headerlink" title="15.9 范围请求"></a>15.9 范围请求</h2><p>范围请求允许客户端实际上只请求文档的一部分。比如HTTP客户端可以通过请求曾获取失败的实体的一个范围，来恢复下载该实体。前提是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象没有改变过。</p>
<p>可以使用Range：bytes=4000-这种形式的范围请求，因为请求方可能不知道文档的大小。还可以用Range首部来请求多个范围（可以按任意顺序给出，也可以相互重叠）。因为客户端可以同时连接多个服务器下载同一个文档的不同部分。</p>
<p>对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多部分主体及Content-Type：multipart/byteranges 首部。</p>
<p>不是所有服务器都接受范围请求，服务器可以通过在响应中包含Accept-Ranges首部的形式向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，规范中只定义了bytes 记号，但具体实现可以用服务器和客户端自己认定的单位来衡量或切分实体。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/W7dJGGZkH5D2R8X5__thumbnail.png"
                      alt="图片"
                ></p>
<p>Range首部在流行的<strong>点对点</strong>（Peer-to-Peer，P2P）文件共享客户端软件中得到广泛应用，它们从不同的对等实体同时下载多媒体文件的不同部分。</p>
<p>范围请求属于实例操控，因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是客户端的范围请求仅当客户端和服务器拥有文档的同一个版本时才有意义。</p>
<h2 id="15-10-差异编码"><a href="#15-10-差异编码" class="headerlink" title="15.10 差异编码"></a>15.10 差异编码</h2><p>差异编码通过交换对象改变的部分而不是完整的对象来优化传输性能。差异编码也属于实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。</p>
<p>客户端必须告诉服务器现有资源的版本，是否接受资源最新版的差异（delta），知道将差异应用于现有版本的哪些算法。</p>
<p>服务器必须检查客户端是否有这个资源现有版本，通过算法计算客户端资源现有版本与新版之间的差异，然后发送给客户端，告知客户端所发送的是差异，并说明新资源的（ETag），因为客户端将差异应用于其老版本之后就会得到这个版本。</p>
<p>如果客户端想告诉服务器接受资源的差异，就发送A-IM（Accept-Instance-Manipulation）首部，而不用发送完整的资源。在A-IM首部中，客户端说明知道哪些算法可以把差异应用于老版本而得到最新版本。</p>
<p>服务端发送的是一个特殊的响应代码一226 IM Used，告知客户端它正在发送的是所请求对象的实例操控，而不是完整的对象。IM（Instance-Manipulation）首部，说明用于计算差异的算法，还有新的ETag首部，以及Delta-Base首部，说明用于计算差异的基线文档的ETag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/1zeEzzzA7jllslxR__thumbnail.png"
                      alt="图片"
                ></p>
<p>客户端用A-IM首部说明可以接受的一些实例操控的类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/l9MCr1VSHCxu3wQi__thumbnail.png"
                      alt="图片"
                ></p>
<p>服务器侧的<strong>差异生成器</strong>根据基线文档和该文档的最新实例，并用客户端在A-IM首部中指明的算法计算它们之间的差异。客户端侧的<strong>差异应用器</strong>得到差异，将其应用于基线文档，得到文档的最新实例。</p>
<p>在返回给客户端之前，文档可以经过多种实例操控，这样可以获得最大程度的压缩。例如，用vcdiff算法产生的差异后可以再用gzip算法压缩。</p>
<p>差异编码可以减少传输次数，但支持差异编码的服务器必须保存资源的所有不同版本，才能计算新版本与所请求的客户端持有的现有版本之间的差异。这样服务器必须增加磁盘空间来保存文档的各种旧的实例，可能反而得不偿失。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/HTTP/Ttoo45eBe0QpTIHZ__thumbnail.png"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP权威指南</category>
        <category>15-实体和编码</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>03-WebKit架构和模块</title>
    <url>/2021/01/21/note/webkit/03-WebKit%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="3-1-WebKit-架构及模块"><a href="#3-1-WebKit-架构及模块" class="headerlink" title="3.1 WebKit 架构及模块"></a>3.1 WebKit 架构及模块</h2><h3 id="3-1-1-获取WebKit"><a href="#3-1-1-获取WebKit" class="headerlink" title="3.1.1 获取WebKit"></a>3.1.1 获取WebKit</h3><p>WebKit是一个开源项目，可以从<a class="link"   href="http://www.webkit.org官方网站下载源代码./" >www.webkit.org官方网站下载源代码。<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="3-1-2-WebKit-架构"><a href="#3-1-2-WebKit-架构" class="headerlink" title="3.1.2 WebKit 架构"></a>3.1.2 WebKit 架构</h3><p>WebKit支持不同的浏览器，因为不同浏览器的需求不同，所以在WebKit中，一些代码可以共享，另外一部分不同的被称为WebKit的移植（Ports）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/3NEAHZuv3WuglE3I.png"
                      alt="图片"
                ></p>
<p>图中的WebKit架构，虚线框表示该部分模块在不同浏览器使用的WebKit内核中的实现不是普遍共享的，实线框标记的模块表示它们基本上是共享的，但是否共享可以通过不同的编译配置改变它们的行为。</p>
<p>图中最下面的是“<strong>操作系统</strong>”，WebKit可以在不同的操作系统上工作。不同浏览器可能会依赖不同的操作系统，同一个浏览器使用的WebKit也可能依赖不同的操作系统。</p>
<p>在“操作系统”层之上的就是WebKit赖以工作的<strong>第三方库</strong>，这些库是WebKit运行的基础。通常来讲，它们包括<strong>图形库</strong>、<strong>网络库</strong>、<strong>视频库</strong>等。</p>
<p>在它们二者之上的就是WebKit项目，图中把它细分为两层，每层包含很多模块，由于图的大小限制，略去了其中一些次要模块。这些模块支撑网页加载和渲染过程。</p>
<p><strong>WebCore</strong>是加载和渲染网页的基础部分，包括<strong>HTML解释器</strong>、<strong>CSS解释器</strong>、<strong>SVG</strong>、<strong>DOM</strong>、<strong>渲染树</strong>（RenderObject树、RenderLayer树等），以及<strong>Inspector</strong>（Web Inspector、调试网页）。这些共享部分有些是基础框架，其背后的支持也需要各个平台的不同实现。WebCore这些部分主要被加载和渲染过程的第一、二阶段所使用。</p>
<p><strong>JavaScriptCore引擎</strong>是WebKit中的默认JavaScript 引擎，WebKit 中对JavaScript 引擎的调用是独立于引擎的。</p>
<p><strong>WebKit Ports</strong>指的是WebKit中的非共享部分，包括<strong>硬件加速架构</strong>、<strong>网络栈</strong>、<strong>视频解码</strong>、<strong>图片解码</strong>等。这些模块由于平台差异、依赖的第三方库和需求不同等方面原因，就产生了移植部分，导致众多WebKit版本的行为并非一致。</p>
<p>在WebCore和WebKit Ports之上的层主要是提供嵌入式编程接口，是提供给浏览器调用的。图中左右两个部分分别是<strong>狭义WebKit的接口</strong>和<strong>WebKit2的接口</strong>。因为接口与具体的移植有关，所以有一个与浏览器相关的<strong>绑定层，</strong>绑定层上面就是WebKit项目对外暴露的接口层。接口层的定义也是与移植密切相关的。</p>
<p>WebKit还有一个部分<strong>测试用例</strong>在图中没有展现出来，包括<strong>布局测试用例</strong>（Layout Tests）和<strong>性能测试用例</strong>（Performance Tests），这两类测试包含了大量的测试用例和期望结果。总体上来讲WebKit移植还是共享大量的用例。这些用例被用来验证渲染结果的正确性。每个浏览器所用的WebKit必须保证能够编译出来一个可执行程序，称为DumpRenderTree，它被用来运行测试用例并将渲染结果同期望结果对比。</p>
<h2 id="3-2-基于Blink的Chromium浏览器结构"><a href="#3-2-基于Blink的Chromium浏览器结构" class="headerlink" title="3.2 基于Blink的Chromium浏览器结构"></a>3.2 基于Blink的Chromium浏览器结构</h2><h3 id="3-2-1-Chromium浏览器的架构及模块"><a href="#3-2-1-Chromium浏览器的架构及模块" class="headerlink" title="3.2.1 Chromium浏览器的架构及模块"></a>3.2.1 Chromium浏览器的架构及模块</h3><p>Chromium也是基于WebKit（Blink）的。</p>
<h4 id="3-2-1-1-架构和模块"><a href="#3-2-1-1-架构和模块" class="headerlink" title="3.2.1.1 架构和模块"></a>3.2.1.1 架构和模块</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/IinKReweDux5nZou.png"
                      alt="图片"
                ></p>
<p>Chromium的架构和主要的模块中，Blink 只是其中的一块，和它并列的还有众多的Chromium模块，包括<strong>GPU/CommandBuffer</strong>（硬件加速架构）、<strong>V8 JavaScript引擎</strong>、<strong>沙箱模型</strong>、<strong>CC</strong>（Chromium Compositor）、<strong>IPC</strong>、<strong>UI</strong>等。</p>
<p><strong>Content 模块</strong>和<strong>Content API</strong>（接口）是Chromium对渲染网页功能的抽象。Content这里是指用来渲染网页内容的模块，没有Content模块，浏览器的开发者也可以在WebKit的Chromium移植上渲染网页内容，但是却没有办法获得沙箱模型、跨进程的GPU硬件加速机制、众多的HTML5功能，因为这些功能很多是在Content层里实现的。</p>
<p>Content模块和Content API将下面的渲染机制、安全机制和插件机制等隐藏起来，提供一个接口层。该接口目前被上层模块或者其他项目使用，内部调用者包括Chromium浏览器、Content Shell 等，外部包括<strong>CEF</strong>（Chromium Embedded Framework）、Opera 浏览器等。</p>
<p><strong>Chromium浏览器</strong>和<strong>Content Shell</strong>是构建在Content API之上的两个“浏览器”，Chromium具有浏览器完整的功能，而Content Shell是使用Content API来包装的一层简单的“壳”，但也是一个简单的“浏览器”，用户可以使用Content模块来渲染和显示网页内容。Content Shell的作用，其一可以用来测试Content模块很多功能的正确性，例如渲染、硬件加速等；其二是一个参考，可以被很多外部的项目参考来开发基于Content API的浏览器或者各种类型的项目。</p>
<p>在Android系统上，ContentShell的作用更大，这是因为同它并排的左侧的Chromium浏览器的代码没有开源，导致开发者只能依赖Content Shell。</p>
<p><strong>Android WebView</strong>是为了满足Android系统上的WebView而设计的，其思想是利用Chromium的实现来替换原来Android系统默认的WebView。</p>
<h4 id="3-2-1-2-多进程模型"><a href="#3-2-1-2-多进程模型" class="headerlink" title="3.2.1.2 多进程模型"></a>3.2.1.2 多进程模型</h4><p>多进程模型的好处：</p>
<ol>
<li>避免因单个页面的不响应或者崩溃而影响整个浏览器的稳定性，特别是对用户界面的影响；</li>
<li>当第三方插件崩溃时不会影响页面或者浏览器的稳定性，因为第三方插件也被使用单独的进程来运行；</li>
<li>方便了安全模型的实施，也就是沙箱模型是基于多进程架构的。这很大程度上也是WebKit2 产生的原因。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/qT1uN6gND8xF5hwh.png"
                      alt="图片"
                ></p>
<p>Chromium架构设计的灵活性，使用者还可以通过设置来改变它的进程模型方式。图中方框代表进程，连接线代表IPC进程间通信。</p>
<p><strong>Browser进程</strong>：浏览器的主进程，负责浏览器界面的显示、各个页面的管理，是所有其他类型进程的祖先，负责它们的创建和销毁等工作，它有且仅有一个。</p>
<p><strong>Renderer进程</strong>：网页的渲染进程，负责页面的渲染工作，Blink/WebKit 的渲染工作主要在这个进程中完成，可能有多个，但是Renderer 进程的数量与用户打开的网页数量不一定一致。因为Chromium允许用户配置，此外在沙箱模型启动的情况下，该进程可能会发生一些改变。</p>
<p><strong>NPAPI插件进程</strong>：该进程是为NPAPI 类型的插件而创建的。其创建的基本原则是每种类型的插件只会被创建一次，而且仅当使用时才被创建。当多个网页使用同一种类型的插件的时候，进程会为每个使用者创建一个实例，所以插件进程是被共享的。</p>
<p><strong>GPU进程</strong>：最多只有一个，当且仅当GPU硬件加速打开的时候才会被创建，主要用于对3D图形加速调用的实现。</p>
<p><strong>Pepper插件进程</strong>：同NPAPI插件进程，不同的是为Pepper 插件而创建的进程。</p>
<p><strong>其他类型的进程</strong>：图中还有一些其他类型的进程在之后介绍。</p>
<p>对于桌面系统（Windows、Linux、Mac OS）中的Chromium浏览器，它们的进程模型总结后包括以下一些特征：</p>
<ol>
<li>Browser进程和页面的渲染是分开的，页面渲染导致的崩溃不会导致浏览器主界面的崩溃。</li>
<li>每个网页是独立的进程，这保证了页面之间相互不影响。</li>
<li>插件进程也是独立的，插件本身的问题不会影响浏览器主界面和网页。</li>
<li>GPU 硬件加速进程也是独立的。</li>
</ol>
<p>对于Chromium的Android版，主体进程模型大致相同，不同主要指：</p>
<ol>
<li><strong>GPU进程，</strong>GPU进程演变成Browser进程的一个线程，目的之一是节省资源。</li>
<li><strong>Renderer进程，</strong>Android版不支持插件，所以没有插件进程，Renderer也是独立的进程，但是会演变成Android上的服务（service）进程。而且由于Android系统的局限性，Renderer进程的数目会被严格限制，这就涉及到了影子（Phantom）标签的议题。影子标签就是浏览器会将后台的网页所使用的渲染设施都清除，只是原来的一个影子，当用户再次切换的时候，网页需要重新加载和渲染。</li>
</ol>
<p>Chromium允许用户配置Renderer 进程被创建的方式，模型的类型有：</p>
<ol>
<li><strong>Process-per-site-instance</strong>：该类型的含义是为每一个页面都创建一个独立的Render进程，不管这些页面是否来自于同一域。好处是每个页面互不影响，坏处是资源的浪费。</li>
<li><strong>Process-per-site</strong>：该类型的含义是属于同一个域的页面共享同一个进程，而不同属一个域的页面则分属不同的进程。好处是对于相同的域，进程可以共享，内存消耗相对较小，坏处是可能会有特别大的Renderer 进程。</li>
<li><strong>Process-per-tab</strong>：该类型的含义是为每个标签页都创建一个独立的进程，而不管它们是否是不同域不同实例，这也是Chromium的默认行为，但会浪费资源。</li>
<li><strong>Single process</strong>：该类型的含义是不为页面创建任何独立的进程，所有渲染工作都在Browser进程中进行，它们是Browser进程中的多个线程。这个类型在桌面系统上一般不推荐使用，只有在比较单进程和多进程时相对有用，但在Chromium的Android版本上，在Android WebView中，该模式被采用。<h4 id="3-2-1-3-Browser进程和Renderer进程"><a href="#3-2-1-3-Browser进程和Renderer进程" class="headerlink" title="3.2.1.3 Browser进程和Renderer进程"></a>3.2.1.3 Browser进程和Renderer进程</h4></li>
</ol>
<p>Browser进程和Renderer进程都是在WebKit的接口之外由Chromium引入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/CTnRBqgG4ElY7uhV.png"
                      alt="图片"
                ></p>
<p><strong>WebKit接口层</strong>，一般基于WebKit接口层的浏览器直接在上面构建，而没有引入复杂的多进程架构。</p>
<p><strong>WebKit黏附层</strong>，因为Chromium中一些类型和WebKit内部不一致，所以需要一个桥接层。</p>
<p><strong>Renderer</strong>，主要处理进程间通信，接受来自Browser进程的请求，并调用相应的WebKit接口层。同时将WebKit的处理结果发送回去。上面这些层都是在Renderer进程中工作的。</p>
<p><strong>RendererHost</strong>，目的也是处理同Renderer进程之间的通信，不过RendererHost是给Renderer进程发送请求并接收来自Renderer进程的结果。</p>
<p><strong>Web Contents</strong>表示的是网页的内容，它同时包括显示网页内容的子窗口，子窗口最后被嵌入浏览器的用户界面，作为它的一个标签页。</p>
<h4 id="3-2-1-4-多线程模型"><a href="#3-2-1-4-多线程模型" class="headerlink" title="3.2.1.4 多线程模型"></a>3.2.1.4 多线程模型</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/vbkdMTBjTVYMog53.png"
                      alt="图片"
                ></p>
<p>网页的加载和渲染过程在图中模型下的基本工作方式如以下步骤：</p>
<ol>
<li>Browser进程收到用户的请求，首先由UI线程处理，而且将相应的任务转给IO线程，它随即将该任务传递给Renderer进程。</li>
<li>Renderer进程的IO线程经过解释后交给渲染线程。渲染线程接受请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。最后Renderer进程将结果由IO线程传递给Browser进程。</li>
<li>最后，Browser进程接收到结果并将结果绘制出来。</li>
</ol>
<p>Chromium为了保持线程间通信和同步，同时避免造成死锁或者资源的竞争冲突等问题，在绝大多数的场景，使用事件和一种Chromium新创建的任务传递机制，仅在非用不可的情况下才使用锁或者线程安全对象。</p>
<h4 id="3-2-1-5-Content接口"><a href="#3-2-1-5-Content接口" class="headerlink" title="3.2.1.5 Content接口"></a>3.2.1.5 Content接口</h4><p>Content接口不仅提供了一层对多进程进行渲染的抽象接口，而且它支持所有的HTML5功能、GPU硬件加速功能和沙箱机制。Content接口按照功能分成六个部分，每个部分的接口一般也可以分成两类，第一类是嵌入者（可以是Chromium浏览器、CEF3和Content Shell）调用的接口，另一类是嵌入者应该实现的回调接口，被Content接口的内部实现所调用，用来参与具体实现的逻辑或者事件的监听等。</p>
<ol>
<li><strong>App</strong>。这部分主要与应用程序或者进程的创建和初始化相关，它被所有的进程使用，用来处理一些进程的公共操作。包括两种类型，第一类主要包括进程创建的初始化函数，也就是Content模块的初始化和关闭动作；第二类主要是各种回调函数，用来告诉嵌入者启动完成，进程启动、退出，沙盒模型初始化开始和结束等。</li>
<li><strong>Browser</strong>。第一类包括对一些HTML5功能和其他高级功能实现的参与。第二类主要是实现部分的逻辑，被Browser进程调用，还有就是一些事件的函数回调。</li>
<li><strong>Common</strong>。主要定义一些公共的接口，这些被Renderer和Browser共享，例如一些进程相关、参数、GPU相关等。</li>
<li><strong>Plugin</strong>。仅有一个接口类，通知嵌入者Plugin进程何时被创建。</li>
<li><strong>Renderer</strong>。第一类包含获取RenderThread的消息循环、注册V8Extension、计算JavaScript表达式等。第二类包括ContentRendererClient，主要是实现部分逻辑，被Browser端（或者进程）调用，还有就是一些事件的函数回调。</li>
<li><strong>Utility</strong>。工具类接口，主要包括让嵌入者参与Content接口中的线程创建和消息的过滤。<h2 id="3-3-WebKit2"><a href="#3-3-WebKit2" class="headerlink" title="3.3 WebKit2"></a>3.3 WebKit2</h2></li>
</ol>
<h3 id="3-3-1-WebKit2架构及模块"><a href="#3-3-1-WebKit2架构及模块" class="headerlink" title="3.3.1 WebKit2架构及模块"></a>3.3.1 WebKit2架构及模块</h3><p>相比于狭义的WebKit，WebKit2是一套全新的结构和接口。它主要目的和思想同Chromium类似，就是将渲染过程放在单独的进程中来完成，独立于用户界面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/DcFsDgQUQEzoXb3W.png"
                      alt="图片"
                ></p>
<p>WebKit2中也引入了插件进程和网络进程。Web进程对应于Chromium中的Renderer进程，主要是渲染网页。UI进程对应于Chromium中的Browser进程。接口就暴露在该进程中，应用程序只需调用该接口即可。应用程序指的是浏览器或者任何使用该接口的程序。</p>
<h3 id="3-3-2-WebKit-和WebKit2嵌入式接口"><a href="#3-3-2-WebKit-和WebKit2嵌入式接口" class="headerlink" title="3.3.2 WebKit 和WebKit2嵌入式接口"></a>3.3.2 WebKit 和WebKit2嵌入式接口</h3><p>WebKit提供嵌入式接口，该接口表示其他程序可以将网页渲染嵌入在程序中作为其中的一部分，或用户界面的一部分。对于WebKit的Chromium移植来说，它的接口主要用于Chromium浏览器，而不是嵌入式的使用方式。</p>
<p>在WebKit项目中，狭义WebKit的接口主要思想是将网页的渲染结果作为用户界面中的一个窗口部件，它用来显示网页的内容。按功能大致可以把所有接口分成六种类型：</p>
<ol>
<li>设置加载网页、获取加载进度、停止加载、重新加载等；</li>
<li>遍历前后浏览记录类，可以前进、后退等；</li>
<li>网页的很多设置，例如缩放、主题、背景、模式、编码等；</li>
<li>查找网页的内容、高亮等；</li>
<li>触控事件、鼠标事件处理；</li>
<li>查看网页源代码、显示调试窗口等与开发者相关的接口，是通常的嵌入式接口提供的功能。</li>
</ol>
<p>WebKit2接口不同于WebKit的接口，它们是不兼容的，但目的都是提供嵌入式的应用接口。WebKit2接口大致可以分为两个大的部分，</p>
<ol>
<li><strong>WebView相关的接口</strong>，表示渲染的设置、渲染过程、界面等，其中大多数跟各个移植紧密相关。有三个主要的类，它们被各个移植所共享。<ol>
<li>WKView[Ref]：表示的是一个与平台相关的视图，例如在Windows上它表示的就是一个窗口的句柄。</li>
<li>WKContextRef：所有页面的上下文，这些被共享的信息包括local storage、设置等。</li>
<li>WKPageRef：表示网页，也就是浏览的基本单位。</li>
</ol>
</li>
<li>上面<strong>接口依赖的基础类</strong>，它们被各个移植所共享，既包括容器、字符串等基础类，也包括跟网页相关的基础类，例如URL、请求、网页设置等。</li>
</ol>
<p>WebKit2还有WebBundle接口，在Web进程里，其目的是让某些移植访问DOM，目前还没有明确的需求。</p>
<h3 id="3-3-3-比较WebKit2和Chromium的多进程模型以及接口"><a href="#3-3-3-比较WebKit2和Chromium的多进程模型以及接口" class="headerlink" title="3.3.3 比较WebKit2和Chromium的多进程模型以及接口"></a>3.3.3 比较WebKit2和Chromium的多进程模型以及接口</h3><p>下图详细描述了WebKit 接口和Chromium的多进程的关系，以及和Content接口的关系。前面笔者也介绍了一些，例如Renderer进程直接调用WebKit接口，以及和Content接口允许应用程序注入并参与Content之下各个进程的内部逻辑。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/WebKit/IZ9qB9RUHmSwUfSc.png"
                      alt="图片"
                ></p>
<p>首先，Chromium使用的仍然是WebKit接口，而不是WebKit2接口，也就是说Chromium是在WebKit接口之上构建的多进程架构。</p>
<p>其次，WebKit2 的接口希望尽量将多进程结构隐藏起来，但对Chromium来说，它的主要目的是给Chromium提供Content接口以便构建浏览器，其本身目标不是提供嵌入式接口，虽然有CEF项目基于它构建了嵌入式接口。</p>
<p>最后，Chromium中每个进程都是从相同的二进制可执行文件启动，而基于WebKit2的进程则未必如此。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>WebKit技术内幕</category>
        <category>03-WebKit架构和模块</category>
      </categories>
      <tags>
        <tag>WebKit</tag>
      </tags>
  </entry>
  <entry>
    <title>04-变量、作用域与内存</title>
    <url>/2021/01/23/note/JavaScript/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1　原始值与引用值"></a>4.1　原始值与引用值</h2><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。<strong>原始值</strong>（primitive value）就是最简单的数据，<strong>引用值</strong>（reference value）则是由多个值构成的对象。</p>
<p>在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。保存原始值的变量是<strong>按值</strong>（by value）访问的，因为我们操作的就是存储在变量中的实际值。</p>
<p>引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，操作的是对该对象的<strong>引用</strong>（reference）而非实际的对象本身。为此，保存引用值的变量是<strong>按引用</strong>（by reference）访问的。</p>
<blockquote>
<p><strong>注意</strong>在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。</p>
</blockquote>
<h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1　动态属性"></a>4.1.1　动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方，直到对象被销毁或属性被显式地删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>只有引用值可以动态添加后面可以使用的属性。<br>原始类型的初始化可以只使用原始字面量形式。如果使用的是<code>new</code>关键字，则JavaScript会创建一个<code>Object</code>类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age);    <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age);    <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2　复制值"></a>4.1.2　复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure>
<p>当把<code>num2</code>初始化为<code>num1</code>时，<code>num2</code>也会得到数值5。这个值跟存储在<code>num1</code>中的5是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/Z3MwAaHFyTk7NBDe__thumbnail.png"
                      alt="图片"
                ></p>
<p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>下图展示了变量与堆内存中对象之间的关系。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/DThTdySREjpH3Zdg__thumbnail.png"
                      alt="图片"
                ></p>
<h3 id="4-1-3-传递参数（review）"><a href="#4-1-3-传递参数（review）" class="headerlink" title="4.1.3　传递参数（review）"></a>4.1.3　传递参数（review）</h3><p>ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。</p>
<p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，用ECMAScript的话说，就是<code>arguments</code>对象中的一个槽位）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>如果<code>num</code>是按引用传递的，那么<code>count</code>的值也会被修改为30。这个事实在使用数值这样的原始值时是非常明显的。但是如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>在函数内部，<code>obj</code>和<code>person</code>都指向同一个对象。结果就是，即使对象是按值传进函数的，<code>obj</code>也会通过引用访问对象。当函数内部给<code>obj</code>设置了<code>name</code>属性时，函数外部的对象也会反映这个变化，因为<code>obj</code>指向的对象保存在全局作用域的堆内存上。但这不意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子将<code>obj</code>重新定义为一个有着不同<code>name</code>的新对象。当<code>person</code>传入<code>setName()</code>时，其<code>name</code>属性被设置为<code>&quot;Nicholas&quot;</code>。然后变量<code>obj</code>被设置为一个新对象且<code>name</code>属性被设置为<code>&quot;Greg&quot;</code>。如果<code>person</code>是按引用传递的，那么<code>person</code>应该自动将指针改为指向<code>name</code>为<code>&quot;Greg&quot;</code>的对象。可是，当我们再次访问<code>person.name</code>时，它的值还是<code>&quot;Nicholas&quot;</code>，这表明函数中参数的值改变之后，原始的引用仍然没变。当<code>obj</code>在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p>
<blockquote>
<p><strong>注意</strong>ECMAScript中函数的参数就是局部变量。</p>
</blockquote>
<h3 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4　确定类型"></a>4.1.4　确定类型</h3><p><code>typeof</code>操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或<code>undefined</code>的最好方式。如果值是对象或<code>null</code>，那么<code>typeof</code>返回<code>&quot;object&quot;</code>，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">let</span> u;</span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符，如果变量是给定引用类型（由其原型链决定）的实例，则<code>instanceof</code>操作符返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// 变量persion是Object吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);   <span class="comment">// 变量colors是Array吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量pattern是RegExp吗？</span></span><br></pre></td></tr></table></figure>
<p>因为按照定义，所有引用值都是<code>Object</code>的实例，因此通过<code>instanceof</code>操作符检测任何引用值和<code>Object</code>构造函数都会返回<code>true</code>。如果用<code>instanceof</code>检测原始值，则始终会返回<code>false</code>，因为原始值不是对象。</p>
<blockquote>
<p><strong>注意</strong><code>typeof</code>操作符在用于检测函数时会返回<code>&quot;function&quot;</code>。当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，<code>typeof</code>也会返回<code>&quot;function&quot;</code>。ECMA-262规定，任何实现内部<code>[[Call]]</code>方法的对象都应该在<code>typeof</code>检测时返回<code>&quot;function&quot;</code>。因为上述浏览器中的正则表达式实现了这个方法，所以<code>typeof</code>对正则表达式也返回<code>&quot;function&quot;</code>。在IE和Firefox中，<code>typeof</code>对正则表达式返回<code>&quot;object&quot;</code>。</p>
</blockquote>
<h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2　执行上下文与作用域"></a>4.2　执行上下文与作用域</h2><p>变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象</strong>（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p>
<p>全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，就是<code>window</code>对象，因此所有通过<code>var</code>定义的全局变量和函数都会成为<code>window</code>对象的属性和方法。使用<code>let</code>和<code>const</code>的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p>
<p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p>
<p>上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其<strong>活动对象</strong>（activation object）用作变量对象。活动对象最初只有一个定义变量：<code>arguments</code>（全局上下文中没有这个变量）。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到，那么通常会报错。）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (color === <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line">    color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>对这个例子而言，函数<code>changeColor()</code>的作用域链包含两个对象：一个是它自己的变量对象（就是定义<code>arguments</code>对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量<code>color</code>，就是因为可以在作用域链中找到它。<br>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">    <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以访问color和anotherColor，但访问不到tempColor</span></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>以上代码涉及3个上下文：全局上下文、<code>changeColor()</code>和<code>swapColors()</code>的局部上下文。下图展示了这个例子的作用域链。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/HNpFjNH3iS4j2ofk__thumbnail.png"
                      alt="图片"
                ></p>
<p>矩形表示不同的上下文。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。<code>swapColors()</code>局部上下文的作用域链中有3个对象：<code>swapColors()</code>的变量对象、<code>changeColor()</code>的变量对象和全局变量对象。<code>swapColors()</code>的局部上下文首先从自己的变量对象开始搜索变量和函数，搜不到就去搜索上一级变量对象。<code>changeColor()</code>上下文的作用域链中只有2个对象：它自己的变量对象和全局变量对象。因此，它不能访问<code>swapColors()</code>的上下文。</p>
<blockquote>
<p><strong>注意</strong>函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。</p>
</blockquote>
<h3 id="4-2-1-作用域链增强"><a href="#4-2-1-作用域链增强" class="headerlink" title="4.2.1　作用域链增强"></a>4.2.1　作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种（<code>eval()</code>调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常代码执行到下面任意一种情况时会出现这个现象，即：</p>
<ul>
<li><code>try</code>/<code>catch</code>语句的<code>catch</code>块</li>
<li><code>with</code>语句</li>
</ul>
<p>这两种情况下，都会在作用域链前端添加一个变量对象。对<code>with</code>语句来说，会向作用域链前端添加指定的对象；对<code>catch</code>语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;<span class="comment">//未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>with</code>语句将<code>location</code>对象作为上下文，因此<code>location</code>会被添加到作用域链前端。<code>buildUrl()</code>函数中定义了一个变量<code>qs</code>。当<code>with</code>语句中的代码引用变量<code>href</code>时，实际上引用的是<code>location.href</code>，也就是自己变量对象的属性。在引用<code>qs</code>时，引用的则是定义在<code>buildUrl()</code>中的那个变量，它定义在函数上下文的变量对象上。而在<code>with</code>语句中使用<code>var</code>声明的变量<code>url</code>会成为函数上下文的一部分，可以作为函数的值被返回；但因为实际这里使用<code>let</code>声明的变量<code>url</code>，被限制在块级作用域，所以在<code>with</code>块之外没有定义。</p>
<blockquote>
<p><strong>注意</strong>IE的实现在IE8之前是有偏差的，即它们会将<code>catch</code>语句中捕获的错误添加到执行上下文的变量对象上，而不是<code>catch</code>语句的变量对象上，导致在<code>catch</code>块外部都可以访问到错误。IE9纠正了这个问题。</p>
</blockquote>
<h3 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2　变量声明"></a>4.2.2　变量声明</h3><h4 id="4-2-2-1-使用var的函数作用域声明"><a href="#4-2-2-1-使用var的函数作用域声明" class="headerlink" title="4.2.2.1   使用var的函数作用域声明"></a><strong>4.2.2.1   使用</strong><code>var</code>的函数作用域声明</h4><p>在使用<code>var</code>声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在<code>with</code>语句中，最接近的上下文也是函数上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);         <span class="comment">// 报错：sum在这里不是有效变量</span></span><br></pre></td></tr></table></figure>
<p>如果省略上面例子中的关键字<code>var</code>，<code>sum</code>会被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)  </span>&#123;</span><br><span class="line">  sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);         <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>未经声明而初始化变量是JavaScript编程中一个非常常见的错误，会导致很多问题。为此在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p>
</blockquote>
<p><code>var</code>声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。下面的例子展示了在全局作用域中两段等价的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br></pre></td></tr></table></figure>
<p>下面是两个等价的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通声明的提升意味着会输出<code>undefined</code>而不是<code>Reference Error</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-2-使用let的块级作用域声明"><a href="#4-2-2-2-使用let的块级作用域声明" class="headerlink" title="4.2.2.2   使用let的块级作用域声明"></a><strong>4.2.2.2   使用</strong><code>let</code>的块级作用域声明</h4><p>ES6新增的<code>let</code>关键字的作用域是块级的。块级作用域由最近的一对包含花括号<code>&#123;&#125;</code>界定。<code>if</code>块、<code>while</code>块、<code>function</code>块，甚至连单独的块也是<code>let</code>声明变量的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line">                <span class="comment">// var声明也会导致报错</span></span><br><span class="line"><span class="comment">// 这不是对象字面量，而是一个独立的块</span></span><br><span class="line"><span class="comment">// JavaScript解释器会根据其中内容识别出它来</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>与<code>var</code>的另一个不同之处是在同一作用域内不能声明两次。重复的<code>var</code>声明会被忽略，而重复的<code>let</code>声明会抛出<code>SyntaxError</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: 标识符b已经声明过了</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>的行为非常适合在循环中声明迭代变量。使用<code>var</code>声明的迭代变量会泄漏到循环外部，这种情况应该避免。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError: j没有定义</span></span><br></pre></td></tr></table></figure>
<p>严格来讲，<code>let</code>在JavaScript运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用<code>let</code>变量。</p>
<h4 id="4-2-2-3-使用const的常量声明"><a href="#4-2-2-3-使用const的常量声明" class="headerlink" title="4.2.2.3   使用const的常量声明"></a><strong>4.2.2.3   使用</strong><code>const</code>的常量声明</h4><p>使用<code>const</code>声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>除了要遵循以上规则，其他方面与<code>let</code>声明是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>声明只应用到顶级原语或者对象。换句话说，赋值为对象的<code>const</code>变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果想让整个对象都不能修改，可以使用<code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错，但会静默失败：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o3.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>由于<code>const</code>声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化。</p>
<blockquote>
<p><strong>注意</strong>开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用<code>const</code>声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。</p>
<h4 id="4-2-2-4-标识符查找"><a href="#4-2-2-4-标识符查找" class="headerlink" title="4.2.2.4   标识符查找"></a><strong>4.2.2.4   标识符查找</strong></h4></blockquote>
<p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;blue&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，调用函数<code>getColor()</code>时会引用变量<code>color</code>。为确定<code>color</code>的值会进行两步搜索。第一步，搜索<code>getColor()</code>的变量对象，查找名为<code>color</code>的标识符。结果没找到，于是继续搜索下一个变量对象（来自全局上下文），然后就找到了名为<code>color</code>的标识符。因为全局变量对象上有<code>color</code>的定义，所以搜索结束。<br>对搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;green&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>getColor()</code>内部声明了一个名为<code>color</code>的局部变量。在调用这个函数时，变量会被声明。在执行到函数返回语句时，代码引用了变量<code>color</code>。于是开始在局部上下文中搜索这个标识符，结果找到了值为<code>&#39;green&#39;</code>的变量<code>color</code>。因为变量已找到，搜索随即停止，所以就使用这个局部变量。这意味着函数会返回<code>&#39;green&#39;</code>。在局部变量<code>color</code>声明之后的任何代码都无法访问全局变量<code>color</code>，除非使用完全限定的写法<code>window.color</code>。</p>
<blockquote>
<p><strong>注意</strong>标识符查找有一定代价。访问局部变量比访问全局变量要快，因为不用切换作用域。</p>
</blockquote>
<h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3　垃圾回收"></a>4.3　垃圾回收</h2><p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。JavaScript通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p>
<p>以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量有不同的实现方式，在浏览器的发展史上，主要用到过两种标记策略：标记清理和引用计数。</p>
<h3 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1　标记清理"></a>4.3.1　标记清理</h3><p>JavaScript最常用的垃圾回收策略是<strong>标记清理</strong>（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p>
<p>垃圾回收程序运行的时候，会标记内存中存储的所有变量（标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次<strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2　引用计数"></a>4.3.2　引用计数</h3><p>另一种没那么常用的垃圾回收策略是<strong>引用计数</strong>（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
<p>引用计数会遇到了严重的问题：<strong>循环引用</strong>。就是对象A有一个指针指向对象B，而对象B也引用了对象A。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  objectA.someOtherObject = objectB;</span><br><span class="line">  objectB.anotherObject = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>objectA</code>和<code>objectB</code>通过各自的属性相互引用，意味着它们的引用数都是2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，<code>objectA</code>和<code>objectB</code>在函数结束后还会存在，因为它们的引用数永远不会变成0。如果函数被多次调用，则会导致大量内存永远不会被释放。<br>在IE8及更早版本的IE中，并非所有对象都是原生JavaScript对象。BOM和DOM中的对象是C++实现的组件对象模型（COM，Component Object Model）对象，而COM对象使用引用计数实现垃圾回收。因此，即使这些版本IE的JavaScript引擎使用标记清理，JavaScript存取的COM对象依旧使用引用计数。下面这个简单的例子展示了涉及COM对象的循环引用问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br></pre></td></tr></table></figure>
<p>这个例子在一个DOM对象（<code>element</code>）和一个原生JavaScript对象（<code>myObject</code>）之间制造了循环引用。因此DOM元素的内存永远不会被回收，即使它已经被从页面上删除了也是如此。<br>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>把变量设置为<code>null</code>实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。<br>为了补救这一点，IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。</p>
<h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3　性能"></a>4.3.3　性能</h3><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。</p>
<p>现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，“在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”</p>
<p>由于调度垃圾回收程序方面的问题会导致性能下降，IE曾饱受诟病。它的策略是根据分配数，比如分配了256个变量、4096个对象/数组字面量和数组槽位（slot），或者64KB字符串。只要满足其中某个条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就会导致垃圾回收程序过于频繁地运行。</p>
<p>IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7的起始阈值都与IE6的相同。如果垃圾回收程序回收的内存不到已分配的15%，这些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存达到已分配的85%，则阈值重置为默认值。这么一个简单的修改，极大地提升了重度依赖JavaScript的网页在浏览器中的性能。</p>
<blockquote>
<p><strong>警告</strong>在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在IE中，<code>window.CollectGarbage()</code>方法会立即触发垃圾回收。在Opera 7及更高版本中，调用<code>window.opera.collect()</code>也会启动垃圾回收程序。</p>
</blockquote>
<h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4　内存管理"></a>4.3.4　内存管理</h3><p>在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。</p>
<p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为<code>null</code>，从而释放其引用。这也可以叫作<strong>解除引用</strong>。这个建议最适合全局变量和全局对象的属性，因为局部变量在超出作用域后会被自动解除引用，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  localPerson.name = name;</span><br><span class="line">  <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> globalPerson = createPerson(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="comment">// 解除globalPerson对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>不过解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p>
<h4 id="4-3-4-1-通过const和let声明提升性能"><a href="#4-3-4-1-通过const和let声明提升性能" class="headerlink" title="4.3.4.1   通过const和let声明提升性能"></a><strong>4.3.4.1   通过</strong><code>const</code>和<code>let</code>声明提升性能</h4><p>ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为<code>const</code>和<code>let</code>都以块（而非函数）为作用域，所以相比于使用<code>var</code>，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。</p>
<h4 id="4-3-4-2-隐藏类和删除操作"><a href="#4-3-4-2-隐藏类和删除操作" class="headerlink" title="4.3.4.2   隐藏类和删除操作"></a><strong>4.3.4.2   隐藏类和删除操作</strong></h4><p>有时候需要根据浏览器使用的JavaScript引擎来采取不同的性能优化策略。V8 JavaScript引擎在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。</p>
<p>运行期间，V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure>
<p>V8会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a2.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>此时两个<code>Article</code>实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。<br>解决方案就是避免JavaScript的“先创建再补充”（ready-fire-aim）式的动态属性赋值，在构造函数中一次性声明所有属性，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这样两个实例基本上就一样了（不考虑<code>hasOwnProperty</code>的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过使用<code>delete</code>关键字会导致生成相同的隐藏类片段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author;</span><br></pre></td></tr></table></figure>
<p>这样即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为<code>null</code>。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line">a1.author = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-3-内存泄漏（review）"><a href="#4-3-4-3-内存泄漏（review）" class="headerlink" title="4.3.4.3   内存泄漏（review）"></a><strong>4.3.4.3   内存泄漏（review）</strong></h4><p>在内存有限的设备上或函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合理的引用导致的。</p>
<p>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时解释器会把变量<code>name</code>当作<code>window</code>的属性来创建（相当于<code>window.name = &#39;Jake&#39;</code>）。因为在<code>window</code>对象上创建的属性，导致<code>window</code>本身不被清理就不会消失。只要在变量声明前头加上<code>var</code>、<code>let</code>或<code>const</code>关键字即可解决。<br>定时器也可能会导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>只要定时器一直运行，回调函数中引用的<code>name</code>就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。<br>使用JavaScript闭包也很容易造成内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这会导致分配给<code>name</code>的内存被泄漏。以上代码创建了一个内部闭包，只要<code>outer</code>函数存在就不能清理<code>name</code>，因为闭包一直在引用着它。假如<code>name</code>的内容很大，那可能就是个大问题。</p>
<h4 id="4-3-4-4-静态分配与对象池-review"><a href="#4-3-4-4-静态分配与对象池-review" class="headerlink" title="4.3.4.4   静态分配与对象池(review)"></a><strong>4.3.4.4   静态分配与对象池(review)</strong></h4><p>为了提升JavaScript性能，最后要考虑的就是浏览器。关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。</p>
<p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。下面是一个计算二维矢量加法的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resultant = <span class="keyword">new</span> Vector();</span><br><span class="line">  resultant.x = a.x + b.x;</span><br><span class="line">  resultant.y = a.y + b.y;</span><br><span class="line">  <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。再加上这个矢量加法函数如果频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。<br>该问题的解决方案是不要动态创建矢量对象，让它使用一个已有的矢量对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b, resultant</span>) </span>&#123;</span><br><span class="line">  resultant.x = a.x + b.x;</span><br><span class="line">  resultant.y = a.y + b.y;</span><br><span class="line">  <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这需要在其他地方实例化矢量参数<code>resultant</code>，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？<br>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vectorPool是已有的对象池</span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.allocate();</span><br><span class="line">v1.x = <span class="number">10</span>;</span><br><span class="line">v1.y = <span class="number">5</span>;</span><br><span class="line">v2.x = -<span class="number">3</span>;</span><br><span class="line">v2.y = -<span class="number">6</span>;</span><br><span class="line">addVector(v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log([v3.x, v3.y]); <span class="comment">// [7, -1]</span></span><br><span class="line">vectorPool.free(v1);</span><br><span class="line">vectorPool.free(v2);</span><br><span class="line">vectorPool.free(v3);</span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象,则这里也需要把这些属性设置为null</span></span><br><span class="line">v1 = <span class="literal">null</span>;</span><br><span class="line">v2 = <span class="literal">null</span>;</span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vectorList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> vector = <span class="keyword">new</span> Vector();</span><br><span class="line">vectorList.push(vector);</span><br></pre></td></tr></table></figure>
<p>由于JavaScript数组的大小是动态可变的，引擎会删除大小为100的数组，再创建一个新的大小为200的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。</p>
<blockquote>
<p><strong>注意</strong>静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能，但并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p>
</blockquote>
<h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4　小结"></a>4.4　小结</h2><p>JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。原始值和引用值有以下特点。</p>
<ul>
<li>原始值大小固定，因此保存在栈内存上。</li>
<li>从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li>
<li>引用值是对象，存储在堆内存上。</li>
<li>包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</li>
<li>从一个变量到另一个变量复制引用值只会复制指针，因此两个变量都指向同一个对象。</li>
<li><code>typeof</code>操作符可以确定值的原始类型，而<code>instanceof</code>操作符用于确保值的引用类型。</li>
</ul>
<p>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。</p>
<ul>
<li>执行上下文分全局上下文、函数上下文和块级上下文。</li>
<li>代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li>
<li>函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。</li>
<li>全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。</li>
<li>变量的执行上下文用于确定什么时候释放内存。</li>
</ul>
<p>JavaScript的垃圾回收程序可以总结如下。</p>
<ul>
<li>离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。</li>
<li>主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回收它们的内存。</li>
<li>引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，某些旧版本的IE仍会受这种算法的影响，因为JavaScript会访问非原生JavaScript对象（如DOM元素）。</li>
<li>引用计数在代码中存在循环引用时会出现问题。</li>
<li>解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
        <category>04-变量、作用域与内存</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>03-语言基础</title>
    <url>/2021/01/23/note/JavaScript/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1　语法"></a>3.1　语法</h2><h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1　区分大小写"></a>3.1.1　区分大小写</h3><p>ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符。</p>
<h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2　标识符"></a>3.1.2　标识符</h3><p><strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p>
<ol>
<li>第一个字符必须是一个字母、下划线_或美元符号$；</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。</p>
<p>ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>不能作为标识符。</p>
<h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3　注释"></a>3.1.3　注释</h3><p>包括单行注释和块注释。单行注释以两个斜杠字符开头，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>
<p>块注释以一个斜杠和一个星号（<code>/*</code>）开头，以它们的反向组合（<code>*/</code>）结尾，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是多行</span></span><br><span class="line"><span class="comment">注释 */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4　严格模式"></a>3.1.4　严格模式</h3><p>严格模式是一种不同的JavaScript解析和执行模型，要对整个脚本启用严格模式，在脚本开头加上：”use strict”;，它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。也可以单独指定一个函数在严格模式下执行，把这个预处理指令放到函数体开头即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5　语句"></a>3.1.5　语句</h3><p>ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sum &#x3D; a + b      &#x2F;&#x2F; 没有分号也有效，但不推荐</span><br></pre></td></tr></table></figure>
<p>加分号有助于防止省略造成的问题，比如避免输入内容不完整，也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误），也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。<br>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号（<code>&#123;</code>）标识开始，一个右花括号（<code>&#125;</code>）标识结束：</p>
<p>if之类的控制语句只在执行多条语句时要求必须有代码块。最好始终在控制语句中使用代码块，即使要执行的只有一条语句。</p>
<p>在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。</p>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2　关键字与保留字"></a>3.2　关键字与保留字</h2><p>保留的关键字不能用作标识符或属性名。ECMA-262第6版规定的所有关键字如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break       do          in            typeof</span><br><span class="line">case        else        instanceof    var</span><br><span class="line">catch       export      new           void</span><br><span class="line">class       extends     return        while</span><br><span class="line">const       finally     super         with</span><br><span class="line">continue    for         switch        yield</span><br><span class="line">debugger    function    this</span><br><span class="line">default     if          throw</span><br><span class="line">delete      import      try</span><br></pre></td></tr></table></figure>
<p>规范中也描述了一组<strong>未来的保留字</strong>，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">始终保留:</span><br><span class="line">enum</span><br><span class="line">严格模式下保留:</span><br><span class="line">implements  package     public</span><br><span class="line">interface   protected   static</span><br><span class="line">let         private</span><br><span class="line">模块代码中保留:</span><br><span class="line">await</span><br></pre></td></tr></table></figure>
<p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。但最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的ECMAScript版本。</p>
<h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3　变量"></a>3.3　变量</h2><p>ECMAScript变量是松散类型的，变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：<code>var</code>、<code>const</code>和<code>let</code>。其中，<code>var</code>在ECMAScript的所有版本中都可以使用，而<code>const</code>和<code>let</code>只能在ECMAScript 6及更晚的版本中使用。</p>
<h3 id="3-3-1var关键字"><a href="#3-3-1var关键字" class="headerlink" title="3.3.1var关键字"></a>3.3.1<code>var</code>关键字</h3><p>要定义变量，可以使用<code>var</code>操作符（注意<code>var</code>是一个关键字），后跟变量名（即标识符）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var message;</span><br></pre></td></tr></table></figure>
<p>（不初始化的情况下，变量会保存一个特殊值<code>undefined</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>初始化变量不会将它标识为字符串类型，只是一个简单的赋值而已。随后不仅可以改变保存的值，也可以改变值的类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">message = <span class="number">100</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-1var声明作用域"><a href="#3-3-1-1var声明作用域" class="headerlink" title="3.3.1.1var声明作用域"></a>3.3.1.1<code>var</code>声明作用域</h4><p><code>var</code>声明作用域关键的问题在于，使用<code>var</code>操作符定义的变量会成为包含它的函数的局部变量。使用<code>var</code>在一个函数内部定义一个变量，该变量将在函数退出时被销毁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<p>在函数内定义变量时省略<code>var</code>操作符，可以创建一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   message = <span class="string">&quot;hi&quot;</span>;     <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>虽然可以通过省略<code>var</code>操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出<code>ReferenceError</code>。</p>
</blockquote>
<p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进并不是必需的，但这样有利于阅读理解。<br>在严格模式下，不能定义名为<code>eval</code>和<code>arguments</code>的变量，否则会导致语法错误。</p>
<h4 id="3-3-1-2var声明提升"><a href="#3-3-1-2var声明提升" class="headerlink" title="3.3.1.2var声明提升"></a>3.3.1.2<code>var</code>声明提升</h4><p>使用<code>var</code>时，声明的变量会自动提升到函数作用域顶部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>反复多次使用<code>var</code>声明同一个变量也没有问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2let声明"><a href="#3-3-2let声明" class="headerlink" title="3.3.2let声明"></a>3.3.2<code>let</code>声明</h3><p><code>let</code>跟<code>var</code>最明显的区别是<code>let</code>声明的范围是块作用域，而<code>var</code>声明的范围是函数作用域。它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于<code>var</code>的作用域限制同样也适用于<code>let</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);   <span class="comment">// Matt</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);   <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>也不允许同一个块作用域中出现冗余声明。这样会导致报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;  <span class="comment">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);    <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混用<code>let</code>和<code>var</code>同样可能会到冗余声明。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-1-暂时性死区"><a href="#3-3-2-1-暂时性死区" class="headerlink" title="3.3.2.1**暂时性死区**"></a><strong>3.3.2.1**</strong>暂时性死区**</h4><p><code>let</code>与<code>var</code>的另一个重要的区别，就是<code>let</code>声明的变量不会在作用域中被提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="comment">// age不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p>在解析代码时，JavaScript引擎也会注意出现在块后面的<code>let</code>声明，只不过在此之前不能以任何方式来引用未声明的变量。在<code>let</code>声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出<code>ReferenceError</code>。</p>
<h4 id="3-3-2-2-全局声明"><a href="#3-3-2-2-全局声明" class="headerlink" title="3.3.2.2**全局声明**"></a><strong>3.3.2.2**</strong>全局声明**</h4><p>使用<code>let</code>在全局作用域中声明的变量不会成为<code>window</code>对象的属性（<code>var</code>声明的变量会）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但<code>let</code>声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免<code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p>
<h4 id="3-3-2-3-条件声明（review）"><a href="#3-3-2-3-条件声明（review）" class="headerlink" title="3.3.2.3**条件声明（review）**"></a><strong>3.3.2.3**</strong>条件声明（review）**</h4><p>在使用<code>var</code>声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为<code>let</code>的作用域是块，所以不可能检查前面是否已经使用<code>let</code>声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line">  <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="comment">// 这里没问题，因为可以被作为一个提升声明来处理</span></span><br><span class="line">  <span class="comment">// 不需要检查之前是否声明过同名变量</span></span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="comment">// 如果age之前声明过，这里会报错</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>try</code>/<code>catch</code>语句或<code>typeof</code>操作符也不能解决，因为<code>let</code>声明的作用域仅限于该条件块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line">  <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// name被限制在if &#123;&#125; 块的作用域内</span></span><br><span class="line">  <span class="comment">// 因此这个赋值形同全局赋值</span></span><br><span class="line">  name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> (age) &#123;</span><br><span class="line">    <span class="comment">// 如果age没有声明过，则会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="keyword">let</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// age被限制在catch &#123;&#125;块的作用域内</span></span><br><span class="line">  <span class="comment">// 因此这个赋值形同全局赋值</span></span><br><span class="line">  age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>为此，对于<code>let</code>声明关键字，不能依赖条件声明模式。</p>
<blockquote>
<p><strong>注意</strong>条件声明是一种反模式，它让程序变得更难理解。</p>
</blockquote>
<h4 id="3-3-2-4for循环中的let声明"><a href="#3-3-2-4for循环中的let声明" class="headerlink" title="3.3.2.4for循环中的let声明"></a>3.3.2.4<code>for</code>循环中的<code>let</code>声明</h4><p>在<code>let</code>出现之前，<code>for</code>循环定义的迭代变量会渗透到循环体外部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>改成使用<code>let</code>之后，这个问题就消失了，因为迭代变量的作用域仅限于<code>for</code>循环块内部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i没有定义</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>var</code>的时候，最常见的问题是对迭代变量的奇特声明和修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能以为会输出0、1、2、3、4</span></span><br><span class="line"><span class="comment">// 实际上会输出5、5、5、5、5</span></span><br></pre></td></tr></table></figure>
<p>在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的<code>i</code>都是同一个变量，因而输出的都是同一个最终值。<br>而在使用<code>let</code>声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个<code>setTimeout</code>引用的都是不同的变量实例，所以<code>console.log</code>输出的是循环执行过程中每个迭代变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-3const声明"><a href="#3-3-3const声明" class="headerlink" title="3.3.3const声明"></a>3.3.3<code>const</code>声明</h3><p><code>const</code>的行为与<code>let</code>基本相同，唯一区别是用它声明变量时必须同时初始化变量，且修改<code>const</code>声明的变量会导致运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="comment">// const也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// const声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>声明的限制只适用于它指向的变量的引用。如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>不能用<code>const</code>来声明迭代变量（因为迭代变量会自增）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>const</code>声明一个不会被修改的<code>for</code>循环变量。因为和<code>let</code>声明一样JavaScript引擎会为<code>for</code>循环中的<code>const</code>声明分别创建独立的变量实例。这对<code>for-of</code>和<code>for-in</code>循环特别有意义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> j = <span class="number">7</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7, 7, 7, 7, 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4　声明风格及最佳实践"></a>3.3.4　声明风格及最佳实践</h3><p>ECMAScript 6增加<code>let</code>和<code>const</code>从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的<code>var</code>所造成的各种问题，已经让JavaScript社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。</p>
<h4 id="3-3-4-1-不使用var"><a href="#3-3-4-1-不使用var" class="headerlink" title="3.3.4.1   不使用var"></a><strong>3.3.4.1   不使用</strong><code>var</code></h4><p>限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<h4 id="3-3-4-2const优先，let次之"><a href="#3-3-4-2const优先，let次之" class="headerlink" title="3.3.4.2const优先，let次之"></a>3.3.4.2<code>const</code>优先，<code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4　数据类型"></a>3.4　数据类型</h2><p>ECMAScript有6种简单数据类型（也称为<strong>原始类型</strong>）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。还有一种复杂数据类型叫<code>Object</code>（对象）。<code>Object</code>是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。一种数据类型可以当作多种数据类型来使用。</p>
<h3 id="3-4-1typeof操作符"><a href="#3-4-1typeof操作符" class="headerlink" title="3.4.1typeof操作符"></a>3.4.1<code>typeof</code>操作符</h3><p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。<code>typeof</code>操作符就是为此而生的。对一个值使用<code>typeof</code>操作符会返回下列字符串之一：</p>
<ul>
<li><code>&quot;undefined&quot;</code>表示值未定义；</li>
<li><code>&quot;boolean&quot;</code>表示值为布尔值；</li>
<li><code>&quot;string&quot;</code>表示值为字符串；</li>
<li><code>&quot;number&quot;</code>表示值为数值；</li>
<li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或<code>null</code>；</li>
<li><code>&quot;function&quot;</code>表示值为函数；</li>
<li><code>&quot;symbol&quot;</code>表示值为符号。</li>
</ul>
<p>下面是使用<code>typeof</code>操作符的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);    <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message));   <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);         <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>typeof</code>是一个操作符而不是函数，所以不需要参数（但可以使用参数）。<br><code>typeof</code>在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用<code>typeof   null</code>返回的是<code>&quot;object&quot;</code>。这是因为特殊值<code>null</code>被认为是一个对空对象的引用。</p>
<blockquote>
<p><strong>注意</strong>严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此通过<code>typeof</code>操作符来区分函数和其他对象。</p>
</blockquote>
<h3 id="3-4-2Undefined类型"><a href="#3-4-2Undefined类型" class="headerlink" title="3.4.2Undefined类型"></a>3.4.2<code>Undefined</code>类型</h3><p><code>Undefined</code>类型只有一个值，就是特殊值<code>undefined</code>。当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>变量<code>message</code>和<code>undefined</code>的字面值是相等的。但变量<code>message</code>显式地以<code>undefined</code>来初始化是不必要的，因为默认情况下，任何未经初始化的变量都会取得<code>undefined</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>永远不要显式地给某个变量设置<code>undefined</code>值。字面值<code>undefined</code>主要用于比较。增加这个特殊值的目的就是为了正式明确空对象指针（<code>null</code>）和未初始化变量的区别。</p>
</blockquote>
<p>包含<code>undefined</code>值的变量跟未定义变量是有区别的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;    <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>对未声明的变量，只能对它调用<code>typeof</code>。（对未声明的变量调用<code>delete</code>也不会报错，但这个操作没什么用，且在严格模式下会抛出错误。）<br>在对未初始化的变量和对未声明的变量调用<code>typeof</code>时，返回的结果都是<code>&quot;undefined&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>从逻辑上讲，虽然严格来讲这两个变量存在根本性差异，但它对任何一个变量都不可能执行什么真正的操作。</p>
<blockquote>
<p><strong>注意</strong>即使未初始化的变量会被自动赋予<code>undefined</code>值，但建议在声明变量的同时进行初始化。这样，当<code>typeof</code>返回<code>&quot;undefined&quot;</code>时，会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p>
</blockquote>
<p><code>undefined</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// age没有声明</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line">  <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-3Null类型"><a href="#3-4-3Null类型" class="headerlink" title="3.4.3Null类型"></a>3.4.3<code>Null</code>类型</h3><p><code>Null</code>类型同样只有一个值，即特殊值<code>null</code>。逻辑上讲，<code>null</code>值表示一个空对象指针，这也是给<code>typeof</code>传一个<code>null</code>会返回<code>&quot;object&quot;</code>的原因：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> car);  <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>在定义将来要保存对象值的变量时，建议使用<code>null</code>来初始化，不要使用其他值。这样，只要检查这个变量的值是不是<code>null</code>就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// car是一个对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>undefined</code>值是由<code>null</code>值派生而来的，因此ECMA-262将它们定义为表面上相等。用等于操作符（<code>==</code>）会为了比较而转换它的操作数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>即使<code>null</code>和<code>undefined</code>有关系，它们的用途也是完全不一样的。只要变量要保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量。这样就可以保持<code>null</code>是空对象指针的语义，并进一步将其与<code>undefined</code>区分开来。<br><code>null</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。例子也如前面所示。</p>
<h3 id="3-4-4Boolean类型"><a href="#3-4-4Boolean类型" class="headerlink" title="3.4.4Boolean类型"></a>3.4.4<code>Boolean</code>类型</h3><p><code>Boolean</code>（布尔值）类型有两个字面值：<code>true</code>和<code>false</code>。这两个布尔值不同于数值，<code>true</code>不等于1，<code>false</code>不等于0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> lost = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>布尔值字面量<code>true</code>和<code>false</code>是区分大小写的，因此<code>True</code>和<code>False</code>（及其他大小混写形式）是有效的标识符，但不是布尔值。<br>虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。可以调用特定的<code>Boolean()</code>转型函数，将一个其他类型的值转换为布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，字符串<code>message</code>会被转换为布尔值并保存在变量<code>messageAsBoolean</code>中。<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为<code>true</code>或<code>false</code>的规则取决于数据类型和实际的值。<br>|数据类型|转换为true的值|转换为false的值|<br>|:—-|:—-|:—-|<br>|Boolean|true|false|<br>|String|非空字符串|””（空字符串）|<br>|Number|非零数值（包括无穷值）|0、NaN|<br>|Object|任意对象|null|<br>|Undefined|N/A（不存在）|undefined|</p>
<p><code>if</code>等流控制语句会自动执行其他类型值到布尔值的转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Value is true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。</p>
<h3 id="3-4-5Number类型"><a href="#3-4-5Number类型" class="headerlink" title="3.4.5Number类型"></a>3.4.5<code>Number</code>类型</h3><p><code>Number</code>类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，直接写出来即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>;  <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure>
<p>用八进制（以8为基数）字面量表示，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。<br>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。ECMAScript 2015或ES6中的八进制值通过前缀<code>0o</code>来表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>;  <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>;  <span class="comment">// 无效的八进制值，当成79处理</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span>;   <span class="comment">// 无效的八进制值，当成8处理</span></span><br></pre></td></tr></table></figure>
<p>整数也可以或十六进制（以16为基数）字面量表示。必须让真正的数值前缀<code>0x</code>（区分大小写），然后是十六进制数字（0<del>9以及A</del>F）。十六进制数字中的字母大小写均可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>;   <span class="comment">// 十六进制10</span></span><br><span class="line"><span class="keyword">let</span> hexNum2 = <span class="number">0x1f</span>;  <span class="comment">// 十六进制31</span></span><br></pre></td></tr></table></figure>
<p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<blockquote>
<p><strong>注意</strong>由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。</p>
<h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1   浮点值"></a><strong>3.4.5.1   浮点值</strong></h4></blockquote>
<p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">.1</span>;   <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">// 小数点后面没有数字，当成整数1处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">// 小数点后面是零，当成整数10处理</span></span><br></pre></td></tr></table></figure>
<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure>
<p>科学记数法也可以用于表示非常小的数值。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为3e-7）。<br>浮点值的精确度最高可达17位小数，但在算术计算中不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123;      <span class="comment">// 别这么干！</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;You got 0.3.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个数值分别是0.05和0.25，或者0.15和0.15，没问题。但如果是0.1和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p>
<blockquote>
<p><strong>注意</strong>之所以存在这种舍入错误，是因为使用了IEEE 754数值。其他使用相同格式的语言也有这个问题。</p>
<h4 id="3-4-5-2-值的范围"><a href="#3-4-5-2-值的范围" class="headerlink" title="3.4.5.2   值的范围"></a><strong>3.4.5.2   值的范围</strong></h4></blockquote>
<p>由于内存的限制，ECMAScript可以表示的最小数值保存在<code>Number.MIN_VALUE</code>中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。</p>
<p>如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的<code>Infinity</code>（无穷）值。任何无法表示的负数以<code>-Infinity</code>（负无穷大）表示，任何无法表示的正数以<code>Infinity</code>（正无穷大）表示。</p>
<p>如果计算返回正<code>Infinity</code>或负<code>Infinity</code>，则该值将不能再进一步用于任何计算。这是因为<code>Infinity</code>没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用<code>isFinite()</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>使用<code>Number.NEGATIVE_INFINITY</code>和<code>Number.POSITIVE_INFINITY</code>也可以获取正、负<code>Infinity</code>。这两个属性包含的值分别就是<code>-Infinity</code>和<code>Infinity</code>。</p>
</blockquote>
<h4 id="3-4-5-3NaN"><a href="#3-4-5-3NaN" class="headerlink" title="3.4.5.3NaN"></a>3.4.5.3<code>NaN</code></h4><p>有一个特殊的数值叫<code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回<code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span>/+<span class="number">0</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>如果分子是非0值，分母是有符号0或无符号0，则会返回<code>Infinity</code>或<code>-Infinity</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/-<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>NaN</code>有几个独特的属性。首先，任何涉及<code>NaN</code>的操作始终返回<code>NaN</code>（如<code>NaN/10</code>），在连续多步计算时这可能是个问题。其次，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript提供了<code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给<code>isNaN()</code>后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>));      <span class="comment">// false，10是数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>虽然不常见，但<code>isNaN()</code>可以用于测试对象。首先会调用对象的<code>valueOf()</code>方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用<code>toString()</code>方法，并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式。</p>
<h4 id="3-4-5-4-数值转换"><a href="#3-4-5-4-数值转换" class="headerlink" title="3.4.5.4   数值转换"></a><strong>3.4.5.4   数值转换</strong></h4></blockquote>
<p>有3个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。</p>
<p><code>Number()</code>函数基于如下规则执行转换。</p>
<pre><code>1. 布尔值，`true`转换为1，`false`转换为0。
2. 数值，直接返回。
3. `null`，返回0。
4. `undefined`，返回`NaN`。
5. 字符串，应用以下规则。
    1. 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，`Number(&quot;1&quot;)`返回1，`Number(&quot;123&quot;)`返回123，`Number(&quot;011&quot;)`返回11（忽略前面的零）。
    2. 如果字符串包含有效的浮点值格式如`&quot;1.1&quot;`，则会转换为相应的浮点值（同样，忽略前面的零）。
    3. 如果字符串包含有效的十六进制格式如`&quot;0xf&quot;`，则会转换为与该十六进制值对应的十进制整数值。
    4. 如果是空字符串（不包含字符），则返回0。
    5. 如果字符串包含除上述情况之外的其他字符，则返回`NaN`。
6. 对象，调用`valueOf()`方法，并按照上述规则转换返回的值。如果转换结果是`NaN`，则调用`toString()`方法，再按照转换字符串的规则转换。</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>);              <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>);        <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);            <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>一元加操作符与<code>Number()</code>函数遵循相同的转换规则。</p>
</blockquote>
<p><code>Number()</code>函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用<code>parseInt()</code>函数。<code>parseInt()</code>函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回<code>NaN</code>。这意味着空字符串也会返回<code>NaN</code>。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p>
<p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以<code>&quot;0x&quot;</code>开头，就会被解释为十六进制整数。如果字符串以<code>&quot;0&quot;</code>开头，且紧跟着数值字符，就会被解释为八进制整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>);          <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 10，解释为十六进制整数</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);        <span class="comment">// 22 因为小数点不是有效的整数字符</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>);        <span class="comment">// 70，解释为十进制值</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>);       <span class="comment">// 15，解释为十六进制整数</span></span><br></pre></td></tr></table></figure>
<p>不同的数值格式很容易混淆，因此<code>parseInt()</code>也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入16作为第二个参数，以便正确解析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br></pre></td></tr></table></figure>
<p>事实上，如果提供了十六进制参数，那么字符串前面的<code>&quot;0x&quot;</code>可以省掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);  <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>通过第二个参数，可以极大扩展转换后获得的结果类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>);   <span class="comment">// 2，按二进制解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);   <span class="comment">// 8，按八进制解析</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);  <span class="comment">// 10，按十进制解析</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>);  <span class="comment">// 16，按十六进制解析</span></span><br></pre></td></tr></table></figure>
<p>因为不传底数参数相当于让<code>parseInt()</code>自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p>
<blockquote>
<p><strong>注意</strong>多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。</p>
</blockquote>
<p><code>parseFloat()</code>函数的工作方式跟<code>parseInt()</code>函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p>
<p><code>parseFloat()</code>函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为<code>parseFloat()</code>只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则<code>parseFloat()</code>返回整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234，按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>);      <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>);   <span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>);    <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>);   <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-6String类型"><a href="#3-4-6String类型" class="headerlink" title="3.4.6String类型"></a>3.4.6<code>String</code>类型</h3><p><code>String</code>（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure>
<p>跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript语法中表示字符串的引号没有区别。并且以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Nicholas&quot;; // 语法错误：开头和结尾的引号必须是同一种</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-1-字符字面量"><a href="#3-4-6-1-字符字面量" class="headerlink" title="3.4.6.1   字符字面量"></a><strong>3.4.6.1   字符字面量</strong></h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字面量</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">反斜杠（\）</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td>
</tr>
<tr>
<td align="left">\`</td>
<td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td>
</tr>
<tr>
<td align="left">\x<em>nn</em></td>
<td align="left">以十六进制编码<em>nn</em>表示的字符（其中<em>n</em>是十六进制数字0~F），例如\x41等于”A”</td>
</tr>
<tr>
<td align="left">\u<em>nnnn</em></td>
<td align="left">以十六进制编码<em>nnnn</em>表示的Unicode字符（其中<em>n</em>是十六进制数字0~F），例如\u03a3等于希腊字符”Σ”</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is the letter sigma: \u03a3.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>即使包含6个字符长的转义序列，变量<code>text</code>仍然是28个字符长。因为转义序列表示一个字符。<br>字符串的长度可以通过其<code>length</code>属性获取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p>
</blockquote>
<h4 id="3-4-6-2字符串的特点"><a href="#3-4-6-2字符串的特点" class="headerlink" title="3.4.6.2字符串的特点"></a>3.4.6.2<strong>字符串的特点</strong></h4><p>ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3   转换为字符串"></a><strong>3.4.6.3   转换为字符串</strong></h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的<code>toString()</code>方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString();      <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString();  <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toString()</code>方法可见于数值、布尔值、对象和字符串值。（字符串值使用<code>toString()</code>方法只是简单地返回自身的一个副本。）<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法。<br>多数情况下，<code>toString()</code>不接收任何参数。但对数值调用这个方法时，<code>toString()</code>可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，<code>toString()</code>返回数值的十进制字符串表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());     <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));    <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));    <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));   <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));   <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果不确定一个值是不是<code>null</code>或<code>undefined</code>，可以使用<code>String()</code>转型函数，它始终会返回表示相应类型值的字符串。<code>String()</code>函数遵循如下规则。<br>    1. 如果值有<code>toString()</code>方法，则调用该方法（不传参数）并返回结果。<br>    2. 如果值是<code>null</code>，返回<code>&quot;null&quot;</code>。<br>    3. 如果值是<code>undefined</code>，返回<code>&quot;undefined&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value1));  <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value2));  <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value3));  <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value4));  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>用加号操作符给一个值加上一个空字符串<code>&quot;&quot;</code>也可以将其转换为字符串。</p>
<h4 id="3-4-6-4-模板字面量（review）"><a href="#3-4-6-4-模板字面量（review）" class="headerlink" title="3.4.6.4   模板字面量（review）"></a><strong>3.4.6.4   模板字面量（review）</strong></h4></blockquote>
<p>ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineTemplateLiteral);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString === myMultiLinetemplateLiteral); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>模板字面量在定义模板时特别有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br></pre></td></tr></table></figure>
<p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意，格式正确的模板字符串可能反而会看起来缩进不当：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个模板字面量在换行符之后有25个空格符</span></span><br><span class="line"><span class="keyword">let</span> myTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">                         second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myTemplateLiteral.length);  <span class="comment">// 47</span></span><br><span class="line"><span class="comment">// 这个模板字面量以一个换行符开头</span></span><br><span class="line"><span class="keyword">let</span> secondTemplateLiteral = <span class="string">`</span></span><br><span class="line"><span class="string">first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(secondTemplateLiteral[<span class="number">0</span>] === <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-5-字符串插值（review）"><a href="#3-4-6-5-字符串插值（review）" class="headerlink" title="3.4.6.5   字符串插值（review）"></a><strong>3.4.6.5   字符串插值（review）</strong></h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p>
<p>字符串插值通过在<code>$&#123;&#125;</code>中使用一个JavaScript表达式实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedString =</span><br><span class="line">  value + <span class="string">&#x27; to the &#x27;</span> + exponent + <span class="string">&#x27; power is &#x27;</span> + (value * value);</span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral =</span><br><span class="line">  <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; <span class="string">`World`</span> &#125;</span>!`</span>);  <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>将表达式转换为字符串时会调用<code>toString()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>);      <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>在插值表达式中可以调用函数和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>模板也可以插入自己之前的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">append();  <span class="comment">// abc</span></span><br><span class="line">append();  <span class="comment">// abcabc</span></span><br><span class="line">append();  <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-6-模板字面量标签函数（review）"><a href="#3-4-6-6-模板字面量标签函数（review）" class="headerlink" title="3.4.6.6   模板字面量标签函数（review）"></a><strong>3.4.6.6   模板字面量标签函数（review）</strong></h4><p>模板字面量也支持定义<strong>标签函数</strong>（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p>
<p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="built_in">console</span>.log(aValExpression);</span><br><span class="line">  <span class="built_in">console</span>.log(bValExpression);</span><br><span class="line">  <span class="built_in">console</span>.log(sumExpression);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);   <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);     <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(expression);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);  <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于有n个插值的模板字面量，传给标签函数的表达式参数的个数始终是n，而传给标签函数的第一个参数所包含的字符串个数则始终是n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zipTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strings[<span class="number">0</span>] +</span><br><span class="line">         expressions.map(<span class="function">(<span class="params">e, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;e&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">                    .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult =    <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = zipTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);  <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);    <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-7-原始字符串-review"><a href="#3-4-6-7-原始字符串-review" class="headerlink" title="3.4.6.7   原始字符串(review)"></a><strong>3.4.6.7   原始字符串(review)</strong></h4><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的<code>String.raw</code>标签函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode示例</span></span><br><span class="line"><span class="comment">// \u00A9是版权符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);            <span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);  <span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br><span class="line"><span class="comment">// 对实际的换行符来说是不行的</span></span><br><span class="line"><span class="comment">// 它们不会被转换成转义序列的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure>
<p>可以通过标签函数的第一个参数，即字符串数组的<code>.raw</code>属性取得每个字符串的原始内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Actual characters:&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(string);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Escaped characters;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.raw) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rawString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-7Symbol类型"><a href="#3-4-7Symbol类型" class="headerlink" title="3.4.7Symbol类型"></a>3.4.7<code>Symbol</code>类型</h3><p><code>Symbol</code>（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<p>听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。</p>
<h4 id="3-4-7-1-符号的基本用法"><a href="#3-4-7-1-符号的基本用法" class="headerlink" title="3.4.7.1   符号的基本用法"></a><strong>3.4.7.1   符号的基本用法</strong></h4><p>符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型，所以<code>typeof</code>操作符对符号返回<code>symbol</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p>调用<code>Symbol()</code>函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是这个字符串参数与符号定义或标识完全无关：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol == otherGenericSymbol);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol);          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，只要创建<code>Symbol()</code>实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol);  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol);      <span class="comment">// Symbol(foo);</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol()</code>函数不能用作构造函数，与<code>new</code>关键字一起使用。这样是为了避免创建符号包装对象，像使用<code>Boolean</code>、<code>String</code>或<code>Number</code>那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myString);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myNumber);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>如果你确实想使用符号包装对象，可以借用<code>Object()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol);   <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-2-使用全局符号注册表"><a href="#3-4-7-2-使用全局符号注册表" class="headerlink" title="3.4.7.2   使用全局符号注册表"></a><strong>3.4.7.2   使用全局符号注册表</strong></h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用<code>Symbol.for()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，就生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);       <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);  <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用<code>Symbol()</code>定义的符号也不等同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给<code>Symbol.for()</code>的任何值都会被转换为字符串。注册表中使用的键同时也会被用作符号描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(emptyGlobalSymbol);    <span class="comment">// Symbol(undefined)</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>Symbol.keyFor()</code>来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s));   <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果传给<code>Symbol.keyFor()</code>的不是符号，则该方法抛出<code>TypeError</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-3-使用符号作为属性-review"><a href="#3-4-7-3-使用符号作为属性-review" class="headerlink" title="3.4.7.3   使用符号作为属性(review)"></a><strong>3.4.7.3   使用符号作为属性(review)</strong></h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code>/<code>Object.definedProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line">  [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">  [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">//  Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。两个方法的返回值彼此互斥。<code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规和符号属性描述符的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">  qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure>
<p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">  [Symbol(&#39;foo&#39;)]: &#39;foo val&#39;,</span><br><span class="line">  [Symbol(&#39;bar&#39;)]: &#39;bar val&#39;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o);</span><br><span class="line">&#x2F;&#x2F; &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span><br><span class="line">let barSymbol &#x3D; Object.getOwnPropertySymbols(o)</span><br><span class="line">              .find((symbol) &#x3D;&gt; symbol.toString().match(&#x2F;bar&#x2F;));</span><br><span class="line">console.log(barSymbol);</span><br><span class="line">&#x2F;&#x2F; Symbol(bar)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-4-常用内置符号"><a href="#3-4-7-4-常用内置符号" class="headerlink" title="3.4.7.4   常用内置符号"></a><strong>3.4.7.4   常用内置符号</strong></h4><p>ECMAScript 6引入了一批<strong>常用内置符号</strong>（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。它们以<code>Symbol</code>工厂函数字符串属性的形式存在。</p>
<p>内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变<code>for-of</code>在迭代该对象时的行为。</p>
<p>这些内置符号也没有什么特别之处，它们就是全局函数<code>Symbol</code>的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>
<blockquote>
<p><strong>注意</strong>在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为<code>@@</code>。比如，<code>@@iterator</code>指的就是<code>Symbol.iterator</code>。</p>
</blockquote>
<h4 id="3-4-7-5Symbol-asyncIterator（review）"><a href="#3-4-7-5Symbol-asyncIterator（review）" class="headerlink" title="3.4.7.5Symbol.asyncIterator（review）"></a><strong>3.4.7.5</strong><code>Symbol.asyncIterator（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的<code>AsyncIterator</code>，由<code>for-await-of</code>语句使用”。也就是这个符号表示实现异步迭代器API的函数。</p>
<p><code>for-await-of</code>循环会利用这个函数执行异步迭代操作。循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>AsyncGenerator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.asyncIterator]());</span><br><span class="line"><span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>技术上，这个由<code>Symbol.asyncIterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回<code>Promise</code>实例。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过异步生成器函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="built_in">this</span>.asyncIdx++));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>Symbol.asyncIterator</code>是ES2018规范定义的，因此只有版本非常新的浏览器支持它。关于异步迭代和<code>for-await-of</code>循环的细节，参见附录A。</p>
</blockquote>
<h4 id="3-4-7-6Symbol-hasInstance"><a href="#3-4-7-6Symbol-hasInstance" class="headerlink" title="3.4.7.6Symbol.hasInstance"></a>3.4.7.6<code>Symbol.hasInstance</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用”。<code>instanceof</code>操作符可以用来确定一个对象实例的原型链上是否有原型。<code>instanceof</code>的典型使用场景如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在ES6中，<code>instanceof</code>操作符会使用<code>Symbol.hasInstance</code>函数来确定关系。以<code>Symbol.hasInstance</code>为键的函数会执行同样的操作，只是操作数对调了一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](f)); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个属性定义在Function的原型上，因此默认在所有函数和类上都可以调用。由于instanceof操作符会在原型链上寻找这个属性定义，因此可以在继承的类上通过静态方法重新定义这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-7Symbol-isConcatSpreadable（review）"><a href="#3-4-7-7Symbol-isConcatSpreadable（review）" class="headerlink" title="3.4.7.7Symbol.isConcatSpreadable（review）"></a>3.4.7.7<code>Symbol.isConcatSpreadable（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是<code>true</code>，则对象应该用<code>Array.prototype.concat()</code>打平其数组元素”。ES6中的<code>Array.prototype.concat()</code>方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。</p>
<p>数组对象默认情况下会被打平到已有的数组，<code>false</code>或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，<code>true</code>或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在<code>Symbol.isConcatSpreadable</code>被设置为<code>true</code>的情况下将被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line">arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-8Symbol-iterator（review）"><a href="#3-4-7-8Symbol-iterator（review）" class="headerlink" title="3.4.7.8Symbol.iterator（review）"></a>3.4.7.8<code>Symbol.iterator（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由<code>for-of</code>语句使用”。换句话说，这个符号表示实现迭代器API的函数。</p>
<p><code>for-of</code>循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以<code>Symbol.iterator</code>为键的函数，并默认这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>Generator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>技术上，这个由<code>Symbol.iterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回值。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过生成器函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.idx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">count();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-9Symbol-match-（review）"><a href="#3-4-7-9Symbol-match-（review）" class="headerlink" title="3.4.7.9Symbol.match``（review）"></a>3.4.7.9<code>Symbol.match``（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用”。<code>String.prototype.match()</code>方法会使用以<code>Symbol.match</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]);</span><br><span class="line"><span class="comment">// f [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义<code>Symbol.match</code>函数以取代默认对正则表达式求值的行为，从而让<code>match()</code>方法使用非正则表达式实例。<code>Symbol.match</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(FooMatcher)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(FooMatcher)); <span class="comment">// false</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMatcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-10Symbol-replace（review）"><a href="#3-4-7-10Symbol-replace（review）" class="headerlink" title="3.4.7.10Symbol.replace（review）"></a>3.4.7.10<code>Symbol.replace（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>方法使用”。<code>String.prototype.replace()</code>方法会使用以<code>Symbol.replace</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]);</span><br><span class="line"><span class="comment">// f [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.replace(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.replace</code>函数以取代默认对正则表达式求值的行为，从而让<code>replace()</code>方法使用非正则表达式实例。<code>Symbol.replace</code>函数接收两个参数，即调用<code>replace()</code>方法的字符串实例和替换字符串。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooReplacer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(FooReplacer, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReplacer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(<span class="keyword">new</span> StringReplacer(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-11Symbol-search（review）"><a href="#3-4-7-11Symbol-search（review）" class="headerlink" title="3.4.7.11Symbol.search（review）"></a>3.4.7.11<code>Symbol.search（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用”。<code>String.prototype.search()</code>方法会使用以<code>Symbol.search</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]);</span><br><span class="line"><span class="comment">// f [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.search</code>函数以取代默认对正则表达式求值的行为，从而让<code>search()</code>方法使用非正则表达式实例。<code>Symbol.search</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSearcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(FooSearcher)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(FooSearcher)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(FooSearcher)); <span class="comment">// -1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSearcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-12Symbol-species（review）"><a href="#3-4-7-12Symbol-species（review）" class="headerlink" title="3.4.7.12Symbol.species（review）"></a>3.4.7.12<code>Symbol.species（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用<code>Symbol.species</code>定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);   <span class="comment">// true</span></span><br><span class="line">bar = bar.concat(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// true</span></span><br><span class="line">baz = baz.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-13Symbol-split（review）"><a href="#3-4-7-13Symbol-split（review）" class="headerlink" title="3.4.7.13Symbol.split（review）"></a>3.4.7.13<code>Symbol.split（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用”。<code>String.prototype.split()</code>方法会使用以<code>Symbol.split</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]);</span><br><span class="line"><span class="comment">// f [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.split(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.split</code>函数以取代默认对正则表达式求值的行为，从而让<code>split()</code>方法使用非正则表达式实例。<code>Symbol.split</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSplitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(FooSplitter));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSplitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(<span class="keyword">new</span> StringSplitter(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-14Symbol-toPrimitive（review）"><a href="#3-4-7-14Symbol-toPrimitive（review）" class="headerlink" title="3.4.7.14Symbol.toPrimitive（review）"></a>3.4.7.14<code>Symbol.toPrimitive（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的<code>Symbol.toPrimitive</code>属性上定义一个函数可以改变默认行为。</p>
<p>根据提供给这个函数的参数（<code>string</code>、<code>number</code>或<code>default</code>），可以控制返回的原始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo);       <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo);       <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));   <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + bar);     <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - bar);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-15Symbol-toStringTag（review）"><a href="#3-4-7-15Symbol-toStringTag（review）" class="headerlink" title="3.4.7.15Symbol.toStringTag（review）"></a>3.4.7.15<code>Symbol.toStringTag（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用”。</p>
<p>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s);                      <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString());           <span class="comment">// [object Set]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Set</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo);                      <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString());           <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar);                      <span class="comment">// Bar &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString());           <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-16Symbol-unscopables（review）"><a href="#3-4-7-16Symbol-unscopables（review）" class="headerlink" title="3.4.7.16Symbol.unscopables（review）"></a>3.4.7.16<code>Symbol.unscopables（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的<code>with</code>环境绑定中排除”。设置这个符号并让其映射对应属性的键值为<code>true</code>，就可以阻止该属性出现在<code>with</code>环境绑定中，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">  foo: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>不推荐使用<code>with</code>，因此也不推荐使用<code>Symbol.unscopables</code>。</p>
</blockquote>
<h3 id="3-4-8Object类型"><a href="#3-4-8Object类型" class="headerlink" title="3.4.8Object类型"></a>3.4.8<code>Object</code>类型</h3><p>ECMAScript中的对象其实就是一组数据和功能的集合。对象通过<code>new</code>操作符后跟对象类型的名称来创建。开发者可以通过创建<code>Object</code>类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这个语法类似Java，但ECMAScript只要求在给构造函数提供参数时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<p><code>Object</code>的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java中的<code>java.lang.Object</code>，ECMAScript中的<code>Object</code>也是派生其他对象的基类。<code>Object</code>类型的所有属性和方法在派生的对象上同样存在。<br>每个<code>Object</code>实例都有如下属性和方法。</p>
<ul>
<li><code>constructor</code>：用于创建当前对象的函数。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li>
<li><code>isPrototypeof(object)</code>：用于判断当前对象是否为另一个对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用<code>for-in</code>语句枚举。与<code>hasOwnProperty()</code>一样，属性名必须是字符串。</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li>
</ul>
<p>因为在ECMAScript中<code>Object</code>是所有对象的基类，所以任何对象都有这些属性和方法。</p>
<blockquote>
<p><strong>注意</strong>严格来讲，ECMA-262中对象的行为不一定适合JavaScript中的其他对象。比如浏览器环境中的BOM和DOM对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ECMA-262约束，所以它们可能会也可能不会继承<code>Object</code>。</p>
</blockquote>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5　操作符"></a>3.5　操作符</h2><p>ECMA-262描述了一组可用于操作数据值的<strong>操作符</strong>，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code>valueOf()</code>和<code>/</code>或<code>toString()</code>方法来取得可以计算的值。</p>
<h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1　一元操作符"></a>3.5.1　一元操作符</h3><p>只操作一个值的操作符叫<strong>一元操作符</strong>（unary operator），是ECMAScript中最简单的操作符。</p>
<h4 id="3-5-1-1-递增-递减操作符"><a href="#3-5-1-1-递增-递减操作符" class="headerlink" title="3.5.1.1   递增/递减操作符"></a><strong>3.5.1.1   递增/递减操作符</strong></h4><p>递增和递减操作符有两个版本：前缀版和后缀版。前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p>
<p>前缀递增操作符会给数值加1，把两个加号（<code>++</code>）放到变量前头即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">++age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<p>前缀递减操作符也类似。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">--age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//28</span></span><br></pre></td></tr></table></figure>
<p>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有<strong>副作用</strong>。）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);         <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>递增和递减的后缀版语法一样（分别是<code>++</code>和<code>--</code>），只不过要放在变量后面。后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。某些情况下，这种差异没影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">age++;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<p>把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>这4个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。<br>    1. 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。<br>    2. 对于字符串，如果不是有效的数值形式，则将变量的值设置为<code>NaN</code>。变量类型从字符串变成数值。<br>    3. 对于布尔值，如果是<code>false</code>，则转换为0再应用改变。变量类型从布尔值变成数值。<br>    4. 对于布尔值，如果是<code>true</code>，则转换为1再应用改变。变量类型从布尔值变成数值。<br>    5. 对于浮点值，加1或减1。<br>    6. 如果是对象，则调用其<code>valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code>NaN</code>，则调用<code>toString()</code>并再次应用其他规则。变量类型从对象变成数值。</p>
<p>下面的例子演示了这些规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++;  <span class="comment">// 值变成数值3</span></span><br><span class="line">s2++;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b++;   <span class="comment">// 值变成数值1</span></span><br><span class="line">f--;   <span class="comment">// 值变成0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--;   <span class="comment">// 值变成-2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-1-2-一元加和减"><a href="#3-5-1-2-一元加和减" class="headerlink" title="3.5.1.2   一元加和减"></a><strong>3.5.1.2   一元加和减</strong></h4><p><strong>一元加和减操作符</strong>在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（<code>+</code>）表示，放在变量前头，对数值没有任何影响：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = +num;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>如果将一元减应用到非数值，则会执行与使用<code>Number()</code>转型函数一样的类型转换：布尔值<code>false</code>和<code>true</code>转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的<code>valueOf()</code>和/或<code>toString()</code>方法以得到可以转换的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;  <span class="comment">// 值变成数值1</span></span><br><span class="line">s2 = +s2;  <span class="comment">// 值变成数值1.1</span></span><br><span class="line">s3 = +s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = +b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = +f;    <span class="comment">// 不变，还是1.1</span></span><br><span class="line">o = +o;    <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure>
<p>一元减由一个减号（<code>-</code>）表示，放在变量前头，主要用于把数值变成负值，如把1转换为-1。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// -25</span></span><br></pre></td></tr></table></figure>
<p>在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = -s1;  <span class="comment">// 值变成数值-1</span></span><br><span class="line">s2 = -s2;  <span class="comment">// 值变成数值-1.1</span></span><br><span class="line">s3 = -s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = -b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = -f;    <span class="comment">// 变成-1.1</span></span><br><span class="line">o = -o;    <span class="comment">// 值变成数值1</span></span><br></pre></td></tr></table></figure>
<p>一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。</p>
<h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2　位操作符"></a>3.5.2　位操作符</h3><p>ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。但这个转换也导致了一个奇特的副作用，即特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0处理。</p>
<p>如果将位操作符应用到非数值，那么首先会自动使用<code>Number()</code>函数将该值转换为数值，然后再应用位操作。最终结果是数值。要注意的是，在处理有符号整数时，我们无法访问第31位。</p>
<p>在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = -<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;-10010&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>默认情况下，ECMAScript中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p>
<h4 id="3-5-2-1-按位非"><a href="#3-5-2-1-按位非" class="headerlink" title="3.5.2.1   按位非"></a><strong>3.5.2.1   按位非</strong></h4></blockquote>
<p>按位非操作符用波浪符（<code>~</code>）表示，它的作用是返回数值的一补数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;      <span class="comment">// 二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1;   <span class="comment">// 二进制11111111111111111111111111100110</span></span><br><span class="line"><span class="built_in">console</span>.log(num2);  <span class="comment">// -26</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出，按位非的最终效果是对数值取反并减1，就像执行如下操作的结果一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = -num1 - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2);   <span class="comment">// &quot;-26&quot;</span></span><br></pre></td></tr></table></figure>
<p>尽管两者返回的结果一样，但位操作的速度快得多。因为位操作是在数值的底层表示上完成的。</p>
<h4 id="3-5-2-2-按位与"><a href="#3-5-2-2-按位与" class="headerlink" title="3.5.2.2   按位与"></a><strong>3.5.2.2   按位与</strong></h4><p>按位与操作符用和号（<code>&amp;</code>）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p>
<p>|第一个数值的位|第二个数值的位|结果|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|1|1|1|<br>|1|0|0|<br>|0|1|0|<br>|0|0|0|</p>
<p>下面看一个例子，我们对数值25和3求与操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>看下面的二进制计算过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<p>如上所示，25和3的二进制表示中，只有第0位上的两个数都是1。于是结果数值的所有其他位都会以0填充，因此结果就是1。</p>
<h4 id="3-5-2-3-按位或"><a href="#3-5-2-3-按位或" class="headerlink" title="3.5.2.3   按位或"></a><strong>3.5.2.3   按位或</strong></h4><p>按位或操作符用管道符（<code>|</code>）表示，同样有两个操作数。按位或遵循如下真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数值的位</th>
<th align="left">第二个数值的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>仍然用按位与的示例，如果对25和3执行按位或，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<p>可见25和3的按位或操作的结果是27：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"> OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>
<p>在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。</p>
<h4 id="3-5-2-4-按位异或"><a href="#3-5-2-4-按位异或" class="headerlink" title="3.5.2.4   按位异或"></a><strong>3.5.2.4   按位异或</strong></h4><p>按位异或用脱字符（<code>^</code>）表示，同样有两个操作数。下面是按位异或的真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数的位</th>
<th align="left">第二个数的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>对数值25和3执行按位异或操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let result &#x3D; 25 ^ 3;</span><br><span class="line">console.log(result); &#x2F;&#x2F; 26</span><br></pre></td></tr></table></figure>
<p>可见，25和3的按位异或操作结果为26，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">XOR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-5-左移"><a href="#3-5-2-5-左移" class="headerlink" title="3.5.2.5   左移"></a><strong>3.5.2.5   左移</strong></h4><p>左移操作符用两个小于号（<code>&lt;&lt;</code>）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值2（二进制10）向左移5位，就会得到64（二进制1000000），如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;              <span class="comment">// 等于二进制10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;  <span class="comment">// 等于二进制1000000，即十进制64</span></span><br></pre></td></tr></table></figure>
<p>注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值（见图3-2）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/b7qdJi277GnnBKhO__thumbnail.png"
                      alt="图片"
                ></p>
<p>左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。</p>
<h4 id="3-5-2-6-有符号右移"><a href="#3-5-2-6-有符号右移" class="headerlink" title="3.5.2.6   有符号右移"></a><strong>3.5.2.6   有符号右移</strong></h4><p>有符号右移由两个大于号（<code>&gt;&gt;</code>）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;             <span class="comment">// 等于二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;  <span class="comment">// 等于二进制10，即十进制2</span></span><br></pre></td></tr></table></figure>
<p>同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图3-3）。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/lfyDtLTtly9xPjgW__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="3-5-2-7-无符号右移"><a href="#3-5-2-7-无符号右移" class="headerlink" title="3.5.2.7   无符号右移"></a><strong>3.5.2.7   无符号右移</strong></h4><p>无符号右移用3个大于号表示（<code>&gt;&gt;&gt;</code>），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。</p>
<p>对于负数，有时候差异会非常大。右移会给空位补0，而不管符号位是什么。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = -<span class="number">64</span>;              <span class="comment">// 等于二进制11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;   <span class="comment">// 等于十进制134217726</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3　布尔操作符"></a>3.5.3　布尔操作符</h3><p>布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。</p>
<h4 id="3-5-3-1-逻辑非"><a href="#3-5-3-1-逻辑非" class="headerlink" title="3.5.3.1   逻辑非"></a><strong>3.5.3.1   逻辑非</strong></h4><p>逻辑非操作符由一个叹号（<code>!</code>）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。</p>
<pre><code>1. 如果操作数是对象，则返回`false`。
2. 如果操作数是空字符串，则返回`true`。
3. 如果操作数是非空字符串，则返回`false`。
4. 如果操作数是数值0，则返回`true`。
5. 如果操作数是非0数值（包括`Infinity`），则返回`false`。
6. 如果操作数是`null`，则返回`true`。
7. 如果操作数是`NaN`，则返回`true`。
8. 如果操作数是`undefined`，则返回`true`。</code></pre>
<p>以下示例验证了上述行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;blue&quot;</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;&quot;</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">12345</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（<code>!!</code>），相当于调用了转型函数<code>Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用<code>Boolean()</code>函数是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;blue&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">12345</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-2-逻辑与"><a href="#3-5-3-2-逻辑与" class="headerlink" title="3.5.3.2   逻辑与"></a><strong>3.5.3.2   逻辑与</strong></h4><p>逻辑与操作符由两个和号（<code>&amp;&amp;</code>）表示，应用到两个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>逻辑与操作符遵循如下真值表：<br>|第一个操作数|第二个操作数|结果|<br>|:—-|:—-|:—-|<br>|true|true|true|<br>|true|false|false|<br>|false|true|false|<br>|false|false|false|</p>
<p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。</p>
<pre><code>1. 如果第一个操作数是对象，则返回第二个操作数。
2. 如果第二个操作数是对象，则只有第一个操作数求值为`true`才会返回该对象。
3. 如果两个操作数都是对象，则返回第二个操作数。
4. 如果有一个操作数是`null`，则返回`null`。
5. 如果有一个操作数是`NaN`，则返回`NaN`。
6. 如果有一个操作数是`undefined`，则返回`undefined`。</code></pre>
<p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是<code>false</code>，那么无论第二个操作数是什么值，结果也不可能等于<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable); <span class="comment">// 这里会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 不会执行这一行</span></span><br></pre></td></tr></table></figure>
<p>假如变量<code>found</code>的值是<code>false</code>，那么就不会报错了：</p>
<h4 id="3-5-3-3-逻辑或"><a href="#3-5-3-3-逻辑或" class="headerlink" title="3.5.3.3   逻辑或"></a><strong>3.5.3.3   逻辑或</strong></h4><p>逻辑或操作符由两个管道符（<code>||</code>）表示，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="literal">true</span> || <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>逻辑或操作符遵循如下真值表：<br>|第一个操作数|第二个操作数|结果|<br>|:—-|:—-|:—-|<br>|true|true|true|<br>|true|false|true|<br>|false|true|true|<br>|false|false|false|</p>
<p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。</p>
<pre><code>1. 如果第一个操作数是对象，则返回第一个操作数。
2. 如果第一个操作数求值为`false`，则返回第二个操作数。
3. 如果两个操作数都是对象，则返回第一个操作数。
4. 如果两个操作数都是`null`，则返回`null`。
5. 如果两个操作数都是`NaN`，则返回`NaN`。
6. 如果两个操作数都是`undefined`，则返回`undefined`。</code></pre>
<p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为<code>true</code>，第二个操作数就不会再被求值了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable); <span class="comment">// 不会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure>
<p>利用这个行为，可以避免给变量赋值<code>null</code>或<code>undefined</code>。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = preferredObject || backupObject;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，变量<code>myObject</code>会被赋予两个值中的一个。其中，<code>preferredObject</code>变量包含首选的值，<code>backupObject</code>变量包含备用的值。如果<code>preferredObject</code>不是<code>null</code>，则它的值就会赋给<code>myObject</code>；如果<code>preferredObject</code>是<code>null</code>，则<code>backupObject</code>的值就会赋给<code>myObject</code>。这种模式在ECMAScript代码中经常用于变量赋值。</p>
<h3 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4　乘性操作符"></a>3.5.4　乘性操作符</h3><p>ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用<code>Number()</code>转型函数转换为数值。这意味着空字符串会被当成0，而布尔值<code>true</code>会被当成1。</p>
<h4 id="3-5-4-1-乘法操作符"><a href="#3-5-4-1-乘法操作符" class="headerlink" title="3.5.4.1   乘法操作符"></a><strong>3.5.4.1   乘法操作符</strong></h4><p>乘法操作符由一个星号（<code>*</code>）表示，可以用于计算两个数值的乘积。其语法类似于C语言。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">34</span> * <span class="number">56</span>;</span><br></pre></td></tr></table></figure>
<p>乘法操作符在处理特殊值时也有一些特殊的行为。</p>
<ol>
<li>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果ECMAScript不能表示乘积，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以非0的有限数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>乘以<code>Infinity</code>，则返回<code>Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-2-除法操作符"><a href="#3-5-4-2-除法操作符" class="headerlink" title="3.5.4.2   除法操作符"></a><strong>3.5.4.2   除法操作符</strong></h4></li>
</ol>
<p>除法操作符由一个斜杠（<code>/</code>）表示，用于计算第一个操作数除以第二个操作数的商，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">66</span> / <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>除法操作符针对特殊值也有一些特殊的行为。</p>
<ol>
<li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是0除以0，则返回<code>NaN</code>。</li>
<li>如果是非0的有限值除以0，则根据第一个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>除以任何数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-3-取模操作符-reivew"><a href="#3-5-4-3-取模操作符-reivew" class="headerlink" title="3.5.4.3   取模操作符(reivew)"></a><strong>3.5.4.3   取模操作符(reivew)</strong></h4></li>
</ol>
<p>取模（余数）操作符由一个百分比符号（<code>%</code>）表示，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">26</span> % <span class="number">5</span>; <span class="comment">// 等于1</span></span><br></pre></td></tr></table></figure>
<p>取模操作符对特殊值也有一些特殊的行为。</p>
<ol>
<li>如果操作数是数值，则执行常规除法运算，返回余数。</li>
<li>如果被除数是无限值，除数是有限值，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是无限值，则返回被除数。</li>
<li>如果被除数是0，除数不是0，则返回0。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h3 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5　指数操作符"></a>3.5.5　指数操作符</h3></li>
</ol>
<p>ECMAScript 7新增了指数操作符，<code>Math.pow()</code>现在有了自己的操作符<code>**</code>，结果是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>);         <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>指数操作符也有自己的指数赋值操作符<code>**=</code>，该操作符执行指数运算和结果的赋值操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared **= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6　加性操作符"></a>3.5.6　加性操作符</h3><p>加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。但在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p>
<h4 id="3-5-6-1-加法操作符（review）"><a href="#3-5-6-1-加法操作符（review）" class="headerlink" title="3.5.6.1   加法操作符（review）"></a><strong>3.5.6.1   加法操作符（review）</strong></h4><p>加法操作符（<code>+</code>）用于求两个数的和，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：<br>    1. 如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>；<br>    2. 如果是<code>Infinity</code>加<code>Infinity</code>，则返回<code>Infinity</code>；<br>    3. 如果是<code>-Infinity</code>加<code>-Infinity</code>，则返回<code>-Infinity</code>；<br>    4. 如果是<code>Infinity</code>加<code>-Infinity</code>，则返回<code>NaN</code>；<br>    5. 如果是<code>+0</code>加<code>+0</code>，则返回<code>+0</code>；<br>    6. 如果是<code>-0</code>加<code>+0</code>，则返回<code>+0</code>；<br>    7. 如果是<code>-0</code>加<code>-0</code>，则返回<code>-0</code>。</p>
<p>不过，如果有一个操作数是字符串，则要应用如下规则：</p>
<pre><code>1. 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；
2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</code></pre>
<p>如果有任一操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法以获取字符串，然后再应用前面的关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则调用<code>String()</code>函数，分别获取<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> + <span class="number">5</span>;        <span class="comment">// 两个数值</span></span><br><span class="line"><span class="built_in">console</span>.log(result1);       <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;      <span class="comment">// 一个数值和一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);       <span class="comment">// &quot;55&quot;</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br></pre></td></tr></table></figure>
<p>这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值，结果是一个字符串。第二次加法仍然是用一个字符串去加一个数值，同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + (num1 + num2);</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;The sum of 5 and 10 is 15&quot;</span></span><br></pre></td></tr></table></figure>
<p>在此，我们用括号把两个数值变量括了起来，意思是让解释器先执行两个数值的加法，然后再把结果追加给字符串。因此，最终得到的字符串变成了<code>&quot;The sum of 5 and 10 is 15&quot;</code>。</p>
<h4 id="3-5-6-2-减法操作符-review"><a href="#3-5-6-2-减法操作符-review" class="headerlink" title="3.5.6.2   减法操作符(review)"></a><strong>3.5.6.2   减法操作符(review)</strong></h4><p>减法操作符（<code>-</code>）也是使用很频繁的一种操作符，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。<br>    1. 如果两个操作数都是数值，则执行数学减法运算并返回结果。<br>    2. 如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。<br>    3. 如果是<code>Infinity</code>减<code>Infinity</code>，则返回<code>NaN</code>。<br>    4. 如果是<code>-Infinity</code>减<code>-Infinity</code>，则返回<code>NaN</code>。<br>    5. 如果是<code>Infinity</code>减<code>-Infinity</code>，则返回<code>Infinity</code>。<br>    6. 如果是<code>-Infinity</code>减<code>Infinity</code>，则返回<code>-Infinity</code>。<br>    7. 如果是<code>+0</code>减<code>+0</code>，则返回<code>+0</code>。<br>    8. 如果是<code>+0</code>减<code>-0</code>，则返回<code>-0</code>。<br>    9. 如果是<code>-0</code>减<code>-0</code>，则返回<code>+0</code>。<br>    10. 如果有任一操作数是字符串、布尔值、<code>null</code>或<code>undefined</code>，则先在后台使用<code>Number()</code>将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。<br>    11. 如果有任一操作数是对象，则调用其<code>valueOf()</code>方法取得表示它的数值。如果该值是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法，然后再将得到的字符串转换为数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> - <span class="literal">true</span>; <span class="comment">// true被转换为1，所以结果是4</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> - <span class="number">1</span>;  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> - <span class="number">3</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;   <span class="comment">// &quot;&quot;被转换为0，所以结果是5</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;  <span class="comment">// &quot;2&quot;被转换为2，所以结果是3</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// null被转换为0，所以结果是5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7　关系操作符"></a>3.5.7　关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）和大于等于（<code>&gt;=</code>）。这几个操作符都返回布尔值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p>
<ul>
<li>如果操作数都是数值，则执行数值比较。</li>
<li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li>
<li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li>
<li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法，取得结果后再根据前面的规则执行比较。如果没有<code>valueOf()</code>操作符，则调用<code>toString()</code>方法，取得结果后再根据前面的规则执行比较。</li>
<li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
</ul>
<p>在使用关系操作符比较两个字符串时，很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span> &lt; <span class="string">&quot;alphabet&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式，然后再比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alphabet&quot;</span>.toLowerCase(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>另一个奇怪的现象是在比较两个数值字符串的时候，比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符<code>&quot;2&quot;</code>的编码是50，而字符<code>&quot;3&quot;</code>的编码是51）。如果有一个操作数是数值，那么比较的结果就对了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>只要是数值和字符串比较，字符串就会先被转换为数值，然后进行数值比较。对于数值字符串而言，这样能保证结果正确。<br>如果字符串不能转换成数值呢？比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// 因为&quot;a&quot;会转换为NaN，所以结果是false</span></span><br></pre></td></tr></table></figure>
<p>因为字符<code>&quot;a&quot;</code>不能转换成任何有意义的数值，所以只能转换为<code>NaN</code>。这里有一个规则，即任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8　相等操作符"></a>3.5.8　相等操作符</h3><p>判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是<strong>等于</strong>和<strong>不等于</strong>，它们在比较之前执行转换。第二组是<strong>全等</strong>和<strong>不全等</strong>，它们在比较之前不执行转换。</p>
<h4 id="3-5-8-1-等于和不等于"><a href="#3-5-8-1-等于和不等于" class="headerlink" title="3.5.8.1   等于和不等于"></a><strong>3.5.8.1   等于和不等于</strong></h4><p>ECMAScript中的等于操作符用两个等于号（<code>==</code>）表示，如果操作数相等，则会返回<code>true</code>。不等于操作符用叹号和等于号（<code>!=</code>）表示，如果两个操作数不相等，则会返回<code>true</code>。这两个操作符都会先进行类型转换（通常称为<strong>强制类型转换</strong>）再确定操作数是否相等。</p>
<p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p>
<ol>
<li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。</li>
<li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的<code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较。</li>
</ol>
<p>在进行比较时，这两个操作符会遵循如下规则。</p>
<ol>
<li><code>null</code>和<code>undefined</code>相等。</li>
<li><code>null</code>和<code>undefined</code>不能转换为其他类型的值再进行比较。</li>
<li>如果有任一操作数是<code>NaN</code>，则相等操作符返回<code>false</code>，不相等操作符返回<code>true</code>。记住：即使两个操作数都是<code>NaN</code>，相等操作符也返回<code>false</code>，因为按照规则，<code>NaN</code>不等于<code>NaN</code>。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code>true</code>。否则，两者不相等。</li>
</ol>
<p>下表总结了一些特殊情况及比较的结果。</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null == undefined</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“NaN” == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">5 == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN != NaN</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">false == 0</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 1</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 2</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">undefined == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">null == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">“5” == 5</td>
<td align="left">true</td>
</tr>
</tbody></table>
<h4 id="3-5-8-2-全等和不全等"><a href="#3-5-8-2-全等和不全等" class="headerlink" title="3.5.8.2   全等和不全等"></a><strong>3.5.8.2   全等和不全等</strong></h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3个等于号（<code>===</code>）表示，只有两个操作数在不转换的前提下相等才返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>);  <span class="comment">// true，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<p>不全等操作符用一个叹号和两个等于号（<code>!==</code>）表示，只有两个操作数在不转换的前提下不相等才返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> != <span class="number">55</span>);  <span class="comment">// false，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> !== <span class="number">55</span>); <span class="comment">// true，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<p>另外虽然<code>null == undefined</code>是<code>true</code>（因为这两个值类似），但<code>null === undefined</code>是<code>false</code>，因为它们不是相同的数据类型。</p>
<blockquote>
<p><strong>注意</strong>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p>
</blockquote>
<h3 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9　条件操作符"></a>3.5.9　条件操作符</h3><p>条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10　赋值操作符"></a>3.5.10　赋值操作符</h3><p>简单赋值用等于号（<code>=</code>）表示，将右手边的值赋给左手边的变量，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值使用乘性、加性或位操作符后跟等于号（<code>=</code>）表示。这些赋值操作符是类似如下常见赋值操作的简写形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = num + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码的第二行可以通过复合赋值来完成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p>
<ul>
<li>乘后赋值（<code>*=</code>）</li>
<li>除后赋值（<code>/=</code>）</li>
<li>取模后赋值（<code>%=</code>）</li>
<li>加后赋值（<code>+=</code>）</li>
<li>减后赋值（<code>-=</code>）</li>
<li>左移后赋值（<code>&lt;&lt;=</code>）</li>
<li>右移后赋值（<code>&gt;&gt;=</code>）</li>
<li>无符号右移后赋值（<code>&gt;&gt;&gt;=</code>）</li>
</ul>
<p>这些操作符仅仅是简写语法，使用它们不会提升性能。</p>
<h3 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11　逗号操作符"></a>3.5.11　逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>num</code>将被赋值为0，因为0是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</p>
<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6　语句"></a>3.6　语句</h2><p>ECMA-262描述了一些语句（也称为<strong>流控制语句</strong>），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p>
<h3 id="3-6-1if语句"><a href="#3-6-1if语句" class="headerlink" title="3.6.1if语句"></a>3.6.1<code>if</code>语句</h3><p><code>if</code>语句是使用最频繁的语句之一，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的最佳实践是使用语句块，即使只有一行代码要执行也是如此。这是因为语句块可以避免对什么条件下执行什么产生困惑。可以像这样连续使用多个<code>if</code>语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-2do-while语句"><a href="#3-6-2do-while语句" class="headerlink" title="3.6.2do-while语句"></a>3.6.2<code>do-while</code>语句</h3><p><code>do-while</code>语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。<code>do-while</code>的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>后测试循环经常用于这种情形：循环体内代码在退出前至少要执行一次。</p>
</blockquote>
<h3 id="3-6-3while语句"><a href="#3-6-3while语句" class="headerlink" title="3.6.3while语句"></a>3.6.3<code>while</code>语句</h3><p><code>while</code>语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code>循环体内的代码有可能不会执行。下面是<code>while</code>循环的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-4for语句"><a href="#3-6-4for语句" class="headerlink" title="3.6.4for语句"></a>3.6.4<code>for</code>语句</h3><p><code>for</code>语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>for</code>循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用<code>let</code>声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。<br>初始化、条件表达式和循环后表达式都不是必需的。因此可以创建一个无穷循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无穷循环</span></span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只包含条件表达式，那么<code>for</code>循环实际上就变成了<code>while</code>循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; count; ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法通过<code>while</code>循环实现的逻辑，同样也无法使用<code>for</code>循环实现。因此<code>for</code>循环只是将循环相关的代码封装在了一起而已。</p>
<h3 id="3-6-5for-in语句"><a href="#3-6-5for-in语句" class="headerlink" title="3.6.5for-in语句"></a>3.6.5<code>for-in</code>语句</h3><p><code>for-in</code>语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里控制语句中的<code>const</code>也不是必需的。但为确保这个局部变量不被修改，推荐使用<code>const</code>。<br>ECMAScript中对象的属性是无序的，因此<code>for-in</code>语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p>
<p>如果<code>for-in</code>循环要迭代的变量是<code>null</code>或<code>undefined</code>，则不执行循环体。</p>
<h3 id="3-6-6for-of语句（review）"><a href="#3-6-6for-of语句（review）" class="headerlink" title="3.6.6for-of语句（review）"></a>3.6.6<code>for-of</code>语句（review）</h3><p><code>for-of</code>语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for-of</code>循环会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则<code>for-of</code>语句会抛出错误。</p>
<blockquote>
<p><strong>注意</strong>ES2018对<code>for-of</code>语句进行了扩展，增加了<code>for-await-of</code>循环，以支持生成期约（promise）的异步可迭代对象。。</p>
</blockquote>
<h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7　标签语句"></a>3.6.7　标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>start</code>是一个标签，可以在后面通过<code>break</code>或<code>continue</code>语句引用。标签语句的典型应用场景是嵌套循环。</p>
<h3 id="3-6-8break和continue语句"><a href="#3-6-8break和continue语句" class="headerlink" title="3.6.8break和continue语句"></a>3.6.8<code>break</code>和<code>continue</code>语句</h3><p><code>break</code>和<code>continue</code>语句为执行循环代码提供了更严格的控制手段。其中，<code>break</code>语句用于立即退出循环，强制执行循环后的下一条语句。而<code>continue</code>语句也用于立即退出循环，但会再次从循环顶部开始执行。</p>
<p><code>break</code>与标签语句一起使用，返回代码中特定的位置。通常是在嵌套循环中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p>添加标签不仅让<code>break</code>退出（使用变量<code>j</code>）的内部循环，也会退出（使用变量<code>i</code>）的外部循环。<code>continue</code>语句也可以使用标签，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p><code>continue</code>语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当<code>i</code>和<code>j</code>都等于5时，会执行<code>continue</code>，跳到外部循环继续执行。<br>组合使用标签语句和<code>break</code>、<code>continue</code>能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p>
<h3 id="3-6-9with语句（review）"><a href="#3-6-9with语句（review）" class="headerlink" title="3.6.9with语句（review）"></a>3.6.9<code>with</code>语句（review）</h3><p><code>with</code>语句的用途是将代码作用域设置为特定的对象，主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利,其语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br></pre></td></tr></table></figure>
<p>上面代码中的每一行都用到了<code>location</code>对象。如果使用<code>with</code>语句，就可以少写一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>with</code>语句用于连接<code>location</code>对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索<code>location</code>对象，看它是否有一个同名的属性。如果有，则该变量会被求值为<code>location</code>对象的属性。<br>严格模式不允许使用<code>with</code>语句，否则会抛出错误。</p>
<blockquote>
<p><strong>警告</strong>由于<code>with</code>语句影响性能且难于调试其中的代码，通常不推荐使用<code>with</code>语句。</p>
</blockquote>
<h3 id="3-6-10switch语句"><a href="#3-6-10switch语句" class="headerlink" title="3.6.10switch语句"></a>3.6.10<code>switch</code>语句</h3><p><code>switch</code>语句是与<code>if</code>语句紧密相关的一种流控制语句，每个<code>case</code>（条件/分支）相当于：“如果表达式等于后面的值，则执行下面的语句。”<code>break</code>关键字会导致代码执行跳出<code>switch</code>语句。如果没有<code>break</code>，则代码会继续匹配下一个条件。<code>default</code>关键字用于在任何条件都没有满足时指定默认执行的语句（相当于<code>else</code>语句）。</p>
<p>为避免不必要的条件判断，最好给每个条件后面都加上<code>break</code>语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了<code>break</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="comment">/*跳过*/</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;25 or 35&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然<code>switch</code>语句是从其他语言借鉴过来的，但ECMAScript为它赋予了一些独有的特性。首先<code>switch</code>语句可以用于所有数据类型。其次，条件的值不需要是常量，也可以是变量或表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 10.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 10 and 20.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;More than 20.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>switch</code>语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型</p>
</blockquote>
<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7　函数"></a>3.7　函数</h2><p>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用<code>function</code>关键字声明，后跟一组参数，然后是函数体。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是调用函数<code>sayHi()</code>的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sayHi(<span class="string">&quot;Nicholas&quot;</span>, <span class="string">&quot;how are you today?&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用<code>return</code>语句来返回函数的值，用法是后跟要返回的值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>return</code>语句之外没有任何特殊声明表明该函数有返回值。然后就可以这样调用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = sum(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>只要碰到<code>return</code>语句，函数会立即停止执行并退出。因此<code>return</code>语句后的代码不会被执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数里也可以有多个<code>return</code>语句，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num2 - num1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>return</code>语句也可以不带返回值。这时候，函数会立即停止执行并返回<code>undefined</code>。这种用法最常用于提前终止函数执行，并不是为了返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。</p>
</blockquote>
<p>严格模式对函数也有一些限制：</p>
<ul>
<li>函数不能以<code>eval</code>或<code>arguments</code>作为名称；</li>
<li>函数的参数不能叫<code>eval</code>或<code>arguments</code>；</li>
<li>两个函数的参数不能叫同一个名称。</li>
</ul>
<p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>
<h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8　小结"></a>3.8　小结</h2><p>JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。</p>
<ul>
<li>ECMAScript中的基本数据类型包括<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。</li>
<li>与其他语言不同，ECMAScript不区分整数和浮点值，只有<code>Number</code>一种数值数据类型。</li>
<li><code>Object</code>是一种复杂数据类型，它是这门语言中所有对象的基类。</li>
<li>严格模式为这门语言中某些容易出错的部分施加了限制。</li>
<li>ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。</li>
<li>这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如<code>if</code>语句、<code>for</code>语句和<code>switch</code>语句等。</li>
</ul>
<p>ECMAScript中的函数与其他语言中的函数不一样。</p>
<ul>
<li>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。</li>
<li>不指定返回值的函数实际上会返回特殊值<code>undefined</code>。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>JavaScript高级程序设计(第四版)</category>
        <category>03-语言基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
