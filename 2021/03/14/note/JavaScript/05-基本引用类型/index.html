<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="HTML,CSS,JavaScript">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="胡倚豪">
    
    <title>
        
            05-基本引用类型 |
        
        HuOneNumber | 个人博客
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/avatar.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#33FFCC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"description":"慢慢来，深几度。。。","background_img":"/images/bg.svg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="别着急，慢慢来" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                HuOneNumber | 个人博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">05-基本引用类型</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">胡倚豪</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-03-14 21:18:40
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/">JavaScript高级程序设计(第四版)</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/05-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">05-基本引用类型</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>17.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>72 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>引用值（或者对象）是某个特定<strong>引用类型</strong>的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”，ECMAScript缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法。</p>
<p>对象被认为是某个特定引用类型的<strong>实例</strong>。新对象通过使用<code>new</code>操作符后跟一个<strong>构造函数</strong>（constructor）来创建。构造函数就是用来创建新对象的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>这行代码创建了引用类型<code>Date</code>的一个新实例，并将它保存在变量<code>now</code>中。<code>Date()</code>在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。</p>
<blockquote>
<p><strong>注意</strong>函数也是一种引用类型。</p>
</blockquote>
<h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1　Date"></a>5.1　Date</h2><p><code>Date</code>类型将日期保存为自协调世界时（UTC）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式，<code>Date</code>类型可以精确表示1970年1月1日之前及之后285616年的日期。</p>
<p>要创建日期对象，就使用<code>new</code>操作符来调用<code>Date</code>构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>在不给<code>Date</code>构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示。ECMAScript为此提供了两个辅助方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。<br><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。所有实现都必须支持下列日期格式：</p>
<ul>
<li>“月/日/年”，如<code>&quot;5/23/2019&quot;</code>；</li>
<li>“月 日, 年”，如<code>&quot;May 23, 2019&quot;</code>；</li>
<li>“周几 月 日 年 时:分:秒 时区”，如<code>&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;</code>；</li>
<li>ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如<code>2019-05-23T00:00:00</code>（只适用于兼容ES5的实现）。</li>
</ul>
<p>比如，要创建一个表示“2019年5月23日”的日期对象，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">&quot;May 23, 2019&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法会返回<code>NaN</code>。如果直接把表示日期的字符串传给<code>Date</code>构造函数，那么<code>Date</code>会在后台调用<code>Date.parse()</code>。换句话说，下面这行代码跟前面那行代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>不同的浏览器对<code>Date</code>类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期，因此有些浏览器会将<code>&quot;January 32, 2019&quot;</code>解释为<code>&quot;February 1, 2019&quot;</code>。Opera则会插入当前月的当前日，返回<code>&quot;January 当前日, 2019&quot;</code>。</p>
</blockquote>
<p><code>Date.UTC()</code>方法也返回日期的毫秒表示，但使用的是跟<code>Date.parse()</code>不同的信息来生成这个值。传给<code>Date.UTC()</code>的参数是年、零起点月数（1月是0，2月是1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT时间2000年1月1日零点</span></span><br><span class="line"><span class="keyword">let</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// GMT时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure>
<p>与<code>Date.parse()</code>一样，<code>Date.UTC()</code>也会被<code>Date</code>构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是GMT日期。不过<code>Date</code>构造函数跟<code>Date.UTC()</code>接收的参数是一样的。前面的例子也可以这样来写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地时间2000年1月1日零点</span></span><br><span class="line"><span class="keyword">let</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 本地时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了与前面例子中相同的两个日期，但这次的两个日期是（由于系统设置决定的）本地时区的日期。<br>ECMAScript还提供了<code>Date.now()</code>方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="built_in">Date</span>.now(),</span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-继承的方法"><a href="#5-1-1-继承的方法" class="headerlink" title="5.1.1　继承的方法"></a>5.1.1　继承的方法</h3><p><code>Date</code>类型重写了<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。但与其他类型不同，重写后这些方法的返回值不一样。<code>Date</code>类型的<code>toLocaleString()</code>方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。<code>toString()</code>方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。下面给出了<code>toLocaleString()</code>和<code>toString()</code>返回的2019年2月1日零点的示例（地区为<code>&quot;en-US&quot;</code>的PST，即Pacific Standard Time，太平洋标准时间）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toLocaleString() - <span class="number">2</span>/<span class="number">1</span>/<span class="number">2019</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> AM</span><br><span class="line">toString() - Thu Feb <span class="number">1</span> <span class="number">2019</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> GMT-<span class="number">0800</span> (Pacific Standard Time)</span><br></pre></td></tr></table></figure>
<p>在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着<code>toLocaleString()</code>和<code>toString()</code>可能只对调试有用，不能用于显示。<br><code>Date</code>类型的<code>valueOf()</code>方法不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。这也是确保日期先后的一个简单方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 2019年1月1日</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// 2019年2月1日</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt; date2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-日期格式化方法"><a href="#5-1-2-日期格式化方法" class="headerlink" title="5.1.2　日期格式化方法"></a>5.1.2　日期格式化方法</h3><p><code>Date</code>类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p>
<ul>
<li><code>toDateString()</code>显示日期中的周几、月、日、年（格式特定于实现）；</li>
<li><code>toTimeString()</code>显示日期中的时、分、秒和时区（格式特定于实现）；</li>
<li><code>toLocaleDateString()</code>显示日期中的周几、月、日、年（格式特定于实现和地区）；</li>
<li><code>toLocaleTimeString()</code>显示日期中的时、分、秒（格式特定于实现和地区）；</li>
<li><code>toUTCString()</code>显示完整的UTC日期（格式特定于实现）。</li>
</ul>
<p>这些方法的输出与<code>toLocaleString()</code>和<code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p>
<blockquote>
<p><strong>注意</strong>还有一个方法叫<code>toGMTString()</code>，这个方法跟<code>toUTCString()</code>是一样的，目的是为了向后兼容。不过，规范建议新代码使用<code>toUTCString()</code>。</p>
</blockquote>
<h3 id="5-1-3-日期-时间组件方法"><a href="#5-1-3-日期-时间组件方法" class="headerlink" title="5.1.3　日期/时间组件方法"></a>5.1.3　日期/时间组件方法</h3><p><code>Date</code>类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getTime()/setTime(<em>milliseconds</em>)</td>
<td align="left">返回/设置日期的毫秒表示；返回与valueOf()相同</td>
</tr>
<tr>
<td align="left">getFullYear()/getUTCFullYear()<br>setFullYear(<em>year</em>)/setUTCFullYear(<em>year</em>)</td>
<td align="left">返回/设置4位数年（即2019而不是19）</td>
</tr>
<tr>
<td align="left">getMonth()/getUTCMonth()<br>setMonth(<em>month</em>)/setUTCMonth(<em>month</em>)</td>
<td align="left">返回/设置日期的月（0表示1月，11表示12月），设置大于11加年</td>
</tr>
<tr>
<td align="left">getDate()/getUTCDate()<br>setUTCDate(<em>date</em>)/setDate(<em>date</em>)</td>
<td align="left">返回/设置日期中的日（1~31），设置大于该月天数，则加月</td>
</tr>
<tr>
<td align="left">getDay()/getUTCDay()</td>
<td align="left">返回日期中表示周几的数值（0表示周日，6表示周六）</td>
</tr>
<tr>
<td align="left">getHours()/getUTCHours()<br>setHours(<em>hours</em>)/setUTCHours(<em>hours</em>)</td>
<td align="left">返回/设置日期中的时（0~23），设置<em>hours</em>大于23，则加日</td>
</tr>
<tr>
<td align="left">getMinutes()/getUTCMinutes()<br>setMinutes(<em>minutes</em>)/setUTCMinutes(<em>minutes</em>)</td>
<td align="left">返回日期中的分（0~59），设置<em>minutes</em>大于59，则加时</td>
</tr>
<tr>
<td align="left">getSeconds()/getUTCSeconds()<br>setSeconds(<em>seconds</em>)/setUTCSeconds(<em>seconds</em>)</td>
<td align="left">返回/设置日期中的秒（0~59），设置<em>seconds</em>大于59，则加分</td>
</tr>
<tr>
<td align="left">getMilliseconds()/getUTCMilliseconds()<br>setMilliseconds(<em>milliseconds</em>)/setUTCMilliseconds(<em>milliseconds</em>)</td>
<td align="left">返回/设置日期中的毫秒</td>
</tr>
<tr>
<td align="left">getTimezoneOffset()</td>
<td align="left">返回以分钟计的UTC与本地时区的偏移量</td>
</tr>
</tbody></table>
<h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2　RegExp"></a>5.2　RegExp</h2><p>ECMAScript通过<code>RegExp</code>类型支持正则表达式。正则表达式使用类似Perl的简洁语法来创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>
<p>这个正则表达式的<code>pattern</code>（模式）可以是任何的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个<code>flags</code>（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p>
<ul>
<li><code>g</code>：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li>
<li><code>i</code>：不区分大小写，表示在查找匹配时忽略<code>pattern</code>和字符串的大小写。</li>
<li><code>m</code>：多行模式，表示查找到一行文本末尾时会继续查找。</li>
<li><code>y</code>：粘附模式，表示只查找从<code>lastIndex</code>开始及之后的字符串。</li>
<li><code>u</code>：Unicode模式，启用Unicode匹配。</li>
<li><code>s</code>：<code>dotAll</code>模式，表示元字符<code>.</code>匹配任何字符（包括<code>\n</code>或<code>\r</code>）。</li>
</ul>
<p>使用不同模式和标记可以创建出各种正则表达式，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中的所有&quot;at&quot;</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，所有<strong>元字符</strong>在模式中也必须转义，包括：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ] &#125; ? * + .</span><br></pre></td></tr></table></figure>
<p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;[bc]at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有&quot;.at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用<code>RegExp</code>构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 跟pattern1一样，只不过是用构造函数创建的</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>RegExp</code>构造函数的两个参数都是字符串。因为<code>RegExp</code>的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如<code>\n</code>（<code>\</code>转义后的字符串是<code>\\</code>，在正则表达式字符串中则要写成<code>\\\\</code>）。<br>|字面量模式|对应的字符串|<br>|:—-|:—-|<br>|/[bc]at/|”\[bc\]at”|<br>|/.at/|”\.at”|<br>|/name/age/|”name\/age”|<br>|/\w\hello\123/|”\w\\hello\\123”|</p>
<p>此外，使用<code>RegExp</code>也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/cat/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re1);  <span class="comment">// &quot;/cat/g&quot;</span></span><br><span class="line"><span class="keyword">const</span> re3 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(re3);  <span class="comment">// &quot;/cat/i&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1   RegExp实例属性"></a>5.2.1   <code>RegExp</code>实例属性</h3><p>每个<code>RegExp</code>实例都有下列属性，提供有关模式的各方面信息。</p>
<ul>
<li><code>global</code>：布尔值，表示是否设置了<code>g</code>标记。</li>
<li><code>ignoreCase</code>：布尔值，表示是否设置了<code>i</code>标记。</li>
<li><code>unicode</code>：布尔值，表示是否设置了<code>u</code>标记。</li>
<li><code>sticky</code>：布尔值，表示是否设置了<code>y</code>标记。</li>
<li><code>lastIndex</code>：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。</li>
<li><code>multiline</code>：布尔值，表示是否设置了<code>m</code>标记。</li>
<li><code>dotAll</code>：布尔值，表示是否设置了<code>s</code>标记。</li>
<li><code>source</code>：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li>
<li><code>flags</code>：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern2.global);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);      <span class="comment">// &quot;\[bc\]at&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.flags);       <span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-RegExp实例方法"><a href="#5-2-2-RegExp实例方法" class="headerlink" title="5.2.2   RegExp实例方法"></a>5.2.2   <code>RegExp</code>实例方法</h3></li>
</ul>
<p><code>RegExp</code>实例的主要方法是<code>exec()</code>，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但包含两个额外的属性：<code>index</code>和<code>input</code>。<code>index</code>是字符串中匹配模式的起始位置，<code>input</code>是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input);   <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);      <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);      <span class="comment">// &quot; and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);      <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，模式包含两个捕获组：最内部的匹配项<code>&quot; and baby&quot;</code>，以及外部的匹配项<code>&quot; and dad&quot;</code>或<code>&quot; and dad and baby&quot;</code>。调用<code>exec()</code>后找到了一个匹配项。因为整个字符串匹配模式，所以<code>matchs</code>数组的<code>index</code>属性就是0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串。<br>如果模式设置了全局标记，则每次调用<code>exec()</code>方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次<code>exec()</code>，也只会返回第一个匹配的信息，<code>lastIndex</code>在非全局模式下始终不变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>如果在这个模式上设置了<code>g</code>标记，则每次调用<code>exec()</code>都会在字符串中向前搜索下一个匹配项，直到搜索到字符串末尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 3</span></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 8</span></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// sat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<p>在全局匹配模式下，每次调用<code>exec()</code>都会更新<code>lastIndex</code>值，以反映上次匹配的最后一个字符的索引。<br>如果模式设置了粘附标记<code>y</code>，则每次调用<code>exec()</code>就只会在<code>lastIndex</code>的位置上寻找匹配项。粘附标记覆盖全局标记。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/y</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 以索引3对应的字符开头找不到匹配项，因此exec()返回null</span></span><br><span class="line"><span class="comment">// exec()没找到匹配项，于是将lastIndex设置为0</span></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches);             <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 向前设置lastIndex可以让粘附的模式通过exec()找到下一个匹配项：</span></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>;</span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>正则表达式的另一个方法是<code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回<code>true</code>，否则返回<code>false</code>。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况，常用于验证用户输入。<code>test()</code>经常用在<code>if</code>语句中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;000-00-0000&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;The pattern was matched.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论正则表达式是怎么创建的，继承的方法<code>toLocaleString()</code>和<code>toString()</code>都返回正则表达式的字面量表示。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;gi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern.toString());       <span class="comment">// /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.toLocaleString()); <span class="comment">// /\[bc\]at/gi</span></span><br></pre></td></tr></table></figure>
<p>这里的模式是通过<code>RegExp</code>构造函数创建的，但<code>toLocaleString()</code>和<code>toString()</code>返回的都是其字面量的形式。</p>
<blockquote>
<p><strong>注意</strong>正则表达式的<code>valueOf()</code>方法返回正则表达式本身。</p>
<h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3   RegExp构造函数属性"></a>5.2.3   <code>RegExp</code>构造函数属性</h3></blockquote>
<p><code>RegExp</code>构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了<code>RegExp</code>构造函数的属性。</p>
<table>
<thead>
<tr>
<th align="left">全名</th>
<th align="left">简写</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">input</td>
<td align="left">$_</td>
<td align="left">最后搜索的字符串（非标准特性）</td>
</tr>
<tr>
<td align="left">lastMatch</td>
<td align="left">$&amp;</td>
<td align="left">最后匹配的文本</td>
</tr>
<tr>
<td align="left">lastParen</td>
<td align="left">$+</td>
<td align="left">最后匹配的捕获组（非标准特性）</td>
</tr>
<tr>
<td align="left">leftContext</td>
<td align="left">$`</td>
<td align="left">input字符串中出现在lastMatch前面的文本</td>
</tr>
<tr>
<td align="left">rightContext</td>
<td align="left">$’</td>
<td align="left">input字符串中出现在lastMatch后面的文本</td>
</tr>
</tbody></table>
<p>通过这些属性可以提取出与<code>exec()</code>和<code>test()</code>执行的操作相关的信息。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);        <span class="comment">// this has been a short summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);  <span class="comment">// this has been a</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);    <span class="comment">// short</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen);    <span class="comment">// s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大多数简写形式都不是合法的ECMAScript标识符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：Opera 不支持简写属性名</span></span><br><span class="line"><span class="comment"> * IE 不支持多行匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);      <span class="comment">// this has been a short summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$`&quot;</span>]);   <span class="comment">// this has been a</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]);   <span class="comment">// summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]);   <span class="comment">// short</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$+&quot;</span>]);   <span class="comment">// s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RegExp</code>还有其他几个构造函数属性，可以存储最多9个捕获组的匹配项。这些属性通过<code>RegExp.$1~RegExp.$9</code>来访问，分别包含第1~9个捕获组的匹配项。在调用<code>exec()</code>或<code>test()</code>时，这些属性就会被填充，然后就可以像下面这样使用它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);  <span class="comment">// sh</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2);  <span class="comment">// t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，模式包含两个捕获组。调用<code>test()</code>搜索字符串之后，因为找到了匹配项所以返回<code>true</code>，而且可以打印出通过<code>RegExp</code>构造函数的<code>$1</code>和<code>$2</code>属性取得的两个捕获组匹配的内容。</p>
<blockquote>
<p><strong>注意</strong><code>RegExp</code>构造函数的所有属性没有任何Web标准出处，因此不要在生产环境中使用它们。</p>
<h3 id="5-2-4-模式局限"><a href="#5-2-4-模式局限" class="headerlink" title="5.2.4   模式局限"></a>5.2.4   模式局限</h3></blockquote>
<p>正则表达式的下列特性目前还没有得到ECMAScript的支持：</p>
<ul>
<li><code>\A</code>和<code>\Z</code>锚（分别匹配字符串的开始和末尾）</li>
<li>联合及交叉类</li>
<li>原子组</li>
<li><code>x</code>（忽略空格）匹配模式</li>
<li>条件式匹配</li>
<li>正则表达式注释<h3 id="5-2-5-正则表达式（补充）"><a href="#5-2-5-正则表达式（补充）" class="headerlink" title="5.2.5   正则表达式（补充）"></a>5.2.5   正则表达式（补充）</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">含义</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\ \</td>
<td align="left">只有在特殊字符之前的反斜杠表示下一个字符不是特殊字符，按照字面理解。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入的开始。如果有多行标记m，那么也匹配换行符后紧跟的位置。</td>
<td align="left">/^A/并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入的结束。如果有多行标记m，那么也匹配换行符前的位置。<br>如果 ^和 $ 在一起，表示必须是精确匹配。</td>
<td align="left">/t$/并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前一个表达式 0 次或多次。等价于{0,}。</td>
<td align="left">/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面一个表达式 1 次或者多次。等价于{1,}。</td>
<td align="left">/a+/会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面一个表达式 0 次或者 1 次。等价于{0,1}。<br>如果*<em>紧跟在任何量词 <em>、 +、? 或 {} 的后面</em></em>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。</td>
<td align="left">/e?le?/匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。<br>“123abc” 使用/\d+/将会匹配 “123”，而使用/\d+?/则只会匹配到 “1”。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">（小数点）默认匹配除换行符之外的任何单个字符。</td>
<td align="left">/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’。如果有s(“dotAll”) 标记，也会匹配换行符。</td>
</tr>
<tr>
<td align="left">(x)</td>
<td align="left">匹配 ‘x’ 并且记住匹配项，供此后使用。其中括号被称为<em>捕获括号</em>。</td>
<td align="left">/(foo) (bar) \1 \2/ 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住”foo bar foo bar” 中的前两个单词’foo’和’bar’。模式中的\1和\2表示第一个和第二个被捕获括号匹配的子字符串，即foo和bar，匹配原字符串中的后两个单词。注意\1、\2、…、\n是用在正则表达式的匹配环节。而在正则表达式的替换环节，则要使用像$1、$2、…、$n这样的语法，例如，’bar foo’.replace(/(…) (…)/, ‘$2 $1’)。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)，这里的n是数字。</td>
<td align="left">/apple(,)\sorange\1/匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</td>
</tr>
<tr>
<td align="left">(?:x)</td>
<td align="left">匹配 ‘x’ 但是不记住匹配项。这种括号叫作<em>非捕获括号</em>，使得定义与正则表达式运算符一起使用的子表达式。</td>
<td align="left">/foo{1,2}/只应用于 ‘foo’ 的最后一个字符 ‘o’。如果使用非捕获括号，/(?:foo){1,2}/，则会应用于整个 ‘foo’ 单词。</td>
</tr>
<tr>
<td align="left">x(?=y)</td>
<td align="left">匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。</td>
<td align="left">/Jack(?=Sprat|Frost)/匹配’Jack’仅当它后面跟着’Sprat’或者是’Frost’。但是’Sprat’和’Frost’都不是匹配结果的一部分。</td>
</tr>
<tr>
<td align="left">(?&lt;=y)x</td>
<td align="left">匹配’x’仅当’x’前面是’y’.这种叫做后行断言。</td>
<td align="left">/(?&lt;=Jack|Tom)Sprat/匹配’ Sprat ‘仅仅当它前面是’Jack’或者是’Tom’。但是’Jack’和’Tom’都不是匹配结果的一部分。</td>
</tr>
<tr>
<td align="left">x(?!y)</td>
<td align="left">仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。</td>
<td align="left">仅仅当这个数字后面没有跟小数点的时候，/\d+(?!.)/ 匹配一个数字。正则表达式/\d+(?!.)/.exec(“3.141”)匹配’141’而不是’3.141</td>
</tr>
<tr>
<td align="left">(?&lt;!<em>y</em>)<em>x</em></td>
<td align="left">仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。</td>
<td align="left">仅仅当这个数字前面没有负号的时候，/(?&lt;!-)\d+/匹配一个数字。/(?&lt;!-)\d+/.exec(‘3’)匹配到 “3”./(?&lt;!-)\d+/.exec(‘-3’)因为这个数字前有负号，所以没有匹配到。</td>
</tr>
<tr>
<td align="left">x|y</td>
<td align="left">匹配’x’或者’y’。</td>
<td align="left">/green|red/匹配“green apple”中的’green’和“red apple”中的’red’</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个正整数，匹配了前面一个字符必须刚好出现了 n 次。</td>
<td align="left">/a{2}/ 不会匹配“candy”中的’a’,但匹配“caaandy”中的前两个’a’。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n是一个正整数，匹配前一个字符至少出现了n次。</td>
<td align="left">/a{2,}/ 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td>
<td align="left">/a{1, 3}/ 配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。</td>
</tr>
<tr>
<td align="left">[xyz]</td>
<td align="left">一个字符集合。匹配方括号中的任意字符，包括转义序列。可以使用破折号（-）来指定一个字符范围。点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。不必进行转义，不过转义也是起作用的。</td>
<td align="left">[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的’b’,也都匹配“city”中的’c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</td>
</tr>
<tr>
<td align="left">[^xyz]</td>
<td align="left">一个反向字符集。它匹配任何没有包含在方括号中的字符。可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</td>
<td align="left">[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中的’r’，也匹配“chop”中的’h’。</td>
</tr>
<tr>
<td align="left">[\b]</td>
<td align="left">匹配一个退格(U+0008)。（特例）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。</td>
<td align="left">/\bm/匹配“moon”中的’m’；  /oon\b/匹配”moon”中的’oon’。<br><strong>注意：</strong>大写和小写的罗马字母，十进制数字和下划线字符被视为断词，不作为“字”字符。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">匹配一个非单词边界。匹配如下几种情况：<br>字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符<br>两个单词字符之间两个非单词字符之间<br>空字符串。</td>
<td align="left">/\B../匹配”noonday”中的’oo’, 而/y\B../匹配”possibly yesterday”中的’yes’</td>
</tr>
<tr>
<td align="left">\cX</td>
<td align="left">当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。</td>
<td align="left">/\cM/匹配字符串中的 control-M (U+000D)。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配一个数字。等价于[0-9]。</td>
<td align="left">/\d/或者/[0-9]/匹配”B2 is the suite number.”中的’2’。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配一个非数字字符。等价于[^0-9]。</td>
<td align="left">/\D/或者/[^0-9]/匹配”B2 is the suite number.”中的’B’ 。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符 (U+000C)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符 (U+000A)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符 (U+000D)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配一个空白字符，包括空格、制表符、换页符和换行符。</td>
<td align="left">/\s\w*/匹配”foo bar.”中的’ bar’。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配一个非空白字符。</td>
<td align="left">/\S\w*/匹配”foo bar.”中的’foo’。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个水平制表符 (U+0009)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符 (U+000B)。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</td>
<td align="left">/\w/匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配一个非单字字符。等价于[^A-Za-z0-9_]。</td>
<td align="left">/\W/或者/[^A-Za-z0-9_]/匹配 “50%.”中的 ‘%’。</td>
</tr>
<tr>
<td align="left">\0</td>
<td align="left">匹配 NULL（U+0000）字符， 后面不能跟其它小数，因为\0<digits>是一个八进制转义序列。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\xhh</td>
<td align="left">匹配一个两位十六进制数（\x00-\xFF）表示的字符。</td>
<td align="left">\x0A等价于\n</td>
</tr>
<tr>
<td align="left">\uhhhh</td>
<td align="left">匹配一个四位十六进制数表示的 UTF-16 代码单元。</td>
<td align="left">\u0009等价于\t</td>
</tr>
<tr>
<td align="left">\u{hhhh}或\u{hhhhh}</td>
<td align="left">（仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3　原始值包装类型"></a>5.3　原始值包装类型</h2><p>为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这里，<code>s1</code>是一个包含字符串的变量，它是一个原始值。第二行紧接着在<code>s1</code>上调用了<code>substring()</code>方法，并把结果保存在<code>s2</code>中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。这是因为当第二行访问<code>s1</code>时，是以读模式访问的，也就是从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3步：<br>(1) 创建一个<code>String</code>类型的实例；</p>
<p>(2) 调用实例上的特定方法；</p>
<p>(3) 销毁实例。</p>
<p>可以把这3步想象成执行了如下3行ECMAScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也类似如此。<br>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过<code>new</code>实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间，也就是无法在运行时给原始值添加属性和方法。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.color);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>这里的第二行代码尝试给字符串<code>s1</code>添加了一个<code>color</code>属性。可是，第三行代码访问<code>color</code>属性时，它却不见了。原因就是第二行代码运行时会临时创建一个<code>String</code>对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里又创建了一个新的<code>String</code>对象，但这个对象没有<code>color</code>属性。<br>可以显式地使用<code>Boolean</code>、<code>Number</code>和<code>String</code>构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在显式创建的原始值包装类型的实例上调用<code>typeof</code>会返回<code>&quot;object&quot;</code>，所有原始值包装对象都会转换为布尔值<code>true</code>。</p>
<p>另外，<code>Object</code>构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果传给<code>Object</code>的是字符串，则会创建一个<code>String</code>的实例。如果是数值，则会创建<code>Number</code>的实例。布尔值则会得到<code>Boolean</code>的实例。<br>注意，使用<code>new</code>调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value);    <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number);    <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);   <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);       <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，变量<code>number</code>中保存的是一个值为25的原始数值，而变量<code>obj</code>中保存的是一个<code>Number</code>的实例。</p>
<h3 id="5-3-1Boolean"><a href="#5-3-1Boolean" class="headerlink" title="5.3.1Boolean"></a>5.3.1<code>Boolean</code></h3><p><code>Boolean</code>是对应布尔值的引用类型。要创建一个<code>Boolean</code>对象，就使用<code>Boolean</code>构造函数并传入<code>true</code>或<code>false</code>，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><code>Boolean</code>的实例会重写<code>valueOf()</code>方法，返回一个原始值<code>true</code>或<code>false</code>。<code>toString()</code>方法被调用时也会被覆盖，返回字符串<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>。强烈建议永远不要使用<code>Boolean</code>对象。因为在布尔表达式中使用<code>Boolean</code>对象时，容易引起误会，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(falseObject &amp;&amp; <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(falseValue &amp;&amp; <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>因为这个表达式是对<code>falseObject</code>对象而不是对它表示的值（<code>false</code>）求值，而所有对象在布尔表达式中都会自动转换为<code>true</code>。<br>原始值和引用值（<code>Boolean</code>对象）还有几个区别。首先，<code>typeof</code>操作符对原始值返回<code>&quot;boolean&quot;</code>，但对引用值返回<code>&quot;object&quot;</code>。同样，<code>Boolean</code>对象是<code>Boolean</code>类型的实例，在使用<code>instaceof</code>操作符时返回<code>true</code>，但对原始值则返回<code>false</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);             <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);              <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-2Number"><a href="#5-3-2Number" class="headerlink" title="5.3.2Number"></a>5.3.2<code>Number</code></h3><p><code>Number</code>是对应数值的引用类型。要创建一个<code>Number</code>对象，就使用<code>Number</code>构造函数并传入一个数值，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>与<code>Boolean</code>类型一样，<code>Number</code>类型重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法。<code>valueOf()</code>方法返回<code>Number</code>对象表示的原始数值，另外两个方法返回数值字符串。<code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());   <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));  <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));  <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>除了继承的方法，<code>Number</code>类型还提供了几个用于将数值格式化为字符串的方法。<br><code>toFixed()</code>方法返回包含指定小数点位数的数值字符串，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>toFixed()</code>方法接收了参数<code>2</code>，表示返回的数值字符串要包含两位小数。结果返回值为<code>&quot;10.00&quot;</code>，小数位填充了0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.01&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toFixed()</code>自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，<code>0.1 + 0.2 = 0.30000000000000004</code>。</p>
<blockquote>
<p><strong>注意</strong><code>toFixed()</code>方法可以表示有0~20个小数位的数值。某些浏览器可能支持更大的范围。</p>
</blockquote>
<p><code>toExponential()</code>，返回以科学记数法（也称为指数记数法）表示的数值字符串。与<code>toFixed()</code>一样，<code>toExponential()</code>也接收一个参数，表示结果中小数的位数。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>));  <span class="comment">// &quot;1.0e+1&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的输出为<code>&quot;1.0e+1&quot;</code>。一般来说，这么小的数不用表示为科学记数法形式。如果想得到数值最适当的形式，那么可以使用<code>toPrecision()</code>。<br><code>toPrecision()</code>方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>本质上，<code>toPrecision()</code>方法会根据数值和精度来决定调用<code>toFixed()</code>还是<code>toExponential()</code>。为了以正确的小数位精确表示数值，这3个方法都会向上或向下舍入。</p>
<blockquote>
<p><strong>注意</strong><code>toPrecision()</code>方法可以表示带1~21个小数位的数值。某些浏览器可能支持更大的范围，但这是通常被支持的范围。</p>
</blockquote>
<p>与<code>Boolean</code>对象类似，同样不建议直接实例化<code>Number</code>对象。在处理原始数值和引用数值时，<code>typeof</code>和<code>instacnceof</code>操作符会返回不同的结果，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> numberValue = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject);             <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue);              <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>);   <span class="comment">// false </span></span><br></pre></td></tr></table></figure>
<p><code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>IEEE 754数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code>（<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/14/rLyY1VZMH5oQtD9.gif"
                      alt="gif.gif"
                >）到<code>Number.MAX_SAFE_INTEGER</code>（<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/14/3YnaD86ptI9Zwly.gif"
                      alt="gif _1_.gif"
                >）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用<code>Number.isSafeInteger()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>));             <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>));       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-3String"><a href="#5-3-3String" class="headerlink" title="5.3.3String"></a>5.3.3<code>String</code></h3><p><code>String</code>是对应字符串的引用类型。要创建一个<code>String</code>对象，使用<code>String</code>构造函数并传入一个数值，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>String</code>对象的方法可以在所有字符串原始值上调用。3个继承的方法<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。<br>每个<code>String</code>对象都有一个<code>length</code>属性，表示字符串中字符的数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.length); <span class="comment">// &quot;11&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，即使字符串中包含双字节字符（而不是单字节的ASCII字符），也仍然会按单字符来计数。</p>
<h4 id="5-3-3-1-JavaScript字符"><a href="#5-3-3-1-JavaScript字符" class="headerlink" title="5.3.3.1   JavaScript字符"></a><strong>5.3.3.1   JavaScript字符</strong></h4><p>JavaScript字符串由16位码元（code unit）组成。对多数字符来说，每16位码元对应一个字符。换句话说，字符串的<code>length</code>属性表示字符串包含多少16位码元：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><code>charAt()</code>方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16位码元，并返回该码元对应的字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)); <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p>JavaScript字符串使用了两种Unicode编码混合的策略：UCS-2和UTF-16。对于可以采用16位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的。<br>使用<code>charCodeAt()</code>方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是U+0063</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">// 99</span></span><br><span class="line"><span class="comment">// 十进制99等于十六进制63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>方法用于根据给定的UTF-16码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>));  <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>));          <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于U+0000~U+FFFF范围内的字符，<code>length</code>、<code>charAt()</code>、<code>charCodeAt()</code>和<code>fromCharCode()</code>返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用16位表示的，而这几个方法也都基于16位码元完成操作。只要字符编码大小与码元大小一一对应，这些方法就能如期工作。<br>这个对应关系在扩展到Unicode增补字符平面时就不成立了。问题很简单，即16位只能唯一表示65 536个字符。这对于大多数语言字符集是足够了，在Unicode中称为<strong>基本多语言平面</strong>（BMP）。为了表示更多的字符，Unicode采用了一个策略，即每个字符使用另外16位去选择一个<strong>增补平面</strong>。这种每个字符使用两个16位码元的策略称为<strong>代理对</strong>。</p>
<p>在涉及增补平面的字符时，前面讨论的字符串方法就会出问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;smiling face with smiling eyes&quot; 表情符号的编码是U+1F60A</span></span><br><span class="line"><span class="comment">// 0x1F60A === 128522</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length);          <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>));       <span class="comment">// &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">3</span>));       <span class="comment">// &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));   <span class="comment">// 55357</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">3</span>));   <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1F60A</span>)); <span class="comment">// 😊</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure>
<p>这些方法仍然将16位码元当作一个字符，事实上索引2和索引3对应的码元应该被看成一个代理对，只对应一个字符。<code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成），并正确地将其识别为一个Unicode笑脸字符。<br>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用<code>codePointAt()</code>来代替<code>charCodeAt()</code>。<code>codePointAt()</code>接收16位码元的索引并返回该索引位置上的码点（code point）。<strong>码点</strong>是Unicode中一个字符的完整标识。码点可能是16位，也可能是32位，而<code>codePointAt()</code>方法可以从指定码元位置识别完整的码点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">1</span>)); <span class="comment">// 98</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">2</span>)); <span class="comment">// 128522</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">3</span>)); <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">4</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>注意，如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现，可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...<span class="string">&quot;ab😊de&quot;</span>]); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;😊&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>fromCharCode()</code>也有一个对应的<code>fromCodePoint()</code>。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>, <span class="number">98</span>, <span class="number">128522</span>, <span class="number">100</span>, <span class="number">101</span>));   <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-2normalize-方法"><a href="#5-3-3-2normalize-方法" class="headerlink" title="5.3.3.2normalize()方法"></a>5.3.3.2<code>normalize()</code><strong>方法</strong></h4><p>某些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP字符表示，也可以通过一个代理对表示。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// U+00C5：上面带圆圈的大写拉丁字母A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>));          <span class="comment">// Å</span></span><br><span class="line"><span class="comment">// U+212B：长度单位“埃”</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>));          <span class="comment">// Å</span></span><br><span class="line"><span class="comment">// U+004：大写拉丁字母A</span></span><br><span class="line"><span class="comment">// U+030A：上面加个圆圈</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>));  <span class="comment">// Å</span></span><br></pre></td></tr></table></figure>
<p>比较操作符不在乎字符看起来是什么样的，因此这3个字符互不相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1, a2, a3); <span class="comment">// Å, Å, Å</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a2);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a3);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>为解决这个问题，Unicode提供了4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和NFKC（Normalization Form KC）。可以使用<code>normalize()</code>方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：<code>&quot;NFD&quot;</code>、<code>&quot;NFC&quot;</code>、<code>&quot;NFKD&quot;</code>或<code>&quot;NFKC&quot;</code>。<br>通过比较字符串与其调用<code>normalize()</code>的返回值，就可以知道该字符串是否已经规范化了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="comment">// U+00C5是对0+212B进行NFC/NFKC规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// U+212B是未规范化的</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// U+0041/U+030A是对0+212B进行NFD/NFKD规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFD&quot;</span>) === a2.normalize(<span class="string">&quot;NFD&quot;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2.normalize(<span class="string">&quot;NFKC&quot;</span>) === a3.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFC&quot;</span>) === a3.normalize(<span class="string">&quot;NFC&quot;</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-3-字符串操作方法"><a href="#5-3-3-3-字符串操作方法" class="headerlink" title="5.3.3.3   字符串操作方法"></a><strong>5.3.3.3   字符串操作方法</strong></h4><p><code>concat()</code>，用于将一个或多个字符串拼接成一个新字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);      <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>concat()</code>方法可以接收任意多个参数，因此可以一次性拼接多个字符串，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);      <span class="comment">// &quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然<code>concat()</code>方法可以拼接字符串，但更常用的方式是使用加号操作符（<code>+</code>）。而且多数情况下更方便。<br>ECMAScript提供了3个从字符串中提取子字符串的方法：<code>slice()</code>、<code>substr()</code>和<code>substring()</code>。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对<code>slice()</code>和<code>substring()</code>而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来,不包含该位置）。对<code>substr()</code>而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与<code>concat()</code>方法一样，<code>slice()</code>、<code>substr()</code>和<code>substring()</code>也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>));       <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>));   <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>));      <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));    <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));   <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure>
<p>当某个参数是负值时，这3个方法的行为又有不同。<code>slice()</code>方法将所有负值参数都当成字符串长度加上负参数值。<code>substring()</code>方法会将所有负参数值都转换为0。<code>substr()</code>方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(-<span class="number">3</span>));         <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(-<span class="number">3</span>));     <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(-<span class="number">3</span>));        <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, -<span class="number">4</span>));      <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, -<span class="number">4</span>));  <span class="comment">// &quot;hel&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, -<span class="number">4</span>));     <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure>
<p><code>substring(3, 0)</code>，等价于<code>substring(0, 3)</code>，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对<code>substr()</code>来说，第二个参数会被转换为<code>0</code>，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</p>
<h4 id="5-3-3-4-字符串位置方法"><a href="#5-3-3-4-字符串位置方法" class="headerlink" title="5.3.3.4   字符串位置方法"></a><strong>5.3.3.4   字符串位置方法</strong></h4><p>有两个方法用于在字符串中定位子字符串：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回<code>-1</code>）。两者的区别在于，<code>indexOf()</code>方法从字符串开头开始查找子字符串，而<code>lastIndexOf()</code>方法从字符串末尾开始查找子字符串。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>));     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，<code>indexOf()</code>会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；<code>lastIndexOf()</code>则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>));     <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>像这样使用第二个参数并循环调用<code>indexOf()</code>或<code>lastIndexOf()</code>，就可以在字符串中找到所有的目标子字符串，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> pos = stringValue.indexOf(<span class="string">&quot;e&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">  positions.push(pos);</span><br><span class="line">  pos = stringValue.indexOf(<span class="string">&quot;e&quot;</span>, pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positions); <span class="comment">// [3,24,32,35,52]</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-5字符串包含方法"><a href="#5-3-3-5字符串包含方法" class="headerlink" title="5.3.3.5字符串包含方法"></a>5.3.3.5<strong>字符串包含方法</strong></h4><p>ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code>、<code>endsWith()</code>和<code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，<code>startsWith()</code>检查开始于索引0的匹配项，<code>endsWith()</code>检查开始于索引<code>(string.length - substring.length)</code>的匹配项，而<code>includes()</code>检查整个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;bar&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;qux&quot;</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>startsWith()</code>和<code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-6trim-方法"><a href="#5-3-3-6trim-方法" class="headerlink" title="5.3.3.6trim()方法"></a>5.3.3.6<code>trim()</code><strong>方法</strong></h4><p>ECMAScript在所有字符串上都提供了<code>trim()</code>方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;  hello world  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.trim();</span><br><span class="line"><span class="built_in">console</span>.log(stringValue);         <span class="comment">// &quot;  hello world &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(trimmedStringValue);  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>trim()</code>返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。<br>另外，<code>trimLeft()</code>和<code>trimRight()</code>方法分别用于从字符串开始和末尾清理空格符。</p>
<h4 id="5-3-3-7repeat-方法"><a href="#5-3-3-7repeat-方法" class="headerlink" title="5.3.3.7repeat()方法"></a>5.3.3.7<code>repeat()</code><strong>方法</strong></h4><p>ECMAScript在所有字符串上都提供了<code>repeat()</code>方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>);</span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-8padStart-和padEnd-方法"><a href="#5-3-3-8padStart-和padEnd-方法" class="headerlink" title="5.3.3.8padStart()和padEnd()方法"></a>5.3.3.8<code>padStart()</code><strong>和</strong><code>padEnd()</code><strong>方法</strong></h4><p><code>padStart()</code>和<code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>));       <span class="comment">// &quot;   foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));  <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>));         <span class="comment">// &quot;foo   &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));    <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure>
<p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>));        <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>));   <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>));          <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-9字符串迭代与解构"><a href="#5-3-3-9字符串迭代与解构" class="headerlink" title="5.3.3.9字符串迭代与解构"></a>5.3.3.9<strong>字符串迭代与解构</strong></h4><p>字符串的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。可以像下面这样手动使用迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>在<code>for-of</code>循环中可以通过这个迭代器按序访问每个字符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure>
<p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。比如，可以更方便地把字符串分割为字符数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...message]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-10-字符串大小写转换"><a href="#5-3-3-10-字符串大小写转换" class="headerlink" title="5.3.3.10   字符串大小写转换"></a><strong>5.3.3.10   字符串大小写转换</strong></h4><p>下一组方法涉及大小写转换，包括4个方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>。<code>toLocaleLowerCase()</code>和<code>toLocaleUpperCase()</code>方法旨在基于特定地区实现。在少数语言中，Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());  <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toUpperCase());        <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());  <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLowerCase());        <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-11字符串模式匹配方法"><a href="#5-3-3-11字符串模式匹配方法" class="headerlink" title="5.3.3.11字符串模式匹配方法"></a>5.3.3.11<strong>字符串模式匹配方法</strong></h4><p><code>match()</code>方法，这个方法本质上跟<code>RegExp</code>对象的<code>exec()</code>方法相同。<code>match()</code>方法接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">// 等价于pattern.exec(text)</span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// &quot;cat&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>match()</code>方法返回的数组与<code>RegExp</code>对象的<code>exec()</code>方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。<br>另一个查找模式的字符串方法是<code>search()</code>。这个方法唯一的参数与<code>match()</code>方法一样：正则表达式字符串或<code>RegExp</code>对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。<code>search()</code>始终从字符串开头向后匹配模式。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>replace()</code>方法，接收两个参数，第一个参数可以是一个<code>RegExp</code>对象或一个字符串（但这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.replace(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &quot;cond, bat, sat, fat&quot;</span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262中规定了下表中的值。<br>|字符序列|替换文本|<br>|:—-|:—-|<br>|$$|$|<br>|$&amp;|匹配整个模式的子字符串。与RegExp.lastMatch相同|<br>|$’|匹配的子字符串之前的字符串。与RegExp.rightContext相同|<br>|$`|匹配的子字符串之后的字符串。与RegExp.leftContext相同|<br>|$<em>n</em>|匹配第<em>n</em>个捕获组的字符串，其中<em>n</em>是0<del>9。比如，$1是匹配第一个捕获组的字符串，$2是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串|<br>|$<em>nn</em>|匹配第<em>nn</em>个捕获组字符串，其中<em>nn</em>是01</del>99。比如，$01是匹配第一个捕获组的字符串，$02是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串|</p>
<p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">&quot;word ($1)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure>
<p><code>replace()</code>的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到3个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(htmlEscape(<span class="string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后一个与模式匹配相关的字符串方法是<code>split()</code>。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是<code>RegExp</code>对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;red,blue,green,yellow&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.split(<span class="string">&quot;,&quot;</span>);       <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.split(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>);    <span class="comment">// [&quot;red&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.split(<span class="regexp">/[^,]+/</span>);   <span class="comment">// [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>
<p>注意在最后一次调用<code>split()</code>时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（<code>&quot;red&quot;</code>）和末尾（<code>&quot;yellow&quot;</code>）。</p>
<h4 id="5-3-3-12localeCompare-方法"><a href="#5-3-3-12localeCompare-方法" class="headerlink" title="5.3.3.12localeCompare()方法"></a>5.3.3.12<code>localeCompare()</code><strong>方法</strong></h4><p><code>localeCompare()</code>，比较两个字符串，返回如下3个值中的一个。</p>
<pre><code>1. 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是`-1`，具体还要看与实际值相关的实现。）
2. 如果字符串与字符串参数相等，则返回`0`。
3. 如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是`1`，具体还要看与实际值相关的实现。）</code></pre>
<p>下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>));    <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>在这里，字符串<code>&quot;yellow&quot;</code>与3个不同的值进行了比较：<code>&quot;brick&quot;</code>、<code>&quot;yellow&quot;</code>和<code>&quot;zoo&quot;</code>。<code>&quot;brick&quot;</code>按字母表顺序应该排在<code>&quot;yellow&quot;</code>前头，因此<code>localeCompare()</code>返回1。<code>&quot;yellow&quot;</code>等于<code>&quot;yellow&quot;</code>，因此<code>&quot;localeCompare()&quot;</code>返回<code>0</code>。最后，<code>&quot;zoo&quot;</code>在<code>&quot;yellow&quot;</code>后面，因此<code>localeCompare()</code>返回<code>-1</code>。强调一下，因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用<code>localeCompare()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = stringValue.localeCompare(value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; comes before the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; comes after the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; is equal to the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">determineOrder(<span class="string">&quot;brick&quot;</span>);</span><br><span class="line">determineOrder(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">determineOrder(<span class="string">&quot;zoo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样一来，就可以保证在所有实现中都能正确判断字符串的顺序了。<br><code>localeCompare()</code>的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是ECMAScript实现的标准语言，<code>localeCompare()</code>区分大小写，大写字母排在小写字母前面。</p>
<h4 id="5-3-3-13HTML方法"><a href="#5-3-3-13HTML方法" class="headerlink" title="5.3.3.13HTML方法"></a>5.3.3.13<strong>HTML方法</strong></h4><p>早期的浏览器开发商认为使用JavaScript动态生成HTML标签是一个需求。因此，早期浏览器扩展了规范，增加了辅助生成HTML标签的方法。下表总结了这些HTML方法。这些方法基本上已经没有人使用了，因为结果通常不是语义化的标记。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">anchor(<em>name</em>)</td>
<td align="left"><a name="*name*"><em>string</em></a></td>
</tr>
<tr>
<td align="left">big()</td>
<td align="left"><big><em>string</em></big></td>
</tr>
<tr>
<td align="left">bold()</td>
<td align="left"><b><em>string</em></b></td>
</tr>
<tr>
<td align="left">fixed()</td>
<td align="left"><tt><em>string</em></tt></td>
</tr>
<tr>
<td align="left">fontcolor(<em>color</em>)</td>
<td align="left"><font color="*color*"><em>string</em></font></td>
</tr>
<tr>
<td align="left">fontsize(<em>size</em>)</td>
<td align="left"><font size="*size*"><em>string</em></font></td>
</tr>
<tr>
<td align="left">italics()</td>
<td align="left"><i><em>string</em></i></td>
</tr>
<tr>
<td align="left">link(url)</td>
<td align="left"><a href="*url*"><em>string</em></a></td>
</tr>
<tr>
<td align="left">small()</td>
<td align="left"><small><em>string</em></small></td>
</tr>
<tr>
<td align="left">strike()</td>
<td align="left"><strike><em>string</em></strike></td>
</tr>
<tr>
<td align="left">sub()</td>
<td align="left"><sub><em>string</em></sub></td>
</tr>
<tr>
<td align="left">sup()</td>
<td align="left"><sup><em>string</em></sup></td>
</tr>
</tbody></table>
<h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4　单例内置对象"></a>5.4　单例内置对象</h2><p>ECMA-262对内置对象的定义是“任何由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括<code>Object</code>、<code>Array</code>和<code>String</code>。另外两个单例内置对象：<code>Global</code>和<code>Math</code>。</p>
<h3 id="5-4-1Global"><a href="#5-4-1Global" class="headerlink" title="5.4.1Global"></a>5.4.1<code>Global</code></h3><p><code>Global</code>对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。ECMA-262规定<code>Global</code>对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成<code>Global</code>对象的属性 。包括<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和<code>parseFloat()</code>，实际上都是<code>Global</code>对象的方法。除了这些，<code>Global</code>对象上还有另外一些方法。</p>
<h4 id="5-4-1-1-URL编码方法"><a href="#5-4-1-1-URL编码方法" class="headerlink" title="5.4.1.1   URL编码方法"></a><strong>5.4.1.1   URL编码方法</strong></h4><p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。</p>
<p><code>ecnodeURI()</code>方法用于对整个URI进行编码，比如<code>&quot;www.wrox.com/illegal value.js&quot;</code>。而<code>encodeURIComponent()</code>方法用于编码URI中单独的组件，比如前面URL中的<code>&quot;illegal value.js&quot;</code>。这两个方法的主要区别是，<code>encodeURI()</code>不会编码属于URL组件的特殊字符，比如：、/、?、#，而<code>encodeURIComponent()</code>会编码它发现的所有非标准字符。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>一般来说，使用<code>encodeURIComponent()</code>应该比使用<code>encodeURI()</code>的频率更高，这是因为编码查询字符串参数比编码基准URI的次数更多。</p>
</blockquote>
<p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>相对的是<code>decodeURI()</code>和<code>decodeURIComponent()</code>。<code>decodeURI()</code>只对使用<code>encodeURI()</code>编码过的字符解码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>;</span><br><span class="line"><span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));</span><br><span class="line"><span class="comment">// http:// www.wrox.com/illegal value.js#start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>URI方法<code>encodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURI()</code>和<code>decodeURIComponent()</code>取代了<code>escape()</code>和<code>unescape()</code>方法，后者在ECMA-262第3版中就已经废弃了。URI方法始终是首选方法，因为它们对所有Unicode字符进行编码，而原来的方法只能正确编码ASCII字符。不要在生产环境中使用<code>escape()</code>和<code>unescape()</code>。</p>
</blockquote>
<h4 id="5-4-1-2eval-方法"><a href="#5-4-1-2eval-方法" class="headerlink" title="5.4.1.2eval()方法"></a>5.4.1.2<code>eval()</code><strong>方法</strong></h4><p><code>eval()</code>方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>);</span><br><span class="line"><span class="comment">//上面这行代码的功能与下一行等价：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当解释器发现<code>eval()</code>调用时，会将参数解释为实际的ECMAScript语句，然后将其插入到该位置。通过<code>eval()</code>执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在<code>eval()</code>调用内部被引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>);  <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;let msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//Reference Error: msg is not defined,这里不明白</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<p>通过<code>eval()</code>定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在<code>eval()</code>执行的时候才会被创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();<span class="comment">// hi</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>); &#125;<span class="comment">//函数提升</span></span><br><span class="line">sayHi();<span class="comment">// sayHi is not defined</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>但在严格模式下，在<code>eval()</code>内部创建的变量和函数无法被外部访问，赋值给<code>eval</code>也会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="string">&quot;hi&quot;</span>;  <span class="comment">// 导致错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>解释代码字符串的能力是非常强大的，但也非常危险。在使用<code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</p>
</blockquote>
<h4 id="5-4-1-3Global对象属性"><a href="#5-4-1-3Global对象属性" class="headerlink" title="5.4.1.3Global对象属性"></a>5.4.1.3<code>Global</code><strong>对象属性</strong></h4><p><code>Global</code>对象有很多属性，其中一些前面已经提到过了。像<code>undefined</code>、<code>NaN</code>和<code>Infinity</code>等特殊值都是<code>Global</code>对象的属性。此外，所有原生引用类型构造函数，比如<code>Object</code>和<code>Function</code>，也都是<code>Global</code>对象的属性。下表列出了所有这些属性。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">undefined</td>
<td align="left">特殊值undefined</td>
</tr>
<tr>
<td align="left">NaN</td>
<td align="left">特殊值NaN</td>
</tr>
<tr>
<td align="left">Infinity</td>
<td align="left">特殊值Infinity</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">Object的构造函数</td>
</tr>
<tr>
<td align="left">Array</td>
<td align="left">Array的构造函数</td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">Function的构造函数</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">Boolean的构造函数</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">String的构造函数</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">Number的构造函数</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">Date的构造函数</td>
</tr>
<tr>
<td align="left">RegExp</td>
<td align="left">RegExp的构造函数</td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">Symbol的伪构造函数</td>
</tr>
<tr>
<td align="left">Error</td>
<td align="left">Error的构造函数</td>
</tr>
<tr>
<td align="left">EvalError</td>
<td align="left">EvalError的构造函数</td>
</tr>
<tr>
<td align="left">RangeError</td>
<td align="left">RangeError的构造函数</td>
</tr>
<tr>
<td align="left">ReferenceError</td>
<td align="left">ReferenceError的构造函数</td>
</tr>
<tr>
<td align="left">SyntaxError</td>
<td align="left">SyntaxError的构造函数</td>
</tr>
<tr>
<td align="left">TypeError</td>
<td align="left">TypeError的构造函数</td>
</tr>
<tr>
<td align="left">URIError</td>
<td align="left">URIError的构造函数</td>
</tr>
</tbody></table>
<h4 id="5-4-1-4window对象"><a href="#5-4-1-4window对象" class="headerlink" title="5.4.1.4window对象"></a>5.4.1.4<code>window</code><strong>对象</strong></h4><p>虽然ECMA-262没有规定直接访问<code>Global</code>对象的方式，但浏览器将<code>window</code>对象实现为<code>Global</code>对象的代理。因此，所有全局作用域中声明的变量和函数都变成了<code>window</code>的属性。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>window</code>对象在JavaScript中远不止实现了<code>ECMAScript</code>的<code>Global</code>对象那么简单。关于<code>window</code>对象的更多介绍，请参考第12章。</p>
</blockquote>
<p>另一种获取<code>Global</code>对象的方式是使用如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">global</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这段代码创建一个立即调用的函数表达式，返回了<code>this</code>的值。如前所述，当一个函数在没有明确（通过成为某个对象的方法，或者通过<code>call()</code>/<code>apply()</code>）指定<code>this</code>值的情况下执行时，<code>this</code>值等于<code>Global</code>对象。因此，调用一个简单返回<code>this</code>的函数是在任何执行上下文中获取<code>Global</code>对象的通用方式。</p>
<h3 id="5-4-2Math"><a href="#5-4-2Math" class="headerlink" title="5.4.2Math"></a>5.4.2<code>Math</code></h3><p>ECMAScript提供了<code>Math</code>对象作为保存数学公式、信息和计算的地方。<code>Math</code>对象提供了一些辅助计算的属性和方法。</p>
<blockquote>
<p><strong>注意</strong><code>Math</code>对象上提供的计算要比直接在JavaScript实现的快得多，因为<code>Math</code>对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令。但使用<code>Math</code>计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。</p>
</blockquote>
<h4 id="5-4-2-1Math对象属性"><a href="#5-4-2-1Math对象属性" class="headerlink" title="5.4.2.1Math对象属性"></a>5.4.2.1<code>Math</code><strong>对象属性</strong></h4><p><code>Math</code>对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Math.E</td>
<td align="left">自然对数的基数e的值</td>
</tr>
<tr>
<td align="left">Math.LN10</td>
<td align="left">10为底的自然对数</td>
</tr>
<tr>
<td align="left">Math.LN2</td>
<td align="left">2为底的自然对数</td>
</tr>
<tr>
<td align="left">Math.LOG2E</td>
<td align="left">以2为底e的对数</td>
</tr>
<tr>
<td align="left">Math.LOG10E</td>
<td align="left">以10为底e的对数</td>
</tr>
<tr>
<td align="left">Math.PI</td>
<td align="left">π的值</td>
</tr>
<tr>
<td align="left">Math.SQRT1_2</td>
<td align="left">1/2的平方根</td>
</tr>
<tr>
<td align="left">Math.SQRT2</td>
<td align="left">2的平方根</td>
</tr>
</tbody></table>
<h4 id="5-4-2-2min-和max-方法"><a href="#5-4-2-2min-和max-方法" class="headerlink" title="5.4.2.2min()和max()方法"></a>5.4.2.2<code>min()</code><strong>和</strong><code>max()</code><strong>方法</strong></h4><p><code>min()</code>和<code>max()</code>方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// 54</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>使用这两个方法可以避免使用额外的循环和<code>if</code>语句来确定一组数值的最大最小值。<br>要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...val);</span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-3舍入方法"><a href="#5-4-2-3舍入方法" class="headerlink" title="5.4.2.3舍入方法"></a>5.4.2.3<strong>舍入方法</strong></h4><p>接下来是用于把小数值舍入为整数的4个方法：<code>Math.ceil()</code>、<code>Math.floor()</code>、<code>Math.round()</code>和<code>Math.fround()</code>。这几个方法处理舍入的方式如下所述。</p>
<pre><code>1. `Math.ceil()`方法始终向上舍入为最接近的整数。
2. `Math.floor()`方法始终向下舍入为最接近的整数。
3. `Math.round()`方法执行四舍五入。
4. `Math.fround()`方法返回数值最接近的单精度（32位）浮点值表示。</code></pre>
<p>以下示例展示了这些方法的用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>));   <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>));  <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>));  <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.4</span>));  <span class="comment">// 0.4000000059604645</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.5</span>));  <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>));  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>5.4.2.4<code>random()</code><strong>方法</strong></p>
<p><code>Math.random()</code>方法返回一个0~1范围内的随机数，其中包含0但不包含1。<code>Math.random()</code>从一组整数中随机选择一个数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total_number_of_choices + first_possible_value)</span><br></pre></td></tr></table></figure>
<p>比如如果想从1~10范围内随机选择一个数，代码就是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>很多时候，通过函数来算出可选总数和最小可能的值可能更方便，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> choices = upperValue - lowerValue + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num = selectFrom(<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// 2~10范围内的值，其中包含2和10</span></span><br></pre></td></tr></table></figure>
<p>这里的函数<code>selectFrom()</code>接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加<code>1</code>得到可选总数，然后再套用上面的公式。于是，调用<code>selectFrom(2,10)</code>就可以从2~10（包含）范围内选择一个值了。使用这个函数，从一个数组中随机选择一个元素就很容易，比如：</p>
<blockquote>
<p><strong>注意</strong><code>Math.random()</code>方法在这里出于演示目的是没有问题的。如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用<code>window.crypto.getRandomValues()</code>。</p>
</blockquote>
<h4 id="5-4-2-5其他方法"><a href="#5-4-2-5其他方法" class="headerlink" title="5.4.2.5其他方法"></a>5.4.2.5<strong>其他方法</strong></h4><p><code>Math</code>对象还有很多涉及各种简单或高阶数运算的方法。下表总结了<code>Math</code>对象的其他方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Math.abs(<em>x</em>)</td>
<td align="left">返回<em>x</em>的绝对值</td>
</tr>
<tr>
<td align="left">Math.e<em>x</em>p(<em>x</em>)</td>
<td align="left">返回Math.E的<em>x</em>次幂</td>
</tr>
<tr>
<td align="left">Math.e<em>x</em>pm1(<em>x</em>)</td>
<td align="left">等于Math.e<em>x</em>p(<em>x</em>) - 1</td>
</tr>
<tr>
<td align="left">Math.log(<em>x</em>)</td>
<td align="left">返回<em>x</em>的自然对数</td>
</tr>
<tr>
<td align="left">Math.log1p(<em>x</em>)</td>
<td align="left">等于1 + Math.log(<em>x</em>)</td>
</tr>
<tr>
<td align="left">Math.pow(<em>x</em>,<em>power</em>)</td>
<td align="left">返回<em>x</em>的<em>power</em>次幂</td>
</tr>
<tr>
<td align="left">Math.hypot(<em>…nums</em>)</td>
<td align="left">返回<em>nums</em>中每个数平方和的平方根</td>
</tr>
<tr>
<td align="left">Math.clz32(<em>x</em>)</td>
<td align="left">返回32位整数<em>x</em>的前置零的数量</td>
</tr>
<tr>
<td align="left">Math.sign(<em>x</em>)</td>
<td align="left">返回表示<em>x</em>符号的1、0、-0或-1</td>
</tr>
<tr>
<td align="left">Math.trunc(<em>x</em>)</td>
<td align="left">返回<em>x</em>的整数部分，删除所有小数</td>
</tr>
<tr>
<td align="left">Math.sqrt(<em>x</em>)</td>
<td align="left">返回<em>x</em>的平方根</td>
</tr>
<tr>
<td align="left">Math.cbrt(<em>x</em>)</td>
<td align="left">返回<em>x</em>的立方根</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">返回<em>x</em>的</td>
</tr>
<tr>
<td align="left">Math.atan2(<em>y</em>,<em>x</em>)</td>
<td align="left">返回<em>y</em>/<em>x</em>的反正切</td>
</tr>
<tr>
<td align="left">Math.cos(<em>x</em>)/Math.acos(<em>x</em>)/Math.acosh(<em>x</em>)</td>
<td align="left">返回<em>x</em>的余弦/反余弦/反双曲余弦</td>
</tr>
<tr>
<td align="left">Math.sin(<em>x</em>)/Math.asin(<em>x</em>)/Math.asinh(<em>x</em>)</td>
<td align="left">返回<em>x</em>的正弦/反正弦/反双曲正弦</td>
</tr>
<tr>
<td align="left">Math.tan(<em>x</em>)/Math.atan(<em>x</em>)/Math.atanh(<em>x</em>)</td>
<td align="left">返回<em>x</em>的正切/反正切/反双曲正切</td>
</tr>
</tbody></table>
<p>即便这些方法都是由ECMA-262定义的，对正弦、余弦、正切等计算的实现仍然取决于浏览器，因为计算这些值的方式有很多种。因此，这些方法的精度可能因实现而异。</p>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5　小结"></a>5.5　小结</h2><p>JavaScript中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。</p>
<ul>
<li>引用值与传统面向对象编程语言中的类相似，但实现不同。</li>
<li><code>Date</code>类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。</li>
<li><code>RegExp</code>类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。</li>
</ul>
<p>JavaScript比较独特的一点是，函数实际上是<code>Function</code>类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。</p>
<p>由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。它们都具备如下特点。</p>
<ul>
<li>每种包装类型都映射到同名的原始类型。</li>
<li>以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。</li>
<li>涉及原始值的语句执行完毕后，包装对象就会被销毁。</li>
</ul>
<p>当代码开始执行时，全局上下文中会存在两个内置对象：<code>Global</code>和<code>Math</code>。其中，<code>Global</code>对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为<code>window</code>对象。所有全局变量和函数都是<code>Global</code>对象的属性。<code>Math</code>对象包含辅助完成复杂计算的属性和方法。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：05-基本引用类型</li>
        <li>本文作者：胡倚豪</li>
        <li>创建时间：2021-03-14 21:18:40</li>
        <li>
            本文链接：huonenumber.github.io/2021/03/14/note/JavaScript/05-基本引用类型/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/03/09/diary/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%83%B3%E6%B3%95/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">博客搭建的想法</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oRtabIpmHUsCjAVoocAuRiR6-gzGzoHsz',
                    appKey: '8MQB6tSReJAP6eYmI5OGVpTo',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请尽情吐槽吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '胡倚豪';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">胡倚豪</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <!-- <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div> -->
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Date"><span class="nav-text">5.1　Date</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">5.1.1　继承的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-text">5.1.2　日期格式化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-text">5.1.3　日期&#x2F;时间组件方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-RegExp"><span class="nav-text">5.2　RegExp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-RegExp%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="nav-text">5.2.1   RegExp实例属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-RegExp%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-text">5.2.2   RegExp实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-RegExp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="nav-text">5.2.3   RegExp构造函数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E6%A8%A1%E5%BC%8F%E5%B1%80%E9%99%90"><span class="nav-text">5.2.4   模式局限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="nav-text">5.2.5   正则表达式（补充）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.3　原始值包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1Boolean"><span class="nav-text">5.3.1Boolean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2Number"><span class="nav-text">5.3.2Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3String"><span class="nav-text">5.3.3String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-1-JavaScript%E5%AD%97%E7%AC%A6"><span class="nav-text">5.3.3.1   JavaScript字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-2normalize-%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.2normalize()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.3   字符串操作方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.4   字符串位置方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.5字符串包含方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-6trim-%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.6trim()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-7repeat-%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.7repeat()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-8padStart-%E5%92%8CpadEnd-%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.8padStart()和padEnd()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-9%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%AD%E4%BB%A3%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="nav-text">5.3.3.9字符串迭代与解构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-10-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="nav-text">5.3.3.10   字符串大小写转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-11%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.11字符串模式匹配方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-12localeCompare-%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.12localeCompare()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-13HTML%E6%96%B9%E6%B3%95"><span class="nav-text">5.3.3.13HTML方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%8D%95%E4%BE%8B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="nav-text">5.4　单例内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1Global"><span class="nav-text">5.4.1Global</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-1-URL%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-text">5.4.1.1   URL编码方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-2eval-%E6%96%B9%E6%B3%95"><span class="nav-text">5.4.1.2eval()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-3Global%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="nav-text">5.4.1.3Global对象属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-4window%E5%AF%B9%E8%B1%A1"><span class="nav-text">5.4.1.4window对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2Math"><span class="nav-text">5.4.2Math</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-1Math%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="nav-text">5.4.2.1Math对象属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-2min-%E5%92%8Cmax-%E6%96%B9%E6%B3%95"><span class="nav-text">5.4.2.2min()和max()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-3%E8%88%8D%E5%85%A5%E6%96%B9%E6%B3%95"><span class="nav-text">5.4.2.3舍入方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-text">null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-5%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-text">5.4.2.5其他方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%B0%8F%E7%BB%93"><span class="nav-text">5.5　小结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
