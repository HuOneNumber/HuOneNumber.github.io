<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="HTML,CSS,JavaScript">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="胡倚豪">
    
    <title>
        
            06-集合引用类型 |
        
        HuOneNumber | 个人博客
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/avatar.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#33FFCC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"description":"慢慢来，深几度。。。","background_img":"/images/bg.svg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="别着急，慢慢来" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                HuOneNumber | 个人博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">06-集合引用类型</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">胡倚豪</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-03-28 18:46:33
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/">JavaScript高级程序设计(第四版)</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/06-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">06-集合引用类型</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>19.2k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>80 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="6-1-Object"><a href="#6-1-Object" class="headerlink" title="6.1　Object"></a>6.1　Object</h2><p>大多数引用值的示例使用的是<code>Object</code>类型。显式地创建<code>Object</code>的实例有两种方式。第一种是使用<code>new</code>操作符和<code>Object</code>构造函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用<strong>对象字面量</strong>（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>左大括号（<code>&#123;</code>）表示对象字面量开始，因为它出现在一个<strong>表达式上下文</strong>（expression context）中。表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号表示一个表达式的开始。同样是左大括号，如果出现在<strong>语句上下文</strong>（statement context）中，比如<code>if</code>语句的条件后面，则表示一个语句块的开始。逗号用于在对象字面量中分隔属性，在最后一个属性后面加上逗号在老的浏览器中会导致报错，但所有现代浏览器都支持这种写法。<br>在对象字面量表示法中，属性名可以是字符串或数值，注意，数值属性会自动转换为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;; <span class="comment">// 与new Object()相同</span></span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>在使用对象字面量表示法定义对象时，并不会实际调用<code>Object</code>构造函数。</p>
</blockquote>
<p>虽然使用哪种方式创建<code>Object</code>实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给函数传递大量可选参数的主要方式，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">    output += <span class="string">&quot;Name: &quot;</span> + args.name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    output += <span class="string">&quot;Age: &quot;</span> + args.age + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  alert(output);</span><br><span class="line">&#125;</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span></span><br><span class="line">&#125;);</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: <span class="string">&quot;Greg&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>这种模式非常适合函数有大量可选参数的情况。一般来说，命名参数更直观，但在可选参数过多的时候就显得笨拙了。最好的方式是对必选参数使用命名参数，再通过一个对象字面量来封装多个可选参数。</p>
</blockquote>
<p>虽然属性一般是通过<strong>点语法</strong>来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&quot;name&quot;</span>]); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用中括号的主要优势就是可以通过变量访问属性，就像下面这个例子中一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[propertyName]); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，不能使用点语法来访问，就可以使用中括号语法。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。</p>
<blockquote>
<p><strong>注意</strong>第8章将更全面、深入地介绍<code>Object</code>类型。</p>
</blockquote>
<h2 id="6-2-Array"><a href="#6-2-Array" class="headerlink" title="6.2 Array"></a>6.2 Array</h2><p>ECMAScript数组跟其他编程语言的数组有很大区别。ECMAScript数组也同样是一组有序的数据，但数组中每个槽位可以存储任意类型的数据。</p>
<h3 id="6-2-1-创建数组"><a href="#6-2-1-创建数组" class="headerlink" title="6.2.1　创建数组"></a>6.2.1　创建数组</h3><p>有几种基本的方式可以创建数组。一种是使用<code>Array</code>构造函数，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后<code>length</code>属性就会被自动创建并设置为这个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>也可以给<code>Array</code>构造函数传入要保存的元素。比如，下面的代码会创建一个包含3个字符串值的数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建数组时可以给构造函数传一个值。如果这个值是数值，则会创建一个长度为指定数值的数组（多个就不会）；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);     <span class="comment">// 创建一个包含3个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">3</span>);      <span class="comment">// [2,3]</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Greg&quot;</span>); <span class="comment">// 创建一个只包含一个元素，即字符串&quot;Greg&quot;的数组</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>Array</code>构造函数时，也可以省略<code>new</code>操作符。结果是一样的，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>);     <span class="comment">// 创建一个包含3个元素的数组</span></span><br></pre></td></tr></table></figure>
<p>另一种创建数组的方式是使用<strong>数组字面量</strong>（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,];                    <span class="comment">// 创建一个包含2个元素的数组</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>与对象一样，在使用数组字面量表示法创建数组不会调用<code>Array</code>构造函数。</p>
</blockquote>
<p><code>Array</code>构造函数还有两个ES6新增的用于创建数组的静态方法：<code>from()</code>和<code>of()</code>。<code>from()</code>用于将类数组结构转换为数组实例，<code>of()</code>用于将一组参数转换为数组实例。</p>
<p><code>Array.from()</code>的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个<code>length</code>属性和可索引元素的结构。这种方式可用于很多场合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span></span><br><span class="line"><span class="comment">// 可以使用from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">                   .set(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">1</span>)</span><br><span class="line">                   .add(<span class="number">2</span>)</span><br><span class="line">                   .add(<span class="number">3</span>)</span><br><span class="line">                   .add(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(m)); <span class="comment">// [[1, 2], [3, 4]]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1);</span><br><span class="line"><span class="built_in">console</span>.log(a2);        <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">alert(a1 === a2); <span class="comment">// false</span></span><br><span class="line">alert(a1 == a2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arguments对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrayLikeObject));<span class="comment">//[1, 2, 3, 4],length非必要</span></span><br></pre></td></tr></table></figure>
<p><code>Array.from()</code>还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用<code>Array.from().map()</code>那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中<code>this</code>的值。但这个重写的<code>this</code>值在箭头函数中不适用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="built_in">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="built_in">console</span>.log(a3);  <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>
<p><code>Array.of()</code>可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的<code>Array.prototype.slice.call(arguments)</code>，一种异常笨拙的将<code>arguments</code>对象转换为数组的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>));  <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-数组空位"><a href="#6-2-2-数组空位" class="headerlink" title="6.2.2　数组空位"></a>6.2.2　数组空位</h3><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。</p>
<p>可以像下面这样创建一个空位数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [,,,,,]; <span class="comment">// 创建包含5个元素的数组</span></span><br><span class="line"><span class="built_in">console</span>.log(options.length);   <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(options);          <span class="comment">// [,,,,,]</span></span><br></pre></td></tr></table></figure>
<p>ES6新增方法普遍将这些空位当成存在的元素，只不过值为<code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(option === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Array</span>.from([,,,]); <span class="comment">// 使用ES6的Array.from()创建的包含3个空位的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> a) &#123;</span><br><span class="line">  alert(val === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">alert(<span class="built_in">Array</span>.of(...[,,,])); <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> options.entries()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// map()会跳过空位置</span></span><br><span class="line"><span class="built_in">console</span>.log(options.map(<span class="function">() =&gt;</span> <span class="number">6</span>));  <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br><span class="line"><span class="comment">// join()视空位置为空字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(options.join(<span class="string">&#x27;-&#x27;</span>));     <span class="comment">// &quot;1----5&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用<code>undefined</code>值代替。</p>
</blockquote>
<h3 id="6-2-3-数组索引"><a href="#6-2-3-数组索引" class="headerlink" title="6.2.3　数组索引"></a>6.2.3　数组索引</h3><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 定义一个字符串数组</span></span><br><span class="line">alert(colors[<span class="number">0</span>]);                       <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">&quot;black&quot;</span>;                    <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">&quot;brown&quot;</span>;                    <span class="comment">// 添加第四项</span></span><br></pre></td></tr></table></figure>
<p>数组中元素的数量保存在<code>length</code>属性中，这个属性始终返回0或大于0的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// 创建一个空数组</span></span><br><span class="line">alert(colors.length); <span class="comment">// 3</span></span><br><span class="line">alert(names.length);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>数组<code>length</code>属性的独特之处在于，它不是只读的。通过修改<code>length</code>属性，可以从数组末尾删除或添加元素。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果将<code>length</code>设置为大于数组元素数的值，则新添加的元素都将以<code>undefined</code>填充。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">4</span>;</span><br><span class="line">alert(colors[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>这里将数组<code>colors</code>的<code>length</code>设置为4，虽然数组只包含3个元素。位置3在数组中不存在，因此访问其值会返回特殊值<code>undefined</code>。<br>使用<code>length</code>属性可以方便地向数组末尾添加元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">colors[colors.length] = <span class="string">&quot;black&quot;</span>;        <span class="comment">// 添加一种颜色（位置3）</span></span><br><span class="line">colors[colors.length] = <span class="string">&quot;brown&quot;</span>;        <span class="comment">// 再添加一种颜色（位置4）</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>colors</code>数组有一个值被插入到位置99，这中间的所有元素，即位置3~98，实际上并不存在，因此在访问时会返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors &#x3D; [&quot;re d&quot;, &quot;blue&quot;, &quot;green&quot;];  &#x2F;&#x2F; 创建一个包含3个字符串的数组</span><br><span class="line">colors[99] &#x3D; &quot;black&quot;;                   &#x2F;&#x2F; 添加一种颜色（位置99）</span><br><span class="line">alert(colors.length);                   &#x2F;&#x2F; 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>数组最多可以包含4 294 967 295个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。</p>
</blockquote>
<h3 id="6-2-4-检测数组"><a href="#6-2-4-检测数组" class="headerlink" title="6.2.4　检测数组"></a>6.2.4　检测数组</h3><p>判断一个对象是不是数组，在只有一个网页（因而只有一个全局作用域）的情况下，使用<code>instanceof</code>操作符就足矣：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>instanceof</code>的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的<code>Array</code>构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。<br>为解决这个问题，提供了<code>Array.isArray()</code>方法，目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-5-迭代器方法"><a href="#6-2-5-迭代器方法" class="headerlink" title="6.2.5　迭代器方法"></a>6.2.5　迭代器方法</h3><p>在ES6中，<code>Array</code>的原型上暴露了3个用于检索数组内容的方法：<code>keys()</code>、<code>values()</code>和<code>entries()</code>。<code>keys()</code>返回数组索引的迭代器，<code>values()</code>返回数组元素的迭代器，而<code>entries()</code>返回索引/值对的迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容</span></span><br><span class="line"><span class="comment">// 通过Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys());</span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values());</span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries());</span><br><span class="line"><span class="built_in">console</span>.log(aKeys);     <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(aValues);   <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries);  <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br></pre></td></tr></table></figure>
<p>使用ES6的解构可以非常容易地在循环中拆分键/值对：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.entries()) &#123;</span><br><span class="line">  alert(idx);</span><br><span class="line">  alert(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-6-复制和填充方法"><a href="#6-2-6-复制和填充方法" class="headerlink" title="6.2.6　复制和填充方法"></a>6.2.6　复制和填充方法</h3><p>ES6新增了两个方法：批量复制方法<code>copyWithin()</code>，以及填充数组方法<code>fill()</code>。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p>
<p>使用<code>fill()</code>方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。如果有负值索，则相当于数组长度加上它转换成的一个正索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 用5填充整个数组</span></span><br><span class="line">zeroes.fill(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);       <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用6填充索引大于等于3的元素</span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 6, 6]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);       <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用7填充索引大于等于1且小于3的元素</span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 7, 7, 0, 0];</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);       <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用8填充索引大于等于1且小于4的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1)</span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4)</span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure>
<p><code>fill()</code>静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.fill(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与<code>fill()</code>使用同样的计算方法，第一个参数，插入到哪个索引的位置，剩下两个参数是复制内容的索引范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line">    reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 从ints中复制索引0开始的内容，插入到索引5开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints);  <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 从ints中复制索引5开始的内容，插入到索引0开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints);  <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 从ints中复制索引0开始到索引3结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引4开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// JavaScript引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.copyWithin(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); <span class="comment">//  ints.copyWithin(6, 3, 7);</span></span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p><code>copyWithin()</code>静默忽略超出数组边界、零长度及方向相反的索引范围：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line">    reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, -<span class="number">15</span>, -<span class="number">12</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line">reset()</span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">ints.copyWithin(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line">reset();</span><br><span class="line"><span class="comment">// 索引部分可用，复制、填充可用部分</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-7-转换方法"><a href="#6-2-7-转换方法" class="headerlink" title="6.2.7　转换方法"></a>6.2.7　转换方法</h3><p>所有对象都有<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。其中，<code>valueOf()</code>返回的还是数组本身。而<code>toString()</code>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其<code>toString()</code>方法，以得到最终的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line">alert(colors.toString());   <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors.valueOf());    <span class="comment">// red,blue,green</span></span><br><span class="line">alert(colors);              <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>因为<code>alert()</code>期待字符串，所以会在后台调用数组的<code>toString()</code>方法，从而得到跟前面一样的结果。<br><code>toLocaleString()</code>方法也可能返回跟<code>toString()</code>和<code>valueOf()</code>相同的结果，但不一定。在调用数组的<code>toLocaleString()</code>方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的<code>toLocaleString()</code>方法，而不是<code>toString()</code>方法。</p>
<p>如果想使用不同的分隔符，则可以使用<code>join()</code>方法。<code>join()</code>方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">alert(colors.join(<span class="string">&quot;,&quot;</span>));     <span class="comment">// red,green,blue</span></span><br><span class="line">alert(colors.join(<span class="string">&quot;||&quot;</span>));    <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>如果不给<code>join()</code>传入任何参数，或者传入<code>undefined</code>，则仍然使用逗号作为分隔符。</p>
<blockquote>
<p><strong>注意</strong>如果数组中某一项是<code>null</code>或<code>undefined</code>，则在<code>join()</code>、<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>返回的结果中会以空字符串表示。</p>
</blockquote>
<h3 id="6-2-8-栈方法"><a href="#6-2-8-栈方法" class="headerlink" title="6.2.8　栈方法"></a>6.2.8　栈方法</h3><p>ECMAScript数组提供了<code>push()</code>和<code>pop()</code>方法，以实现类似栈的行为。</p>
<p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。<code>pop()</code>方法则用于删除数组的最后一项，同时减少数组的<code>length</code>值，返回被删除的项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                 <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  <span class="comment">// 推入两项</span></span><br><span class="line">alert(colors);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();       <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(colors);          <span class="comment">// [&quot;red&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-9-队列方法"><a href="#6-2-9-队列方法" class="headerlink" title="6.2.9　队列方法"></a>6.2.9　队列方法</h3><p><code>shift()</code>，删除数组的第一项并返回它，然后数组长度减1。</p>
<p><code>shift()</code>和<code>push()</code>，可以把数组当成队列来使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                 <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  <span class="comment">// 推入两项</span></span><br><span class="line"><span class="keyword">let</span> item = colors.shift();  <span class="comment">// 取得第一项</span></span><br><span class="line">alert(item);         <span class="comment">// red</span></span><br><span class="line">alert(colors);       <span class="comment">// [&quot;green&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>unshift()</code>方法，就是执行跟<code>shift()</code>相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。</p>
<h3 id="6-2-10-排序方法"><a href="#6-2-10-排序方法" class="headerlink" title="6.2.10　排序方法"></a>6.2.10　排序方法</h3><p>数组有两个方法可以用来对元素重新排序：<code>reverse()</code>和<code>sort()</code>。<code>reverse()</code>方法就是将数组元素反向排列。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values);  <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<p>这个方法直观，但不够灵活，所以才有了<code>sort()</code>方法。默认情况下，<code>sort()</code>会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，<code>sort()</code>会在每一项上调用<code>String()</code>转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。因此，即使5小于10，但字符串<code>&quot;10&quot;</code>在字符串<code>&quot;5&quot;</code>的前头，所以10还是会排到5前面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);  <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>为此，<code>sort()</code>方法可以接收一个<strong>比较函数</strong>，用于判断哪个值应该排在前面。<br>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个比较函数可以适用于大多数数据类型，可以把它当作参数传给sort()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);  <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<p>比较函数也可以产生降序效果，只要把返回值交换一下即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);  <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<p>此外，这个比较函数还可简写为一个箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? <span class="number">1</span> : a &gt; b ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">alert(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>reverse()</code>和<code>sort()</code>都返回调用它们的数组的引用。</p>
</blockquote>
<p>如果数组的元素是数值，或者是其<code>valueOf()</code>方法返回数值的对象（如<code>Date</code>对象），还可以更简单，因为比较函数就是要返回小于0、0和大于0的数值，因此减法操作完全可以满足要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-11-操作方法"><a href="#6-2-11-操作方法" class="headerlink" title="6.2.11　操作方法"></a>6.2.11　操作方法</h3><p><code>concat()</code>方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则<code>concat()</code>会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。原始数组保持不变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(colors);   <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure>
<p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcatSpreadable</code>。这个符号能够阻止<code>concat()</code>打平参数数组。相反，把这个值设置为<code>true</code>可以强制打平类数组对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;pink&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;cyan&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">newColors[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, newColors);</span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.concat(moreNewColors);</span><br><span class="line"><span class="built_in">console</span>.log(colors);   <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors3);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。<code>slice()</code>方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则<code>slice()</code>会返回该索引到数组末尾的所有元素。如果有两个参数，则<code>slice()</code>返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。不影响原始数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">alert(colors2);  <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line">alert(colors3);  <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>如果<code>slice()</code>的参数有负值，那么就以数值长度加上这个负值的结果确定位置。比如，在包含5个元素的数组上调用<code>slice(-2,-1)</code>，就相当于调用<code>slice(3,4)</code>。如果结束位置小于开始位置，则返回空数组。</p>
</blockquote>
<p><code>splice()</code>的主要目的是在数组中间插入元素，但有<code>3</code>种不同的方式使用这个方法。</p>
<ul>
<li><strong>删除</strong>。需要给<code>splice()</code>传2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如<code>splice(0, 2)</code>会删除前两个元素。</li>
<li><strong>插入</strong>。需要给<code>splice()</code>传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置前插入元素。第三个参数之后还可以传任意多个要插入的元素。</li>
<li><strong>替换</strong>。<code>splice()</code>在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。</li>
</ul>
<p><code>splice()</code>方法始终返回包含了从数组中被删除的元素数组（如果没有删除元素，则返回空数组）。会影响原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">// 删除第一项</span></span><br><span class="line">alert(colors);                     <span class="comment">// green,blue</span></span><br><span class="line">alert(removed);                    <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>);   <span class="comment">// 在位置1插入两个元素</span></span><br><span class="line">alert(colors);               <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line">alert(removed);              <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>);  <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line">alert(colors);               <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line">alert(removed);              <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-12-搜索和位置方法"><a href="#6-2-12-搜索和位置方法" class="headerlink" title="6.2.12　搜索和位置方法"></a>6.2.12　搜索和位置方法</h3><p>ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p>
<h4 id="6-2-12-1-严格相等"><a href="#6-2-12-1-严格相等" class="headerlink" title="6.2.12.1   严格相等"></a><strong>6.2.12.1   严格相等</strong></h4><p>ECMAScript提供了3个严格相等的搜索方法：<code>indexOf()</code>、<code>lastIndexOf()</code>和<code>includes()</code>。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。<code>indexOf()</code>和<code>includes()</code>方法从起始搜索位置（默认第一项）开始向后搜索，而<code>lastIndexOf()</code>从起始搜索位置（默认最后一项）开始向前搜索。</p>
<p><code>indexOf()</code>和<code>lastIndexOf()</code>都返回要查找的元素在数组中的位置，如果没找到则返回-1。<code>includes()</code>返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（<code>===</code>）比较，也就是必须严格相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>));          <span class="comment">// 3</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>));      <span class="comment">// 5</span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>));         <span class="comment">// true</span></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>));       <span class="comment">// 5</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>));   <span class="comment">// 3</span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>, <span class="number">7</span>));      <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> morePeople = [person];</span><br><span class="line">alert(people.indexOf(person));      <span class="comment">// -1</span></span><br><span class="line">alert(morePeople.indexOf(person));  <span class="comment">// 0</span></span><br><span class="line">alert(people.includes(person));     <span class="comment">// false</span></span><br><span class="line">alert(morePeople.includes(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="6-2-12-2-断言函数"><a href="#6-2-12-2-断言函数" class="headerlink" title="6.2.12.2   断言函数"></a><strong>6.2.12.2   断言函数</strong></h4><p>ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p>
<p>断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p>
<p><code>find()</code>和<code>findIndex()</code>方法使用了断言函数。这两个方法都从数组的最小索引开始。<code>find()</code>返回第一个匹配的元素，<code>findIndex()</code>返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部<code>this</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">alert(people.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br><span class="line">alert(people.findIndex(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>找到匹配项后，这两个方法都不再继续搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 找到第一个匹配项后，不会继续搜索</span></span><br><span class="line">evens.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element);</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">  <span class="built_in">console</span>.log(array);</span><br><span class="line">  <span class="keyword">return</span> element === <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-13-迭代方法"><a href="#6-2-13-迭代方法" class="headerlink" title="6.2.13　迭代方法"></a>6.2.13　迭代方法</h3><p>ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中<code>this</code>的值）。传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。这些方法都不改变调用它们的数组。</p>
<ul>
<li><code>every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回<code>true</code>，则这个方法返回<code>true</code>。</li>
<li><code>filter()</code>：对数组每一项都运行传入的函数，函数返回<code>true</code>的项会组成数组之后返回。适合从数组中筛选满足给定条件的元素。</li>
<li><code>forEach()</code>：对数组每一项都运行传入的函数，没有返回值。相当于使用<code>for</code>循环遍历数组</li>
<li><code>map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。适合创建一个与原始数组元素一一对应的新数组。</li>
<li><code>some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回<code>true</code>，则这个方法返回<code>true</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(everyResult);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(someResult);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(filterResult);  <span class="comment">// 3,4,5,4,3</span></span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line">alert(mapResult);  <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-2-14-归并方法"><a href="#6-2-14-归并方法" class="headerlink" title="6.2.14　归并方法"></a>6.2.14　归并方法</h3></li>
</ul>
<p>ECMAScript为数组提供了两个归并方法：<code>reduce()</code>和<code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。<code>reduce()</code>方法从数组第一项开始遍历到最后一项。而<code>reduceRight()</code>从最后一项开始遍历至第一项。</p>
<p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给<code>reduce()</code>和<code>reduceRight()</code>的函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
<p>可以使用<code>reduce()</code>函数执行累加数组中所有数值的操作，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line">alert(sum);  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p><code>reduceRight()</code>方法与之类似，只是方向相反。</p>
<h2 id="6-3-定型数组"><a href="#6-3-定型数组" class="headerlink" title="6.3　定型数组"></a>6.3　定型数组</h2><p>定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。</p>
<h3 id="6-3-1-历史"><a href="#6-3-1-历史" class="headerlink" title="6.3.1　历史"></a>6.3.1　历史</h3><p>早在2006年，浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套JavaScript API，从而充分利用3D图形API和GPU加速，以便在<code>&lt;canvas&gt;</code>元素上渲染复杂的图形。</p>
<h4 id="6-3-1-1-WebGL"><a href="#6-3-1-1-WebGL" class="headerlink" title="6.3.1.1   WebGL"></a><strong>6.3.1.1   WebGL</strong></h4><p>最后的JavaScript API是基于OpenGL ES（OpenGL for Embedded Systems）2.0规范的。OpenGL ES是OpenGL专注于2D和3D计算机图形的子集。这个新API被命名为WebGL（Web Graphics Library），有了它，开发者就能够编写涉及复杂图形的应用程序，它会被兼容WebGL的浏览器原生解释执行。</p>
<p>在WebGL的早期版本中，JavaScript数组与原生数组之间不匹配，出现了性能问题。因为图形驱动程序API通常不需要以JavaScript默认双精度浮点格式传递给它们的数值，而这恰恰是JavaScript数组在内存中的格式。因此，每次WebGL与JavaScript运行时之间传递数组时，WebGL绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，这要花费很多时间。</p>
<h4 id="6-3-1-1-定型数组"><a href="#6-3-1-1-定型数组" class="headerlink" title="6.3.1.1   定型数组"></a><strong>6.3.1.1   定型数组</strong></h4><p>Mozilla为解决这个问题而实现了<code>CanvasFloatArray</code>。这是一个提供JavaScript接口的、C语言风格的浮点值数组。JavaScript运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序API，也可以直接从底层获取到。最终，<code>CanvasFloatArray</code>变成了<code>Float32Array</code>，也是定型数组中可用的第一个“类型”。</p>
<h3 id="6-3-2-ArrayBuffer"><a href="#6-3-2-ArrayBuffer" class="headerlink" title="6.3.2 ArrayBuffer"></a>6.3.2 ArrayBuffer</h3><p><code>ArrayBuffer</code>对象代表储存二进制数据的一段内存，它不能直接读写，只能通过<code>DataView</code>视图和定型数组来读写，视图的作用是以指定格式解读<code>ArrayBuffer</code>存储的二进制数据。</p>
<p><code>ArrayBuffer</code>是所有定型数组及视图引用的基本单位。</p>
<blockquote>
<p><strong>注意</strong><code>SharedArrayBuffer</code>是<code>ArrayBuffer</code>的一个变体，可以无须复制就在执行上下文间传递它。</p>
</blockquote>
<p><code>ArrayBuffer()</code>是一个普通的JavaScript构造函数，可用于在内存中分配特定数量的字节空间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);  <span class="comment">// 在内存中分配16字节</span></span><br><span class="line">alert(buf.byteLength);            <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p><code>ArrayBuffer</code>一经创建就不能再调整大小。不过可以使用<code>slice()</code>复制其全部或部分到一个新实例中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.slice(<span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line">alert(buf2.byteLength);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p><code>ArrayBuffer</code>某种程度上类似于C++的<code>malloc()</code>，但也有几个明显的区别。</p>
<ul>
<li><code>malloc()</code>在分配失败时会返回一个<code>null</code>指针。<code>ArrayBuffer</code>在分配失败时会抛出错误。</li>
<li><code>malloc()</code>可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。<code>ArrayBuffer</code>分配的内存不能超过<code>Number.MAX_SAFE_INTEGER</code>（<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/28/gr45RjvVdkUATbH.gif"
                      alt="gif _1_.gif"
                >)）字节。</li>
<li><code>malloc()</code>调用成功不会初始化实际的地址。声明<code>ArrayBuffer</code>则会将所有二进制位初始化为0。</li>
<li>通过<code>malloc()</code>分配的堆内存除非调用<code>free()</code>或程序退出，否则系统不能再使用。而通过声明<code>ArrayBuffer</code>分配的堆内存可以被当成垃圾回收，不用手动释放。<h3 id="6-3-3-DataView"><a href="#6-3-3-DataView" class="headerlink" title="6.3.3 DataView"></a>6.3.3 DataView</h3></li>
</ul>
<p><code>DataView</code>视图专为文件I/O和网络I/O设计，其API支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。<code>DataView</code>对缓冲内容没有任何预设，也不能迭代。</p>
<p>必须在对已有的<code>ArrayBuffer</code>读取或写入时才能创建<code>DataView</code>实例。这个实例可以使用全部或部分<code>ArrayBuffer</code>，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// DataView默认使用整个ArrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">alert(fullDataView.byteOffset);      <span class="comment">// 0</span></span><br><span class="line">alert(fullDataView.byteLength);      <span class="comment">// 16</span></span><br><span class="line">alert(fullDataView.buffer === buf);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">//   byteOffset=0表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">//   byteLength=8限制视图为前8个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">alert(firstHalfDataView.byteOffset);      <span class="comment">// 0</span></span><br><span class="line">alert(firstHalfDataView.byteLength);      <span class="comment">// 8</span></span><br><span class="line">alert(firstHalfDataView.buffer === b  uf);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 如果不指定，则DataView会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">//   byteOffset=8表示视图从缓冲的第9个字节开始</span></span><br><span class="line"><span class="comment">//   byteLength未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">8</span>);</span><br><span class="line">alert(secondHalfDataView.byteOffset);      <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.byteLength);      <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.buffer === buf);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>要通过<code>DataView</code>读取缓冲，还需要几个组件。<br>• 首先是要读或写的字节偏移量。可以看成<code>DataView</code>中的某种“地址”。</p>
<p>•<code>DataView</code>应该使用<code>ElementType</code>来实现JavaScript的<code>Number</code>类型到缓冲内二进制格式的转换。</p>
<p>• 最后是内存中值的字节序默认为大端字节序。</p>
<h4 id="6-3-3-1-ElementType"><a href="#6-3-3-1-ElementType" class="headerlink" title="6.3.3.1 ElementType"></a>6.3.3.1 ElementType</h4><p><code>DataView</code>对存储在缓冲内的数据类型没有预设。它暴露的API强制开发者在读、写时指定一个<code>ElementType</code>，然后<code>DataView</code>为读、写而完成相应的转换。</p>
<p>ECMAScript 6支持8种不同的<code>ElementType</code>。</p>
<table>
<thead>
<tr>
<th>ElementType</th>
<th>字节</th>
<th>说明</th>
<th>等价的C类型</th>
<th>值的范围</th>
</tr>
</thead>
<tbody><tr>
<td>Int8</td>
<td>1</td>
<td>8位有符号整数</td>
<td>signed char</td>
<td>-128~127</td>
</tr>
<tr>
<td>Uint8</td>
<td>1</td>
<td>8位无符号整数</td>
<td>unsigned char</td>
<td>0~255</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
<td>16位有符号整数</td>
<td>short</td>
<td>-32 768~32 767</td>
</tr>
<tr>
<td>Uint16</td>
<td>2</td>
<td>16位无符号整数</td>
<td>unsigned short</td>
<td>0~65 535</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
<td>32位有符号整数</td>
<td>int</td>
<td>-2 147 483 648~2 147 483 647</td>
</tr>
<tr>
<td>Uint32</td>
<td>4</td>
<td>32位无符号整数</td>
<td>unsigned int</td>
<td>0~4 294 967 295</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
<td>32位IEEE-754浮点数</td>
<td>float</td>
<td>-3.4e+38~+3.4e+38</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
<td>64位IEEE-754浮点数</td>
<td>double</td>
<td>-1.7e+308~+1.7e+308</td>
</tr>
</tbody></table>
<p><code>DataView</code>为上表中的每种类型都暴露了<code>get</code>和<code>set</code>方法，这些方法使用<code>byteOffset</code>定位要读取或写入值的位置。不同类型之间是可以互换使用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个DataView</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 说明整个缓冲确实所有二进制位都是0</span></span><br><span class="line"><span class="comment">// 读取缓冲第一个和第二个字节</span></span><br><span class="line">alert(view.getInt8(<span class="number">0</span>));  <span class="comment">// 0</span></span><br><span class="line">alert(view.getInt8(<span class="number">1</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 读取整个缓冲</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为1</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">255</span>);  <span class="comment">// 255的二进制表示是11111111（2^8 - 1）</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0xFF</span>); <span class="comment">// DataView会自动将数据转换为特定的ElementType，255的十六进制表示是0xFF</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-2-字节序"><a href="#6-3-3-2-字节序" class="headerlink" title="6.3.3.2   字节序"></a><strong>6.3.3.2   字节序</strong></h4><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。<code>DataView</code>只支持两种约定：大端字节序（也称为网络字节序）和小端字节序。大端字节序是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反。</p>
<p>JavaScript运行时所在系统的原生字节序决定了如何读取或写入字节，但对一段内存而言，<code>DataView</code>是一个中立接口，它会遵循指定的字节序。<code>DataView</code>的所有API方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为<code>true</code>即可启用小端字节序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个DataView</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是1</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于1</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于1</span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001</span></span><br><span class="line"><span class="comment">// 按大端字节序读取Uint16，0x80是高字节，0x01是低字节</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>)); <span class="comment">// 0x8001 = 2^15 + 2^0 = 32769</span></span><br><span class="line"><span class="comment">// 按小端字节序读取Uint16，0x01是高字节，0x80是低字节</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 0x0180 = 2^8 + 2^7 = 384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按大端字节序写入Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0004</span>);</span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>);<span class="comment">// 按小端字节序写入Uint16</span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 2</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-3-边界情形"><a href="#6-3-3-3-边界情形" class="headerlink" title="6.3.3.3   边界情形"></a><strong>6.3.3.3   边界情形</strong></h4><p><code>DataView</code>完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出<code>RangeError</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.setInt32(<span class="number">4</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p><code>DataView</code>在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0。如果无法转换，则抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">1.5</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line">view.setInt8(<span class="number">0</span>, [<span class="number">4</span>]);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 4</span></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="built_in">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-4-定型数组"><a href="#6-3-4-定型数组" class="headerlink" title="6.3.4　定型数组"></a>6.3.4　定型数组</h3><p>定型数组是另一种形式的<code>ArrayBuffer</code>视图。虽然概念上与<code>DataView</code>接近，但区别在于，它特定于一种<code>ElementType</code>且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API和更高的性能。设计定型数组的目的就是提高与WebGL等原生库交换二进制数据的效率。</p>
<p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过<code>&lt;ElementType&gt;.from()</code>和<code>&lt;ElementType&gt;.of()</code>也可以创建定型数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个12字节的缓冲</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="comment">// 创建一个引用该缓冲的Int32Array</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buf);</span><br><span class="line">alert(ints.length); <span class="comment">// 这个定型数组知道自己的每个元素需要4字节，因此长度为3</span></span><br><span class="line"><span class="comment">// 创建一个长度为6的Int32Array</span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 每个数值使用4字节，因此ArrayBuffer是24字节</span></span><br><span class="line">alert(ints2.length);             <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 类似DataView，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line">alert(ints2.buffer.byteLength);  <span class="comment">// 24</span></span><br><span class="line"><span class="comment">// 创建一个包含[2, 4, 6, 8]的Int32Array</span></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line">alert(ints3.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints3.buffer.byteLength); <span class="comment">// 16</span></span><br><span class="line">alert(ints3[<span class="number">2</span>]);                <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 通过复制ints3的值创建一个Int16Array</span></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(ints3);</span><br><span class="line"><span class="comment">// 这个新类型数组会分配自己的缓冲</span></span><br><span class="line"><span class="comment">// 对应索引的每个值会相应地转换为新格式</span></span><br><span class="line">alert(ints4.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints4.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints4[<span class="number">2</span>]);                <span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 基于普通数组来创建一个Int16Array</span></span><br><span class="line"><span class="keyword">const</span> ints5 = <span class="built_in">Int16Array</span>.from([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]);</span><br><span class="line">alert(ints5.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints5.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints5[<span class="number">2</span>]);                <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 基于传入的参数创建一个Float32Array</span></span><br><span class="line"><span class="keyword">const</span> floats = <span class="built_in">Float32Array</span>.of(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>);</span><br><span class="line">alert(floats.length);            <span class="comment">// 3</span></span><br><span class="line">alert(floats.buffer.byteLength); <span class="comment">// 12</span></span><br><span class="line">alert(floats[<span class="number">2</span>]);                <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure>
<p>定型数组的构造函数和实例都有一个<code>BYTES_PER_ELEMENT</code>属性，返回该类型数组中每个元素的大小：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT);  <span class="comment">// 2</span></span><br><span class="line">alert(<span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT);  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">1</span>),</span><br><span class="line">      floats = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">1</span>);</span><br><span class="line">alert(ints.BYTES_PER_ELEMENT);        <span class="comment">// 4</span></span><br><span class="line">alert(floats.BYTES_PER_ELEMENT);      <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>如果定型数组没有用任何值初始化，则其关联的缓冲会以0填充：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">4</span>);</span><br><span class="line">alert(ints[<span class="number">0</span>]);  <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">1</span>]);  <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">2</span>]);  <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">3</span>]);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-1-定型数组行为"><a href="#6-3-4-1-定型数组行为" class="headerlink" title="6.3.4.1   定型数组行为"></a><strong>6.3.4.1   定型数组行为</strong></h4><p>从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：</p>
<ol>
<li><code>[]</code></li>
<li><code>copyWithin()</code></li>
<li><code>entries()</code></li>
<li><code>every()</code></li>
<li><code>fill()</code></li>
<li><code>filter()</code></li>
<li><code>find()</code></li>
<li><code>findIndex()</code></li>
<li><code>forEach()</code></li>
<li><code>indexOf()</code></li>
<li><code>join()</code></li>
<li><code>keys()</code></li>
<li><code>lastIndexOf()</code></li>
<li><code>length</code></li>
<li><code>map()</code></li>
<li><code>reduce()</code></li>
<li><code>reduceRight()</code></li>
<li><code>reverse()</code></li>
<li><code>slice()</code></li>
<li><code>some()</code></li>
<li><code>sort()</code></li>
<li><code>toLocaleString()</code></li>
<li><code>toString()</code></li>
<li><code>values()</code></li>
</ol>
<p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> doubleints = ints.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span>*x);</span><br><span class="line">alert(doubleints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>定型数组有一个<code>Symbol.iterator</code>符号属性，因此可以通过<code>for..of</code>循环和扩展操作符来操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> int <span class="keyword">of</span> ints) &#123;</span><br><span class="line">  alert(int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">alert(<span class="built_in">Math</span>.max(...ints)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-2-合并、复制和修改定型数组"><a href="#6-3-4-2-合并、复制和修改定型数组" class="headerlink" title="6.3.4.2   合并、复制和修改定型数组"></a><strong>6.3.4.2   合并、复制和修改定型数组</strong></h4><p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p>
<ol>
<li><code>concat()</code></li>
<li><code>pop()</code></li>
<li><code>push()</code></li>
<li><code>shift()</code></li>
<li><code>splice()</code></li>
<li><code>unshift()</code></li>
</ol>
<p>不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：<code>set()</code>和<code>subarray()</code>。</p>
<p><code>set()</code>从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建长度为8的int16数组</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 把定型数组复制为前4个值</span></span><br><span class="line"><span class="comment">// 偏移量默认为索引0</span></span><br><span class="line">container.set(<span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(container);  <span class="comment">// [1,2,3,4,0,0,0,0]</span></span><br><span class="line"><span class="comment">// 把普通数组复制为后4个值</span></span><br><span class="line"><span class="comment">// 偏移量4表示从索引4开始插入</span></span><br><span class="line">container.set([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(container);  <span class="comment">// [1,2,3,4,5,6,7,8]</span></span><br><span class="line"><span class="comment">// 溢出会抛出错误</span></span><br><span class="line">container.set([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">7</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p><code>subarray()</code>执行与<code>set()</code>相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">Int16Array</span>.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 把整个数组复制为一个同类型的新数组</span></span><br><span class="line"><span class="keyword">const</span> fullCopy = source.subarray();</span><br><span class="line"><span class="built_in">console</span>.log(fullCopy);  <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 从索引2开始复制数组</span></span><br><span class="line"><span class="keyword">const</span> halfCopy = source.subarray(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(halfCopy);  <span class="comment">// [6, 8]</span></span><br><span class="line"><span class="comment">// 从索引1开始复制到索引3</span></span><br><span class="line"><span class="keyword">const</span> partialCopy = source.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(partialCopy);  <span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure>
<p>定型数组没有原生的拼接能力，但使用定型数组API提供的很多工具可以手动构建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是应该返回的数组类型</span></span><br><span class="line"><span class="comment">// 其余参数是应该拼接在一起的定型数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typedArrayConcat</span>(<span class="params">typedArrayConstructor, ...typedArrays</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计算所有数组中包含的元素总数</span></span><br><span class="line">  <span class="keyword">const</span> numElements = typedArrays.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> (x.length || x) + y.length);</span><br><span class="line">  <span class="comment">// 按照提供的类型创建一个数组，为所有元素留出空间</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> typedArrayConstructor(numElements);</span><br><span class="line">  <span class="comment">// 依次转移数组</span></span><br><span class="line">  <span class="keyword">let</span> currentOffset = <span class="number">0</span>;</span><br><span class="line">  typedArrays.map(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    resultArray.set(x, currentOffset);</span><br><span class="line">    currentOffset += x.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> concatArray = typedArrayConcat(<span class="built_in">Int32Array</span>,</span><br><span class="line">                                     <span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                                     <span class="built_in">Int16Array</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">                                     <span class="built_in">Float32Array</span>.of(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line"><span class="built_in">console</span>.log(concatArray);  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(concatArray <span class="keyword">instanceof</span> <span class="built_in">Int32Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-3-下溢和上溢"><a href="#6-3-4-3-下溢和上溢" class="headerlink" title="6.3.4.3*下溢和上溢**"></a>6.3.4.3*<em>下溢和上溢**</em></h4><p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为2的有符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个二补数形式的有符号整数</span></span><br><span class="line"><span class="comment">// 范围是-128（-1 * 2^7）~127（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 长度为2的无符号整数数组</span></span><br><span class="line"><span class="comment">// 每个索引保存一个无符号整数</span></span><br><span class="line"><span class="comment">// 范围是0~255（2^7 - 1）</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引</span></span><br><span class="line"><span class="comment">// 索引只取最低有效位上的8位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>;      <span class="comment">// 0x100</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 0]</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>;      <span class="comment">// 0x1FF</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 255]</span></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line"><span class="comment">// 0xFF是以二补数形式表示的-1（截取到8位）,</span></span><br><span class="line"><span class="comment">// 但255是一个无符号整数</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = -<span class="number">1</span>        <span class="comment">// 0xFF (truncated to 8 bits)</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 255]</span></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80是无符号整数的128，是二补数形式的-128</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>;        <span class="comment">// 0x80</span></span><br><span class="line"><span class="built_in">console</span>.log(ints);    <span class="comment">// [0, -128]</span></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF是无符号整数的255，是二补数形式的-1</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>;        <span class="comment">// 0xFF</span></span><br><span class="line"><span class="built_in">console</span>.log(ints);    <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure>
<p>除了8种元素类型，还有一种“夹板”数组类型：<code>Uint8ClampedArray</code>，不允许任何方向溢出。超出最大值255的值会被向下舍入为255，而小于最小值0的值会被向上舍入为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clampedInts = <span class="keyword">new</span> <span class="built_in">Uint8ClampedArray</span>([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">256</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(clampedInts); <span class="comment">// [0, 0, 255, 255]</span></span><br></pre></td></tr></table></figure>
<p><code>Uint8ClampedArray</code>完全是HTML5<code>canvas</code>元素的历史留存，除非真的做跟<code>canvas</code>相关的开发，否则不要使用它。</p>
<h2 id="6-4Map"><a href="#6-4Map" class="headerlink" title="6.4Map"></a>6.4<code>Map</code></h2><p><code>Map</code>是一种新的集合类型，<code>Map</code>的大多数特性都可以通过<code>Object</code>类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，值得细细甄别。</p>
<h3 id="6-4-1-基本API"><a href="#6-4-1-基本API" class="headerlink" title="6.4.1　基本API"></a>6.4.1　基本API</h3><p>使用<code>new</code>关键字和<code>Map</code>构造函数可以创建一个空映射：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>
<p>如果想在创建的同时初始化实例，可以给<code>Map</code>构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(m1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(m2.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[]]);</span><br><span class="line">alert(m3.has(<span class="literal">undefined</span>));  <span class="comment">// true</span></span><br><span class="line">alert(m3.get(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>初始化之后，可以使用<code>set()</code>方法再添加键/值对。另外，可以使用<code>get()</code>和<code>has()</code>进行查询，可以通过<code>size</code>属性获取映射中的键/值对的数量，还可以使用<code>delete()</code>和<code>clear()</code>删除值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>));  <span class="comment">// undefined</span></span><br><span class="line">alert(m.size);              <span class="comment">// 0</span></span><br><span class="line">m.set(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>)</span><br><span class="line"> .set(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt</span></span><br><span class="line">alert(m.size);             <span class="comment">// 2</span></span><br><span class="line">m.delete(<span class="string">&quot;firstName&quot;</span>);     <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.size);             <span class="comment">// 1</span></span><br><span class="line">m.clear(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">alert(m.size);             <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>set()</code>方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">m.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>)</span><br><span class="line"> .set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">alert(m.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>与<code>Object</code>只能使用数值、字符串或符号作为键不同，<code>Map</code>可以使用任何JavaScript数据类型作为键。映射的值与<code>Object</code>类似，是没有限制的。<code>Map</code>内部使用SameValueZero比较操作（ECMAScript规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">m.set(functionKey, <span class="string">&quot;functionValue&quot;</span>);</span><br><span class="line">m.set(symbolKey, <span class="string">&quot;symbolValue&quot;</span>);</span><br><span class="line">m.set(objectKey, <span class="string">&quot;objectValue&quot;</span>);</span><br><span class="line">alert(m.get(functionKey));  <span class="comment">// functionValue</span></span><br><span class="line">alert(m.get(symbolKey));    <span class="comment">// symbolValue</span></span><br><span class="line">alert(m.get(objectKey));    <span class="comment">// objectValue</span></span><br><span class="line"><span class="comment">// SameValueZero比较意味着独立实例不冲突</span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;,</span><br><span class="line">      objVal = &#123;&#125;,</span><br><span class="line">      arrKey = [],</span><br><span class="line">      arrVal = [];</span><br><span class="line">m.set(objKey, objVal);</span><br><span class="line">m.set(arrKey, arrVal);</span><br><span class="line">objKey.foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arrKey.push(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure>
<p>SameValueZero比较也可能导致意想不到的冲突：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN</span></span><br><span class="line">      b = <span class="number">0</span>/<span class="string">&quot;&quot;</span>, <span class="comment">// NaN</span></span><br><span class="line">      pz = +<span class="number">0</span>,</span><br><span class="line">      nz = -<span class="number">0</span>;</span><br><span class="line">alert(a === b);   <span class="comment">// false</span></span><br><span class="line">alert(pz === nz); <span class="comment">// true</span></span><br><span class="line">m.set(a, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">m.set(pz, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">alert(m.get(b));  <span class="comment">// foo</span></span><br><span class="line">alert(m.get(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>SameValueZero是ECMAScript规范新增的相等性比较算法。关于ECMAScript的相等性比较，可以参考MDN文档中的文章“Equality Comparisons and Sameness”。</p>
</blockquote>
<h3 id="6-4-2-顺序与迭代"><a href="#6-4-2-顺序与迭代" class="headerlink" title="6.4.2　顺序与迭代"></a>6.4.2　顺序与迭代</h3><p>与<code>Object</code>类型的一个主要差异是，<code>Map</code>实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。</p>
<p>映射实例可以提供一个迭代器（<code>Iterator</code>），能以插入顺序生成<code>[key, value]</code>形式的数组。可以通过<code>entries()</code>方法（或者<code>Symbol.iterator</code>属性，它引用<code>entries()</code>）取得这个迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m[<span class="built_in">Symbol</span>.iterator]()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br></pre></td></tr></table></figure>
<p>因为<code>entries()</code>是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure>
<p>如果不使用迭代器，而是使用回调方式，则可以调用映射的<code>forEach(callback, opt_thisArg)</code>方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">m.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// key1 -&gt; val1</span></span><br><span class="line"><span class="comment">// key2 -&gt; val2</span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure>
<p><code>keys()</code>和<code>values()</code>分别返回以插入顺序生成键和值的迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1</span></span><br><span class="line"><span class="comment">// key2</span></span><br><span class="line"><span class="comment">// key3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure>
<p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.keys()) &#123;</span><br><span class="line">  key = <span class="string">&quot;newKey&quot;</span>;</span><br><span class="line">  alert(key);             <span class="comment">// newKey</span></span><br><span class="line">  alert(m1.get(<span class="string">&quot;key1&quot;</span>));  <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [keyObj, <span class="string">&quot;val1&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  key.id = <span class="string">&quot;newKey&quot;</span>;</span><br><span class="line">  alert(key);            <span class="comment">// &#123;id: &quot;newKey&quot;&#125;</span></span><br><span class="line">  alert(m.get(keyObj));  <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line">alert(keyObj);           <span class="comment">// &#123;id: &quot;newKey&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-3-选择Object还是Map"><a href="#6-4-3-选择Object还是Map" class="headerlink" title="6.4.3　选择Object还是Map"></a>6.4.3　选择<code>Object</code>还是<code>Map</code></h3><ol>
<li><strong>内存占用</strong></li>
</ol>
<p>存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现,但给定固定大小的内存，<code>Map</code>大约可以比<code>Object</code>多存储50%的键/值对。</p>
<ol start="2">
<li><strong>插入性能</strong></li>
</ol>
<p>向<code>Object</code>和<code>Map</code>中插入新键/值对的消耗大致相当，不过插入<code>Map</code>在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然<code>Map</code>的性能更佳。</p>
<ol start="3">
<li><strong>查找速度</strong></li>
</ol>
<p>从大型<code>Object</code>和<code>Map</code>中查找键/值对的性能差异极小，但如果只包含少量键/值对，则<code>Object</code>有时候速度更快。在把<code>Object</code>当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对<code>Map</code>来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择<code>Object</code>更好一些。</p>
<ol start="4">
<li><strong>删除性能</strong></li>
</ol>
<p>使用<code>delete</code>删除<code>Object</code>属性的性能一直以来饱受诟病，为此，出现了一些伪删除对象属性的操作，包括把属性值设置为<code>undefined</code>或<code>null</code>。如果代码涉及大量删除操作，那么毫无疑问应该选择<code>Map</code>。</p>
<h2 id="6-5WeakMap"><a href="#6-5WeakMap" class="headerlink" title="6.5WeakMap"></a>6.5<code>WeakMap</code></h2><p>ECMAScript 6新增的“弱映射”（<code>WeakMap</code>）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。<code>WeakMap</code>是<code>Map</code>的“兄弟”类型，其API也是<code>Map</code>的子集。<code>WeakMap</code>中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱映射”中键的弱引用。</p>
<h3 id="6-5-1-基本API"><a href="#6-5-1-基本API" class="headerlink" title="6.5.1　基本API"></a>6.5.1　基本API</h3><p>可以使用<code>new</code>关键字实例化一个空的<code>WeakMap</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure>
<p>弱映射中的键只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置键会抛出<code>TypeError</code>。值的类型没有限制。<br>如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 使用嵌套数组初始化弱映射</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [key2, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [key3, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(wm.get(key1)); <span class="comment">// val1</span></span><br><span class="line">alert(wm.get(key2)); <span class="comment">// val2</span></span><br><span class="line">alert(wm.get(key3)); <span class="comment">// val3</span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [key3, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as WeakMap key</span></span><br><span class="line"><span class="keyword">typeof</span> wm2;</span><br><span class="line"><span class="comment">// ReferenceError: wm2 is not defined</span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作键</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  stringKey, <span class="string">&quot;val1&quot;</span></span><br><span class="line">]);</span><br><span class="line">alert(wm3.get(stringKey)); <span class="comment">// &quot;val1&quot;</span></span><br></pre></td></tr></table></figure>
<p>初始化之后同样可以使用<code>set()</code>再添加键/值对，可以使用<code>get()</code>和<code>has()</code>查询，还可以使用<code>delete()</code>删除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;;</span><br><span class="line">alert(wm.has(key1)); <span class="comment">// false</span></span><br><span class="line">alert(wm.get(key1)); <span class="comment">// undefined</span></span><br><span class="line">wm.set(key1, <span class="string">&quot;Matt&quot;</span>)</span><br><span class="line">  .set(key2, <span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(wm.has(key1)); <span class="comment">// true</span></span><br><span class="line">alert(wm.get(key1)); <span class="comment">// Matt</span></span><br><span class="line">wm.delete(key1);     <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(wm.has(key1)); <span class="comment">// false</span></span><br><span class="line">alert(wm.has(key2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>set()</code>方法也返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>().set(key1, <span class="string">&quot;val1&quot;</span>);</span><br><span class="line">wm.set(key2, <span class="string">&quot;val2&quot;</span>)</span><br><span class="line">  .set(key3, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">alert(wm.get(key1)); <span class="comment">// val1</span></span><br><span class="line">alert(wm.get(key2)); <span class="comment">// val2</span></span><br><span class="line">alert(wm.get(key3)); <span class="comment">// val3</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-2-弱键"><a href="#6-5-2-弱键" class="headerlink" title="6.5.2　弱键"></a>6.5.2　弱键</h3><p><code>WeakMap</code>中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但弱映射中值的引用可<strong>不是</strong>“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(&#123;&#125;, <span class="string">&quot;val&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>set()</code>方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一个空映射。这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。<br>再看一个稍微不同的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> container = &#123;</span><br><span class="line">  key: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">wm.set(container.key, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.key = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>container</code>对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。但如果调用了<code>removeReference()</code>，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键/值对清理掉，这也是使用<code>WeakMap</code>的目的。因为当没有任何指向这个对象的引用的时候，就只有<code>WeakMap</code>对键对象的弱引用，而弱引用不会阻止垃圾回收。</p>
<h3 id="6-5-3-不可迭代键"><a href="#6-5-3-不可迭代键" class="headerlink" title="6.5.3　不可迭代键"></a>6.5.3　不可迭代键</h3><p>因为<code>WeakMap</code>中的键/值对任何时候都可能被销毁，所以没有提供迭代其键/值对的能力，同时也没有像<code>clear()</code>这样一次性销毁所有键/值的方法。因为不能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取得值。即便代码可以访问<code>WeakMap</code>实例，也没办法看到其中的内容，因为有可能已经被回收了。</p>
<p>如果<code>WeakMap</code>实例允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。</p>
<p>因为原始值是按值传递，这样的话实例中的键与变量<code>key</code>就失去联系了，即便变量<code>key</code>的内存被回收了，实例中的键也还存在，重新创建一个和之前字符串相等的变量就可以获得键值对的信息，所以<code>WeakMap</code>实例只用对象作为键，保证只有通过键对象的引用才能取得值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;abc&#x27;</span> </span><br><span class="line">wm.set(key, <span class="number">100</span>) </span><br></pre></td></tr></table></figure>
<h3 id="6-5-4-使用弱映射"><a href="#6-5-4-使用弱映射" class="headerlink" title="6.5.4　使用弱映射"></a>6.5.4　使用弱映射</h3><h4 id="6-5-4-1-私有变量"><a href="#6-5-4-1-私有变量" class="headerlink" title="*6.5.4.1   私有变量**"></a>*<em>6.5.4.1   私有变量**</em></h4><p>弱映射造就了在JavaScript中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。</p>
<p>下面是一个示例实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.setId(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setPrivate</span>(<span class="params">property, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> privateMembers = wm.get(<span class="built_in">this</span>) || &#123;&#125;;</span><br><span class="line">    privateMembers[property] = value;</span><br><span class="line">    wm.set(<span class="built_in">this</span>, privateMembers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getPrivate</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="built_in">this</span>)[property];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setPrivate(<span class="built_in">this</span>.idProperty, id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getId</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getPrivate(<span class="built_in">this</span>.idProperty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// 并不是真正私有的</span></span><br><span class="line">alert(wm.get(user)[user.idProperty]); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>
<p>于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，可以用一个闭包把<code>WeakMap</code>包装起来，这样就可以把弱映射与外界完全隔离开了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">      <span class="built_in">this</span>.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setPrivate</span>(<span class="params">property, value</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> privateMembers = wm.get(<span class="built_in">this</span>) || &#123;&#125;;</span><br><span class="line">      privateMembers[property] = value;</span><br><span class="line">      wm.set(<span class="built_in">this</span>, privateMembers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getPrivate</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> wm.get(<span class="built_in">this</span>)[property];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setPrivate(<span class="built_in">this</span>.idProperty, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getPrivate(<span class="built_in">this</span>.idProperty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>
<p>这样拿不到弱映射中的健，也就无法取得弱映射中对应的值。虽然这防止了前面提到的访问，但整个代码也完全陷入了ES6之前的闭包私有变量模式。</p>
<h4 id="6-5-4-2-DOM节点元数据"><a href="#6-5-4-2-DOM节点元数据" class="headerlink" title="6.5.4.2   DOM节点元数据"></a><strong>6.5.4.2   DOM节点元数据</strong></h4><p>因为<code>WeakMap</code>实例不会妨碍垃圾回收，所以非常适合保存关联元数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.set(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>假设代码执行后，页面被JavaScript改变了，原来的登录按钮从DOM树中被删掉了，那么当节点从DOM树中被删除后，垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）。<br>但如果使用映射，由于映射中还保存着按钮的引用，所以对应的DOM节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。</p>
<h2 id="6-6Set"><a href="#6-6Set" class="headerlink" title="6.6Set"></a>6.6<code>Set</code></h2><p>ECMAScript 6新增的<code>Set</code>是一种新集合类型。<code>Set</code>在很多方面都像是加强的<code>Map</code>，这是因为它们的大多数API和行为都是共有的。</p>
<h3 id="6-6-1-基本API"><a href="#6-6-1-基本API" class="headerlink" title="6.6.1　基本API"></a>6.6.1　基本API</h3><p>使用<code>new</code>关键字和<code>Set</code>构造函数可以创建一个空集合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure>
<p>如果想在创建的同时初始化实例，则可以给<code>Set</code>构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">alert(s1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(s2.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>初始化之后，可以使用<code>add()</code>增加值，使用<code>has()</code>查询，通过<code>size</code>取得元素数量，以及使用<code>delete()</code>和<code>clear()</code>删除元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// false</span></span><br><span class="line">alert(s.size);           <span class="comment">// 0</span></span><br><span class="line">s.add(<span class="string">&quot;Matt&quot;</span>)</span><br><span class="line"> .add(<span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// true</span></span><br><span class="line">alert(s.size);           <span class="comment">// 2</span></span><br><span class="line">s.delete(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// false</span></span><br><span class="line">alert(s.has(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">alert(s.size);           <span class="comment">// 1</span></span><br><span class="line">s.clear(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// false</span></span><br><span class="line">alert(s.has(<span class="string">&quot;Frisbie&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(s.size);           <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><code>add()</code>返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&quot;val1&quot;</span>);</span><br><span class="line">s.add(<span class="string">&quot;val2&quot;</span>)</span><br><span class="line"> .add(<span class="string">&quot;val3&quot;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>与<code>Map</code>类似，<code>Set</code>可以包含任何JavaScript数据类型作为值。集合也使用SameValueZero操作（ECMAScript内部定义，无法在语言中使用），基本上相当于使用严格对象相等的标准来检查值的匹配性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">s.add(functionVal);</span><br><span class="line">s.add(symbolVal);</span><br><span class="line">s.add(objectVal);</span><br><span class="line">alert(s.has(functionVal));   <span class="comment">// true</span></span><br><span class="line">alert(s.has(symbolVal));     <span class="comment">// true</span></span><br><span class="line">alert(s.has(objectVal));     <span class="comment">// true</span></span><br><span class="line"><span class="comment">// SameValueZero检查意味着独立的实例不会冲突</span></span><br><span class="line">alert(s.has(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;,</span><br><span class="line">      arrVal = [];</span><br><span class="line">s.add(objVal);</span><br><span class="line">s.add(arrVal);</span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">alert(s.has(objVal)); <span class="comment">// true</span></span><br><span class="line">alert(s.has(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>add()</code>和<code>delete()</code>操作是幂等的。<code>delete()</code>返回一个布尔值，表示集合中是否存在要删除的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="6-6-2-顺序与迭代"><a href="#6-6-2-顺序与迭代" class="headerlink" title="6.6.2　顺序与迭代"></a>6.6.2　顺序与迭代</h3><p><code>Set</code>会维护值插入时的顺序，因此支持按顺序迭代。</p>
<p>集合实例可以提供一个迭代器（<code>Iterator</code>），能以插入顺序生成集合内容。可以通过<code>values()</code>方法及其别名方法<code>keys()</code>（或者<code>Symbol.iterator</code>属性，它引用<code>values()</code>）取得这个迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">alert(s.values === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line">alert(s.keys === s[<span class="built_in">Symbol</span>.iterator]);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br><span class="line"><span class="comment">// val3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s[<span class="built_in">Symbol</span>.iterator]()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br><span class="line"><span class="comment">// val3</span></span><br></pre></td></tr></table></figure>
<p>因为<code>values()</code>是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...s]); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>集合的<code>entries()</code>方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果不使用迭代器，而是使用回调方式，则可以调用集合的<code>forEach()</code>方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">s.forEach(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// val1 -&gt; val1</span></span><br><span class="line"><span class="comment">// val2 -&gt; val2</span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure>
<p>修改集合中值的属性不会影响其作为集合值的身份：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>]);</span><br><span class="line"><span class="comment">// 字符串原始值作为值不会被修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.values()) &#123;</span><br><span class="line">  value = <span class="string">&quot;newVal&quot;</span>;</span><br><span class="line">  alert(value);          <span class="comment">// newVal</span></span><br><span class="line">  alert(s1.has(<span class="string">&quot;val1&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> valObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([valObj]);</span><br><span class="line"><span class="comment">// 修改值对象的属性，但对象仍然存在于集合中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s2.values()) &#123;</span><br><span class="line">  value.id = <span class="string">&quot;newVal&quot;</span>;</span><br><span class="line">  alert(value);           <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br><span class="line">  alert(s2.has(valObj));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">alert(valObj);            <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-6-3-定义正式集合操作"><a href="#6-6-3-定义正式集合操作" class="headerlink" title="6.6.3　定义正式集合操作*"></a>6.6.3　定义正式集合操作*</h3><p>从各方面来看，<code>Set</code>跟<code>Map</code>都很相似，只是API稍有调整。唯一需要强调的就是集合的API对自身的简单操作。很多开发者都喜欢使用<code>Set</code>操作，但需要手动实现：通过子类化<code>Set</code>，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。</p>
<ul>
<li>某些<code>Set</code>操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</li>
<li><code>Set</code>保留插入顺序，所有方法返回的集合必须保证顺序。</li>
<li>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。</li>
<li>不要修改已有的集合实例。<code>union(a, b)</code>或<code>a.union(b)</code>应该返回包含结果的新集合实例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSet</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">...sets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.union(<span class="built_in">this</span>, ...sets)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">intersection</span>(<span class="params">...sets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.intersection(<span class="built_in">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">difference</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.difference(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">symmetricDifference</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.symmetricDifference(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">cartesianProduct</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.cartesianProduct(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">powerSet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.powerSet(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">union</span>(<span class="params">a, ...bSets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.add(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">intersection</span>(<span class="params">a, ...bSets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.has(aValue)) &#123;</span><br><span class="line">          intersectionSet.delete(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">difference</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.has(bValue)) &#123;</span><br><span class="line">        differenceSet.delete(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">symmetricDifference</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">    <span class="keyword">return</span> a.union(b).difference(a.intersection(b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line">  <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">cartesianProduct</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> XSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.add([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">powerSet</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> XSet().add(<span class="keyword">new</span> XSet());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> set <span class="keyword">of</span> <span class="keyword">new</span> XSet(powerSet)) &#123;</span><br><span class="line">        powerSet.add(<span class="keyword">new</span> XSet(set).add(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-7WeakSet"><a href="#6-7WeakSet" class="headerlink" title="6.7WeakSet"></a>6.7<code>WeakSet</code></h2></li>
</ul>
<p>ECMAScript 6新增的“弱集合”（<code>WeakSet</code>）是一种新的集合类型，为这门语言带来了集合数据结构。<code>WeakSet</code>是<code>Set</code>的“兄弟”类型，其API也是<code>Set</code>的子集。<code>WeakSet</code>中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱集合”中值的弱引用。</p>
<h3 id="6-7-1-基本API"><a href="#6-7-1-基本API" class="headerlink" title="6.7.1　基本API"></a>6.7.1　基本API</h3><p>可以使用<code>new</code>关键字实例化一个空的<code>WeakSet</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure>
<p>弱集合中的值只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置值会抛出<code>TypeError</code>。<br>如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 使用数组初始化弱集合</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, val2, val3]);</span><br><span class="line">alert(ws1.has(val1)); <span class="comment">// true</span></span><br><span class="line">alert(ws1.has(val2)); <span class="comment">// true</span></span><br><span class="line">alert(ws1.has(val3)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">&quot;BADVAL&quot;</span>, val3]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet</span></span><br><span class="line"><span class="keyword">typeof</span> ws2;</span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined</span></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作值</span></span><br><span class="line"><span class="keyword">const</span> stringVal = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;val1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ws3 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([stringVal]);</span><br><span class="line">alert(ws3.has(stringVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>初始化之后可以使用<code>add()</code>再添加新值，可以使用<code>has()</code>查询，还可以使用<code>delete()</code>删除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;;</span><br><span class="line">alert(ws.has(val1)); <span class="comment">// false</span></span><br><span class="line">ws.add(val1)</span><br><span class="line">  .add(val2);</span><br><span class="line">alert(ws.has(val1)); <span class="comment">// true</span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br><span class="line">ws.delete(val1);     <span class="comment">// 只删除这一个值</span></span><br><span class="line">alert(ws.has(val1)); <span class="comment">// false</span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>add()</code>方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>().add(val1);</span><br><span class="line">ws.add(val2)</span><br><span class="line">  .add(val3);</span><br><span class="line">alert(ws.has(val1)); <span class="comment">// true</span></span><br><span class="line">alert(ws.has(val2)); <span class="comment">// true</span></span><br><span class="line">alert(ws.has(val3)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="6-7-2-弱值"><a href="#6-7-2-弱值" class="headerlink" title="6.7.2　弱值"></a>6.7.2　弱值</h3><p>类似于<code>WeakMap</code>。</p>
<h3 id="6-7-3-不可迭代值"><a href="#6-7-3-不可迭代值" class="headerlink" title="6.7.3　不可迭代值"></a>6.7.3　不可迭代值</h3><p>类似于<code>WeakMap</code>。</p>
<h3 id="6-7-4-使用弱集合"><a href="#6-7-4-使用弱集合" class="headerlink" title="6.7.4　使用弱集合"></a>6.7.4　使用弱集合</h3><p>相比于<code>WeakMap</code>实例，<code>WeakSet</code>实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.add(loginButton);</span><br></pre></td></tr></table></figure>
<p>这样，通过查询元素在不在<code>disabledElements</code>中，就可以知道它是不是被禁用了。不过，假如元素从DOM树中被删除了，它的引用却仍然保存在<code>Set</code>中，因此垃圾回收程序也不能回收它。<br>为了让垃圾回收程序回收元素的内存，可以在这里使用<code>WeakSet</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.add(loginButton);</span><br></pre></td></tr></table></figure>
<p>这样，只要<code>WeakSet</code>中任何元素从DOM树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。</p>
<h2 id="6-8-迭代与扩展操作"><a href="#6-8-迭代与扩展操作" class="headerlink" title="6.8　迭代与扩展操作"></a>6.8　迭代与扩展操作</h2><p>ECMAScript 6新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。</p>
<p>有4种原生集合类型定义了默认迭代器：</p>
<ul>
<li><code>Array</code></li>
<li>所有定型数组</li>
<li><code>Map</code></li>
<li><code>Set</code></li>
</ul>
<p>很简单，这意味着上述所有类型都支持顺序迭代，都可以传入<code>for-of</code>循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [</span><br><span class="line">  <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">  typedArr = <span class="built_in">Int16Array</span>.of(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// [5, 6]</span></span><br><span class="line"><span class="comment">// [7, 8]</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);          <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);          <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]);</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(map1);</span><br><span class="line"><span class="built_in">console</span>.log(map1); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map2); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>当然，也可以构建数组的部分元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">0</span>, ...arr1, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>浅复制意味着只会复制对象引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的这些类型都支持多种构建方法，比如<code>Array.of()</code>和<code>Array.from()</code>静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 把数组复制到定型数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="built_in">Int16Array</span>.of(...arr1);</span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="built_in">Int16Array</span>.from(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(typedArr1);   <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(typedArr2);   <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 把数组复制到映射</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, <span class="string">&#x27;val&#x27;</span> + x]));</span><br><span class="line"><span class="built_in">console</span>.log(map);   <span class="comment">// Map &#123;1 =&gt; &#x27;val 1&#x27;, 2 =&gt; &#x27;val 2&#x27;, 3 =&gt; &#x27;val 3&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 把数组复制到集合</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(typedArr2);</span><br><span class="line"><span class="built_in">console</span>.log(set);   <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 把集合复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-9-小结"><a href="#6-9-小结" class="headerlink" title="6.9　小结"></a>6.9　小结</h2><p>JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。</p>
<ul>
<li>引用类型与传统面向对象编程语言中的类相似，但实现不同。</li>
<li><code>Object</code>类型是一个基础类型，所有引用类型都从它继承了基本的行为。</li>
<li><code>Array</code>类型表示一组有序的值，并提供了操作和转换值的能力。</li>
<li>定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。</li>
<li><code>Date</code>类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。</li>
<li><code>RegExp</code>类型是ECMAScript支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。</li>
</ul>
<p>JavaScript比较独特的一点是，函数其实是<code>Function</code>类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。</p>
<p>因为原始值包装类型的存在，所以JavaScript中的原始值可以拥有类似对象的行为。有3种原始值包装类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。它们都具有如下特点。</p>
<ul>
<li>每种包装类型都映射到同名的原始类型。</li>
<li>在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。</li>
<li>涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。</li>
</ul>
<p>JavaScript还有两个在一开始执行代码时就存在的内置对象：<code>Global</code>和<code>Math</code>。其中，<code>Global</code>对象在大多数ECMAScript实现中无法直接访问。不过浏览器将<code>Global</code>实现为<code>window</code>对象。所有全局变量和函数都是<code>Global</code>对象的属性。<code>Math</code>对象包含辅助完成复杂数学计算的属性和方法。</p>
<p>ECMAScript 6新增了一批引用类型：<code>Map</code>、<code>WeakMap</code>、<code>Set</code>和<code>WeakSet</code>。这些类型为组织应用程序数据和简化内存管理提供了新能力。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：06-集合引用类型</li>
        <li>本文作者：胡倚豪</li>
        <li>创建时间：2021-03-28 18:46:33</li>
        <li>
            本文链接：huonenumber.github.io/2021/03/28/note/JavaScript/06-集合引用类型/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/03/28/note/JavaScript/07-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">07-迭代器与生成器</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/03/14/note/JavaScript/05-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">05-基本引用类型</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oRtabIpmHUsCjAVoocAuRiR6-gzGzoHsz',
                    appKey: '8MQB6tSReJAP6eYmI5OGVpTo',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请尽情吐槽吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '胡倚豪';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">胡倚豪</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Object"><span class="nav-text">6.1　Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Array"><span class="nav-text">6.2 Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-text">6.2.1　创建数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D"><span class="nav-text">6.2.2　数组空位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="nav-text">6.2.3　数组索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.2.4　检测数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.5　迭代器方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.6　复制和填充方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-7-%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.7　转换方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-8-%E6%A0%88%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.8　栈方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-9-%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.9　队列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-10-%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.10　排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-11-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.11　操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-12-%E6%90%9C%E7%B4%A2%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.12　搜索和位置方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-12-1-%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89"><span class="nav-text">6.2.12.1   严格相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-12-2-%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0"><span class="nav-text">6.2.12.2   断言函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-13-%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.13　迭代方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-14-%E5%BD%92%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="nav-text">6.2.14　归并方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.3　定型数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E5%8E%86%E5%8F%B2"><span class="nav-text">6.3.1　历史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-1-WebGL"><span class="nav-text">6.3.1.1   WebGL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-1-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.3.1.1   定型数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-ArrayBuffer"><span class="nav-text">6.3.2 ArrayBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-DataView"><span class="nav-text">6.3.3 DataView</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-1-ElementType"><span class="nav-text">6.3.3.1 ElementType</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-2-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-text">6.3.3.2   字节序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-3-%E8%BE%B9%E7%95%8C%E6%83%85%E5%BD%A2"><span class="nav-text">6.3.3.3   边界情形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.3.4　定型数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-1-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84%E8%A1%8C%E4%B8%BA"><span class="nav-text">6.3.4.1   定型数组行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-2-%E5%90%88%E5%B9%B6%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-text">6.3.4.2   合并、复制和修改定型数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-4-3-%E4%B8%8B%E6%BA%A2%E5%92%8C%E4%B8%8A%E6%BA%A2"><span class="nav-text">6.3.4.3*下溢和上溢**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4Map"><span class="nav-text">6.4Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.4.1　基本API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-text">6.4.2　顺序与迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E9%80%89%E6%8B%A9Object%E8%BF%98%E6%98%AFMap"><span class="nav-text">6.4.3　选择Object还是Map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5WeakMap"><span class="nav-text">6.5WeakMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.5.1　基本API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E5%BC%B1%E9%94%AE"><span class="nav-text">6.5.2　弱键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-%E4%B8%8D%E5%8F%AF%E8%BF%AD%E4%BB%A3%E9%94%AE"><span class="nav-text">6.5.3　不可迭代键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-%E4%BD%BF%E7%94%A8%E5%BC%B1%E6%98%A0%E5%B0%84"><span class="nav-text">6.5.4　使用弱映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-4-1-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="nav-text">*6.5.4.1   私有变量**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-4-2-DOM%E8%8A%82%E7%82%B9%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">6.5.4.2   DOM节点元数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6Set"><span class="nav-text">6.6Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.6.1　基本API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E9%A1%BA%E5%BA%8F%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-text">6.6.2　顺序与迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%BC%8F%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-text">6.6.3　定义正式集合操作*</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7WeakSet"><span class="nav-text">6.7WeakSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-%E5%9F%BA%E6%9C%ACAPI"><span class="nav-text">6.7.1　基本API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-%E5%BC%B1%E5%80%BC"><span class="nav-text">6.7.2　弱值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-3-%E4%B8%8D%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%80%BC"><span class="nav-text">6.7.3　不可迭代值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-4-%E4%BD%BF%E7%94%A8%E5%BC%B1%E9%9B%86%E5%90%88"><span class="nav-text">6.7.4　使用弱集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C"><span class="nav-text">6.8　迭代与扩展操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-9-%E5%B0%8F%E7%BB%93"><span class="nav-text">6.9　小结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
