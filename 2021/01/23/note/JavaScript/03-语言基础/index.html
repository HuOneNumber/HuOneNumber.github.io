<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="HTML,CSS,JavaScript">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="胡倚豪">
    
    <title>
        
            03-语言基础 |
        
        HuOneNumber | 个人博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#33FFCC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"description":"慢慢来，深几度。。。","background_img":"/images/bg.svg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="别着急，慢慢来" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                HuOneNumber | 个人博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">03-语言基础</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">胡倚豪</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-01-23 19:31:12
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/">JavaScript高级程序设计(第四版)</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">03-语言基础</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>19.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>80 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1　语法"></a>3.1　语法</h2><h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1　区分大小写"></a>3.1.1　区分大小写</h3><p>ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符。</p>
<h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2　标识符"></a>3.1.2　标识符</h3><p><strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p>
<ol>
<li>第一个字符必须是一个字母或下划线或$；</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。</p>
<p>ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>不能作为标识符。</p>
<h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3　注释"></a>3.1.3　注释</h3><p>包括单行注释和块注释。单行注释以两个斜杠字符开头，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>
<p>块注释以一个斜杠和一个星号（<code>/*</code>）开头，以它们的反向组合（<code>*/</code>）结尾，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是多行</span></span><br><span class="line"><span class="comment">注释 */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4　严格模式"></a>3.1.4　严格模式</h3><p>严格模式是一种不同的JavaScript解析和执行模型，要对整个脚本启用严格模式，在脚本开头加上：”use strict”;，它其实是一个预处理指令也可以单独指定一个函数在严格模式下执行，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5　语句"></a>3.1.5　语句</h3><p>ECMAScript中的语句以分号结尾。省略分号则由解析器确定语句在哪里结尾(不推荐)。</p>
<p>加分号有助于防止省略造成的问题，比如避免输入内容不完整，也便于开发者通过删除空行来压缩代码，也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。</p>
<p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号（<code>&#123;</code>）标识开始，一个右花括号（<code>&#125;</code>）标识结束.</p>
<p>if之类的控制语句只在执行多条语句时要求必须有代码块。最好始终在控制语句中使用代码块，即使要执行的只有一条语句。</p>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2　关键字与保留字"></a>3.2　关键字与保留字</h2><p>保留的关键字不能用作标识符或属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>       <span class="keyword">do</span>          <span class="keyword">in</span>            <span class="keyword">typeof</span></span><br><span class="line"><span class="keyword">case</span>        <span class="keyword">else</span>        <span class="keyword">instanceof</span>    <span class="keyword">var</span></span><br><span class="line"><span class="keyword">catch</span>       <span class="keyword">export</span>      <span class="keyword">new</span>           <span class="keyword">void</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>       <span class="keyword">extends</span>     <span class="title">return</span>        <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">const</span>       <span class="title">finally</span>     <span class="title">super</span>         <span class="title">with</span></span></span><br><span class="line"><span class="class"><span class="title">continue</span>    <span class="title">for</span>         <span class="title">switch</span>        <span class="title">yield</span></span></span><br><span class="line"><span class="class"><span class="title">debugger</span>    <span class="title">function</span>    <span class="title">this</span></span></span><br><span class="line"><span class="class"><span class="title">default</span>     <span class="title">if</span>          <span class="title">throw</span></span></span><br><span class="line"><span class="class"><span class="title">delete</span>      <span class="title">import</span>      <span class="title">try</span></span></span><br></pre></td></tr></table></figure>
<p><strong>未来的保留字</strong>，同样不能用作标识符或属性名。但现在还可以用作对象的属性名（不推荐）。它们是保留给将来做关键字用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//始终保留:</span></span><br><span class="line">enum</span><br><span class="line"><span class="comment">//严格模式下保留:</span></span><br><span class="line">implements  package     public</span><br><span class="line">interface   protected   <span class="keyword">static</span></span><br><span class="line"><span class="keyword">let</span>         private</span><br><span class="line"><span class="comment">//模块代码中保留:</span></span><br><span class="line"><span class="keyword">await</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3　变量"></a>3.3　变量</h2><p>ECMAScript变量是松散类型的，变量可以用于保存任何类型的数据。有3个关键字可以声明变量：<code>var</code>、<code>const</code>和<code>let</code>。</p>
<h3 id="3-3-1-var关键字"><a href="#3-3-1-var关键字" class="headerlink" title="3.3.1   var关键字"></a>3.3.1   <code>var</code>关键字</h3><p>要定义变量，可以使用<code>var</code>操作符，后跟变量名（即标识符）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">//不初始化的情况下，变量会保存一个特殊值`undefined`</span></span><br></pre></td></tr></table></figure>
<p>初始化变量不会将它标识为字符串类型，随后不仅可以改变保存的值，也可以改变值的类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">message = <span class="number">100</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-1-var声明作用域"><a href="#3-3-1-1-var声明作用域" class="headerlink" title="3.3.1.1   var声明作用域"></a>3.3.1.1   <code>var</code>声明作用域</h4><p><code>var</code>声明作用域关键的问题在于，使用<code>var</code>操作符定义的变量会成为包含它的函数的局部变量。使用<code>var</code>在一个函数内部定义一个变量，该变量将在函数退出时被销毁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<p>在函数内定义变量时省略<code>var</code>操作符，可以创建一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   message = <span class="string">&quot;hi&quot;</span>;     <span class="comment">// 全局变量,不推荐，严格模式会报错</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量及可选的初始化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">    found = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>在严格模式下，不能定义名为<code>eval</code>和<code>arguments</code>的变量，否则会导致语法错误。</p>
<h4 id="3-3-1-2-var声明提升"><a href="#3-3-1-2-var声明提升" class="headerlink" title="3.3.1.2   var声明提升"></a>3.3.1.2   <code>var</code>声明提升</h4><p>使用<code>var</code>时，声明的变量会自动提升到函数作用域顶部，反复多次使用<code>var</code>声明同一个变量也没有问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-let声明"><a href="#3-3-2-let声明" class="headerlink" title="3.3.2   let声明"></a>3.3.2   <code>let</code>声明</h3><p><code>var</code>声明的范围是函数作用域，而<code>let</code>声明的范围是块作用域，作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于<code>var</code>的作用域限制同样也适用于<code>let</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);   <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);   <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>不允许同一个块作用域中出现冗余声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;  <span class="comment">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，这是因为同一个块中没有重复声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);    <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混用<code>let</code>和<code>var</code>同样可能会到冗余声明。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-1-暂时性死区"><a href="#3-3-2-1-暂时性死区" class="headerlink" title="**3.3.2.1 **  暂时性死区"></a>**3.3.2.1 **  暂时性死区</h4><p><code>let</code>声明的变量不会在作用域中被提升。在<code>let</code>声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-2-全局声明"><a href="#3-3-2-2-全局声明" class="headerlink" title="3.3.2.2   全局声明"></a><strong>3.3.2.2</strong>   全局声明</h4><p>使用<code>let</code>在全局作用域中声明的变量不会成为<code>window</code>对象的属性（<code>var</code>声明的变量会）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但<code>let</code>声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为避免<code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p>
<h4 id="3-3-2-3-条件声明"><a href="#3-3-2-3-条件声明" class="headerlink" title="3.3.2.3   条件声明"></a>3.3.2.3   条件声明</h4><p>在使用<code>var</code>声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为<code>let</code>的作用域是块，所以不可能检查前面是否已经使用<code>let</code>声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> age = <span class="number">26</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量,那它可以假设还没有声明过,这里声明过，但可以合并为一个声明</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 不需要检查之前是否声明过同名变量，但这里之前声明过，会报错</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> age = <span class="number">36</span>; </span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>try</code>/<code>catch</code>语句或<code>typeof</code>操作符也不能解决，因为<code>let</code>声明的作用域仅限于该条件块。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="comment">// let name = &#x27;Nicholas&#x27;;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量，那它可以假设还没有声明过</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> name;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 因为name被限制在if &#123;&#125; 块的作用域内，因此下面这个赋值形同全局赋值</span></span></span><br><span class="line"><span class="javascript">  name = <span class="string">&#x27;Matt&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">//&#x27;Matt&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为此，对于<code>let</code>声明关键字，不能依赖条件声明模式，这是一种反模式，它让程序变得更难理解。</p>
<h4 id="3-3-2-4-for循环中的let声明"><a href="#3-3-2-4-for循环中的let声明" class="headerlink" title="3.3.2.4   for循环中的let声明"></a>3.3.2.4   <code>for</code>循环中的<code>let</code>声明</h4><p>在<code>let</code>出现之前，<code>for</code>循环定义的迭代变量会渗透到循环体外部：改成使用<code>let</code>之后，这个问题就消失了，因为迭代变量的作用域仅限于<code>for</code>循环块内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i没有定义</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>var</code>的时候，最常见的问题是对迭代变量的奇特声明和修改，而在使用<code>let</code>声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个<code>setTimeout</code>引用的都是不同的变量实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5、5、5、5、5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-3-const声明"><a href="#3-3-3-const声明" class="headerlink" title="3.3.3   const声明"></a>3.3.3   <code>const</code>声明</h3><p><code>const</code>的行为与<code>let</code>基本相同，区别是用它声明变量时必须同时初始化变量，且修改<code>const</code>声明的变量会导致运行时错误。</p>
<p><code>const</code>声明的限制只适用于它指向的变量的引用。如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>不能用<code>const</code>来声明迭代变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>const</code>声明一个不会被修改的<code>for</code>循环变量。这对<code>for-of</code>和<code>for-in</code>循环特别有意义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4　声明风格及最佳实践"></a>3.3.4　声明风格及最佳实践</h3><h4 id="3-3-4-1-不使用var"><a href="#3-3-4-1-不使用var" class="headerlink" title="3.3.4.1   不使用var"></a><strong>3.3.4.1   不使用</strong><code>var</code></h4><p>限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<h4 id="3-3-4-2const优先，let次之"><a href="#3-3-4-2const优先，let次之" class="headerlink" title="3.3.4.2const优先，let次之"></a>3.3.4.2<code>const</code>优先，<code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者发现因意外赋值导致的非预期行为。</p>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4　数据类型"></a>3.4　数据类型</h2><p>ECMAScript有6种简单数据类型，也称为<strong>原始类型</strong>：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。还有一种复杂数据类型叫<code>Object</code>（对象）。</p>
<h3 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1   typeof操作符"></a>3.4.1   <code>typeof</code>操作符</h3><p><code>typeof</code>操作符用来确定任意变量的数据类型。对一个值使用<code>typeof</code>操作符会返回下列字符串之一：</p>
<ul>
<li><code>&quot;undefined&quot;</code>表示值未定义；</li>
<li><code>&quot;boolean&quot;</code>表示值为布尔值；</li>
<li><code>&quot;string&quot;</code>表示值为字符串；</li>
<li><code>&quot;number&quot;</code>表示值为数值；</li>
<li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或<code>null</code>；</li>
<li><code>&quot;function&quot;</code>表示值为函数；</li>
<li><code>&quot;symbol&quot;</code>表示值为符号。</li>
</ul>
<p><code>typeof</code>是一个操作符而不是函数，所以不需要参数，但也可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);    <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message));   <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);         <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>);        <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);       <span class="comment">// &quot;object&quot;,因为特殊值`null`被认为是一个对空对象的引用</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是函数也有自己特殊的属性。为此通过<code>typeof</code>操作符来区分函数和其他对象。</p>
</blockquote>
<h3 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2   Undefined类型"></a>3.4.2   <code>Undefined</code>类型</h3><p><code>Undefined</code>类型只有一个值，就是特殊值<code>undefined</code>。当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值。</p>
<p>变量显式地以<code>undefined</code>来初始化是不必要的，<code>undefined</code>主要用于比较，目的是为了明确空对象指针<code>null</code>和未初始化变量的区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>包含<code>undefined</code>值的变量跟未定义变量是有区别的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;    <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>在对未初始化的变量和对未声明的变量调用<code>typeof</code>时，返回的结果都是<code>&quot;undefined&quot;</code>。对未声明的变量调用<code>delete</code>也不会报错，但这个操作没什么用，且在严格模式下会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>  建议在声明变量的同时进行初始化。当<code>typeof</code>返回<code>&quot;undefined&quot;</code>时，会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p>
</blockquote>
<p><code>undefined</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// age没有声明</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-3-Null类型"><a href="#3-4-3-Null类型" class="headerlink" title="3.4.3   Null类型"></a>3.4.3   <code>Null</code>类型</h3><p><code>Null</code>类型同样只有一个值，即特殊值<code>null</code>。逻辑上讲，<code>null</code>值表示一个空对象指针。</p>
<p>在定义将来要保存对象值的变量时，建议使用<code>null</code>来初始化。这样，只要检查这个变量的值是不是<code>null</code>就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p>
<p><code>undefined</code>值是由<code>null</code>值派生而来的，用等于操作符（<code>==</code>）会为了比较而转换它的操作数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>即使<code>null</code>和<code>undefined</code>有关系，但用途完全不一样的。只要变量要保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量。这样就可以保持<code>null</code>是空对象指针的语义，并进一步将其与<code>undefined</code>区分开来。</p>
<p><code>null</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p>
<h3 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4   Boolean类型"></a>3.4.4   <code>Boolean</code>类型</h3><p><code>Boolean</code>（布尔值）类型有两个字面值：<code>true</code>和<code>false</code>。这两个布尔值不同于数值，<code>true</code>不等于1，<code>false</code>不等于0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> == <span class="number">1</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> === <span class="number">1</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>布尔值字面量<code>true</code>和<code>false</code>是区分大小写的，因此<code>True</code>和<code>False</code>是有效的标识符，但不是布尔值。<br>虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。可以调用特定的<code>Boolean()</code>转型函数，将一个其他类型的值转换为布尔值，转换为<code>true</code>或<code>false</code>的规则取决于数据类型和实际的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">转换为true的值</th>
<th align="left">转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="left">true</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">非空字符串</td>
<td align="left">“”（空字符串）</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">非零数值（包括无穷值）</td>
<td align="left">0、NaN</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">任意对象</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">Undefined</td>
<td align="left">N/A（不存在）</td>
<td align="left">undefined</td>
</tr>
</tbody></table>
<p><code>if</code>等流控制语句会自动执行其他类型值到布尔值的转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Value is true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5   Number类型"></a>3.4.5   <code>Number</code>类型</h3><p><code>Number</code>类型使用IEEE 754格式表示整数和浮点值（也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，直接写出来即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>;  <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure>
<p>用八进制（以8为基数）字面量表示，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。<br>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。ECMAScript 2015或ES6中的八进制值通过前缀<code>0o</code>来表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>;  <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>;  <span class="comment">// 无效的八进制值，当成79处理</span></span><br></pre></td></tr></table></figure>
<p>整数也可以或十六进制（以16为基数）字面量表示。必须让真正的数值前缀<code>0x</code>（区分大小写），然后是十六进制数字（0<del>9以及A</del>F）。十六进制数字中的字母大小写均可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>;   <span class="comment">// 十六进制10</span></span><br></pre></td></tr></table></figure>
<p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<blockquote>
<p><strong>注意</strong>   由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。</p>
</blockquote>
<h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1   浮点值"></a>3.4.5.1   浮点值</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。推荐小数点前面加上整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">.1</span>;   <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">// 小数点后面没有数字，当成整数1处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">// 小数点后面是零，当成整数10处理</span></span><br></pre></td></tr></table></figure>
<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure>
<p>科学记数法也可以用于表示非常小的数值。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为3e-7）。</p>
<blockquote>
<p><strong>注意</strong>   浮点值的精确度最高可达17位小数，但在算术计算中不如整数精确。例如，0.1加0.2得到的不是0.3，之所以存在这种舍入错误，是因为使用了IEEE 754数值。</p>
</blockquote>
<h4 id="3-4-5-2-值的范围"><a href="#3-4-5-2-值的范围" class="headerlink" title="3.4.5.2   值的范围"></a>3.4.5.2   值的范围</h4><p>由于内存的限制，ECMAScript可以表示的最小数值保存在<code>Number.MIN_VALUE</code>中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。</p>
<p>如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为任何无法表示的负数以<code>-Infinity</code>（负无穷大），或者任何无法表示的正数以<code>Infinity</code>（正无穷大），而且该值不能再进一步用于任何计算。因为没有可用于计算的数值表示形式。</p>
<p>要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用<code>isFinite()</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 使用<code>Number.NEGATIVE_INFINITY</code>和<code>Number.POSITIVE_INFINITY</code>也可以获取正、负<code>Infinity</code>。这两个属性包含的值分别就是<code>-Infinity</code>和<code>Infinity</code>。</p>
<h4 id="3-4-5-3-NaN"><a href="#3-4-5-3-NaN" class="headerlink" title="3.4.5.3   NaN"></a>3.4.5.3   <code>NaN</code></h4></blockquote>
<p>有一个特殊的数值叫<code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了，而不是抛出错误。在ECMAScript中，0、+0或-0相除会返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span>/+<span class="number">0</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/-<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<p>任何涉及<code>NaN</code>的操作始终返回<code>NaN</code>（如<code>NaN/10</code>），在连续多步计算时这可能是个问题。其次，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript提供了<code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-5-4-数值转换"><a href="#3-4-5-4-数值转换" class="headerlink" title="3.4.5.4   数值转换"></a>3.4.5.4   数值转换</h4><p>有3个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。</p>
<p><code>Number()</code>函数基于如下规则执行转换。</p>
<ul>
<li>布尔值，<code>true</code>转换为1，<code>false</code>转换为0。</li>
<li>数值，直接返回。</li>
<li><code>null</code>，返回0。</li>
<li><code>undefined</code>，返回<code>NaN</code>。</li>
<li>字符串，应用以下规则。<ul>
<li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，<code>Number(&quot;-1&quot;)</code>返回-1，<code>Number(&quot;123&quot;)</code>返回123，<code>Number(&quot;011&quot;)</code>返回11（忽略前面的零）。</li>
<li>如果字符串包含有效的浮点值格式如<code>&quot;1.1&quot;</code>，则会转换为相应的浮点值（同样，忽略前面的零）。</li>
<li>如果字符串包含有效的十六进制格式如<code>&quot;0xf&quot;</code>，则会转换为与该十六进制值对应的十进制整数值。</li>
<li>如果是空字符串（不包含字符），则返回0。</li>
<li>如果字符串包含除上述情况之外的其他字符，则返回<code>NaN</code>。</li>
</ul>
</li>
<li>对象，调用<code>valueOf()</code>方法，并按照上述规则转换返回的值。如果转换结果是<code>NaN</code>，则调用<code>toString()</code>方法，再按照转换字符串的规则转换。</li>
</ul>
<blockquote>
<p><strong>注意</strong> 一元加操作符与<code>Number()</code>函数遵循相同的转换规则。</p>
</blockquote>
<p>通常在需要得到整数时可以优先使用<code>parseInt()</code>函数。<code>parseInt()</code>函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回<code>NaN</code>。空字符串也会返回<code>NaN</code>。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p>
<p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>);          <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 10，解释为十六进制整数</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);        <span class="comment">// 22 因为小数点不是有效的整数字符</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>);        <span class="comment">// 70，解释为十进制值</span></span><br></pre></td></tr></table></figure>
<p>不同的数值格式很容易混淆，因此<code>parseInt()</code>也接收第二个参数，用于指定底数（进制数）。事实上，如果提供了十六进制参数，那么字符串前面的<code>&quot;0x&quot;</code>可以省掉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);  <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>，议始终传给第二个参数，因为不传底数参数相当于让<code>parseInt()</code>自己决定如何解析。</p>
<p><code>parseFloat()</code>函数的工作方式跟<code>parseInt()</code>函数类似，都是从位置0开始检测每个字符。不同在于第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p>
<p><code>parseFloat()</code>函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为<code>parseFloat()</code>只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则<code>parseFloat()</code>返回整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234，按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>);      <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>);   <span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>);    <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>);   <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6   String类型"></a>3.4.6   <code>String</code>类型</h3><p><code>String</code>（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示。</p>
<p>ECMAScript语法中表示字符串的引号没有区别，但以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Nicholas&quot;; // 语法错误：开头和结尾的引号必须是同一种</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-1-字符字面量"><a href="#3-4-6-1-字符字面量" class="headerlink" title="3.4.6.1   字符字面量"></a><strong>3.4.6.1   字符字面量</strong></h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字面量</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
</tr>
<tr>
<td align="left">\|反斜杠（\）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">\&#39;</td>
<td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td>
</tr>
<tr>
<td align="left">\“</td>
<td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td>
</tr>
<tr>
<td align="left">\`</td>
<td align="left">反引号（\），在字符串以反引号标示时使用，例如\He said, \`hey.\\</td>
</tr>
<tr>
<td align="left">\xnn</td>
<td align="left">以十六进制编码<code>nn</code>表示的字符（其中<em>n</em>是十六进制数字0~F），例如<code>\x41</code>等于”A”</td>
</tr>
<tr>
<td align="left">\unnnn</td>
<td align="left">以十六进制编码<code>nnnn</code>表示的Unicode字符（其中<code>n</code>是十六进制数字0~F），例如<code>\u03a3</code>等于希腊字符”Σ”</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释,转义序列表示一个字符。字符串的长度可以通过其<code>length</code>属性获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is the letter sigma: \u03a3.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p>
<h4 id="3-4-6-2-字符串的特点"><a href="#3-4-6-2-字符串的特点" class="headerlink" title="3.4.6.2   字符串的特点"></a>3.4.6.2   <strong>字符串的特点</strong></h4></blockquote>
<p>ECMAScript中的字符串是不可变的（immutable），要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3   转换为字符串"></a><strong>3.4.6.3   转换为字符串</strong></h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的<code>toString()</code>方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString();      <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString();  <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toString()</code>方法可见于数值、布尔值、对象和字符串值。如果字符串值使用<code>toString()</code>方法，就只是返回自身的一个副本。<br>多数情况下，<code>toString()</code>不接收任何参数。但对数值调用这个方法时，可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，以十进制字符串表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());     <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));    <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));    <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));   <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法，所以不确定一个值是不是<code>null</code>或<code>undefined</code>，可以使用<code>String()</code>转型函数。<code>String()</code>函数遵循如下规则。</p>
<ul>
<li>如果值有<code>toString()</code>方法，则调用该方法（不传参数）并返回结果。</li>
<li>如果值是<code>null</code>，返回<code>&quot;null&quot;</code>。</li>
<li>如果值是<code>undefined</code>，返回<code>&quot;undefined&quot;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value1));  <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value2));  <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value3));  <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value4));  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 ** 用加号操作符给一个值加上一个空字符串<code>&quot;&quot;</code>也可以将其转换为字符串。</p>
</blockquote>
<h4 id="3-4-6-4-模板字面量"><a href="#3-4-6-4-模板字面量" class="headerlink" title="3.4.6.4   模板字面量"></a>3.4.6.4   模板字面量</h4><p>ES6新增使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString);</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineTemplateLiteral);</span><br><span class="line"><span class="comment">// 上面都一样</span></span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure>
<p>模板字面量在定义模板时特别有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br></pre></td></tr></table></figure>
<p>由于模板字面量会保持反引号内部的空格，因此看起来缩进不当的模板字符串，格式可能反而正确。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模板字面量在换行符之后有25个空格符</span></span><br><span class="line"><span class="keyword">let</span> myTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">                         second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myTemplateLiteral.length);  <span class="comment">// 47</span></span><br><span class="line"><span class="comment">// 这个模板字面量以一个换行符开头</span></span><br><span class="line"><span class="keyword">let</span> secondTemplateLiteral = <span class="string">`</span></span><br><span class="line"><span class="string">first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(secondTemplateLiteral[<span class="number">0</span>] === <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-5-字符串插值"><a href="#3-4-6-5-字符串插值" class="headerlink" title="3.4.6.5   字符串插值"></a><strong>3.4.6.5   字符串插值</strong></h4><p>模板字面量的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p>
<p>字符串插值通过在<code>$&#123;&#125;</code>中使用一个JavaScript表达式实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedString =</span><br><span class="line">  value + <span class="string">&#x27; to the &#x27;</span> + exponent + <span class="string">&#x27; power is &#x27;</span> + (value * value);</span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral =</span><br><span class="line">  <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>);      <span class="comment">// Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>模板也可以插入自己之前的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">append();  <span class="comment">// abc</span></span><br><span class="line">append();  <span class="comment">// abcabc</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-6-模板字面量标签函数"><a href="#3-4-6-6-模板字面量标签函数" class="headerlink" title="3.4.6.6   模板字面量标签函数"></a><strong>3.4.6.6   模板字面量标签函数</strong></h4><p>模板字面量支持定义<strong>标签函数</strong>（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p>
<p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。因为表达式参数的数量是可变的，所以通常使用剩余操作符将它们收集到一个数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(expression);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);  <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-7-原始字符串"><a href="#3-4-6-7-原始字符串" class="headerlink" title="3.4.6.7   原始字符串"></a><strong>3.4.6.7   原始字符串</strong></h4><p><code>String.raw</code>标签函数可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);            <span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);  <span class="comment">// \u00A9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但对实际的换行符来说是不行的，因为它们不会被转换成转义序列的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure>
<p>可以通过标签函数的第一个参数，即字符串数组的<code>.raw</code>属性也可取得每个字符串的原始内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Actual characters:&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(string);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Escaped characters;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.raw) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rawString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-7-Symbol类型"><a href="#3-4-7-Symbol类型" class="headerlink" title="3.4.7   Symbol类型"></a>3.4.7   <code>Symbol</code>类型</h3><p><code>Symbol</code>（符号）是ES6新增的数据类型。听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。</p>
<h4 id="3-4-7-1-符号的基本用法"><a href="#3-4-7-1-符号的基本用法" class="headerlink" title="3.4.7.1   符号的基本用法"></a><strong>3.4.7.1   符号的基本用法</strong></h4><p>符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型，所以<code>typeof</code>操作符对符号返回<code>symbol</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p>调用<code>Symbol()</code>函数时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。但是这个字符串参数与符号定义或标识完全无关：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol);          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>符号没有字面量语法。只要创建<code>Symbol()</code>实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol);  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol);      <span class="comment">// Symbol(foo);</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol()</code>函数不能用作构造函数，与<code>new</code>关键字一起使用，这样是为了避免创建符号包装对象，像使用<code>Boolean</code>、<code>String</code>或<code>Number</code>那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>如果确实想使用符号包装对象，可以借用<code>Object()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol);   <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-2-使用全局符号注册表"><a href="#3-4-7-2-使用全局符号注册表" class="headerlink" title="3.4.7.2   使用全局符号注册表"></a><strong>3.4.7.2   使用全局符号注册表</strong></h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用<code>Symbol.for()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，就生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);       <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);  <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用<code>Symbol()</code>定义的符号也不等同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给<code>Symbol.for()</code>的任何值都会被转换为字符串。注册表中使用的键同时也会被用作符号描述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(emptyGlobalSymbol);    <span class="comment">// Symbol(undefined)</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>Symbol.keyFor()</code>来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。如果传给<code>Symbol.keyFor()</code>的不是符号，则该方法抛出<code>TypeError</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s));   <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2));  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-3-使用符号作为属性"><a href="#3-4-7-3-使用符号作为属性" class="headerlink" title="3.4.7.3   使用符号作为属性"></a>3.4.7.3   使用符号作为属性</h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code>/<code>Object.definedProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);  <span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);  <span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line">  [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">  [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">//  Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。两个方法的返回值彼此互斥。<code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规和符号属性描述符的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">  qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));  <span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));  <span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(o));  <span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure>
<p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)]: <span class="string">&#x27;bar val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o);  <span class="comment">// &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(o)</span><br><span class="line">              .find(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.toString().match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="built_in">console</span>.log(barSymbol);  <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-4-常用内置符号"><a href="#3-4-7-4-常用内置符号" class="headerlink" title="3.4.7.4   常用内置符号"></a><strong>3.4.7.4   常用内置符号</strong></h4><p><strong>常用内置符号</strong>（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。它们以<code>Symbol</code>工厂函数字符串属性的形式存在。</p>
<p>内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变<code>for-of</code>在迭代该对象时的行为。</p>
<p>这些内置符号就是全局函数<code>Symbol</code>的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>
<blockquote>
<p>**注意 ** 在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为<code>@@</code>。比如，<code>@@iterator</code>指的就是<code>Symbol.iterator</code>。</p>
</blockquote>
<h4 id="3-4-7-5-Symbol-asyncIterator"><a href="#3-4-7-5-Symbol-asyncIterator" class="headerlink" title="3.4.7.5   Symbol.asyncIterator"></a><strong>3.4.7.5</strong>   <code>Symbol.asyncIterator</code></h4><p>这个符号作为一个属性表示：一个方法，该方法返回对象默认的<code>AsyncIterator</code>，由<code>for-await-of</code>语句使用。也就是表示实现异步迭代器API的函数。</p>
<p><code>for-await-of</code>循环会利用这个函数执行异步迭代操作。循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数会返回一个实现迭代器API的对象。大多数返回的对象是实现该API的<code>AsyncGenerator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.asyncIterator]()); <span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个由<code>Symbol.asyncIterator</code>函数生成的对象可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过异步生成器函数返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="built_in">this</span>.asyncIdx++));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount(); <span class="comment">//分别打印0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-6-Symbol-hasInstance"><a href="#3-4-7-6-Symbol-hasInstance" class="headerlink" title="3.4.7.6   Symbol.hasInstance"></a>3.4.7.6   <code>Symbol.hasInstance</code></h4><p>这个符号作为一个属性表示：一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用。<code>instanceof</code>操作符可以用来确定一个对象实例的原型链上是否有原型。以<code>Symbol.hasInstance</code>为键的函数会执行同样的操作，只是操作数对调了一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个属性定义在Function的原型上，因此默认在所有函数和类上都可以调用。由于<code>instanceof</code>操作符会在原型链上寻找这个属性定义，因此可以在继承的类上通过静态方法重新定义这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-7-Symbol-isConcatSpreadable"><a href="#3-4-7-7-Symbol-isConcatSpreadable" class="headerlink" title="3.4.7.7   Symbol.isConcatSpreadable"></a>3.4.7.7   <code>Symbol.isConcatSpreadable</code></h4><p>这个符号作为一个属性表示：一个布尔值，如果是<code>true</code>，则对象应该用<code>Array.prototype.concat()</code>打平其数组元素。ES6中的<code>Array.prototype.concat()</code>方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。</p>
<p>数组对象默认情况下会被打平到已有的数组，<code>false</code>或假值会导致整个对象被追加到数组末尾。相反，类数组对象默认情况下会被追加到数组末尾，<code>true</code>或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在<code>Symbol.isConcatSpreadable</code>被设置为<code>true</code>的情况下将被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line">arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-8-Symbol-iterator"><a href="#3-4-7-8-Symbol-iterator" class="headerlink" title="3.4.7.8   Symbol.iterator"></a>3.4.7.8   <code>Symbol.iterator</code></h4><p>这个符号作为一个属性表示：一个方法，该方法返回对象默认的迭代器。由<code>for-of</code>语句使用。换句话说，这个符号表示实现迭代器API的函数。</p>
<p><code>for-of</code>循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以<code>Symbol.iterator</code>为键的函数，并默认这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>Generator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个由<code>Symbol.iterator</code>函数生成的对象可以通过其<code>next()</code>方法陆续返回值，也可以隐式地通过生成器函数返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.idx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">count(); <span class="comment">//分别打印0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-9-Symbol-match"><a href="#3-4-7-9-Symbol-match" class="headerlink" title="3.4.7.9   Symbol.match"></a>3.4.7.9   <code>Symbol.match</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用。<code>String.prototype.match()</code>方法会使用以<code>Symbol.match</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]);  <span class="comment">// f [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，则可以重新定义<code>Symbol.match</code>函数以取代默认对正则表达式求值的行为，从而让<code>match()</code>方法使用非正则表达式实例。<code>Symbol.match</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMatcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-10-Symbol-replace"><a href="#3-4-7-10-Symbol-replace" class="headerlink" title="3.4.7.10   Symbol.replace"></a>3.4.7.10   <code>Symbol.replace</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>方法使用。<code>String.prototype.replace()</code>方法会使用以<code>Symbol.replace</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]);<span class="comment">//f [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.replace(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，可以重新定义<code>Symbol.replace</code>函数以取代默认对正则表达式求值的行为，从而让<code>replace()</code>方法使用非正则表达式实例。<code>Symbol.replace</code>函数接收两个参数，即调用<code>replace()</code>方法的字符串实例和替换字符串。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooReplacer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(FooReplacer, <span class="string">&#x27;qux&#x27;</span>));  <span class="comment">// &quot;barquxbaz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReplacer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(<span class="keyword">new</span> StringReplacer(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>));  <span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-11-Symbol-search"><a href="#3-4-7-11-Symbol-search" class="headerlink" title="3.4.7.11   Symbol.search"></a>3.4.7.11   <code>Symbol.search</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用。<code>String.prototype.search()</code>方法会使用以<code>Symbol.search</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]); <span class="comment">// f [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="regexp">/bar/</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，可以重新定义<code>Symbol.search</code>函数以取代默认对正则表达式求值的行为，从而让<code>search()</code>方法使用非正则表达式实例。<code>Symbol.search</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSearcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-12-Symbol-species"><a href="#3-4-7-12-Symbol-species" class="headerlink" title="3.4.7.12   Symbol.species"></a>3.4.7.12   <code>Symbol.species</code></h4><p>这个符号作为一个属性表示：一个函数值，该函数作为创建派生对象的构造函数。这个属性在内置类型中最常用，用<code>Symbol.species</code>定义静态的获取器（getter）方法，当使用 <code>concat()</code> 这样的方法会返回默认的构造函数时，可以覆盖新创建实例的原型定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// true</span></span><br><span class="line">baz = baz.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-13-Symbol-split"><a href="#3-4-7-13-Symbol-split" class="headerlink" title="3.4.7.13   Symbol.split"></a>3.4.7.13   <code>Symbol.split</code></h4><p>这个符号作为一个属性表示：一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用。<code>String.prototype.split()</code>方法会使用以<code>Symbol.split</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]);  <span class="comment">// f [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.split(<span class="regexp">/bar/</span>));  <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，可以重新定义<code>Symbol.split</code>函数以取代默认对正则表达式求值的行为，从而让<code>split()</code>方法使用非正则表达式实例。<code>Symbol.split</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSplitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(<span class="keyword">new</span> StringSplitter(<span class="string">&#x27;foo&#x27;</span>)));  <span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-14-Symbol-toPrimitive"><a href="#3-4-7-14-Symbol-toPrimitive" class="headerlink" title="3.4.7.14   Symbol.toPrimitive"></a>3.4.7.14   <code>Symbol.toPrimitive</code></h4><p>这个符号作为一个属性表示：一个方法，该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的<code>Symbol.toPrimitive</code>属性上定义一个函数可以改变默认行为。</p>
<p>根据提供给这个函数的参数（<code>string</code>、<code>number</code>或<code>default</code>），可以控制返回的原始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));   <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo);       <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo);       <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + bar);     <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - bar);     <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-15-Symbol-toStringTag"><a href="#3-4-7-15-Symbol-toStringTag" class="headerlink" title="3.4.7.15   Symbol.toStringTag"></a>3.4.7.15   <code>Symbol.toStringTag</code></h4><p>这个符号作为一个属性表示：一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用。</p>
<p>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，自定义类实例可以自定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s.toString());           <span class="comment">// [object Set]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Set</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.toString());           <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar.toString());           <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-16-Symbol-unscopables"><a href="#3-4-7-16-Symbol-unscopables" class="headerlink" title="3.4.7.16   Symbol.unscopables"></a>3.4.7.16   <code>Symbol.unscopables</code></h4><p>这个符号作为一个属性表示：一个对象，该对象所有的以及继承的属性，都会从关联对象的<code>with</code>环境绑定中排除。设置这个符号并让其映射对应属性的键值为<code>true</code>，就可以阻止该属性出现在<code>with</code>环境绑定中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">  foo: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong> 不推荐使用<code>with</code>，因此也不推荐使用<code>Symbol.unscopables</code>。</p>
</blockquote>
<h3 id="3-4-8-Object类型"><a href="#3-4-8-Object类型" class="headerlink" title="3.4.8   Object类型"></a>3.4.8   <code>Object</code>类型</h3><p>对象就是一组数据和功能的集合。对象通过<code>new</code>操作符后跟对象类型的名称来创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">// 如果没有参数可以省略括号，合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>每个<code>Object</code>实例都有如下属性和方法。</p>
<ul>
<li><code>constructor</code>：用于创建当前对象的函数。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li>
<li><code>isPrototypeof(object)</code>：用于判断当前对象是否为另一个对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用<code>for-in</code>语句枚举。与<code>hasOwnProperty()</code>一样，属性名必须是字符串。</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li>
</ul>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5　操作符"></a>3.5　操作符</h2><p>ECMAScript中的操作符可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code>valueOf()</code>和<code>/</code>或<code>toString()</code>方法来取得可以计算的值。</p>
<h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1　一元操作符"></a>3.5.1　一元操作符</h3><p>只操作一个值的操作符叫<strong>一元操作符</strong>（unary operator）。</p>
<h4 id="3-5-1-1-递增-递减操作符"><a href="#3-5-1-1-递增-递减操作符" class="headerlink" title="3.5.1.1   递增/递减操作符"></a><strong>3.5.1.1   递增/递减操作符</strong></h4><p>递增和递减操作符有两个版本：</p>
<ul>
<li>前缀版就是位于要操作的变量前头</li>
<li>后缀版就是位于要操作的变量后头。</li>
</ul>
<p>前缀递增操作符会给数值加1，把两个加号（<code>++</code>）放到变量前头即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">++age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br><span class="line"><span class="comment">// 前缀递减操作符也类似 --age</span></span><br></pre></td></tr></table></figure>
<p>使用前缀版，变量的值都会在语句被求值之前改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);         <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>这4个操作符可以作用于任何值，递增和递减操作符遵循如下规则。</p>
<ul>
<li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。如果不是有效的数值形式，则将变量的值设置为<code>NaN</code>。变量类型从字符串变成数值。</li>
<li>对于布尔值，如果是<code>false</code>，则转换为0再应用改变。如果是<code>true</code>，则转换为1再应用改变。变量类型从布尔值变成数值。</li>
<li>对于浮点值，加1或减1。</li>
<li>如果是对象，则调用其<code>valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code>NaN</code>，则调用<code>toString()</code>并再次应用其他规则。变量类型从对象变成数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++;  <span class="comment">// 数值3</span></span><br><span class="line">s2++;  <span class="comment">// NaN</span></span><br><span class="line">b++;   <span class="comment">// 数值1</span></span><br><span class="line">f--;   <span class="comment">// 0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--;   <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-1-2-一元加和减"><a href="#3-5-1-2-一元加和减" class="headerlink" title="3.5.1.2   一元加和减"></a><strong>3.5.1.2   一元加和减</strong></h4><p>一元加放在变量前头，对数值没有任何影响。一元减则把数值变成负值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// -25</span></span><br></pre></td></tr></table></figure>
<p>如果将一元加应用到非数值，则相当于使用<code>Number()</code>转型函数。一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;  <span class="comment">// 值变成数值1</span></span><br><span class="line">s2 = +s2;  <span class="comment">// 值变成数值1.1</span></span><br><span class="line">s3 = +s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = +b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = +f;    <span class="comment">// 不变，还是1.1</span></span><br><span class="line">o = +o;    <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2　位操作符"></a>3.5.2　位操作符</h3><p>ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。但这个转换也导致了，特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0处理。</p>
<p>如果将位操作符应用到非数值，那么首先会自动使用<code>Number()</code>函数将该值转换为数值，然后再应用位操作。最终结果是数值。在处理有符号整数时，无法访问第31位。</p>
<p>在把负值输出为一个二进制字符串时，会得到一个前面加了减号的绝对值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = -<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;-10010&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **默认情况下，ECMAScript中的所有整数都表示为有符号数。但确实存在无符号整数。无符号整数的第32位不表示符号，因为只有正值。</p>
</blockquote>
<h4 id="3-5-2-1-按位非"><a href="#3-5-2-1-按位非" class="headerlink" title="3.5.2.1   按位非"></a>3.5.2.1   按位非</h4><p>按位非操作符用波浪符（<code>~</code>）表示，它的作用是返回数值的补数，最终效果是对数值取反并减1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;      <span class="comment">// 二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1;   <span class="comment">// 二进制11111111111111111111111111100110</span></span><br><span class="line"><span class="built_in">console</span>.log(num2);  <span class="comment">// -26</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-2-按位与"><a href="#3-5-2-2-按位与" class="headerlink" title="3.5.2.2   按位与"></a><strong>3.5.2.2   按位与</strong></h4><p>按位与操作符用和号（<code>&amp;</code>）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p>
<p>|第一个数值的位|第二个数值的位|结果|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|1|1|1|<br>|1|0|0|<br>|0|1|0|<br>|0|0|0|</p>
<p>如果对25和3执行按位与，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-3-按位或"><a href="#3-5-2-3-按位或" class="headerlink" title="3.5.2.3   按位或"></a><strong>3.5.2.3   按位或</strong></h4><p>按位或操作符用管道符（<code>|</code>）表示，同样有两个操作数。按位或遵循如下真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数值的位</th>
<th align="left">第二个数值的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>如果对25和3执行按位或，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27 </span></span><br><span class="line"></span><br><span class="line"><span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"> OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>
<p>在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。</p>
<h4 id="3-5-2-4-按位异或"><a href="#3-5-2-4-按位异或" class="headerlink" title="3.5.2.4   按位异或"></a><strong>3.5.2.4   按位异或</strong></h4><p>按位异或用脱字符（<code>^</code>）表示，同样有两个操作数。下面是按位异或的真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数的位</th>
<th align="left">第二个数的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>对数值25和3执行按位异或操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> ^ <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 26</span></span><br><span class="line"></span><br><span class="line"><span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">XOR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-5-左移"><a href="#3-5-2-5-左移" class="headerlink" title="3.5.2.5   左移"></a><strong>3.5.2.5   左移</strong></h4><p>左移操作符用两个小于号（<code>&lt;&lt;</code>）表示，会按照指定的位数将数值的所有位向左移动。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;              <span class="comment">// 等于二进制10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;  <span class="comment">// 等于二进制1000000，即十进制64</span></span><br></pre></td></tr></table></figure>
<p>注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值（见图3-2）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/Wo1bzsOAa2BZFYH.png"
                      alt="b7qdJi277GnnBKhO__thumbnail.png"
                ></p>
<p>左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。</p>
<h4 id="3-5-2-6-有符号右移"><a href="#3-5-2-6-有符号右移" class="headerlink" title="3.5.2.6   有符号右移"></a><strong>3.5.2.6   有符号右移</strong></h4><p>有符号右移由两个大于号（<code>&gt;&gt;</code>）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;             <span class="comment">// 等于二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;  <span class="comment">// 等于二进制10，即十进制2</span></span><br></pre></td></tr></table></figure>
<p>同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图3-3）。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zdWytfUcQuvbgSJ.png"
                      alt="lfyDtLTtly9xPjgW__thumbnail.png"
                ></p>
<h4 id="3-5-2-7-无符号右移"><a href="#3-5-2-7-无符号右移" class="headerlink" title="3.5.2.7   无符号右移"></a><strong>3.5.2.7   无符号右移</strong></h4><p>无符号右移用3个大于号表示（<code>&gt;&gt;&gt;</code>），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。</p>
<p>对于负数，有时候差异会非常大。右移会给空位补0，而不管符号位是什么。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = -<span class="number">64</span>;              <span class="comment">// 等于二进制11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;   <span class="comment">// 等于十进制134217726</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3　布尔操作符"></a>3.5.3　布尔操作符</h3><p>布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。</p>
<h4 id="3-5-3-1-逻辑非"><a href="#3-5-3-1-逻辑非" class="headerlink" title="3.5.3.1   逻辑非"></a><strong>3.5.3.1   逻辑非</strong></h4><p>逻辑非操作符由一个叹号（<code>!</code>）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。逻辑非操作符会遵循如下规则。</p>
<ul>
<li>如果操作数是对象，则返回<code>false</code>。</li>
<li>如果操作数是空字符串，则返回<code>true</code>。</li>
<li>如果操作数是非空字符串，则返回<code>false</code>。</li>
<li>如果操作数是数值0，则返回<code>true</code>。</li>
<li>如果操作数是非0数值（包括<code>Infinity</code>），则返回<code>false</code>。</li>
<li>如果操作数是<code>null</code>，则返回<code>true</code>。</li>
<li>如果操作数是<code>NaN</code>，则返回<code>true</code>。</li>
<li>如果操作数是<code>undefined</code>，则返回<code>true</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;blue&quot;</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;&quot;</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">12345</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>同时使用两个叹号（<code>!!</code>），相当于调用转型函数<code>Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。</p>
<h4 id="3-5-3-2-逻辑与"><a href="#3-5-3-2-逻辑与" class="headerlink" title="3.5.3.2   逻辑与"></a><strong>3.5.3.2   逻辑与</strong></h4><p>逻辑与操作符由两个和号（<code>&amp;&amp;</code>）表示，应用到两个值。逻辑与操作符是一种短路操作符，如果第一个操作数是假值，返回第一个操作数，如果第一个操作数是真值，返回第二个操作数。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; <span class="string">&#x27;foo&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-3-逻辑或"><a href="#3-5-3-3-逻辑或" class="headerlink" title="3.5.3.3   逻辑或"></a><strong>3.5.3.3   逻辑或</strong></h4><p>逻辑或操作符由两个管道符（<code>||</code>）表示。同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数是真值，第二个操作数就不会再被求值了，第一个是假值，则返回第二个操作数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable); <span class="comment">// 不会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure>
<p>利用这个行为，可以避免给变量赋值<code>null</code>或<code>undefined</code>。这种模式在ECMAScript代码中经常用于变量赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = preferredObject || backupObject;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4　乘性操作符"></a>3.5.4　乘性操作符</h3><p>ECMAScript定义了3个乘性操作符：乘法、除法和取模。在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用<code>Number()</code>转型函数转换为数值。这意味着空字符串会被当成0，而布尔值<code>true</code>会被当成1。</p>
<h4 id="3-5-4-1-乘法操作符"><a href="#3-5-4-1-乘法操作符" class="headerlink" title="3.5.4.1   乘法操作符"></a><strong>3.5.4.1   乘法操作符</strong></h4><p>乘法操作符由一个星号（<code>*</code>）表示，可以用于计算两个数值的乘积。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">34</span> * <span class="number">56</span>; <span class="comment">// 1904</span></span><br></pre></td></tr></table></figure>
<p>乘法操作符在处理特殊值时也有一些特殊的行为：</p>
<ul>
<li>如果操作数都是数值，则执行常规的乘法运算，正负符号不同的值相乘得到负值。如果ECMAScript不能表示乘积，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以非0的有限数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>乘以<code>Infinity</code>，则返回<code>Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-2-除法操作符"><a href="#3-5-4-2-除法操作符" class="headerlink" title="3.5.4.2   除法操作符"></a><strong>3.5.4.2   除法操作符</strong></h4></li>
</ul>
<p>除法操作符由一个斜杠（<code>/</code>）表示，用于计算第一个操作数除以第二个操作数的商。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">66</span> / <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>除法操作符针对特殊值也有一些特殊的行为。</p>
<ul>
<li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是0除以0，则返回<code>NaN</code>。</li>
<li>如果是非0的有限值除以0，则根据第一个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>除以任何数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-3-取模操作符-reivew"><a href="#3-5-4-3-取模操作符-reivew" class="headerlink" title="3.5.4.3   取模操作符(reivew)"></a><strong>3.5.4.3   取模操作符(reivew)</strong></h4></li>
</ul>
<p>取模（余数）操作符由一个百分比符号（<code>%</code>）表示，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">26</span> % <span class="number">5</span>; <span class="comment">// 等于1</span></span><br></pre></td></tr></table></figure>
<p>取模操作符对特殊值也有一些特殊的行为。</p>
<ul>
<li>如果操作数是数值，则执行常规除法运算，返回余数。</li>
<li>如果被除数是无限值，除数是有限值，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是无限值，则返回被除数。</li>
<li>如果被除数是0，除数不是0，则返回0。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h3 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5　指数操作符"></a>3.5.5　指数操作符</h3></li>
</ul>
<p>ECMAScript 7新增了指数操作符，和<code>Math.pow()</code>的操作符<code>**</code>是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>);         <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>指数操作符也有自己的指数赋值操作符<code>**=</code>，该操作符执行指数运算和结果的赋值操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared **= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6　加性操作符"></a>3.5.6　加性操作符</h3><p>加性操作符，即加法和减法操作符。在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p>
<h4 id="3-5-6-1-加法操作符（review）"><a href="#3-5-6-1-加法操作符（review）" class="headerlink" title="3.5.6.1   加法操作符（review）"></a><strong>3.5.6.1   加法操作符（review）</strong></h4><p>加法操作符（<code>+</code>）用于求两个数的和，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：</p>
<ul>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>；</li>
<li>如果是<code>Infinity</code>加<code>Infinity</code>，则返回<code>Infinity</code>；</li>
<li>如果是<code>-Infinity</code>加<code>-Infinity</code>，则返回<code>-Infinity</code>；</li>
<li> 如果是<code>Infinity</code>加<code>-Infinity</code>，则返回<code>NaN</code>；</li>
<li>如果是<code>+0</code>加<code>+0</code>，则返回<code>+0</code>；</li>
<li>如果是<code>-0</code>加<code>+0</code>，则返回<code>+0</code>；</li>
<li>如果是<code>-0</code>加<code>-0</code>，则返回<code>-0</code>。</li>
</ul>
<p>不过，如果有一个操作数是字符串，则要应用如下规则：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</li>
</ul>
<p>如果有任一操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法以获取字符串，然后再应用前面的关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则调用<code>String()</code>函数，分别获取<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> + <span class="number">5</span>;        </span><br><span class="line"><span class="built_in">console</span>.log(result1);    <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;      </span><br><span class="line"><span class="built_in">console</span>.log(result2);    <span class="comment">// &quot;55&quot;</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。这是因为每次加法运算都是独立完成的。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let message = &quot;The sum of 5 and 10 is &quot; + (num1 + num2);</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-6-2-减法操作符-review"><a href="#3-5-6-2-减法操作符-review" class="headerlink" title="3.5.6.2   减法操作符(review)"></a><strong>3.5.6.2   减法操作符(review)</strong></h4><p>减法操作符（<code>-</code>）也是使用很频繁的一种操作符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。</p>
<ul>
<li>如果两个操作数都是数值，则执行数学减法运算并返回结果。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>减<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>-Infinity</code>减<code>-Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>减<code>-Infinity</code>，则返回<code>Infinity</code>。</li>
<li>如果是<code>-Infinity</code>减<code>Infinity</code>，则返回<code>-Infinity</code>。</li>
<li>如果是<code>+0</code>减<code>+0</code>，则返回<code>+0</code>。</li>
<li>如果是<code>+0</code>减<code>-0</code>，则返回<code>-0</code>。</li>
<li>如果是<code>-0</code>减<code>-0</code>，则返回<code>+0</code>。</li>
<li>如果有任一操作数是字符串、布尔值、<code>null</code>或<code>undefined</code>，则先在后台使用<code>Number()</code>将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。</li>
<li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法取得表示它的数值。如果该值是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法，然后再将得到的字符串转换为数值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> - <span class="literal">true</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> - <span class="number">1</span>;  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> - <span class="number">3</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;   <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7　关系操作符"></a>3.5.7　关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）和大于等于（<code>&gt;=</code>）。这几个操作符都返回布尔值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p>
<ul>
<li>如果操作数都是数值，则执行数值比较。</li>
<li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li>
<li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li>
<li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法，取得结果后再根据前面的规则执行比较。如果没有<code>valueOf()</code>操作符，则调用<code>toString()</code>方法，取得结果后再根据前面的规则执行比较。</li>
<li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
</ul>
<p>事实上，大写字母的编码都小于小写字母的编码，要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式，然后再比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span> &lt; <span class="string">&quot;alphabet&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="string">&quot;Brick&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alphabet&quot;</span>.toLowerCase(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在比较两个数值字符串的时候，因为两个操作数都是字符串，所以会逐个比较它们的字符编码，如果有一个操作数是数值，那么比较的结果就对了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// 因为&quot;a&quot;会转换为NaN，所以结果是false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8　相等操作符"></a>3.5.8　相等操作符</h3><p>ECMAScript提供了两组操作符。第一组是<strong>等于</strong>和<strong>不等于</strong>，它们在比较之前执行转换。第二组是<strong>全等</strong>和<strong>不全等</strong>，它们在比较之前不执行转换。</p>
<h4 id="3-5-8-1-等于和不等于"><a href="#3-5-8-1-等于和不等于" class="headerlink" title="3.5.8.1   等于和不等于"></a><strong>3.5.8.1   等于和不等于</strong></h4><p>ECMAScript中的等于操作符用两个等于号（<code>==</code>）表示，如果操作数相等，则会返回<code>true</code>。不等于操作符用叹号和等于号（<code>!=</code>）表示，如果两个操作数不相等，则会返回<code>true</code>。这两个操作符都会先进行类型转换（通常称为<strong>强制类型转换</strong>）再确定操作数是否相等。</p>
<p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p>
<ul>
<li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。</li>
<li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的<code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较。</li>
</ul>
<p>在进行比较时，这两个操作符会遵循如下规则。</p>
<ul>
<li><code>null</code>和<code>undefined</code>相等。</li>
<li><code>null</code>和<code>undefined</code>不能转换为其他类型的值再进行比较。</li>
<li>如果有任一操作数是<code>NaN</code>，则相等操作符返回<code>false</code>，不相等操作符返回<code>true</code>。记住：即使两个操作数都是<code>NaN</code>，相等操作符也返回<code>false</code>，因为<code>NaN</code>不等于<code>NaN</code>。</li>
<li>如果两个操作数都是对象，且都指向同一个对象，则相等操作符返回<code>true</code>。否则，不相等。</li>
</ul>
<p>下表总结了一些特殊情况及比较的结果。</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null == undefined</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“NaN” == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">5 == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN != NaN</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">false == 0</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 1</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 2</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">undefined == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">null == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">“5” == 5</td>
<td align="left">true</td>
</tr>
</tbody></table>
<h4 id="3-5-8-2-全等和不全等"><a href="#3-5-8-2-全等和不全等" class="headerlink" title="3.5.8.2   全等和不全等"></a><strong>3.5.8.2   全等和不全等</strong></h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3个等于号（<code>===</code>）表示，只有两个操作数在不转换的前提下相等才返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>);  <span class="comment">// true，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<p>不全等操作符用一个叹号和两个等于号（<code>!==</code>）表示，只有两个操作数在不转换的前提下不相等才返回<code>true</code>。</p>
<p>另外虽然<code>null == undefined</code>是<code>true</code>（因为这两个值类似），但<code>null === undefined</code>是<code>false</code>，因为它们不是相同的数据类型。</p>
<blockquote>
<p>**注意 **由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。有助于在代码中保持数据类型的完整性。</p>
</blockquote>
<h3 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9　条件操作符"></a>3.5.9　条件操作符</h3><p>语法跟Java中一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10　赋值操作符"></a>3.5.10　赋值操作符</h3><p>简单赋值用等于号（<code>=</code>）表示，将右手边的值赋给左手边的变量，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值使用乘性、加性或位操作符后跟等于号（<code>=</code>）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p>
<ul>
<li>乘后赋值（<code>*=</code>）</li>
<li>除后赋值（<code>/=</code>）</li>
<li>取模后赋值（<code>%=</code>）</li>
<li>加后赋值（<code>+=</code>）</li>
<li>减后赋值（<code>-=</code>）</li>
<li>左移后赋值（<code>&lt;&lt;=</code>）</li>
<li>右移后赋值（<code>&gt;&gt;=</code>）</li>
<li>无符号右移后赋值（<code>&gt;&gt;&gt;=</code>）</li>
</ul>
<h3 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11　逗号操作符"></a>3.5.11　逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作。一条语句中同时声明多个变量是逗号操作符最常用的场景。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure>
<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6　语句"></a>3.6　语句</h2><p>ECMA-262描述了一些语句（也称为<strong>流控制语句</strong>），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p>
<h3 id="3-6-1-if语句"><a href="#3-6-1-if语句" class="headerlink" title="3.6.1   if语句"></a>3.6.1   <code>if</code>语句</h3><p>最佳实践是使用语句块，即使只有一行代码要执行也是如此。这是因为语句块可以避免对什么条件下执行什么产生困惑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-2-do-while语句"><a href="#3-6-2-do-while语句" class="headerlink" title="3.6.2   do-while语句"></a>3.6.2   <code>do-while</code>语句</h3><p><code>do-while</code>语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-6-3-while语句"><a href="#3-6-3-while语句" class="headerlink" title="3.6.3   while语句"></a>3.6.3   <code>while</code>语句</h3><p><code>while</code>语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code>循环体内的代码有可能不会执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-4-for语句"><a href="#3-6-4-for语句" class="headerlink" title="3.6.4   for语句"></a>3.6.4   <code>for</code>语句</h3><p><code>for</code>语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化、条件表达式和循环后表达式都不是必需的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无穷循环</span></span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只包含条件表达式，那么<code>for</code>循环实际上就变成了<code>while</code>循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; count; ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法通过<code>while</code>循环实现的逻辑，同样也无法使用<code>for</code>循环实现。<code>for</code>循环只是将循环相关的代码封装在一起。</p>
<h3 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5   for-in语句"></a>3.6.5   <code>for-in</code>语句</h3><p><code>for-in</code>语句是一种严格的迭代语句，用于枚举对象中的非符号键属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;<span class="comment">// 推荐使用const，确保这个局部变量不被修改</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript中对象的属性是无序的，因此<code>for-in</code>语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p>
<p>如果<code>for-in</code>循环要迭代的变量是<code>null</code>或<code>undefined</code>，则不执行循环体。</p>
<h3 id="3-6-6-for-of语句"><a href="#3-6-6-for-of语句" class="headerlink" title="3.6.6   for-of语句"></a>3.6.6   <code>for-of</code>语句</h3><p><code>for-of</code>语句是一种严格的迭代语句，用于遍历可迭代对象的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for-of</code>循环会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则<code>for-of</code>语句会抛出错误。</p>
<blockquote>
<p>**注意 **ES2018对<code>for-of</code>语句进行了扩展，增加了<code>for-await-of</code>循环，以支持生成期约（promise）的异步可迭代对象。</p>
<h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7   标签语句"></a>3.6.7   标签语句</h3></blockquote>
<p>标签语句用于给语句加标签，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>start</code>是一个标签，可以在后面通过<code>break</code>或<code>continue</code>语句引用。典型应用场景是嵌套循环。</p>
<h3 id="3-6-8-break和continue语句"><a href="#3-6-8-break和continue语句" class="headerlink" title="3.6.8   break和continue语句"></a>3.6.8   <code>break</code>和<code>continue</code>语句</h3><p><code>break</code>语句用于立即退出循环，强制执行循环后的下一条语句。而<code>continue</code>语句也用于立即退出循环，但会再次从循环顶部开始执行。</p>
<p><code>break</code>与标签语句一起使用，返回代码中特定的位置。通常是在嵌套循环中。添加标签不仅让<code>break</code>退出的内部循环，也会退出的外部循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p><code>continue</code>语句也可以使用标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p>组合使用标签语句和<code>break</code>、<code>continue</code>能实现复杂的逻辑，但也容易出错。</p>
<h3 id="3-6-9-with语句"><a href="#3-6-9-with语句" class="headerlink" title="3.6.9   with语句"></a>3.6.9   <code>with</code>语句</h3><p><code>with</code>语句的用途是将代码作用域设置为特定的对象，主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>with</code>语句，就可以少写一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>with</code>语句用于连接<code>location</code>对象。在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索<code>location</code>对象，如果它有一个同名的属性，则该变量会被求值为<code>location</code>对象的属性。</p>
<blockquote>
<p><strong>警告</strong> <code>with</code>语句影响性能且难于调试其中的代码，且严格模式不允许使用。通常不推荐使用<code>with</code>语句。</p>
</blockquote>
<h3 id="3-6-10-switch语句"><a href="#3-6-10-switch语句" class="headerlink" title="3.6.10   switch语句"></a>3.6.10   <code>switch</code>语句</h3><p>每个<code>case</code>（条件/分支）相当于：如果表达式等于后面的值，则执行下面的语句。<code>break</code>关键字会导致代码执行跳出<code>switch</code>语句。如果没有<code>break</code>，则代码会继续匹配下一个条件。<code>default</code>关键字用于在任何条件都没有满足时指定默认执行的语句（相当于<code>else</code>语句）。</p>
<p>为避免不必要的条件判断，最好给每个条件后面都加上<code>break</code>语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了<code>break</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="comment">/*跳过*/</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;25 or 35&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ECMAScript中，<code>switch</code>语句可以用于所有数据类型。其次条件的值不需要是常量，也可以是变量或表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 10.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 10 and 20.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;More than 20.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>**注意 **<code>switch</code>语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型。</p>
</blockquote>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：03-语言基础</li>
        <li>本文作者：胡倚豪</li>
        <li>创建时间：2021-01-23 19:31:12</li>
        <li>
            本文链接：huonenumber.github.io/2021/01/23/note/JavaScript/03-语言基础/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/01/23/note/JavaScript/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">04-变量、作用域与内存</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/01/23/note/HTTP/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">15-实体和编码</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oRtabIpmHUsCjAVoocAuRiR6-gzGzoHsz',
                    appKey: '8MQB6tSReJAP6eYmI5OGVpTo',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请尽情吐槽吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '胡倚豪';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">胡倚豪</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E8%AF%AD%E6%B3%95"><span class="nav-text">3.1　语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-text">3.1.1　区分大小写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">3.1.2　标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E6%B3%A8%E9%87%8A"><span class="nav-text">3.1.3　注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-text">3.1.4　严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.1.5　语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="nav-text">3.2　关键字与保留字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%8F%98%E9%87%8F"><span class="nav-text">3.3　变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-var%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">3.3.1   var关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-1-var%E5%A3%B0%E6%98%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">3.3.1.1   var声明作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-2-var%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="nav-text">3.3.1.2   var声明提升</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-let%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2   let声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-1-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="nav-text">**3.3.2.1 **  暂时性死区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-2-%E5%85%A8%E5%B1%80%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2.2   全局声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-3-%E6%9D%A1%E4%BB%B6%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2.3   条件声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-4-for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84let%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2.4   for循环中的let声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-const%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.3   const声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E5%A3%B0%E6%98%8E%E9%A3%8E%E6%A0%BC%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">3.3.4　声明风格及最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-1-%E4%B8%8D%E4%BD%BF%E7%94%A8var"><span class="nav-text">3.3.4.1   不使用var</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-2const%E4%BC%98%E5%85%88%EF%BC%8Clet%E6%AC%A1%E4%B9%8B"><span class="nav-text">3.3.4.2const优先，let次之</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4　数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-typeof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.4.1   typeof操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-Undefined%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.2   Undefined类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-Null%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.3   Null类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-Boolean%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.4   Boolean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-Number%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.5   Number类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-1-%E6%B5%AE%E7%82%B9%E5%80%BC"><span class="nav-text">3.4.5.1   浮点值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-2-%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-text">3.4.5.2   值的范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-3-NaN"><span class="nav-text">3.4.5.3   NaN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-4-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.4.5.4   数值转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-6-String%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.6   String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-1-%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">3.4.6.1   字符字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">3.4.6.2   字符串的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-3-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.4.6.3   转换为字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-4-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">3.4.6.4   模板字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC"><span class="nav-text">3.4.6.5   字符串插值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-6-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A0%87%E7%AD%BE%E5%87%BD%E6%95%B0"><span class="nav-text">3.4.6.6   模板字面量标签函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-7-%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.4.6.7   原始字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-7-Symbol%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.7   Symbol类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-1-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">3.4.7.1   符号的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-2-%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="nav-text">3.4.7.2   使用全局符号注册表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-3-%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7"><span class="nav-text">3.4.7.3   使用符号作为属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-4-%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7"><span class="nav-text">3.4.7.4   常用内置符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-5-Symbol-asyncIterator"><span class="nav-text">3.4.7.5   Symbol.asyncIterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-6-Symbol-hasInstance"><span class="nav-text">3.4.7.6   Symbol.hasInstance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-7-Symbol-isConcatSpreadable"><span class="nav-text">3.4.7.7   Symbol.isConcatSpreadable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-8-Symbol-iterator"><span class="nav-text">3.4.7.8   Symbol.iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-9-Symbol-match"><span class="nav-text">3.4.7.9   Symbol.match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-10-Symbol-replace"><span class="nav-text">3.4.7.10   Symbol.replace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-11-Symbol-search"><span class="nav-text">3.4.7.11   Symbol.search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-12-Symbol-species"><span class="nav-text">3.4.7.12   Symbol.species</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-13-Symbol-split"><span class="nav-text">3.4.7.13   Symbol.split</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-14-Symbol-toPrimitive"><span class="nav-text">3.4.7.14   Symbol.toPrimitive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-15-Symbol-toStringTag"><span class="nav-text">3.4.7.15   Symbol.toStringTag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-16-Symbol-unscopables"><span class="nav-text">3.4.7.16   Symbol.unscopables</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-8-Object%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.8   Object类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5　操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.1　一元操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-1-%E9%80%92%E5%A2%9E-%E9%80%92%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.1.1   递增&#x2F;递减操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-2-%E4%B8%80%E5%85%83%E5%8A%A0%E5%92%8C%E5%87%8F"><span class="nav-text">3.5.1.2   一元加和减</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.2　位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-1-%E6%8C%89%E4%BD%8D%E9%9D%9E"><span class="nav-text">3.5.2.1   按位非</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-2-%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="nav-text">3.5.2.2   按位与</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-3-%E6%8C%89%E4%BD%8D%E6%88%96"><span class="nav-text">3.5.2.3   按位或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-4-%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="nav-text">3.5.2.4   按位异或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-5-%E5%B7%A6%E7%A7%BB"><span class="nav-text">3.5.2.5   左移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-6-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-text">3.5.2.6   有符号右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-7-%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-text">3.5.2.7   无符号右移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.3　布尔操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-1-%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-text">3.5.3.1   逻辑非</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-2-%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="nav-text">3.5.3.2   逻辑与</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-3-%E9%80%BB%E8%BE%91%E6%88%96"><span class="nav-text">3.5.3.3   逻辑或</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4　乘性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-1-%E4%B9%98%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4.1   乘法操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-2-%E9%99%A4%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4.2   除法操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-3-%E5%8F%96%E6%A8%A1%E6%93%8D%E4%BD%9C%E7%AC%A6-reivew"><span class="nav-text">3.5.4.3   取模操作符(reivew)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.5　指数操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-6-%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.6　加性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-6-1-%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88review%EF%BC%89"><span class="nav-text">3.5.6.1   加法操作符（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-6-2-%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6-review"><span class="nav-text">3.5.6.2   减法操作符(review)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.7　关系操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-8-%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.8　相等操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-8-1-%E7%AD%89%E4%BA%8E%E5%92%8C%E4%B8%8D%E7%AD%89%E4%BA%8E"><span class="nav-text">3.5.8.1   等于和不等于</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-8-2-%E5%85%A8%E7%AD%89%E5%92%8C%E4%B8%8D%E5%85%A8%E7%AD%89"><span class="nav-text">3.5.8.2   全等和不全等</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-9-%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.9　条件操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-10-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.10　赋值操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-11-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.11　逗号操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6　语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-if%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.1   if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-do-while%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.2   do-while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-while%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.3   while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4-for%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.4   for语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5-for-in%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.5   for-in语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-6-for-of%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.6   for-of语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-7-%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.7   标签语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-8-break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.8   break和continue语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-9-with%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.9   with语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-10-switch%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.10   switch语句</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
