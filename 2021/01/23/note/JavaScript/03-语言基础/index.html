<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="HTML,CSS,JavaScript">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="胡倚豪">
    
    <title>
        
            03-语言基础 |
        
        HuOneNumber | 个人博客
    </title>
    <link rel="shortcut icon" href="/images/avatar.png">
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true},"style":{"primary_color":"#33FFCC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"description":"忠于自我、追求极致，这就是极客精神！","background_img":"/images/bg.svg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.3.0"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="别着急，慢慢来" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                HuOneNumber | 个人博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content normal-code-theme">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">03-语言基础</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span>胡倚豪</span>
                        <span class="level">Lv3</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i> 2021-01-23 19:31:12
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/">JavaScript高级程序设计(第四版)</a>
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">03-语言基础</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/JavaScript/">JavaScript</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>27k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>107 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1　语法"></a>3.1　语法</h2><h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1　区分大小写"></a>3.1.1　区分大小写</h3><p>ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符。</p>
<h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2　标识符"></a>3.1.2　标识符</h3><p><strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p>
<ol>
<li>第一个字符必须是一个字母、下划线_或美元符号$；</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ol>
<p>标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。</p>
<p>ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<p>关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>不能作为标识符。</p>
<h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3　注释"></a>3.1.3　注释</h3><p>包括单行注释和块注释。单行注释以两个斜杠字符开头，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>
<p>块注释以一个斜杠和一个星号（<code>/*</code>）开头，以它们的反向组合（<code>*/</code>）结尾，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是多行</span></span><br><span class="line"><span class="comment">注释 */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4　严格模式"></a>3.1.4　严格模式</h3><p>严格模式是一种不同的JavaScript解析和执行模型，要对整个脚本启用严格模式，在脚本开头加上：”use strict”;，它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。也可以单独指定一个函数在严格模式下执行，把这个预处理指令放到函数体开头即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5　语句"></a>3.1.5　语句</h3><p>ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sum &#x3D; a + b      &#x2F;&#x2F; 没有分号也有效，但不推荐</span><br></pre></td></tr></table></figure>
<p>加分号有助于防止省略造成的问题，比如避免输入内容不完整，也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误），也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。<br>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号（<code>&#123;</code>）标识开始，一个右花括号（<code>&#125;</code>）标识结束：</p>
<p>if之类的控制语句只在执行多条语句时要求必须有代码块。最好始终在控制语句中使用代码块，即使要执行的只有一条语句。</p>
<p>在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。</p>
<h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2　关键字与保留字"></a>3.2　关键字与保留字</h2><p>保留的关键字不能用作标识符或属性名。ECMA-262第6版规定的所有关键字如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">break       do          in            typeof</span><br><span class="line">case        else        instanceof    var</span><br><span class="line">catch       export      new           void</span><br><span class="line">class       extends     return        while</span><br><span class="line">const       finally     super         with</span><br><span class="line">continue    for         switch        yield</span><br><span class="line">debugger    function    this</span><br><span class="line">default     if          throw</span><br><span class="line">delete      import      try</span><br></pre></td></tr></table></figure>
<p>规范中也描述了一组<strong>未来的保留字</strong>，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">始终保留:</span><br><span class="line">enum</span><br><span class="line">严格模式下保留:</span><br><span class="line">implements  package     public</span><br><span class="line">interface   protected   static</span><br><span class="line">let         private</span><br><span class="line">模块代码中保留:</span><br><span class="line">await</span><br></pre></td></tr></table></figure>
<p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。但最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的ECMAScript版本。</p>
<h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3　变量"></a>3.3　变量</h2><p>ECMAScript变量是松散类型的，变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：<code>var</code>、<code>const</code>和<code>let</code>。其中，<code>var</code>在ECMAScript的所有版本中都可以使用，而<code>const</code>和<code>let</code>只能在ECMAScript 6及更晚的版本中使用。</p>
<h3 id="3-3-1var关键字"><a href="#3-3-1var关键字" class="headerlink" title="3.3.1var关键字"></a>3.3.1<code>var</code>关键字</h3><p>要定义变量，可以使用<code>var</code>操作符（注意<code>var</code>是一个关键字），后跟变量名（即标识符）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var message;</span><br></pre></td></tr></table></figure>
<p>（不初始化的情况下，变量会保存一个特殊值<code>undefined</code>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>初始化变量不会将它标识为字符串类型，只是一个简单的赋值而已。随后不仅可以改变保存的值，也可以改变值的类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">message = <span class="number">100</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-1var声明作用域"><a href="#3-3-1-1var声明作用域" class="headerlink" title="3.3.1.1var声明作用域"></a>3.3.1.1<code>var</code>声明作用域</h4><p><code>var</code>声明作用域关键的问题在于，使用<code>var</code>操作符定义的变量会成为包含它的函数的局部变量。使用<code>var</code>在一个函数内部定义一个变量，该变量将在函数退出时被销毁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>
<p>在函数内定义变量时省略<code>var</code>操作符，可以创建一个全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   message = <span class="string">&quot;hi&quot;</span>;     <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>虽然可以通过省略<code>var</code>操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出<code>ReferenceError</code>。</p>
</blockquote>
<p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进并不是必需的，但这样有利于阅读理解。<br>在严格模式下，不能定义名为<code>eval</code>和<code>arguments</code>的变量，否则会导致语法错误。</p>
<h4 id="3-3-1-2var声明提升"><a href="#3-3-1-2var声明提升" class="headerlink" title="3.3.1.2var声明提升"></a>3.3.1.2<code>var</code>声明提升</h4><p>使用<code>var</code>时，声明的变量会自动提升到函数作用域顶部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>反复多次使用<code>var</code>声明同一个变量也没有问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2let声明"><a href="#3-3-2let声明" class="headerlink" title="3.3.2let声明"></a>3.3.2<code>let</code>声明</h3><p><code>let</code>跟<code>var</code>最明显的区别是<code>let</code>声明的范围是块作用域，而<code>var</code>声明的范围是函数作用域。它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于<code>var</code>的作用域限制同样也适用于<code>let</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);   <span class="comment">// Matt</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);   <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>也不允许同一个块作用域中出现冗余声明。这样会导致报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;  <span class="comment">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></table></figure>
<p>JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);    <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混用<code>let</code>和<code>var</code>同样可能会到冗余声明。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-1-暂时性死区"><a href="#3-3-2-1-暂时性死区" class="headerlink" title="3.3.2.1**暂时性死区**"></a><strong>3.3.2.1**</strong>暂时性死区**</h4><p><code>let</code>与<code>var</code>的另一个重要的区别，就是<code>let</code>声明的变量不会在作用域中被提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="comment">// age不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p>在解析代码时，JavaScript引擎也会注意出现在块后面的<code>let</code>声明，只不过在此之前不能以任何方式来引用未声明的变量。在<code>let</code>声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出<code>ReferenceError</code>。</p>
<h4 id="3-3-2-2-全局声明"><a href="#3-3-2-2-全局声明" class="headerlink" title="3.3.2.2**全局声明**"></a><strong>3.3.2.2**</strong>全局声明**</h4><p>使用<code>let</code>在全局作用域中声明的变量不会成为<code>window</code>对象的属性（<code>var</code>声明的变量会）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但<code>let</code>声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免<code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p>
<h4 id="3-3-2-3-条件声明（review）"><a href="#3-3-2-3-条件声明（review）" class="headerlink" title="3.3.2.3**条件声明（review）**"></a><strong>3.3.2.3**</strong>条件声明（review）**</h4><p>在使用<code>var</code>声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为<code>let</code>的作用域是块，所以不可能检查前面是否已经使用<code>let</code>声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line">  <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="comment">// 这里没问题，因为可以被作为一个提升声明来处理</span></span><br><span class="line">  <span class="comment">// 不需要检查之前是否声明过同名变量</span></span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="comment">// 如果age之前声明过，这里会报错</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用<code>try</code>/<code>catch</code>语句或<code>typeof</code>操作符也不能解决，因为<code>let</code>声明的作用域仅限于该条件块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line">  <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// name被限制在if &#123;&#125; 块的作用域内</span></span><br><span class="line">  <span class="comment">// 因此这个赋值形同全局赋值</span></span><br><span class="line">  name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> (age) &#123;</span><br><span class="line">    <span class="comment">// 如果age没有声明过，则会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="keyword">let</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// age被限制在catch &#123;&#125;块的作用域内</span></span><br><span class="line">  <span class="comment">// 因此这个赋值形同全局赋值</span></span><br><span class="line">  age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>为此，对于<code>let</code>声明关键字，不能依赖条件声明模式。</p>
<blockquote>
<p><strong>注意</strong>条件声明是一种反模式，它让程序变得更难理解。</p>
</blockquote>
<h4 id="3-3-2-4for循环中的let声明"><a href="#3-3-2-4for循环中的let声明" class="headerlink" title="3.3.2.4for循环中的let声明"></a>3.3.2.4<code>for</code>循环中的<code>let</code>声明</h4><p>在<code>let</code>出现之前，<code>for</code>循环定义的迭代变量会渗透到循环体外部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>改成使用<code>let</code>之后，这个问题就消失了，因为迭代变量的作用域仅限于<code>for</code>循环块内部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i没有定义</span></span><br></pre></td></tr></table></figure>
<p>在使用<code>var</code>的时候，最常见的问题是对迭代变量的奇特声明和修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能以为会输出0、1、2、3、4</span></span><br><span class="line"><span class="comment">// 实际上会输出5、5、5、5、5</span></span><br></pre></td></tr></table></figure>
<p>在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的<code>i</code>都是同一个变量，因而输出的都是同一个最终值。<br>而在使用<code>let</code>声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个<code>setTimeout</code>引用的都是不同的变量实例，所以<code>console.log</code>输出的是循环执行过程中每个迭代变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出0、1、2、3、4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-3const声明"><a href="#3-3-3const声明" class="headerlink" title="3.3.3const声明"></a>3.3.3<code>const</code>声明</h3><p><code>const</code>的行为与<code>let</code>基本相同，唯一区别是用它声明变量时必须同时初始化变量，且修改<code>const</code>声明的变量会导致运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="comment">// const也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// const声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>声明的限制只适用于它指向的变量的引用。如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>不能用<code>const</code>来声明迭代变量（因为迭代变量会自增）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>const</code>声明一个不会被修改的<code>for</code>循环变量。因为和<code>let</code>声明一样JavaScript引擎会为<code>for</code>循环中的<code>const</code>声明分别创建独立的变量实例。这对<code>for-of</code>和<code>for-in</code>循环特别有意义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> j = <span class="number">7</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7, 7, 7, 7, 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4　声明风格及最佳实践"></a>3.3.4　声明风格及最佳实践</h3><p>ECMAScript 6增加<code>let</code>和<code>const</code>从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的<code>var</code>所造成的各种问题，已经让JavaScript社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。</p>
<h4 id="3-3-4-1-不使用var"><a href="#3-3-4-1-不使用var" class="headerlink" title="3.3.4.1   不使用var"></a><strong>3.3.4.1   不使用</strong><code>var</code></h4><p>限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<h4 id="3-3-4-2const优先，let次之"><a href="#3-3-4-2const优先，let次之" class="headerlink" title="3.3.4.2const优先，let次之"></a>3.3.4.2<code>const</code>优先，<code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4　数据类型"></a>3.4　数据类型</h2><p>ECMAScript有6种简单数据类型（也称为<strong>原始类型</strong>）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。还有一种复杂数据类型叫<code>Object</code>（对象）。<code>Object</code>是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。一种数据类型可以当作多种数据类型来使用。</p>
<h3 id="3-4-1typeof操作符"><a href="#3-4-1typeof操作符" class="headerlink" title="3.4.1typeof操作符"></a>3.4.1<code>typeof</code>操作符</h3><p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。<code>typeof</code>操作符就是为此而生的。对一个值使用<code>typeof</code>操作符会返回下列字符串之一：</p>
<ul>
<li><code>&quot;undefined&quot;</code>表示值未定义；</li>
<li><code>&quot;boolean&quot;</code>表示值为布尔值；</li>
<li><code>&quot;string&quot;</code>表示值为字符串；</li>
<li><code>&quot;number&quot;</code>表示值为数值；</li>
<li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或<code>null</code>；</li>
<li><code>&quot;function&quot;</code>表示值为函数；</li>
<li><code>&quot;symbol&quot;</code>表示值为符号。</li>
</ul>
<p>下面是使用<code>typeof</code>操作符的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);    <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message));   <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);         <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为<code>typeof</code>是一个操作符而不是函数，所以不需要参数（但可以使用参数）。<br><code>typeof</code>在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用<code>typeof   null</code>返回的是<code>&quot;object&quot;</code>。这是因为特殊值<code>null</code>被认为是一个对空对象的引用。</p>
<blockquote>
<p><strong>注意</strong>严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此通过<code>typeof</code>操作符来区分函数和其他对象。</p>
</blockquote>
<h3 id="3-4-2Undefined类型"><a href="#3-4-2Undefined类型" class="headerlink" title="3.4.2Undefined类型"></a>3.4.2<code>Undefined</code>类型</h3><p><code>Undefined</code>类型只有一个值，就是特殊值<code>undefined</code>。当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>变量<code>message</code>和<code>undefined</code>的字面值是相等的。但变量<code>message</code>显式地以<code>undefined</code>来初始化是不必要的，因为默认情况下，任何未经初始化的变量都会取得<code>undefined</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>永远不要显式地给某个变量设置<code>undefined</code>值。字面值<code>undefined</code>主要用于比较。增加这个特殊值的目的就是为了正式明确空对象指针（<code>null</code>）和未初始化变量的区别。</p>
</blockquote>
<p>包含<code>undefined</code>值的变量跟未定义变量是有区别的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;    <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>对未声明的变量，只能对它调用<code>typeof</code>。（对未声明的变量调用<code>delete</code>也不会报错，但这个操作没什么用，且在严格模式下会抛出错误。）<br>在对未初始化的变量和对未声明的变量调用<code>typeof</code>时，返回的结果都是<code>&quot;undefined&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>从逻辑上讲，虽然严格来讲这两个变量存在根本性差异，但它对任何一个变量都不可能执行什么真正的操作。</p>
<blockquote>
<p><strong>注意</strong>即使未初始化的变量会被自动赋予<code>undefined</code>值，但建议在声明变量的同时进行初始化。这样，当<code>typeof</code>返回<code>&quot;undefined&quot;</code>时，会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p>
</blockquote>
<p><code>undefined</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// age没有声明</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line">  <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-3Null类型"><a href="#3-4-3Null类型" class="headerlink" title="3.4.3Null类型"></a>3.4.3<code>Null</code>类型</h3><p><code>Null</code>类型同样只有一个值，即特殊值<code>null</code>。逻辑上讲，<code>null</code>值表示一个空对象指针，这也是给<code>typeof</code>传一个<code>null</code>会返回<code>&quot;object&quot;</code>的原因：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> car);  <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>在定义将来要保存对象值的变量时，建议使用<code>null</code>来初始化，不要使用其他值。这样，只要检查这个变量的值是不是<code>null</code>就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// car是一个对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>undefined</code>值是由<code>null</code>值派生而来的，因此ECMA-262将它们定义为表面上相等。用等于操作符（<code>==</code>）会为了比较而转换它的操作数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>即使<code>null</code>和<code>undefined</code>有关系，它们的用途也是完全不一样的。只要变量要保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量。这样就可以保持<code>null</code>是空对象指针的语义，并进一步将其与<code>undefined</code>区分开来。<br><code>null</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。例子也如前面所示。</p>
<h3 id="3-4-4Boolean类型"><a href="#3-4-4Boolean类型" class="headerlink" title="3.4.4Boolean类型"></a>3.4.4<code>Boolean</code>类型</h3><p><code>Boolean</code>（布尔值）类型有两个字面值：<code>true</code>和<code>false</code>。这两个布尔值不同于数值，<code>true</code>不等于1，<code>false</code>不等于0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> lost = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>布尔值字面量<code>true</code>和<code>false</code>是区分大小写的，因此<code>True</code>和<code>False</code>（及其他大小混写形式）是有效的标识符，但不是布尔值。<br>虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。可以调用特定的<code>Boolean()</code>转型函数，将一个其他类型的值转换为布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，字符串<code>message</code>会被转换为布尔值并保存在变量<code>messageAsBoolean</code>中。<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为<code>true</code>或<code>false</code>的规则取决于数据类型和实际的值。<br>|数据类型|转换为true的值|转换为false的值|<br>|:—-|:—-|:—-|<br>|Boolean|true|false|<br>|String|非空字符串|””（空字符串）|<br>|Number|非零数值（包括无穷值）|0、NaN|<br>|Object|任意对象|null|<br>|Undefined|N/A（不存在）|undefined|</p>
<p><code>if</code>等流控制语句会自动执行其他类型值到布尔值的转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Value is true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。</p>
<h3 id="3-4-5Number类型"><a href="#3-4-5Number类型" class="headerlink" title="3.4.5Number类型"></a>3.4.5<code>Number</code>类型</h3><p><code>Number</code>类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，直接写出来即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>;  <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure>
<p>用八进制（以8为基数）字面量表示，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。<br>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。ECMAScript 2015或ES6中的八进制值通过前缀<code>0o</code>来表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>;  <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>;  <span class="comment">// 无效的八进制值，当成79处理</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span>;   <span class="comment">// 无效的八进制值，当成8处理</span></span><br></pre></td></tr></table></figure>
<p>整数也可以或十六进制（以16为基数）字面量表示。必须让真正的数值前缀<code>0x</code>（区分大小写），然后是十六进制数字（0<del>9以及A</del>F）。十六进制数字中的字母大小写均可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>;   <span class="comment">// 十六进制10</span></span><br><span class="line"><span class="keyword">let</span> hexNum2 = <span class="number">0x1f</span>;  <span class="comment">// 十六进制31</span></span><br></pre></td></tr></table></figure>
<p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<blockquote>
<p><strong>注意</strong>由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。</p>
<h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1   浮点值"></a><strong>3.4.5.1   浮点值</strong></h4></blockquote>
<p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">.1</span>;   <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure>
<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">// 小数点后面没有数字，当成整数1处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">// 小数点后面是零，当成整数10处理</span></span><br></pre></td></tr></table></figure>
<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure>
<p>科学记数法也可以用于表示非常小的数值。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为3e-7）。<br>浮点值的精确度最高可达17位小数，但在算术计算中不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123;      <span class="comment">// 别这么干！</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;You got 0.3.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个数值分别是0.05和0.25，或者0.15和0.15，没问题。但如果是0.1和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p>
<blockquote>
<p><strong>注意</strong>之所以存在这种舍入错误，是因为使用了IEEE 754数值。其他使用相同格式的语言也有这个问题。</p>
<h4 id="3-4-5-2-值的范围"><a href="#3-4-5-2-值的范围" class="headerlink" title="3.4.5.2   值的范围"></a><strong>3.4.5.2   值的范围</strong></h4></blockquote>
<p>由于内存的限制，ECMAScript可以表示的最小数值保存在<code>Number.MIN_VALUE</code>中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。</p>
<p>如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的<code>Infinity</code>（无穷）值。任何无法表示的负数以<code>-Infinity</code>（负无穷大）表示，任何无法表示的正数以<code>Infinity</code>（正无穷大）表示。</p>
<p>如果计算返回正<code>Infinity</code>或负<code>Infinity</code>，则该值将不能再进一步用于任何计算。这是因为<code>Infinity</code>没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用<code>isFinite()</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>使用<code>Number.NEGATIVE_INFINITY</code>和<code>Number.POSITIVE_INFINITY</code>也可以获取正、负<code>Infinity</code>。这两个属性包含的值分别就是<code>-Infinity</code>和<code>Infinity</code>。</p>
</blockquote>
<h4 id="3-4-5-3NaN"><a href="#3-4-5-3NaN" class="headerlink" title="3.4.5.3NaN"></a>3.4.5.3<code>NaN</code></h4><p>有一个特殊的数值叫<code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回<code>NaN</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span>/+<span class="number">0</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>如果分子是非0值，分母是有符号0或无符号0，则会返回<code>Infinity</code>或<code>-Infinity</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/-<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>NaN</code>有几个独特的属性。首先，任何涉及<code>NaN</code>的操作始终返回<code>NaN</code>（如<code>NaN/10</code>），在连续多步计算时这可能是个问题。其次，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript提供了<code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给<code>isNaN()</code>后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>));      <span class="comment">// false，10是数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>虽然不常见，但<code>isNaN()</code>可以用于测试对象。首先会调用对象的<code>valueOf()</code>方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用<code>toString()</code>方法，并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式。</p>
<h4 id="3-4-5-4-数值转换"><a href="#3-4-5-4-数值转换" class="headerlink" title="3.4.5.4   数值转换"></a><strong>3.4.5.4   数值转换</strong></h4></blockquote>
<p>有3个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。</p>
<p><code>Number()</code>函数基于如下规则执行转换。</p>
<pre><code>1. 布尔值，`true`转换为1，`false`转换为0。
2. 数值，直接返回。
3. `null`，返回0。
4. `undefined`，返回`NaN`。
5. 字符串，应用以下规则。
    1. 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，`Number(&quot;1&quot;)`返回1，`Number(&quot;123&quot;)`返回123，`Number(&quot;011&quot;)`返回11（忽略前面的零）。
    2. 如果字符串包含有效的浮点值格式如`&quot;1.1&quot;`，则会转换为相应的浮点值（同样，忽略前面的零）。
    3. 如果字符串包含有效的十六进制格式如`&quot;0xf&quot;`，则会转换为与该十六进制值对应的十进制整数值。
    4. 如果是空字符串（不包含字符），则返回0。
    5. 如果字符串包含除上述情况之外的其他字符，则返回`NaN`。
6. 对象，调用`valueOf()`方法，并按照上述规则转换返回的值。如果转换结果是`NaN`，则调用`toString()`方法，再按照转换字符串的规则转换。</code></pre>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>);              <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>);        <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);            <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>一元加操作符与<code>Number()</code>函数遵循相同的转换规则。</p>
</blockquote>
<p><code>Number()</code>函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用<code>parseInt()</code>函数。<code>parseInt()</code>函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回<code>NaN</code>。这意味着空字符串也会返回<code>NaN</code>。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p>
<p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以<code>&quot;0x&quot;</code>开头，就会被解释为十六进制整数。如果字符串以<code>&quot;0&quot;</code>开头，且紧跟着数值字符，就会被解释为八进制整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>);          <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 10，解释为十六进制整数</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);        <span class="comment">// 22 因为小数点不是有效的整数字符</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>);        <span class="comment">// 70，解释为十进制值</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>);       <span class="comment">// 15，解释为十六进制整数</span></span><br></pre></td></tr></table></figure>
<p>不同的数值格式很容易混淆，因此<code>parseInt()</code>也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入16作为第二个参数，以便正确解析：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br></pre></td></tr></table></figure>
<p>事实上，如果提供了十六进制参数，那么字符串前面的<code>&quot;0x&quot;</code>可以省掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);  <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>通过第二个参数，可以极大扩展转换后获得的结果类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>);   <span class="comment">// 2，按二进制解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);   <span class="comment">// 8，按八进制解析</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);  <span class="comment">// 10，按十进制解析</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>);  <span class="comment">// 16，按十六进制解析</span></span><br></pre></td></tr></table></figure>
<p>因为不传底数参数相当于让<code>parseInt()</code>自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p>
<blockquote>
<p><strong>注意</strong>多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。</p>
</blockquote>
<p><code>parseFloat()</code>函数的工作方式跟<code>parseInt()</code>函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p>
<p><code>parseFloat()</code>函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为<code>parseFloat()</code>只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则<code>parseFloat()</code>返回整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234，按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>);      <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>);   <span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>);    <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>);   <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-6String类型"><a href="#3-4-6String类型" class="headerlink" title="3.4.6String类型"></a>3.4.6<code>String</code>类型</h3><p><code>String</code>（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure>
<p>跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript语法中表示字符串的引号没有区别。并且以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Nicholas&quot;; // 语法错误：开头和结尾的引号必须是同一种</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-1-字符字面量"><a href="#3-4-6-1-字符字面量" class="headerlink" title="3.4.6.1   字符字面量"></a><strong>3.4.6.1   字符字面量</strong></h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">字面量</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">反斜杠（\）</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td>
</tr>
<tr>
<td align="left">\`</td>
<td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td>
</tr>
<tr>
<td align="left">\x<em>nn</em></td>
<td align="left">以十六进制编码<em>nn</em>表示的字符（其中<em>n</em>是十六进制数字0~F），例如\x41等于”A”</td>
</tr>
<tr>
<td align="left">\u<em>nnnn</em></td>
<td align="left">以十六进制编码<em>nnnn</em>表示的Unicode字符（其中<em>n</em>是十六进制数字0~F），例如\u03a3等于希腊字符”Σ”</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is the letter sigma: \u03a3.&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>即使包含6个字符长的转义序列，变量<code>text</code>仍然是28个字符长。因为转义序列表示一个字符。<br>字符串的长度可以通过其<code>length</code>属性获取：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p>
</blockquote>
<h4 id="3-4-6-2字符串的特点"><a href="#3-4-6-2字符串的特点" class="headerlink" title="3.4.6.2字符串的特点"></a>3.4.6.2<strong>字符串的特点</strong></h4><p>ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3   转换为字符串"></a><strong>3.4.6.3   转换为字符串</strong></h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的<code>toString()</code>方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString();      <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString();  <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>toString()</code>方法可见于数值、布尔值、对象和字符串值。（字符串值使用<code>toString()</code>方法只是简单地返回自身的一个副本。）<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法。<br>多数情况下，<code>toString()</code>不接收任何参数。但对数值调用这个方法时，<code>toString()</code>可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，<code>toString()</code>返回数值的十进制字符串表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());     <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));    <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));    <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));   <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));   <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果不确定一个值是不是<code>null</code>或<code>undefined</code>，可以使用<code>String()</code>转型函数，它始终会返回表示相应类型值的字符串。<code>String()</code>函数遵循如下规则。<br>    1. 如果值有<code>toString()</code>方法，则调用该方法（不传参数）并返回结果。<br>    2. 如果值是<code>null</code>，返回<code>&quot;null&quot;</code>。<br>    3. 如果值是<code>undefined</code>，返回<code>&quot;undefined&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value1));  <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value2));  <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value3));  <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value4));  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>用加号操作符给一个值加上一个空字符串<code>&quot;&quot;</code>也可以将其转换为字符串。</p>
<h4 id="3-4-6-4-模板字面量（review）"><a href="#3-4-6-4-模板字面量（review）" class="headerlink" title="3.4.6.4   模板字面量（review）"></a><strong>3.4.6.4   模板字面量（review）</strong></h4></blockquote>
<p>ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineTemplateLiteral);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString === myMultiLinetemplateLiteral); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>模板字面量在定义模板时特别有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br></pre></td></tr></table></figure>
<p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意，格式正确的模板字符串可能反而会看起来缩进不当：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模板字面量在换行符之后有25个空格符</span></span><br><span class="line"><span class="keyword">let</span> myTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">                         second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myTemplateLiteral.length);  <span class="comment">// 47</span></span><br><span class="line"><span class="comment">// 这个模板字面量以一个换行符开头</span></span><br><span class="line"><span class="keyword">let</span> secondTemplateLiteral = <span class="string">`</span></span><br><span class="line"><span class="string">first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(secondTemplateLiteral[<span class="number">0</span>] === <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-5-字符串插值（review）"><a href="#3-4-6-5-字符串插值（review）" class="headerlink" title="3.4.6.5   字符串插值（review）"></a><strong>3.4.6.5   字符串插值（review）</strong></h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p>
<p>字符串插值通过在<code>$&#123;&#125;</code>中使用一个JavaScript表达式实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedString =</span><br><span class="line">  value + <span class="string">&#x27; to the &#x27;</span> + exponent + <span class="string">&#x27; power is &#x27;</span> + (value * value);</span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral =</span><br><span class="line">  <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; <span class="string">`World`</span> &#125;</span>!`</span>);  <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>将表达式转换为字符串时会调用<code>toString()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>);      <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>在插值表达式中可以调用函数和方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>模板也可以插入自己之前的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">append();  <span class="comment">// abc</span></span><br><span class="line">append();  <span class="comment">// abcabc</span></span><br><span class="line">append();  <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-6-模板字面量标签函数（review）"><a href="#3-4-6-6-模板字面量标签函数（review）" class="headerlink" title="3.4.6.6   模板字面量标签函数（review）"></a><strong>3.4.6.6   模板字面量标签函数（review）</strong></h4><p>模板字面量也支持定义<strong>标签函数</strong>（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p>
<p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="built_in">console</span>.log(aValExpression);</span><br><span class="line">  <span class="built_in">console</span>.log(bValExpression);</span><br><span class="line">  <span class="built_in">console</span>.log(sumExpression);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);   <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);     <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(expression);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);  <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于有n个插值的模板字面量，传给标签函数的表达式参数的个数始终是n，而传给标签函数的第一个参数所包含的字符串个数则始终是n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zipTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strings[<span class="number">0</span>] +</span><br><span class="line">         expressions.map(<span class="function">(<span class="params">e, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;e&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">                    .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult =    <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = zipTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);  <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);    <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-7-原始字符串-review"><a href="#3-4-6-7-原始字符串-review" class="headerlink" title="3.4.6.7   原始字符串(review)"></a><strong>3.4.6.7   原始字符串(review)</strong></h4><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的<code>String.raw</code>标签函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode示例</span></span><br><span class="line"><span class="comment">// \u00A9是版权符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);            <span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);  <span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br><span class="line"><span class="comment">// 对实际的换行符来说是不行的</span></span><br><span class="line"><span class="comment">// 它们不会被转换成转义序列的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure>
<p>可以通过标签函数的第一个参数，即字符串数组的<code>.raw</code>属性取得每个字符串的原始内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Actual characters:&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(string);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Escaped characters;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.raw) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rawString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-7Symbol类型"><a href="#3-4-7Symbol类型" class="headerlink" title="3.4.7Symbol类型"></a>3.4.7<code>Symbol</code>类型</h3><p><code>Symbol</code>（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<p>听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。</p>
<h4 id="3-4-7-1-符号的基本用法"><a href="#3-4-7-1-符号的基本用法" class="headerlink" title="3.4.7.1   符号的基本用法"></a><strong>3.4.7.1   符号的基本用法</strong></h4><p>符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型，所以<code>typeof</code>操作符对符号返回<code>symbol</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p>调用<code>Symbol()</code>函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是这个字符串参数与符号定义或标识完全无关：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol == otherGenericSymbol);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol);          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，只要创建<code>Symbol()</code>实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol);  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol);      <span class="comment">// Symbol(foo);</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol()</code>函数不能用作构造函数，与<code>new</code>关键字一起使用。这样是为了避免创建符号包装对象，像使用<code>Boolean</code>、<code>String</code>或<code>Number</code>那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myString);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myNumber);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>如果你确实想使用符号包装对象，可以借用<code>Object()</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol);   <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-2-使用全局符号注册表"><a href="#3-4-7-2-使用全局符号注册表" class="headerlink" title="3.4.7.2   使用全局符号注册表"></a><strong>3.4.7.2   使用全局符号注册表</strong></h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用<code>Symbol.for()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，就生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);       <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);  <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用<code>Symbol()</code>定义的符号也不等同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给<code>Symbol.for()</code>的任何值都会被转换为字符串。注册表中使用的键同时也会被用作符号描述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(emptyGlobalSymbol);    <span class="comment">// Symbol(undefined)</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>Symbol.keyFor()</code>来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s));   <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果传给<code>Symbol.keyFor()</code>的不是符号，则该方法抛出<code>TypeError</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-3-使用符号作为属性-review"><a href="#3-4-7-3-使用符号作为属性-review" class="headerlink" title="3.4.7.3   使用符号作为属性(review)"></a><strong>3.4.7.3   使用符号作为属性(review)</strong></h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code>/<code>Object.definedProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line">  [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">  [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">//  Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。两个方法的返回值彼此互斥。<code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规和符号属性描述符的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">  qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure>
<p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">  [Symbol(&#39;foo&#39;)]: &#39;foo val&#39;,</span><br><span class="line">  [Symbol(&#39;bar&#39;)]: &#39;bar val&#39;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o);</span><br><span class="line">&#x2F;&#x2F; &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span><br><span class="line">let barSymbol &#x3D; Object.getOwnPropertySymbols(o)</span><br><span class="line">              .find((symbol) &#x3D;&gt; symbol.toString().match(&#x2F;bar&#x2F;));</span><br><span class="line">console.log(barSymbol);</span><br><span class="line">&#x2F;&#x2F; Symbol(bar)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-4-常用内置符号"><a href="#3-4-7-4-常用内置符号" class="headerlink" title="3.4.7.4   常用内置符号"></a><strong>3.4.7.4   常用内置符号</strong></h4><p>ECMAScript 6引入了一批<strong>常用内置符号</strong>（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。它们以<code>Symbol</code>工厂函数字符串属性的形式存在。</p>
<p>内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变<code>for-of</code>在迭代该对象时的行为。</p>
<p>这些内置符号也没有什么特别之处，它们就是全局函数<code>Symbol</code>的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>
<blockquote>
<p><strong>注意</strong>在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为<code>@@</code>。比如，<code>@@iterator</code>指的就是<code>Symbol.iterator</code>。</p>
</blockquote>
<h4 id="3-4-7-5Symbol-asyncIterator（review）"><a href="#3-4-7-5Symbol-asyncIterator（review）" class="headerlink" title="3.4.7.5Symbol.asyncIterator（review）"></a><strong>3.4.7.5</strong><code>Symbol.asyncIterator（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的<code>AsyncIterator</code>，由<code>for-await-of</code>语句使用”。也就是这个符号表示实现异步迭代器API的函数。</p>
<p><code>for-await-of</code>循环会利用这个函数执行异步迭代操作。循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>AsyncGenerator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.asyncIterator]());</span><br><span class="line"><span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>技术上，这个由<code>Symbol.asyncIterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回<code>Promise</code>实例。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过异步生成器函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="built_in">this</span>.asyncIdx++));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>Symbol.asyncIterator</code>是ES2018规范定义的，因此只有版本非常新的浏览器支持它。关于异步迭代和<code>for-await-of</code>循环的细节，参见附录A。</p>
</blockquote>
<h4 id="3-4-7-6Symbol-hasInstance"><a href="#3-4-7-6Symbol-hasInstance" class="headerlink" title="3.4.7.6Symbol.hasInstance"></a>3.4.7.6<code>Symbol.hasInstance</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用”。<code>instanceof</code>操作符可以用来确定一个对象实例的原型链上是否有原型。<code>instanceof</code>的典型使用场景如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在ES6中，<code>instanceof</code>操作符会使用<code>Symbol.hasInstance</code>函数来确定关系。以<code>Symbol.hasInstance</code>为键的函数会执行同样的操作，只是操作数对调了一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](f)); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个属性定义在Function的原型上，因此默认在所有函数和类上都可以调用。由于instanceof操作符会在原型链上寻找这个属性定义，因此可以在继承的类上通过静态方法重新定义这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-7Symbol-isConcatSpreadable（review）"><a href="#3-4-7-7Symbol-isConcatSpreadable（review）" class="headerlink" title="3.4.7.7Symbol.isConcatSpreadable（review）"></a>3.4.7.7<code>Symbol.isConcatSpreadable（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是<code>true</code>，则对象应该用<code>Array.prototype.concat()</code>打平其数组元素”。ES6中的<code>Array.prototype.concat()</code>方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。</p>
<p>数组对象默认情况下会被打平到已有的数组，<code>false</code>或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，<code>true</code>或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在<code>Symbol.isConcatSpreadable</code>被设置为<code>true</code>的情况下将被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line">arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-8Symbol-iterator（review）"><a href="#3-4-7-8Symbol-iterator（review）" class="headerlink" title="3.4.7.8Symbol.iterator（review）"></a>3.4.7.8<code>Symbol.iterator（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由<code>for-of</code>语句使用”。换句话说，这个符号表示实现迭代器API的函数。</p>
<p><code>for-of</code>循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以<code>Symbol.iterator</code>为键的函数，并默认这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>Generator</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>技术上，这个由<code>Symbol.iterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回值。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过生成器函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.idx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">count();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-9Symbol-match-（review）"><a href="#3-4-7-9Symbol-match-（review）" class="headerlink" title="3.4.7.9Symbol.match``（review）"></a>3.4.7.9<code>Symbol.match``（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用”。<code>String.prototype.match()</code>方法会使用以<code>Symbol.match</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]);</span><br><span class="line"><span class="comment">// f [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义<code>Symbol.match</code>函数以取代默认对正则表达式求值的行为，从而让<code>match()</code>方法使用非正则表达式实例。<code>Symbol.match</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(FooMatcher)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(FooMatcher)); <span class="comment">// false</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMatcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-10Symbol-replace（review）"><a href="#3-4-7-10Symbol-replace（review）" class="headerlink" title="3.4.7.10Symbol.replace（review）"></a>3.4.7.10<code>Symbol.replace（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>方法使用”。<code>String.prototype.replace()</code>方法会使用以<code>Symbol.replace</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]);</span><br><span class="line"><span class="comment">// f [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.replace(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.replace</code>函数以取代默认对正则表达式求值的行为，从而让<code>replace()</code>方法使用非正则表达式实例。<code>Symbol.replace</code>函数接收两个参数，即调用<code>replace()</code>方法的字符串实例和替换字符串。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooReplacer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(FooReplacer, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReplacer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(<span class="keyword">new</span> StringReplacer(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-11Symbol-search（review）"><a href="#3-4-7-11Symbol-search（review）" class="headerlink" title="3.4.7.11Symbol.search（review）"></a>3.4.7.11<code>Symbol.search（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用”。<code>String.prototype.search()</code>方法会使用以<code>Symbol.search</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]);</span><br><span class="line"><span class="comment">// f [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.search</code>函数以取代默认对正则表达式求值的行为，从而让<code>search()</code>方法使用非正则表达式实例。<code>Symbol.search</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSearcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(FooSearcher)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(FooSearcher)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(FooSearcher)); <span class="comment">// -1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSearcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-12Symbol-species（review）"><a href="#3-4-7-12Symbol-species（review）" class="headerlink" title="3.4.7.12Symbol.species（review）"></a>3.4.7.12<code>Symbol.species（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用<code>Symbol.species</code>定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);   <span class="comment">// true</span></span><br><span class="line">bar = bar.concat(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// true</span></span><br><span class="line">baz = baz.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-13Symbol-split（review）"><a href="#3-4-7-13Symbol-split（review）" class="headerlink" title="3.4.7.13Symbol.split（review）"></a>3.4.7.13<code>Symbol.split（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用”。<code>String.prototype.split()</code>方法会使用以<code>Symbol.split</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]);</span><br><span class="line"><span class="comment">// f [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.split(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.split</code>函数以取代默认对正则表达式求值的行为，从而让<code>split()</code>方法使用非正则表达式实例。<code>Symbol.split</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSplitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(FooSplitter));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSplitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(<span class="keyword">new</span> StringSplitter(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-14Symbol-toPrimitive（review）"><a href="#3-4-7-14Symbol-toPrimitive（review）" class="headerlink" title="3.4.7.14Symbol.toPrimitive（review）"></a>3.4.7.14<code>Symbol.toPrimitive（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的<code>Symbol.toPrimitive</code>属性上定义一个函数可以改变默认行为。</p>
<p>根据提供给这个函数的参数（<code>string</code>、<code>number</code>或<code>default</code>），可以控制返回的原始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo);       <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo);       <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));   <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + bar);     <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - bar);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-15Symbol-toStringTag（review）"><a href="#3-4-7-15Symbol-toStringTag（review）" class="headerlink" title="3.4.7.15Symbol.toStringTag（review）"></a>3.4.7.15<code>Symbol.toStringTag（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用”。</p>
<p>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s);                      <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString());           <span class="comment">// [object Set]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Set</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo);                      <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString());           <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar);                      <span class="comment">// Bar &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString());           <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-16Symbol-unscopables（review）"><a href="#3-4-7-16Symbol-unscopables（review）" class="headerlink" title="3.4.7.16Symbol.unscopables（review）"></a>3.4.7.16<code>Symbol.unscopables（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的<code>with</code>环境绑定中排除”。设置这个符号并让其映射对应属性的键值为<code>true</code>，就可以阻止该属性出现在<code>with</code>环境绑定中，如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">  foo: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>不推荐使用<code>with</code>，因此也不推荐使用<code>Symbol.unscopables</code>。</p>
</blockquote>
<h3 id="3-4-8Object类型"><a href="#3-4-8Object类型" class="headerlink" title="3.4.8Object类型"></a>3.4.8<code>Object</code>类型</h3><p>ECMAScript中的对象其实就是一组数据和功能的集合。对象通过<code>new</code>操作符后跟对象类型的名称来创建。开发者可以通过创建<code>Object</code>类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这个语法类似Java，但ECMAScript只要求在给构造函数提供参数时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure>
<p><code>Object</code>的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java中的<code>java.lang.Object</code>，ECMAScript中的<code>Object</code>也是派生其他对象的基类。<code>Object</code>类型的所有属性和方法在派生的对象上同样存在。<br>每个<code>Object</code>实例都有如下属性和方法。</p>
<ul>
<li><code>constructor</code>：用于创建当前对象的函数。</li>
<li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li>
<li><code>isPrototypeof(object)</code>：用于判断当前对象是否为另一个对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用<code>for-in</code>语句枚举。与<code>hasOwnProperty()</code>一样，属性名必须是字符串。</li>
<li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li><code>toString()</code>：返回对象的字符串表示。</li>
<li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li>
</ul>
<p>因为在ECMAScript中<code>Object</code>是所有对象的基类，所以任何对象都有这些属性和方法。</p>
<blockquote>
<p><strong>注意</strong>严格来讲，ECMA-262中对象的行为不一定适合JavaScript中的其他对象。比如浏览器环境中的BOM和DOM对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ECMA-262约束，所以它们可能会也可能不会继承<code>Object</code>。</p>
</blockquote>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5　操作符"></a>3.5　操作符</h2><p>ECMA-262描述了一组可用于操作数据值的<strong>操作符</strong>，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code>valueOf()</code>和<code>/</code>或<code>toString()</code>方法来取得可以计算的值。</p>
<h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1　一元操作符"></a>3.5.1　一元操作符</h3><p>只操作一个值的操作符叫<strong>一元操作符</strong>（unary operator），是ECMAScript中最简单的操作符。</p>
<h4 id="3-5-1-1-递增-递减操作符"><a href="#3-5-1-1-递增-递减操作符" class="headerlink" title="3.5.1.1   递增/递减操作符"></a><strong>3.5.1.1   递增/递减操作符</strong></h4><p>递增和递减操作符有两个版本：前缀版和后缀版。前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p>
<p>前缀递增操作符会给数值加1，把两个加号（<code>++</code>）放到变量前头即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">++age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<p>前缀递减操作符也类似。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">--age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//28</span></span><br></pre></td></tr></table></figure>
<p>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有<strong>副作用</strong>。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);         <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>递增和递减的后缀版语法一样（分别是<code>++</code>和<code>--</code>），只不过要放在变量后面。后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。某些情况下，这种差异没影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">age++;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<p>把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>这4个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。<br>    1. 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。<br>    2. 对于字符串，如果不是有效的数值形式，则将变量的值设置为<code>NaN</code>。变量类型从字符串变成数值。<br>    3. 对于布尔值，如果是<code>false</code>，则转换为0再应用改变。变量类型从布尔值变成数值。<br>    4. 对于布尔值，如果是<code>true</code>，则转换为1再应用改变。变量类型从布尔值变成数值。<br>    5. 对于浮点值，加1或减1。<br>    6. 如果是对象，则调用其<code>valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code>NaN</code>，则调用<code>toString()</code>并再次应用其他规则。变量类型从对象变成数值。</p>
<p>下面的例子演示了这些规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++;  <span class="comment">// 值变成数值3</span></span><br><span class="line">s2++;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b++;   <span class="comment">// 值变成数值1</span></span><br><span class="line">f--;   <span class="comment">// 值变成0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--;   <span class="comment">// 值变成-2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-1-2-一元加和减"><a href="#3-5-1-2-一元加和减" class="headerlink" title="3.5.1.2   一元加和减"></a><strong>3.5.1.2   一元加和减</strong></h4><p><strong>一元加和减操作符</strong>在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（<code>+</code>）表示，放在变量前头，对数值没有任何影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = +num;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>如果将一元减应用到非数值，则会执行与使用<code>Number()</code>转型函数一样的类型转换：布尔值<code>false</code>和<code>true</code>转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的<code>valueOf()</code>和/或<code>toString()</code>方法以得到可以转换的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;  <span class="comment">// 值变成数值1</span></span><br><span class="line">s2 = +s2;  <span class="comment">// 值变成数值1.1</span></span><br><span class="line">s3 = +s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = +b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = +f;    <span class="comment">// 不变，还是1.1</span></span><br><span class="line">o = +o;    <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure>
<p>一元减由一个减号（<code>-</code>）表示，放在变量前头，主要用于把数值变成负值，如把1转换为-1。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// -25</span></span><br></pre></td></tr></table></figure>
<p>在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = -s1;  <span class="comment">// 值变成数值-1</span></span><br><span class="line">s2 = -s2;  <span class="comment">// 值变成数值-1.1</span></span><br><span class="line">s3 = -s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = -b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = -f;    <span class="comment">// 变成-1.1</span></span><br><span class="line">o = -o;    <span class="comment">// 值变成数值1</span></span><br></pre></td></tr></table></figure>
<p>一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。</p>
<h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2　位操作符"></a>3.5.2　位操作符</h3><p>ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。但这个转换也导致了一个奇特的副作用，即特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0处理。</p>
<p>如果将位操作符应用到非数值，那么首先会自动使用<code>Number()</code>函数将该值转换为数值，然后再应用位操作。最终结果是数值。要注意的是，在处理有符号整数时，我们无法访问第31位。</p>
<p>在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = -<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;-10010&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>默认情况下，ECMAScript中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p>
<h4 id="3-5-2-1-按位非"><a href="#3-5-2-1-按位非" class="headerlink" title="3.5.2.1   按位非"></a><strong>3.5.2.1   按位非</strong></h4></blockquote>
<p>按位非操作符用波浪符（<code>~</code>）表示，它的作用是返回数值的一补数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;      <span class="comment">// 二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1;   <span class="comment">// 二进制11111111111111111111111111100110</span></span><br><span class="line"><span class="built_in">console</span>.log(num2);  <span class="comment">// -26</span></span><br></pre></td></tr></table></figure>
<p>由此可以看出，按位非的最终效果是对数值取反并减1，就像执行如下操作的结果一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = -num1 - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2);   <span class="comment">// &quot;-26&quot;</span></span><br></pre></td></tr></table></figure>
<p>尽管两者返回的结果一样，但位操作的速度快得多。因为位操作是在数值的底层表示上完成的。</p>
<h4 id="3-5-2-2-按位与"><a href="#3-5-2-2-按位与" class="headerlink" title="3.5.2.2   按位与"></a><strong>3.5.2.2   按位与</strong></h4><p>按位与操作符用和号（<code>&amp;</code>）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p>
<p>|第一个数值的位|第二个数值的位|结果|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|1|1|1|<br>|1|0|0|<br>|0|1|0|<br>|0|0|0|</p>
<p>下面看一个例子，我们对数值25和3求与操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>看下面的二进制计算过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure>
<p>如上所示，25和3的二进制表示中，只有第0位上的两个数都是1。于是结果数值的所有其他位都会以0填充，因此结果就是1。</p>
<h4 id="3-5-2-3-按位或"><a href="#3-5-2-3-按位或" class="headerlink" title="3.5.2.3   按位或"></a><strong>3.5.2.3   按位或</strong></h4><p>按位或操作符用管道符（<code>|</code>）表示，同样有两个操作数。按位或遵循如下真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数值的位</th>
<th align="left">第二个数值的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>仍然用按位与的示例，如果对25和3执行按位或，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<p>可见25和3的按位或操作的结果是27：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"> OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>
<p>在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。</p>
<h4 id="3-5-2-4-按位异或"><a href="#3-5-2-4-按位异或" class="headerlink" title="3.5.2.4   按位异或"></a><strong>3.5.2.4   按位异或</strong></h4><p>按位异或用脱字符（<code>^</code>）表示，同样有两个操作数。下面是按位异或的真值表：</p>
<table>
<thead>
<tr>
<th align="left">第一个数的位</th>
<th align="left">第二个数的位</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>对数值25和3执行按位异或操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let result &#x3D; 25 ^ 3;</span><br><span class="line">console.log(result); &#x2F;&#x2F; 26</span><br></pre></td></tr></table></figure>
<p>可见，25和3的按位异或操作结果为26，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">XOR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-5-左移"><a href="#3-5-2-5-左移" class="headerlink" title="3.5.2.5   左移"></a><strong>3.5.2.5   左移</strong></h4><p>左移操作符用两个小于号（<code>&lt;&lt;</code>）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值2（二进制10）向左移5位，就会得到64（二进制1000000），如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;              <span class="comment">// 等于二进制10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;  <span class="comment">// 等于二进制1000000，即十进制64</span></span><br></pre></td></tr></table></figure>
<p>注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值（见图3-2）。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/b7qdJi277GnnBKhO__thumbnail.png"
                      alt="图片"
                ></p>
<p>左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。</p>
<h4 id="3-5-2-6-有符号右移"><a href="#3-5-2-6-有符号右移" class="headerlink" title="3.5.2.6   有符号右移"></a><strong>3.5.2.6   有符号右移</strong></h4><p>有符号右移由两个大于号（<code>&gt;&gt;</code>）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;             <span class="comment">// 等于二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;  <span class="comment">// 等于二进制10，即十进制2</span></span><br></pre></td></tr></table></figure>
<p>同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图3-3）。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/note/JavaScript/lfyDtLTtly9xPjgW__thumbnail.png"
                      alt="图片"
                ></p>
<h4 id="3-5-2-7-无符号右移"><a href="#3-5-2-7-无符号右移" class="headerlink" title="3.5.2.7   无符号右移"></a><strong>3.5.2.7   无符号右移</strong></h4><p>无符号右移用3个大于号表示（<code>&gt;&gt;&gt;</code>），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。</p>
<p>对于负数，有时候差异会非常大。右移会给空位补0，而不管符号位是什么。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = -<span class="number">64</span>;              <span class="comment">// 等于二进制11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;   <span class="comment">// 等于十进制134217726</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3　布尔操作符"></a>3.5.3　布尔操作符</h3><p>布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。</p>
<h4 id="3-5-3-1-逻辑非"><a href="#3-5-3-1-逻辑非" class="headerlink" title="3.5.3.1   逻辑非"></a><strong>3.5.3.1   逻辑非</strong></h4><p>逻辑非操作符由一个叹号（<code>!</code>）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。</p>
<pre><code>1. 如果操作数是对象，则返回`false`。
2. 如果操作数是空字符串，则返回`true`。
3. 如果操作数是非空字符串，则返回`false`。
4. 如果操作数是数值0，则返回`true`。
5. 如果操作数是非0数值（包括`Infinity`），则返回`false`。
6. 如果操作数是`null`，则返回`true`。
7. 如果操作数是`NaN`，则返回`true`。
8. 如果操作数是`undefined`，则返回`true`。</code></pre>
<p>以下示例验证了上述行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;blue&quot;</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;&quot;</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">12345</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（<code>!!</code>），相当于调用了转型函数<code>Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用<code>Boolean()</code>函数是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;blue&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">12345</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-2-逻辑与"><a href="#3-5-3-2-逻辑与" class="headerlink" title="3.5.3.2   逻辑与"></a><strong>3.5.3.2   逻辑与</strong></h4><p>逻辑与操作符由两个和号（<code>&amp;&amp;</code>）表示，应用到两个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>逻辑与操作符遵循如下真值表：<br>|第一个操作数|第二个操作数|结果|<br>|:—-|:—-|:—-|<br>|true|true|true|<br>|true|false|false|<br>|false|true|false|<br>|false|false|false|</p>
<p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。</p>
<pre><code>1. 如果第一个操作数是对象，则返回第二个操作数。
2. 如果第二个操作数是对象，则只有第一个操作数求值为`true`才会返回该对象。
3. 如果两个操作数都是对象，则返回第二个操作数。
4. 如果有一个操作数是`null`，则返回`null`。
5. 如果有一个操作数是`NaN`，则返回`NaN`。
6. 如果有一个操作数是`undefined`，则返回`undefined`。</code></pre>
<p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是<code>false</code>，那么无论第二个操作数是什么值，结果也不可能等于<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable); <span class="comment">// 这里会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 不会执行这一行</span></span><br></pre></td></tr></table></figure>
<p>假如变量<code>found</code>的值是<code>false</code>，那么就不会报错了：</p>
<h4 id="3-5-3-3-逻辑或"><a href="#3-5-3-3-逻辑或" class="headerlink" title="3.5.3.3   逻辑或"></a><strong>3.5.3.3   逻辑或</strong></h4><p>逻辑或操作符由两个管道符（<code>||</code>）表示，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="literal">true</span> || <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>逻辑或操作符遵循如下真值表：<br>|第一个操作数|第二个操作数|结果|<br>|:—-|:—-|:—-|<br>|true|true|true|<br>|true|false|true|<br>|false|true|true|<br>|false|false|false|</p>
<p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。</p>
<pre><code>1. 如果第一个操作数是对象，则返回第一个操作数。
2. 如果第一个操作数求值为`false`，则返回第二个操作数。
3. 如果两个操作数都是对象，则返回第一个操作数。
4. 如果两个操作数都是`null`，则返回`null`。
5. 如果两个操作数都是`NaN`，则返回`NaN`。
6. 如果两个操作数都是`undefined`，则返回`undefined`。</code></pre>
<p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为<code>true</code>，第二个操作数就不会再被求值了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable); <span class="comment">// 不会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure>
<p>利用这个行为，可以避免给变量赋值<code>null</code>或<code>undefined</code>。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = preferredObject || backupObject;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，变量<code>myObject</code>会被赋予两个值中的一个。其中，<code>preferredObject</code>变量包含首选的值，<code>backupObject</code>变量包含备用的值。如果<code>preferredObject</code>不是<code>null</code>，则它的值就会赋给<code>myObject</code>；如果<code>preferredObject</code>是<code>null</code>，则<code>backupObject</code>的值就会赋给<code>myObject</code>。这种模式在ECMAScript代码中经常用于变量赋值。</p>
<h3 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4　乘性操作符"></a>3.5.4　乘性操作符</h3><p>ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用<code>Number()</code>转型函数转换为数值。这意味着空字符串会被当成0，而布尔值<code>true</code>会被当成1。</p>
<h4 id="3-5-4-1-乘法操作符"><a href="#3-5-4-1-乘法操作符" class="headerlink" title="3.5.4.1   乘法操作符"></a><strong>3.5.4.1   乘法操作符</strong></h4><p>乘法操作符由一个星号（<code>*</code>）表示，可以用于计算两个数值的乘积。其语法类似于C语言。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">34</span> * <span class="number">56</span>;</span><br></pre></td></tr></table></figure>
<p>乘法操作符在处理特殊值时也有一些特殊的行为。</p>
<ol>
<li>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果ECMAScript不能表示乘积，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>乘以非0的有限数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>乘以<code>Infinity</code>，则返回<code>Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-2-除法操作符"><a href="#3-5-4-2-除法操作符" class="headerlink" title="3.5.4.2   除法操作符"></a><strong>3.5.4.2   除法操作符</strong></h4></li>
</ol>
<p>除法操作符由一个斜杠（<code>/</code>）表示，用于计算第一个操作数除以第二个操作数的商，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">66</span> / <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>除法操作符针对特殊值也有一些特殊的行为。</p>
<ol>
<li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果是0除以0，则返回<code>NaN</code>。</li>
<li>如果是非0的有限值除以0，则根据第一个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果是<code>Infinity</code>除以任何数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-3-取模操作符-reivew"><a href="#3-5-4-3-取模操作符-reivew" class="headerlink" title="3.5.4.3   取模操作符(reivew)"></a><strong>3.5.4.3   取模操作符(reivew)</strong></h4></li>
</ol>
<p>取模（余数）操作符由一个百分比符号（<code>%</code>）表示，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">26</span> % <span class="number">5</span>; <span class="comment">// 等于1</span></span><br></pre></td></tr></table></figure>
<p>取模操作符对特殊值也有一些特殊的行为。</p>
<ol>
<li>如果操作数是数值，则执行常规除法运算，返回余数。</li>
<li>如果被除数是无限值，除数是有限值，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是0，则返回<code>NaN</code>。</li>
<li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li>
<li>如果被除数是有限值，除数是无限值，则返回被除数。</li>
<li>如果被除数是0，除数不是0，则返回0。</li>
<li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h3 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5　指数操作符"></a>3.5.5　指数操作符</h3></li>
</ol>
<p>ECMAScript 7新增了指数操作符，<code>Math.pow()</code>现在有了自己的操作符<code>**</code>，结果是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>);         <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>指数操作符也有自己的指数赋值操作符<code>**=</code>，该操作符执行指数运算和结果的赋值操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared **= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6　加性操作符"></a>3.5.6　加性操作符</h3><p>加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。但在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p>
<h4 id="3-5-6-1-加法操作符（review）"><a href="#3-5-6-1-加法操作符（review）" class="headerlink" title="3.5.6.1   加法操作符（review）"></a><strong>3.5.6.1   加法操作符（review）</strong></h4><p>加法操作符（<code>+</code>）用于求两个数的和，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：<br>    1. 如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>；<br>    2. 如果是<code>Infinity</code>加<code>Infinity</code>，则返回<code>Infinity</code>；<br>    3. 如果是<code>-Infinity</code>加<code>-Infinity</code>，则返回<code>-Infinity</code>；<br>    4. 如果是<code>Infinity</code>加<code>-Infinity</code>，则返回<code>NaN</code>；<br>    5. 如果是<code>+0</code>加<code>+0</code>，则返回<code>+0</code>；<br>    6. 如果是<code>-0</code>加<code>+0</code>，则返回<code>+0</code>；<br>    7. 如果是<code>-0</code>加<code>-0</code>，则返回<code>-0</code>。</p>
<p>不过，如果有一个操作数是字符串，则要应用如下规则：</p>
<pre><code>1. 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；
2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</code></pre>
<p>如果有任一操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法以获取字符串，然后再应用前面的关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则调用<code>String()</code>函数，分别获取<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> + <span class="number">5</span>;        <span class="comment">// 两个数值</span></span><br><span class="line"><span class="built_in">console</span>.log(result1);       <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;      <span class="comment">// 一个数值和一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);       <span class="comment">// &quot;55&quot;</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br></pre></td></tr></table></figure>
<p>这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值，结果是一个字符串。第二次加法仍然是用一个字符串去加一个数值，同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + (num1 + num2);</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;The sum of 5 and 10 is 15&quot;</span></span><br></pre></td></tr></table></figure>
<p>在此，我们用括号把两个数值变量括了起来，意思是让解释器先执行两个数值的加法，然后再把结果追加给字符串。因此，最终得到的字符串变成了<code>&quot;The sum of 5 and 10 is 15&quot;</code>。</p>
<h4 id="3-5-6-2-减法操作符-review"><a href="#3-5-6-2-减法操作符-review" class="headerlink" title="3.5.6.2   减法操作符(review)"></a><strong>3.5.6.2   减法操作符(review)</strong></h4><p>减法操作符（<code>-</code>）也是使用很频繁的一种操作符，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。<br>    1. 如果两个操作数都是数值，则执行数学减法运算并返回结果。<br>    2. 如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。<br>    3. 如果是<code>Infinity</code>减<code>Infinity</code>，则返回<code>NaN</code>。<br>    4. 如果是<code>-Infinity</code>减<code>-Infinity</code>，则返回<code>NaN</code>。<br>    5. 如果是<code>Infinity</code>减<code>-Infinity</code>，则返回<code>Infinity</code>。<br>    6. 如果是<code>-Infinity</code>减<code>Infinity</code>，则返回<code>-Infinity</code>。<br>    7. 如果是<code>+0</code>减<code>+0</code>，则返回<code>+0</code>。<br>    8. 如果是<code>+0</code>减<code>-0</code>，则返回<code>-0</code>。<br>    9. 如果是<code>-0</code>减<code>-0</code>，则返回<code>+0</code>。<br>    10. 如果有任一操作数是字符串、布尔值、<code>null</code>或<code>undefined</code>，则先在后台使用<code>Number()</code>将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。<br>    11. 如果有任一操作数是对象，则调用其<code>valueOf()</code>方法取得表示它的数值。如果该值是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法，然后再将得到的字符串转换为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> - <span class="literal">true</span>; <span class="comment">// true被转换为1，所以结果是4</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> - <span class="number">1</span>;  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> - <span class="number">3</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;   <span class="comment">// &quot;&quot;被转换为0，所以结果是5</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;  <span class="comment">// &quot;2&quot;被转换为2，所以结果是3</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// null被转换为0，所以结果是5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7　关系操作符"></a>3.5.7　关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）和大于等于（<code>&gt;=</code>）。这几个操作符都返回布尔值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p>
<ul>
<li>如果操作数都是数值，则执行数值比较。</li>
<li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li>
<li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li>
<li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法，取得结果后再根据前面的规则执行比较。如果没有<code>valueOf()</code>操作符，则调用<code>toString()</code>方法，取得结果后再根据前面的规则执行比较。</li>
<li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
</ul>
<p>在使用关系操作符比较两个字符串时，很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span> &lt; <span class="string">&quot;alphabet&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式，然后再比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alphabet&quot;</span>.toLowerCase(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>另一个奇怪的现象是在比较两个数值字符串的时候，比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符<code>&quot;2&quot;</code>的编码是50，而字符<code>&quot;3&quot;</code>的编码是51）。如果有一个操作数是数值，那么比较的结果就对了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>只要是数值和字符串比较，字符串就会先被转换为数值，然后进行数值比较。对于数值字符串而言，这样能保证结果正确。<br>如果字符串不能转换成数值呢？比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// 因为&quot;a&quot;会转换为NaN，所以结果是false</span></span><br></pre></td></tr></table></figure>
<p>因为字符<code>&quot;a&quot;</code>不能转换成任何有意义的数值，所以只能转换为<code>NaN</code>。这里有一个规则，即任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8　相等操作符"></a>3.5.8　相等操作符</h3><p>判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是<strong>等于</strong>和<strong>不等于</strong>，它们在比较之前执行转换。第二组是<strong>全等</strong>和<strong>不全等</strong>，它们在比较之前不执行转换。</p>
<h4 id="3-5-8-1-等于和不等于"><a href="#3-5-8-1-等于和不等于" class="headerlink" title="3.5.8.1   等于和不等于"></a><strong>3.5.8.1   等于和不等于</strong></h4><p>ECMAScript中的等于操作符用两个等于号（<code>==</code>）表示，如果操作数相等，则会返回<code>true</code>。不等于操作符用叹号和等于号（<code>!=</code>）表示，如果两个操作数不相等，则会返回<code>true</code>。这两个操作符都会先进行类型转换（通常称为<strong>强制类型转换</strong>）再确定操作数是否相等。</p>
<p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p>
<ol>
<li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。</li>
<li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的<code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较。</li>
</ol>
<p>在进行比较时，这两个操作符会遵循如下规则。</p>
<ol>
<li><code>null</code>和<code>undefined</code>相等。</li>
<li><code>null</code>和<code>undefined</code>不能转换为其他类型的值再进行比较。</li>
<li>如果有任一操作数是<code>NaN</code>，则相等操作符返回<code>false</code>，不相等操作符返回<code>true</code>。记住：即使两个操作数都是<code>NaN</code>，相等操作符也返回<code>false</code>，因为按照规则，<code>NaN</code>不等于<code>NaN</code>。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code>true</code>。否则，两者不相等。</li>
</ol>
<p>下表总结了一些特殊情况及比较的结果。</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null == undefined</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">“NaN” == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">5 == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN == NaN</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">NaN != NaN</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">false == 0</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 1</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">true == 2</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">undefined == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">null == 0</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">“5” == 5</td>
<td align="left">true</td>
</tr>
</tbody></table>
<h4 id="3-5-8-2-全等和不全等"><a href="#3-5-8-2-全等和不全等" class="headerlink" title="3.5.8.2   全等和不全等"></a><strong>3.5.8.2   全等和不全等</strong></h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3个等于号（<code>===</code>）表示，只有两个操作数在不转换的前提下相等才返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>);  <span class="comment">// true，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<p>不全等操作符用一个叹号和两个等于号（<code>!==</code>）表示，只有两个操作数在不转换的前提下不相等才返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> != <span class="number">55</span>);  <span class="comment">// false，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> !== <span class="number">55</span>); <span class="comment">// true，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<p>另外虽然<code>null == undefined</code>是<code>true</code>（因为这两个值类似），但<code>null === undefined</code>是<code>false</code>，因为它们不是相同的数据类型。</p>
<blockquote>
<p><strong>注意</strong>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p>
</blockquote>
<h3 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9　条件操作符"></a>3.5.9　条件操作符</h3><p>条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10　赋值操作符"></a>3.5.10　赋值操作符</h3><p>简单赋值用等于号（<code>=</code>）表示，将右手边的值赋给左手边的变量，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值使用乘性、加性或位操作符后跟等于号（<code>=</code>）表示。这些赋值操作符是类似如下常见赋值操作的简写形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = num + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码的第二行可以通过复合赋值来完成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p>
<ul>
<li>乘后赋值（<code>*=</code>）</li>
<li>除后赋值（<code>/=</code>）</li>
<li>取模后赋值（<code>%=</code>）</li>
<li>加后赋值（<code>+=</code>）</li>
<li>减后赋值（<code>-=</code>）</li>
<li>左移后赋值（<code>&lt;&lt;=</code>）</li>
<li>右移后赋值（<code>&gt;&gt;=</code>）</li>
<li>无符号右移后赋值（<code>&gt;&gt;&gt;=</code>）</li>
</ul>
<p>这些操作符仅仅是简写语法，使用它们不会提升性能。</p>
<h3 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11　逗号操作符"></a>3.5.11　逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>num</code>将被赋值为0，因为0是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</p>
<h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6　语句"></a>3.6　语句</h2><p>ECMA-262描述了一些语句（也称为<strong>流控制语句</strong>），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p>
<h3 id="3-6-1if语句"><a href="#3-6-1if语句" class="headerlink" title="3.6.1if语句"></a>3.6.1<code>if</code>语句</h3><p><code>if</code>语句是使用最频繁的语句之一，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的最佳实践是使用语句块，即使只有一行代码要执行也是如此。这是因为语句块可以避免对什么条件下执行什么产生困惑。可以像这样连续使用多个<code>if</code>语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-2do-while语句"><a href="#3-6-2do-while语句" class="headerlink" title="3.6.2do-while语句"></a>3.6.2<code>do-while</code>语句</h3><p><code>do-while</code>语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。<code>do-while</code>的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>后测试循环经常用于这种情形：循环体内代码在退出前至少要执行一次。</p>
</blockquote>
<h3 id="3-6-3while语句"><a href="#3-6-3while语句" class="headerlink" title="3.6.3while语句"></a>3.6.3<code>while</code>语句</h3><p><code>while</code>语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code>循环体内的代码有可能不会执行。下面是<code>while</code>循环的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-4for语句"><a href="#3-6-4for语句" class="headerlink" title="3.6.4for语句"></a>3.6.4<code>for</code>语句</h3><p><code>for</code>语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>for</code>循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用<code>let</code>声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。<br>初始化、条件表达式和循环后表达式都不是必需的。因此可以创建一个无穷循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无穷循环</span></span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只包含条件表达式，那么<code>for</code>循环实际上就变成了<code>while</code>循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; count; ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法通过<code>while</code>循环实现的逻辑，同样也无法使用<code>for</code>循环实现。因此<code>for</code>循环只是将循环相关的代码封装在了一起而已。</p>
<h3 id="3-6-5for-in语句"><a href="#3-6-5for-in语句" class="headerlink" title="3.6.5for-in语句"></a>3.6.5<code>for-in</code>语句</h3><p><code>for-in</code>语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里控制语句中的<code>const</code>也不是必需的。但为确保这个局部变量不被修改，推荐使用<code>const</code>。<br>ECMAScript中对象的属性是无序的，因此<code>for-in</code>语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p>
<p>如果<code>for-in</code>循环要迭代的变量是<code>null</code>或<code>undefined</code>，则不执行循环体。</p>
<h3 id="3-6-6for-of语句（review）"><a href="#3-6-6for-of语句（review）" class="headerlink" title="3.6.6for-of语句（review）"></a>3.6.6<code>for-of</code>语句（review）</h3><p><code>for-of</code>语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for-of</code>循环会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则<code>for-of</code>语句会抛出错误。</p>
<blockquote>
<p><strong>注意</strong>ES2018对<code>for-of</code>语句进行了扩展，增加了<code>for-await-of</code>循环，以支持生成期约（promise）的异步可迭代对象。。</p>
</blockquote>
<h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7　标签语句"></a>3.6.7　标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>start</code>是一个标签，可以在后面通过<code>break</code>或<code>continue</code>语句引用。标签语句的典型应用场景是嵌套循环。</p>
<h3 id="3-6-8break和continue语句"><a href="#3-6-8break和continue语句" class="headerlink" title="3.6.8break和continue语句"></a>3.6.8<code>break</code>和<code>continue</code>语句</h3><p><code>break</code>和<code>continue</code>语句为执行循环代码提供了更严格的控制手段。其中，<code>break</code>语句用于立即退出循环，强制执行循环后的下一条语句。而<code>continue</code>语句也用于立即退出循环，但会再次从循环顶部开始执行。</p>
<p><code>break</code>与标签语句一起使用，返回代码中特定的位置。通常是在嵌套循环中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<p>添加标签不仅让<code>break</code>退出（使用变量<code>j</code>）的内部循环，也会退出（使用变量<code>i</code>）的外部循环。<code>continue</code>语句也可以使用标签，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<p><code>continue</code>语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当<code>i</code>和<code>j</code>都等于5时，会执行<code>continue</code>，跳到外部循环继续执行。<br>组合使用标签语句和<code>break</code>、<code>continue</code>能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p>
<h3 id="3-6-9with语句（review）"><a href="#3-6-9with语句（review）" class="headerlink" title="3.6.9with语句（review）"></a>3.6.9<code>with</code>语句（review）</h3><p><code>with</code>语句的用途是将代码作用域设置为特定的对象，主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利,其语法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br></pre></td></tr></table></figure>
<p>上面代码中的每一行都用到了<code>location</code>对象。如果使用<code>with</code>语句，就可以少写一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>with</code>语句用于连接<code>location</code>对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索<code>location</code>对象，看它是否有一个同名的属性。如果有，则该变量会被求值为<code>location</code>对象的属性。<br>严格模式不允许使用<code>with</code>语句，否则会抛出错误。</p>
<blockquote>
<p><strong>警告</strong>由于<code>with</code>语句影响性能且难于调试其中的代码，通常不推荐使用<code>with</code>语句。</p>
</blockquote>
<h3 id="3-6-10switch语句"><a href="#3-6-10switch语句" class="headerlink" title="3.6.10switch语句"></a>3.6.10<code>switch</code>语句</h3><p><code>switch</code>语句是与<code>if</code>语句紧密相关的一种流控制语句，每个<code>case</code>（条件/分支）相当于：“如果表达式等于后面的值，则执行下面的语句。”<code>break</code>关键字会导致代码执行跳出<code>switch</code>语句。如果没有<code>break</code>，则代码会继续匹配下一个条件。<code>default</code>关键字用于在任何条件都没有满足时指定默认执行的语句（相当于<code>else</code>语句）。</p>
<p>为避免不必要的条件判断，最好给每个条件后面都加上<code>break</code>语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了<code>break</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="comment">/*跳过*/</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;25 or 35&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然<code>switch</code>语句是从其他语言借鉴过来的，但ECMAScript为它赋予了一些独有的特性。首先<code>switch</code>语句可以用于所有数据类型。其次，条件的值不需要是常量，也可以是变量或表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 10.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 10 and 20.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;More than 20.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><code>switch</code>语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型</p>
</blockquote>
<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7　函数"></a>3.7　函数</h2><p>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用<code>function</code>关键字声明，后跟一组参数，然后是函数体。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是调用函数<code>sayHi()</code>的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHi(<span class="string">&quot;Nicholas&quot;</span>, <span class="string">&quot;how are you today?&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用<code>return</code>语句来返回函数的值，用法是后跟要返回的值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了<code>return</code>语句之外没有任何特殊声明表明该函数有返回值。然后就可以这样调用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = sum(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>只要碰到<code>return</code>语句，函数会立即停止执行并退出。因此<code>return</code>语句后的代码不会被执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数里也可以有多个<code>return</code>语句，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num2 - num1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>return</code>语句也可以不带返回值。这时候，函数会立即停止执行并返回<code>undefined</code>。这种用法最常用于提前终止函数执行，并不是为了返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。</p>
</blockquote>
<p>严格模式对函数也有一些限制：</p>
<ul>
<li>函数不能以<code>eval</code>或<code>arguments</code>作为名称；</li>
<li>函数的参数不能叫<code>eval</code>或<code>arguments</code>；</li>
<li>两个函数的参数不能叫同一个名称。</li>
</ul>
<p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>
<h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8　小结"></a>3.8　小结</h2><p>JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。</p>
<ul>
<li>ECMAScript中的基本数据类型包括<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。</li>
<li>与其他语言不同，ECMAScript不区分整数和浮点值，只有<code>Number</code>一种数值数据类型。</li>
<li><code>Object</code>是一种复杂数据类型，它是这门语言中所有对象的基类。</li>
<li>严格模式为这门语言中某些容易出错的部分施加了限制。</li>
<li>ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。</li>
<li>这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如<code>if</code>语句、<code>for</code>语句和<code>switch</code>语句等。</li>
</ul>
<p>ECMAScript中的函数与其他语言中的函数不一样。</p>
<ul>
<li>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。</li>
<li>不指定返回值的函数实际上会返回特殊值<code>undefined</code>。</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：03-语言基础</li>
        <li>本文作者：胡倚豪</li>
        <li>创建时间：2021-01-23 19:31:12</li>
        <li>
            本文链接：huonenumber.github.io/2021/01/23/note/JavaScript/03-语言基础/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/01/23/note/JavaScript/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">04-变量、作用域与内存</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/01/23/note/HTTP/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">15-实体和编码</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    
        
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oRtabIpmHUsCjAVoocAuRiR6-gzGzoHsz',
                    appKey: '8MQB6tSReJAP6eYmI5OGVpTo',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请尽情吐槽吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {

                        let author = '胡倚豪';
                        author && (author = author.toLocaleLowerCase());

                        for (let vcard of vcards) {
                            const vnick = vcard.querySelector('.vhead .vnick');
                            if (vnick.innerHTML.toLocaleLowerCase() === author) {
                                vnick.innerHTML = `${author} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>


    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span> -
            
            2021 &nbsp; <a href="/">胡倚豪</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数 <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量 <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <!-- <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.3.0</a>
        </div> -->
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E8%AF%AD%E6%B3%95"><span class="nav-text">3.1　语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-text">3.1.1　区分大小写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">3.1.2　标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E6%B3%A8%E9%87%8A"><span class="nav-text">3.1.3　注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-text">3.1.4　严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.1.5　语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="nav-text">3.2　关键字与保留字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%8F%98%E9%87%8F"><span class="nav-text">3.3　变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1var%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">3.3.1var关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-1var%E5%A3%B0%E6%98%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">3.3.1.1var声明作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-2var%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="nav-text">3.3.1.2var声明提升</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2let%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2let声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-1-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="nav-text">3.3.2.1**暂时性死区**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-2-%E5%85%A8%E5%B1%80%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2.2**全局声明**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-3-%E6%9D%A1%E4%BB%B6%E5%A3%B0%E6%98%8E%EF%BC%88review%EF%BC%89"><span class="nav-text">3.3.2.3**条件声明（review）**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-4for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84let%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.2.4for循环中的let声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3const%E5%A3%B0%E6%98%8E"><span class="nav-text">3.3.3const声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E5%A3%B0%E6%98%8E%E9%A3%8E%E6%A0%BC%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">3.3.4　声明风格及最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-1-%E4%B8%8D%E4%BD%BF%E7%94%A8var"><span class="nav-text">3.3.4.1   不使用var</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-2const%E4%BC%98%E5%85%88%EF%BC%8Clet%E6%AC%A1%E4%B9%8B"><span class="nav-text">3.3.4.2const优先，let次之</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4　数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1typeof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.4.1typeof操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2Undefined%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.2Undefined类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3Null%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.3Null类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4Boolean%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.4Boolean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5Number%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.5Number类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-1-%E6%B5%AE%E7%82%B9%E5%80%BC"><span class="nav-text">3.4.5.1   浮点值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-2-%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-text">3.4.5.2   值的范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-3NaN"><span class="nav-text">3.4.5.3NaN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-4-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.4.5.4   数值转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-6String%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.6String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-1-%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-text">3.4.6.1   字符字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">3.4.6.2字符串的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-3-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.4.6.3   转换为字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-4-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.6.4   模板字面量（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.6.5   字符串插值（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-6-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A0%87%E7%AD%BE%E5%87%BD%E6%95%B0%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.6.6   模板字面量标签函数（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-7-%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2-review"><span class="nav-text">3.4.6.7   原始字符串(review)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-7Symbol%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.7Symbol类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-1-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">3.4.7.1   符号的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-2-%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="nav-text">3.4.7.2   使用全局符号注册表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-3-%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7-review"><span class="nav-text">3.4.7.3   使用符号作为属性(review)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-4-%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7"><span class="nav-text">3.4.7.4   常用内置符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-5Symbol-asyncIterator%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.5Symbol.asyncIterator（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-6Symbol-hasInstance"><span class="nav-text">3.4.7.6Symbol.hasInstance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-7Symbol-isConcatSpreadable%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.7Symbol.isConcatSpreadable（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-8Symbol-iterator%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.8Symbol.iterator（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-9Symbol-match-%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.9Symbol.match&#96;&#96;（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-10Symbol-replace%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.10Symbol.replace（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-11Symbol-search%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.11Symbol.search（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-12Symbol-species%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.12Symbol.species（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-13Symbol-split%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.13Symbol.split（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-14Symbol-toPrimitive%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.14Symbol.toPrimitive（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-15Symbol-toStringTag%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.15Symbol.toStringTag（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-7-16Symbol-unscopables%EF%BC%88review%EF%BC%89"><span class="nav-text">3.4.7.16Symbol.unscopables（review）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-8Object%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.4.8Object类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5　操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.1　一元操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-1-%E9%80%92%E5%A2%9E-%E9%80%92%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.1.1   递增&#x2F;递减操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-2-%E4%B8%80%E5%85%83%E5%8A%A0%E5%92%8C%E5%87%8F"><span class="nav-text">3.5.1.2   一元加和减</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.2　位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-1-%E6%8C%89%E4%BD%8D%E9%9D%9E"><span class="nav-text">3.5.2.1   按位非</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-2-%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="nav-text">3.5.2.2   按位与</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-3-%E6%8C%89%E4%BD%8D%E6%88%96"><span class="nav-text">3.5.2.3   按位或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-4-%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="nav-text">3.5.2.4   按位异或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-5-%E5%B7%A6%E7%A7%BB"><span class="nav-text">3.5.2.5   左移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-6-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-text">3.5.2.6   有符号右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-7-%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-text">3.5.2.7   无符号右移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.3　布尔操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-1-%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-text">3.5.3.1   逻辑非</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-2-%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="nav-text">3.5.3.2   逻辑与</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-3-%E9%80%BB%E8%BE%91%E6%88%96"><span class="nav-text">3.5.3.3   逻辑或</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4　乘性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-1-%E4%B9%98%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4.1   乘法操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-2-%E9%99%A4%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.4.2   除法操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-3-%E5%8F%96%E6%A8%A1%E6%93%8D%E4%BD%9C%E7%AC%A6-reivew"><span class="nav-text">3.5.4.3   取模操作符(reivew)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.5　指数操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-6-%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.6　加性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-6-1-%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88review%EF%BC%89"><span class="nav-text">3.5.6.1   加法操作符（review）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-6-2-%E5%87%8F%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6-review"><span class="nav-text">3.5.6.2   减法操作符(review)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.7　关系操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-8-%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.8　相等操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-8-1-%E7%AD%89%E4%BA%8E%E5%92%8C%E4%B8%8D%E7%AD%89%E4%BA%8E"><span class="nav-text">3.5.8.1   等于和不等于</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-8-2-%E5%85%A8%E7%AD%89%E5%92%8C%E4%B8%8D%E5%85%A8%E7%AD%89"><span class="nav-text">3.5.8.2   全等和不全等</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-9-%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.9　条件操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-10-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.10　赋值操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-11-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">3.5.11　逗号操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6　语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1if%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.1if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2do-while%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.2do-while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3while%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.3while语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4for%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.4for语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5for-in%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.5for-in语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-6for-of%E8%AF%AD%E5%8F%A5%EF%BC%88review%EF%BC%89"><span class="nav-text">3.6.6for-of语句（review）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-7-%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.7　标签语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-8break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.8break和continue语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-9with%E8%AF%AD%E5%8F%A5%EF%BC%88review%EF%BC%89"><span class="nav-text">3.6.9with语句（review）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-10switch%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.6.10switch语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E5%87%BD%E6%95%B0"><span class="nav-text">3.7　函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%B0%8F%E7%BB%93"><span class="nav-text">3.8　小结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
