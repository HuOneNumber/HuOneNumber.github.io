<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="HTML,CSS,JavaScript">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="胡倚豪">
    
    <title>
        
            15-实体和编码 |
        
        HuOneNumber | 个人博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#33FFCC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"description":"慢慢来，深几度。。。","background_img":"/images/bg.svg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="别着急，慢慢来" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                HuOneNumber | 个人博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">15-实体和编码</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">胡倚豪</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-01-23 19:00:09
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">HTTP权威指南</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/">15-实体和编码</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/HTTP/">HTTP</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>21 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="15-1-报文是箱子，实体是货物"><a href="#15-1-报文是箱子，实体是货物" class="headerlink" title="15.1 报文是箱子，实体是货物"></a>15.1 报文是箱子，实体是货物</h2><p>报文实体由实体首部和实体主体组成的。首部字段以一个空白的CRLF行结束，随后就是实体主体的原始内容。任何其他描述性的信息都包含在实体首部中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/cnoa3xepd6bS4Nf.png"
                      alt="YuTjZHTRjDigxdVP__thumbnail.png"
                ></p>
<h2 id="15-2-Content-Length：实体的大小"><a href="#15-2-Content-Length：实体的大小" class="headerlink" title="15.2 Content-Length：实体的大小"></a>15.2 Content-Length：实体的大小</h2><p>Content-Length首部指示出报文中实体主体的字节大小，包含了所有内容编码的。Content-Length首部就是带有实体主体的报文必须使用的，除非使用了分块编码。使用Content-Length首部能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段。</p>
<h3 id="15-2-1-检测截尾"><a href="#15-2-1-检测截尾" class="headerlink" title="15.2.1 检测截尾"></a>15.2.1 检测截尾</h3><p>HTTP的早期版本采用关闭连接的办法来划定报文的结束。但客户端无法区分是正常的连接关闭，还是由于服务器崩溃而导致的连接关闭。</p>
<p>客户端需要通过Content-Length来检测报文截尾。尤其对缓存代理服务器来说，如果收到被截尾的报文却没有识别出截尾的话，它可能会存储不完整的内容并多次使用它来提供服务。</p>
<p>缓存代理服务器通常不会为没有显式Content-Length首部的HTTP主体做缓存，以此来减小缓存已截尾报文的风险。</p>
<h3 id="15-2-2-错误的Content-Length"><a href="#15-2-2-错误的Content-Length" class="headerlink" title="15.2.2 错误的Content-Length"></a>15.2.2 错误的Content-Length</h3><p>错误的Content-Length比缺少Content-Length还要糟糕。因此有些客户端、服务器以及代理中就包含特别的算法，用来检测和纠正与有缺陷服务器的交互过程。HTTP/1.1规定用户Agent代理应该在接收且检测到无效长度时通知用户。</p>
<h3 id="15-2-3-Content-Length与持久连接"><a href="#15-2-3-Content-Length与持久连接" class="headerlink" title="15.2.3 Content-Length与持久连接"></a>15.2.3 Content-Length与持久连接</h3><p>因为如果响应通过持久连接传送，客户端无法依赖连接关闭来判别报文的结束，因此客户端通过Content-Length首部知道报文在何处结束，下一 条报文从何处开始。</p>
<p>采用<strong>分块编码</strong>（chunked encoding），使用持久连接时可以没有Content-Length首部。在分块编码的情况下，数据是分为一系列的块来发送的，每块都有大小说明。</p>
<h3 id="15-2-4-内容编码"><a href="#15-2-4-内容编码" class="headerlink" title="15.2.4 内容编码"></a>15.2.4 内容编码</h3><p>HTTP允许对实体主体的内容进行编码，可以使之更安全或进行压缩以节省空间。如果主体进行了内容编码，Content-Length说明的就是编码后主体的字节长度，而不是原始主体的长度。</p>
<h3 id="15-2-5-确定实体主体长度的规则"><a href="#15-2-5-确定实体主体长度的规则" class="headerlink" title="15.2.5 确定实体主体长度的规则"></a>15.2.5 确定实体主体长度的规则</h3><p>下面列出的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置，规则按顺序应用，谁先匹配就用谁：</p>
<ol>
<li>如果特定的HTTP报文类型中不允许带有主体，就忽略Content-Length首部，它是对实际上没有发送出来的主体进行计算的。这种情况下，Content-Length首部是提示性的，并不说明实际的主体长度。</li>
<li>如果报文中有描述传输编码的Transfer-Encoding首部（不采用默认的HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）的特殊模式结束，除非报文已经因连接关闭而结束。</li>
<li>如果报文中有Content-Length首部且报文类型允许有实体主体，而且没有非恒等的Transfer-Encoding首部字段，那么Content-Length的值就是主体的长度。如果收到的报文中Content-Length和Transfer-Encoding首部字段都有，就必须忽略Content-Length，因为传输编码会改变实体主体的表示和传输方式。从而可能就会改变传输的字节数。</li>
<li>如果报文使用了multipart/byteranges（多部分/字节范围）媒体类型，并且没有用Content-Length首部指出实体主体的长度，那么多部分报文中的每个部分都要说明自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。</li>
<li>如果上面的规则都不匹配，实体就在连接关闭的时候结束。只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应。</li>
</ol>
<p>为了和使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的Content-Length首部字段，除非知道服务器兼容HTTP/1.1。对于带有主体但没有Content-Length首部的请求，服务器就应当发送400 Bad Request响应或411 Length Required响应。.</p>
<h2 id="15-3-实体摘要"><a href="#15-3-实体摘要" class="headerlink" title="15.3 实体摘要"></a>15.3 实体摘要</h2><p>发送方可以在生成初始的主体时，生成一个数据的校验和，接收方就可以通过检查这个校验和来检测实体主体的数据是否被修改。</p>
<p>Content-MD5首部是发送对实体主体运行MD5算法的结果，只有产生响应的原始服务器可以计算并发送。中间代理和缓存不应当修改或添加这个首部，否则就会与验证端到端完整性的这个最终目的相冲突。</p>
<p>Content-MD5首部是在对内容做了所有需要的内容编码之后，还没有做传输编码前，计算出来的。为了验证报文的完整性，客户端必须先进行传输编码的解码，然后计算所得到的未进行传输编码的实体主体的MD5。</p>
<p>除了检查报文的完整性之外，MD5还可以当作散列表的关键字，用来快速定位文档并消除不必要的重复内容存储。</p>
<p>作为对HTTP的扩展，增加新的Want-Digest首部，它允许客户端说明期望响应中使用的摘要类型，并使用质量值来建议多种摘要算法并说明优先顺序。</p>
<h2 id="15-4-媒体类型和字符集"><a href="#15-4-媒体类型和字符集" class="headerlink" title="15.4 媒体类型和字符集"></a>15.4 媒体类型和字符集</h2><p>Content-Type首部字段说明实体主体的MIME类型。MIME类型是标准化的名字，用以说明运载实体的基本媒体类型。客户端应用程序使用MIME类型来解释和处理其内容。Content-Type的值是标准化的MIME类型，在互联网号码分配机构（Internet Assigned Numbers Authority，简称IANA）中注册。</p>
<p>MIME类型由一个主媒体类型后面跟一条斜线以及一个子类型组成，子类型用于进一步描述媒体类型。</p>
<p>Content-Type首部说明的是原始实体主体的媒体类型。实体经过内容编码的话，Content-Type首部说明的仍是编码之前的实体主体的类型。，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/jnyXQHRc4t2gT3U.png"
                      alt="Hgvet3LTBs7pzFpx__thumbnail.png"
                ></p>
<h3 id="15-4-1-文本的字符编码"><a href="#15-4-1-文本的字符编码" class="headerlink" title="15.4.1 文本的字符编码"></a>15.4.1 文本的字符编码</h3><p>Content-Type首部还支持可选的参数来进一步说明内容的类型。比如charset（字符集）参数，说明把实体中的比特转换为文本文件中的字符的方法：Content-Type：text/html；</p>
<h3 id="15-4-2-多部分媒体类型"><a href="#15-4-2-多部分媒体类型" class="headerlink" title="15.4.2 多部分媒体类型"></a>15.4.2 多部分媒体类型</h3><p>MIME中的multipart（多部分）电子邮件报文中包含多个报文，它们一起作为复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同的部分之间用分界字符串连接。</p>
<p>HTTP也支持多部分主体。通常只用在下列两种情形之一：</p>
<ol>
<li>多部分表格提交，HTTP使用<strong>Content-Type：multipart/form-data</strong>或<strong>Content-Type：multipart/mixed</strong>首部以及多部分主体来发送这种请求，e.g. Content-Type：multipart/form-data；boundary=[abc]，其中的boundary参数说明了分割主体中不同部分所用的字符串。</li>
<li>作为承载若干文档片段的范围响应。HTTP对范围请求的响应也可以是多部分的，这样的响应中有<strong>Content-Type：multipart/byteranges</strong>首部和带有不同范围的多部分主体。<h2 id="15-5-内容编码"><a href="#15-5-内容编码" class="headerlink" title="15.5 内容编码"></a>15.5 内容编码</h2></li>
</ol>
<p>HTTP应用程序有时在发送之前对内容进行编码，有助于减少传输实体的时间，还可以把内容搅乱或加密，以此来防止未经授权的第三方看到文档的内容。这种类型的编码是在发送方应用到内容之上的。</p>
<h3 id="15-5-1-内容编码过程"><a href="#15-5-1-内容编码过程" class="headerlink" title="15.5.1 内容编码过程"></a>15.5.1 内容编码过程</h3><p>内容编码的过程如下所述：</p>
<ol>
<li>网站服务器生成原始响应报文，其中有原始的Content-Type和Content-Length首部。</li>
<li>内容编码服务器（也可能就是原始的服务器或下行的代理）创建编码后的报文。编码后的报文有同样的Content-Type，但Content-Length可能不同，在编码后的报文中增加Content-Encoding首部，这样接收的应用程序就可以进行解码。</li>
<li>接收程序得到编码后的报文，进行解码，获得原始报文。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ny5FQBflWuTLOAi.png"
                      alt="wfXRqxnk1BEU33wW__thumbnail.png"
                ></p>
<h3 id="15-5-2-内容编码类型"><a href="#15-5-2-内容编码类型" class="headerlink" title="15.5.2 内容编码类型"></a>15.5.2 内容编码类型</h3><p>HTTP定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联网号码分配机构（IANA）对各种编码进行标准化，它给每个内容编码算法分配了唯一的代号。Content-Encoding首部就用这些标准化的代号来说明编码时使用的算法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/z2TfyUgZSmcl75A.png"
                      alt="Bd5Wji9r83iXfpN0__thumbnail.png"
                ></p>
<h3 id="15-5-3-Accept-Encoding首部"><a href="#15-5-3-Accept-Encoding首部" class="headerlink" title="15.5.3 Accept-Encoding首部"></a>15.5.3 Accept-Encoding首部</h3><p>为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放在请求的Accept-Encoding首部里发出去。如果HTTP请求中没有包含Accept-Encoding首部，服务器就可以假设客户端能够接受任何编码方式。</p>
<p>客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q值范围从0.0到1.0，0.0说明客户端不想接受所说明的编码，1.0则表明最希望使用的编码。*表示“任何其他方法”。</p>
<p>identity编码代号只能在Accept-Encoding首部中出现，客户端用它来说明相对于其他内容编码算法的优先级。</p>
<h2 id="15-6-传输编码和分块编码"><a href="#15-6-传输编码和分块编码" class="headerlink" title="15.6 传输编码和分块编码"></a>15.6 传输编码和分块编码</h2><p>传输编码也是作用在实体主体上的可逆变换，使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/qlKXONDHRMSLdmr.png"
                      alt="KmJHDOGZldzZmjDu__thumbnail.png"
                ></p>
<h3 id="15-6-1-可靠传输"><a href="#15-6-1-可靠传输" class="headerlink" title="15.6.1 可靠传输"></a>15.6.1 可靠传输</h3><p>在HTTP协议中，底层的传输设施已经标准化且容错性好，只有少数情况下，所传输的报文主体可能会引发问题：</p>
<ol>
<li><strong>未知的尺寸</strong>。如果不先生成内容，某些网关应用程序和内容编码器无法确定报文主体的最终大小，所以它们希望在知道大小前就开始传输数据。因为HTTP协议要求Content-Length首部必须在数据之前，所以使用传输编码来发送数据，并用特别的结束脚注表明数据结束。</li>
<li><strong>安全性</strong>。可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。但由于像SSL这样的传输层安全体系，很少需要靠传输编码来实现安全性。<h3 id="15-6-2-Transfer-Encoding首部"><a href="#15-6-2-Transfer-Encoding首部" class="headerlink" title="15.6.2 Transfer-Encoding首部"></a>15.6.2 Transfer-Encoding首部</h3></li>
</ol>
<p>用来描述和控制传输编码的两个首部:</p>
<ol>
<li>Transfer-Encoding。告知接收方为了可靠地传输报文，已经对其进行了何种编码。</li>
<li>TE。用在请求首部中，告知服务器可以使用哪些传输编码扩展。</li>
</ol>
<p>HTTP规范只定义了一种传输编码，就是分块编码（chunked）。TE首部也可以使用Q值来说明传输编码的优先顺序，但禁止设为0.0。</p>
<h3 id="15-6-3-分块编码"><a href="#15-6-3-分块编码" class="headerlink" title="15.6.3 分块编码"></a>15.6.3 分块编码</h3><p>分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。</p>
<p>分块编码是一种传输编码，因此是报文的属性，而不是主体的属性。而多部分编码，是主体的属性，它和分块编码是完全独立的。</p>
<h4 id="15-6-3-1-分块与持久连接"><a href="#15-6-3-1-分块与持久连接" class="headerlink" title="15.6.3.1 分块与持久连接"></a>15.6.3.1 分块与持久连接</h4><p>若客户端和服务器之间不是持久连接，客户端就不需要知道主体的长度，而只需要读到服务器关闭主体连接为止。否则必须加上Content-Length首部发送。</p>
<p>但如果服务器动态创建内容，就可能在发送之前无法知道主体的长度，于是通过分块编码解决。服务器可以用大小为0的块作为主体结束的信号，来继续保持连接，为下一个响应做准备。</p>
<p>客户端也可以发送分块的数据给服务器。因为客户端事先不知道服务器是否接受分块编码（因为客户端才会发送TE首部），所以客户端必须做好服务器用411 Length Required响应来拒绝分块请求的准备。</p>
<p>分块编码报文的基本结构：它由起始的HTTP响应首部块开始，随后是一系列分块。每个分块包含一个长度值和该分块的数据。长度值是十六进制形式并将CRLF与数据分隔开。分块中数据的大小以字节计算，不包括长度值与数据之间的CRLF序列以及分块结尾的CRLF序列。最后一个块长度值为0，表示“主体结束”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/yqf1AQakN5l3EWL.png"
                      alt="QefkJBLxwkzvePyF__thumbnail.png"
                ></p>
<h4 id="15-6-3-2-分块报文的拖挂"><a href="#15-6-3-2-分块报文的拖挂" class="headerlink" title="15.6.3.2 分块报文的拖挂"></a>15.6.3.2 分块报文的拖挂</h4><p>只有客户端的TE首部中说明可以接受拖挂，才在分块的报文最后加上。产生原始响应的服务器也可以在分块的报文最后加上拖挂。</p>
<p>拖挂的内容是可选的元数据，客户端不一定需要理解和使用（甚至可以忽略并丢弃拖挂中的内容）。拖挂中可以包含附带的首部字段，它们的值在报文开始的时候可能是无法确定的。比如Content-MD5 ，在文档生成之前很难算出它的MD5。</p>
<p>报文首部中包含一个Trailer首部，列出了跟在分块报文之后的首部列表，除了Transfer-Encoding、Trailer 以及Content-Length首部之外，其他HTTP首部都可以作为拖挂发送，这些首部紧接在最后一个分块之后。</p>
<h3 id="15-6-4-内容编码与传输编码的结合"><a href="#15-6-4-内容编码与传输编码的结合" class="headerlink" title="15.6.4 内容编码与传输编码的结合"></a>15.6.4 内容编码与传输编码的结合</h3><p>内容编码与传输编码可以同时使用。接收方“重构”主体的过程和发送方相反。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/t1bpNjzZSgG4XVv.png"
                      alt="R2V1NNz6yChk86Tq__thumbnail.png"
                ></p>
<h3 id="15-6-5-传输编码的规则"><a href="#15-6-5-传输编码的规则" class="headerlink" title="15.6.5 传输编码的规则"></a>15.6.5 传输编码的规则</h3><p>对报文主体使用传输编码时，必须遵守以下规则，使得接收方能够确定报文的传输长度：</p>
<ol>
<li>传输编码集合中必须包括“分块”，唯一例外是使用关闭连接来结束报文。</li>
<li>当使用分块传输编码时，它必须是最后一个作用到报文主体之上的。</li>
<li>分块传输编码不能多次作用到一个报文主体上。</li>
</ol>
<p>实现传输编码的服务器必须意不把经传输编码后的报文发送给非HTTP/1.1的应用程序。否则如果服务器收到无法理解的经过传输编码的报文，用501 Unimplemented状态码来回复。</p>
<h2 id="15-7-随时间变化的实例"><a href="#15-7-随时间变化的实例" class="headerlink" title="15.7 随时间变化的实例"></a>15.7 随时间变化的实例</h2><p>网站对象并不是静态的。同样的URL会随着时间变化而指向对象的不同版，也就是实例。</p>
<p>HTTP协议规定了称为<strong>实例操控</strong>（instance manipulations）的一系列请求和响应操作，用以操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两种方法都要求客户端能够标识它所拥有（如果有的话）的资源的特定副本，并在一定的条件下请求新的实例。</p>
<h2 id="15-8-验证码和新鲜度"><a href="#15-8-验证码和新鲜度" class="headerlink" title="15.8 验证码和新鲜度"></a>15.8 验证码和新鲜度</h2><p>当文档在客户端“过期”之后（客户端不认为该副本有效），客户端须从服务器请求一份新副本。如果该文档在服务器上并未改变，客户端也就不需要再接收，继续使用缓存的副本即可。</p>
<p>这种特殊的请求，称为<strong>有条件的请求</strong>（conditional request），要求客户端使用验证码</p>
<p>（validator）来告知服务器它当前拥有的版本号，并仅当它当前副本无效才要求发送新的副本。</p>
<h3 id="15-8-1-新鲜度"><a href="#15-8-1-新鲜度" class="headerlink" title="15.8.1 新鲜度"></a>15.8.1 新鲜度</h3><p>服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。服务器可以用Expires（过期）和Cache-Control（缓存控制）来提供这种信息。</p>
<p>同时服务器和客户端不仅都可以用Cache-Control来说明新鲜度，并且除了使用期或过期时间之外，还有很多指令可用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/ysK29bnJzuWZOcB.png"
                      alt="m7VrGBnCBAIpGjwd__thumbnail.png"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/zUOXlkoVYQ3txPF.png"
                      alt="27woIO882zhDrUbJ__thumbnail.png"
                ></p>
<h3 id="15-8-2-有条件的请求与验证码"><a href="#15-8-2-有条件的请求与验证码" class="headerlink" title="15.8.2 有条件的请求与验证码"></a>15.8.2 有条件的请求与验证码</h3><p>当原始服务器上的文档与缓存中已过期的副本相同，而缓存服务器还是要从原始服务器上取文档的话，那缓存服务器就是在浪费网络带宽，给缓存服务器和原始服务器增加不必要的负载。</p>
<p>解决方案：仅当资源改变时才请求副本，这种特殊请求称为有条件的请求，仅当某个特定条件为真时才执行，如果条件不满足，服务器就发回一个HTTP错误码。</p>
<p>每个有条件的请求都通过特定的验证码来发挥作用。验证码是文档实例的特殊属性，用它来测试条件是否为真。可以把验证码看作文件的序列号、版本号，或者最后发生改变的日期时间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/2kSovtqjD1YQaNu.png"
                      alt="ZOLwYk7M1G3NhugX__thumbnail.png"
                ></p>
<p>HTTP把验证码分为两类：<strong>弱验证码</strong>（weak validators）和<strong>强验证码</strong>（strong validators）。</p>
<p>弱验证码不一定能唯一标识资源的一个实例，而强验证码可以。</p>
<p>弱验证码：</p>
<ol>
<li>字节计数验证码，可能资源的内容改变了，而大小还保持不变，资源内容的加密校验和就是强验证码，文档改变时总是会变。</li>
<li>最后修改时间，因为它的描述精度最大就是1秒。资源可能在1秒内可以改变很多次。</li>
</ol>
<p>强验证码：ETag首部被当作强验证码，因为每当资源内容改变时，服务器都可以在ETag首部放置不同的值。ETag首部很灵活，它可以带上任意的文本值，这样就可以设计出各种各样的客户端和服务器验证策略。版本号和摘要校验是很好的ETag首部候选，但不能带有任意的文本。</p>
<p>有时候，不想在缓存服务器再验证时产生很大的传输流量，就需要采用不那么精确的实体标记验证方法。服务器可以在标记前加上”W/“前缀来广播一个“弱”实体标记。对于弱实体标记来说，只有当关联的实体在语义上发生了重大改变时，标记才变化。而强实体标记只要内容变化，标记都一定会改变。</p>
<h2 id="15-9-范围请求"><a href="#15-9-范围请求" class="headerlink" title="15.9 范围请求"></a>15.9 范围请求</h2><p>范围请求允许客户端实际上只请求文档的一部分。比如HTTP客户端可以通过请求曾获取失败的实体的一个范围，来恢复下载该实体。前提是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象没有改变过。</p>
<p>可以使用Range：bytes=4000-这种形式的范围请求，因为请求方可能不知道文档的大小。还可以用Range首部来请求多个范围（可以按任意顺序给出，也可以相互重叠）。因为客户端可以同时连接多个服务器下载同一个文档的不同部分。</p>
<p>对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多部分主体及Content-Type：multipart/byteranges 首部。</p>
<p>不是所有服务器都接受范围请求，服务器可以通过在响应中包含Accept-Ranges首部的形式向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，规范中只定义了bytes 记号，但具体实现可以用服务器和客户端自己认定的单位来衡量或切分实体。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/A2MzCgNQdYvInuW.png"
                      alt="W7dJGGZkH5D2R8X5__thumbnail.png"
                ></p>
<p>Range首部在流行的<strong>点对点</strong>（Peer-to-Peer，P2P）文件共享客户端软件中得到广泛应用，它们从不同的对等实体同时下载多媒体文件的不同部分。</p>
<p>范围请求属于实例操控，因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是客户端的范围请求仅当客户端和服务器拥有文档的同一个版本时才有意义。</p>
<h2 id="15-10-差异编码"><a href="#15-10-差异编码" class="headerlink" title="15.10 差异编码"></a>15.10 差异编码</h2><p>差异编码通过交换对象改变的部分而不是完整的对象来优化传输性能。差异编码也属于实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。</p>
<p>客户端必须告诉服务器现有资源的版本，是否接受资源最新版的差异（delta），知道将差异应用于现有版本的哪些算法。</p>
<p>服务器必须检查客户端是否有这个资源现有版本，通过算法计算客户端资源现有版本与新版之间的差异，然后发送给客户端，告知客户端所发送的是差异，并说明新资源的（ETag），因为客户端将差异应用于其老版本之后就会得到这个版本。</p>
<p>如果客户端想告诉服务器接受资源的差异，就发送A-IM（Accept-Instance-Manipulation）首部，而不用发送完整的资源。在A-IM首部中，客户端说明知道哪些算法可以把差异应用于老版本而得到最新版本。</p>
<p>服务端发送的是一个特殊的响应代码一226 IM Used，告知客户端它正在发送的是所请求对象的实例操控，而不是完整的对象。IM（Instance-Manipulation）首部，说明用于计算差异的算法，还有新的ETag首部，以及Delta-Base首部，说明用于计算差异的基线文档的ETag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/a6SjMEOpBYmCJHl.png"
                      alt="1zeEzzzA7jllslxR__thumbnail.png"
                ></p>
<p>客户端用A-IM首部说明可以接受的一些实例操控的类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/wRvzhJaXt6FPfme.png"
                      alt="l9MCr1VSHCxu3wQi__thumbnail.png"
                ></p>
<p>服务器侧的<strong>差异生成器</strong>根据基线文档和该文档的最新实例，并用客户端在A-IM首部中指明的算法计算它们之间的差异。客户端侧的<strong>差异应用器</strong>得到差异，将其应用于基线文档，得到文档的最新实例。</p>
<p>在返回给客户端之前，文档可以经过多种实例操控，这样可以获得最大程度的压缩。例如，用vcdiff算法产生的差异后可以再用gzip算法压缩。</p>
<p>差异编码可以减少传输次数，但支持差异编码的服务器必须保存资源的所有不同版本，才能计算新版本与所请求的客户端持有的现有版本之间的差异。这样服务器必须增加磁盘空间来保存文档的各种旧的实例，可能反而得不偿失。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2021/03/08/wtf3A2NQOVrXn8U.png"
                      alt="Ttoo45eBe0QpTIHZ__thumbnail.png"
                ></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：15-实体和编码</li>
        <li>本文作者：胡倚豪</li>
        <li>创建时间：2021-01-23 19:00:09</li>
        <li>
            本文链接：huonenumber.github.io/2021/01/23/note/HTTP/15-实体和编码/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/01/23/note/JavaScript/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">03-语言基础</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/01/23/note/HTTP/08-%E9%9B%86%E6%88%90%E7%82%B9%EF%BC%9A%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93%E5%8F%8A%E4%B8%AD%E7%BB%A7/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">08-集成点：网关、隧道及中继</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oRtabIpmHUsCjAVoocAuRiR6-gzGzoHsz',
                    appKey: '8MQB6tSReJAP6eYmI5OGVpTo',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请尽情吐槽吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '胡倚豪';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            .footer {
  font-size: 1rem;
  color: var(--third-text-color);


  a {
    color: var(--third-text-color);


    &:hover {
      color: var(--primary-color);

    }
  }

  .info-container {
    padding-bottom: 10px;
    text-align: center;
  }

  .info-item {
    margin: 5px 0;
  }

  .icon-animate {
    animation: icon-animate 1.2s ease-in-out infinite;
  }

}

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-%E6%8A%A5%E6%96%87%E6%98%AF%E7%AE%B1%E5%AD%90%EF%BC%8C%E5%AE%9E%E4%BD%93%E6%98%AF%E8%B4%A7%E7%89%A9"><span class="nav-text">15.1 报文是箱子，实体是货物</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-Content-Length%EF%BC%9A%E5%AE%9E%E4%BD%93%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-text">15.2 Content-Length：实体的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-1-%E6%A3%80%E6%B5%8B%E6%88%AA%E5%B0%BE"><span class="nav-text">15.2.1 检测截尾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-2-%E9%94%99%E8%AF%AF%E7%9A%84Content-Length"><span class="nav-text">15.2.2 错误的Content-Length</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-3-Content-Length%E4%B8%8E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="nav-text">15.2.3 Content-Length与持久连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-4-%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81"><span class="nav-text">15.2.4 内容编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-5-%E7%A1%AE%E5%AE%9A%E5%AE%9E%E4%BD%93%E4%B8%BB%E4%BD%93%E9%95%BF%E5%BA%A6%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">15.2.5 确定实体主体长度的规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-3-%E5%AE%9E%E4%BD%93%E6%91%98%E8%A6%81"><span class="nav-text">15.3 实体摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-4-%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-text">15.4 媒体类型和字符集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-1-%E6%96%87%E6%9C%AC%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="nav-text">15.4.1 文本的字符编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4-2-%E5%A4%9A%E9%83%A8%E5%88%86%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-text">15.4.2 多部分媒体类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-5-%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81"><span class="nav-text">15.5 内容编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-1-%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="nav-text">15.5.1 内容编码过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-2-%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B"><span class="nav-text">15.5.2 内容编码类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5-3-Accept-Encoding%E9%A6%96%E9%83%A8"><span class="nav-text">15.5.3 Accept-Encoding首部</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-6-%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81%E5%92%8C%E5%88%86%E5%9D%97%E7%BC%96%E7%A0%81"><span class="nav-text">15.6 传输编码和分块编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6-1-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-text">15.6.1 可靠传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6-2-Transfer-Encoding%E9%A6%96%E9%83%A8"><span class="nav-text">15.6.2 Transfer-Encoding首部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6-3-%E5%88%86%E5%9D%97%E7%BC%96%E7%A0%81"><span class="nav-text">15.6.3 分块编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-6-3-1-%E5%88%86%E5%9D%97%E4%B8%8E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="nav-text">15.6.3.1 分块与持久连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-6-3-2-%E5%88%86%E5%9D%97%E6%8A%A5%E6%96%87%E7%9A%84%E6%8B%96%E6%8C%82"><span class="nav-text">15.6.3.2 分块报文的拖挂</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6-4-%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81%E4%B8%8E%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-text">15.6.4 内容编码与传输编码的结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6-5-%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">15.6.5 传输编码的规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-7-%E9%9A%8F%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-text">15.7 随时间变化的实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-8-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%92%8C%E6%96%B0%E9%B2%9C%E5%BA%A6"><span class="nav-text">15.8 验证码和新鲜度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-8-1-%E6%96%B0%E9%B2%9C%E5%BA%A6"><span class="nav-text">15.8.1 新鲜度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-8-2-%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="nav-text">15.8.2 有条件的请求与验证码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-9-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><span class="nav-text">15.9 范围请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-10-%E5%B7%AE%E5%BC%82%E7%BC%96%E7%A0%81"><span class="nav-text">15.10 差异编码</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
