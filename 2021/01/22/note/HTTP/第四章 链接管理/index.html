<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="HTML,CSS,JavaScript">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="胡倚豪">
    
    <title>
        
        HuOneNumber | 个人博客
    </title>
    <link rel="shortcut icon" href="/images/avatar.png">
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true},"style":{"primary_color":"#33FFCC","avatar":"/images/avatar.png","favicon":"/images/avatar.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"description":"别着急，慢慢来","background_img":"/images/bg.svg"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.3.0"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="别着急，慢慢来" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                HuOneNumber | 个人博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content normal-code-theme">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation"></span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span>胡倚豪</span>
                        <span class="level">Lv1</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i> 2021-01-22 19:32:59
    </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>5.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>18 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="TCP链接"><a href="#TCP链接" class="headerlink" title="TCP链接"></a>TCP链接</h2><h3 id="TCP的可靠数据管道"><a href="#TCP的可靠数据管道" class="headerlink" title="TCP的可靠数据管道"></a>TCP的可靠数据管道</h3><p>HTTP连接实际，上就是TCP连接和一些使用连接的规则，TCP为HTTP提供了一条可靠的比特传输管道。</p>
<h3 id="TCP流、IP分组"><a href="#TCP流、IP分组" class="headerlink" title="TCP流、IP分组"></a>TCP流、IP分组</h3><p>TCP的数据是通过IP分组（IP 数据报）的小数据块来发送的。安全版本HTTPS就是在HTTP和TCP之间插入了一个（称为TLS或SSL的）密码加密层图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/EcJv4cg2UJABtNpp.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>TCP段是由IP分组承载。每个IP分组中包括：</p>
<pre><code>    1. 一个IP分组首部，包含源和目的IP地址、长度和其他一些标记（通常为20字节）；
    2. 一个TCP段首部包含了TCP端口号、TCP控制标记，以及用于数据排序和完整性检查的一些数字值。（通常为20字节）；
    3. 一个TCP数据块（0个或多个字节）。</code></pre>
<h3 id="TCP连接的正确运行"><a href="#TCP连接的正确运行" class="headerlink" title="TCP连接的正确运行"></a>TCP连接的正确运行</h3><p>计算机随时都有几条TCP连接处于打开状态，TCP 通过端口号来保持连接的正确运行。</p>
<p>TCP连接通过4个值来识别：**&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;。**这4个值唯一地定义了一条连接。两条不同的TCP连接不能拥有4个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/46GDogLOzoqcLen7.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>操作系统提供了一些操纵其TCP连接的工具。我们来看一个TCP编程接口。这个套接字API向HTTP程序员隐藏了TCP和IP的所有细节。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/qv4I1NjxFUOC6xh8.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>套接字API允许用户创建TCP的端点数据结构，将这些端点与远程服务器的TCP端点进行连接，并对数据流进行读写。TCP API隐藏了所有底层网络协议的握手细节，以及TCP数据流与IP分组之间的分段和重装细节。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/vAn3ica3x7NtExWZ.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>从Web服务器等待连接（S4）开始。客户端根据URL判定出IP地址和端口号，并建立一条到服务器的TCP连接（C3）。</p>
<p>建立连接后，客户端就会发送HTTP请求（C5），服务器读取请求（S6）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（S7），并将数据写回客户端。客户端读取数据（C6），并对响应数据进行处理（C7）。</p>
<h2 id="TCP性能"><a href="#TCP性能" class="headerlink" title="TCP性能"></a>TCP性能</h2><h3 id="HTTP事务的时延"><a href="#HTTP事务的时延" class="headerlink" title="HTTP事务的时延"></a>HTTP事务的时延</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/N1zHevdCojb7owBy.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>与建立TCP连接、传输请求、响应报文的时间相比，事务处理可能是很短的，除非客户端或服务器超载，或正处理复杂的动态资源，否则HTTP时延就是由TCP网络时延构成的。</p>
<p>HTTP事务的时延原因：</p>
<p>（1）<strong>DNS解析</strong>，但大多数HTTP客户端都有一个小的DNS缓存，用来保存近期所访问站点的IP地址，可以很快地将主机名解析出来。</p>
<p>（2）客户端会向服务器发送一条TCP连接请求，并等待服务器回送请求接受应答。每条新的<strong>TCP连接的连接建立时延</strong>，最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值会很高。</p>
<p>（3）连接建立后，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器从TCP连接中<strong>读取请求报文</strong>，并<strong>处理请求报文</strong>，因特网<strong>传输请求报文</strong>、服务器处理请求报文都需要时间。</p>
<p>（4）Web服务器会<strong>回送HTTP响应</strong>，这些TCP网络时延的大小取决于<strong>硬件速度</strong>、<strong>网络和服务器的负载</strong>，<strong>请求和响应报文的尺寸</strong>，以及客户端和服务器之间的<strong>距离</strong>。<strong>TCP协议的技术复杂性</strong>也会对时延产生巨大的影响。</p>
<h3 id="TCP相关时延"><a href="#TCP相关时延" class="headerlink" title="TCP相关时延"></a>TCP相关时延</h3><pre><code>1. TCP连接建立握手，
2. 用于捎带确认的TCP延迟确认算法
3. TCP慢启动拥塞控制；
4. 数据聚集的Nagle算法；
5. TIME_WAIT时延和端口耗尽。</code></pre>
<h4 id="TCP连接的握手时延"><a href="#TCP连接的握手时延" class="headerlink" title="TCP连接的握手时延"></a>TCP连接的握手时延</h4><p>建立一条新的TCP连接时，甚至是在发送任意数据之前，TCP软件之间会交换一系列的IP分组，对连接的有关参数进行沟通。如果连接用来传送少量数据，这些交换过程就会降低HTTP的性能。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/McjEXqUcLmE8y4Qe.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p><strong>TCP连接握手步骤:</strong></p>
<pre><code>1. 请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40 ~60个字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求（参见a）。
2. 如果服务器接受连接，会对一些连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受（参见b）。
3. 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图c）。现代的TCP栈都允许客户端在这个确认分组中发送数据。</code></pre>
<p>通常HTTP事务不会交换太多数据，SYN/SYN+ACK握手会产生一个可测量的时延。TCP连接的ACK分组通常都足够承载整个HTTP请求报文，而且很多HTTP服务器响应报文都可以放人一个IP分组中去。最后导致小的HTTP事务可能会在TCP建立上花费50%，或更多的时间。</p>
<h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><p>每个TCP段有一个序列号和数据完整性校验和，来确保数据的成功传输。接收者收到完好的段时，会向发送者回送确认分组。如果发送者没有在指定时间内收到确认信息，发送者就认为分组已破坏或损毁，会重发数据。</p>
<p>由于确认报文很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“<strong>捎带</strong>”。TCP将返回的确认信息与输出的数据分组结合在一起。</p>
<p>为增加确认报文找到同向传输数据分组的可能，TCP栈实现了一种<strong>“延迟确认”算法，</strong>会在一个特定的窗口时间（通常100 ~ 200毫秒）内将输出确认存放在缓冲区中，以寻找能捎带它的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求-应答行为，导致当希望有相反方向回传分组的时候，偏偏没有那么多。</p>
<p>延迟确认算法会引入相当大的时延。根据所使用操作系统的不同，可以调整或禁止延迟确认算法。</p>
<h4 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h4><p>TCP数据传输的性能还取决于TCP连接的使用期（age）。TCP连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为TCP慢启动（slow start），防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。HTTP事务不能一次将所有分组都发送出去，必须发送一个分组，等待确认，才可以发送两个分组，再次被确认，就可以发送四个分组，以此类推。这种方式被称为“打开拥塞窗口”。</p>
<p>由于这种拥塞控制特性，新连接的传输速度会比已经交换过数据的“已调谐”连接慢。</p>
<h4 id="Nagle算法与TCP-NODELAY"><a href="#Nagle算法与TCP-NODELAY" class="headerlink" title="Nagle算法与TCP_NODELAY"></a>Nagle算法与TCP_NODELAY</h4><p>TCP有数据流接口，每个TCP段中都至少装载了40个字节的标记和首部，所以如果TCP发送了大量包含少量数据的分组，网络的性能会下降。</p>
<p><strong>Nagle算法</strong>：试图在发送一个分组之前，将大量TCP数据绑定在一起，以提高网络效率。Nagle算法鼓励发送全尺寸的段，只有当所有其他分组都被确认之后，才发送非全尺寸的分组。如果其他分组仍在传输中，就将那部分数据缓存起来。只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸分组的数据时，才会将缓存的数据发送出去。</p>
<p><strong>Nagle算法缺陷</strong>：首先，小的HTTP报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题，Nagle算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟100 ~ 200毫秒。</p>
<p>HTTP应用程序通常设置参数TCP_NODELAY，禁用Nagle算法，这样须确保会向TCP写入大块的数据，不会产生一堆小分组。</p>
<h4 id="TIME-WAIT累积与端口耗尽"><a href="#TIME-WAIT累积与端口耗尽" class="headerlink" title="TIME__WAIT累积与端口耗尽"></a>TIME__WAIT累积与端口耗尽</h4><p>当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，维持的时间，是最大分段使用期的两倍（称为2MSL，通常为2分钟）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。这也防止之前连接的复制分组插入了具有相同连接值的新TCP流，会破坏TCP数据。</p>
<p>但在性能基准测试时，TIME__WAIT 也限制了可用的连接值组合。因为在只有一个客户端和一台Web服务器的情况下，构建一条TCP连接的4个值，只有源端口号可以随意改变，客户端每次连接到服务器上去时，都会获得一个新的源端口，以实现连接的唯一性。但由于可用源端口的数量有限，而且在2MSL秒内连接是无法重用的，连接率就被限制了。</p>
<p>可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</p>
<p>即使没有遇到端口耗尽问题，也要小心有大量连接处于打开状态的情况，或为处于等待状态的连接分配了大量控制块的情况。在有大量打开连接或控制块的情况下，有些操作系统的速度会减缓。</p>
<h2 id="HTTP链接的处理"><a href="#HTTP链接的处理" class="headerlink" title="HTTP链接的处理"></a>HTTP链接的处理</h2><h3 id="connection首部"><a href="#connection首部" class="headerlink" title="connection首部"></a>connection首部</h3><p>Connection首部有3种类型的标签：</p>
<pre><code>1. HTTP 首部字段名，列出了只与此连接有关的首部；
2. 任意标签值，用于描述此连接的非标准选项；
3. 值close，说明操作完成之后需关闭这条持久连接。</code></pre>
<p>如果连接标签中包含了HTTP首部字段的名称，那么这个首部字段就包含了与一些连接有关的信息，不能将其转发，在将报文转发出去之前，删除Connection所列出的首部字段以及自身。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/MWKLFwHwkjmuqWQY.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<h3 id="串行事务处理时延"><a href="#串行事务处理时延" class="headerlink" title="串行事务处理时延"></a>串行事务处理时延</h3><p>串行加载缺点：1、叠加链接时延和慢启动时延。2、有些浏览器需要完全加载后才显示。</p>
<p>新的链接方法：</p>
<pre><code>1. 并行连接：通过多条TCP连接发起并发的HTTP请求。
2. 持久连接：重用TCP连接，以消除连接及关闭时延。
3. 管道化连接：通过共享的TCP连接发起并发的HTTP请求。
4. 复用的连接：交替传送请求和响应报文（实验阶段）。</code></pre>
<h2 id="并行链接"><a href="#并行链接" class="headerlink" title="并行链接"></a>并行链接</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/E02QnUnHmeOPbogJ.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></h2><p>并行链接的优点：</p>
<pre><code>1. 每个事务都有自己的连接，装载是并行的，连接的时延也是重叠的。（嵌入的组件不一定都在同一台Web服务器上，可以同多台服务器建立并行的连接）。
2. 可以让用户感觉更快。</code></pre>
<p>并行链接的缺点：</p>
<pre><code>1. 如果并行加载多个对象，每个对象竞争有限的带宽，都会以较慢的速度按比例加载。
2. 打开大量连接会消耗很多内存资源，从造成服务器、代理性能的下降。
3. 由于TCP慢启动特性，每条新连接的性能都会有所降低。</code></pre>
<p>浏览器一般会将并行连接的总数限制为4个。服务器可以随意关闭来自特定客户端的超量连接。</p>
<h2 id="持久链接"><a href="#持久链接" class="headerlink" title="持久链接"></a>持久链接</h2><p><strong>站点本地性</strong>（site locality）：Web客户端经常打开到同一个站点的连接。因此，初始化了对某服务器HTTP请求的应用程序可能会对那台服务器不久发起更多的请求。</p>
<p><strong>持久连接</strong>：HTTP设备在事务处理结束之后将TCP连接保持在打开状态，以便为未来的HTTP请求重用现存的连接，直到客户端或服务器决定将其关闭为止。</p>
<p>优点：避开缓慢的连接建立阶段；避免慢启动的拥塞适应阶段。</p>
<p>缺点：累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/RUOT3rgreZZqeDQ5.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>持久连接与并行连接配合使用是高效的方式。通常，Web应用程序打开少量的并行连接，其中的每一个都是持久连接。</p>
<p>持久连接有两种类型：比较老的**”keep-alive”连接<strong>，现代的</strong>“persistent”连接**</p>
<h3 id="HTTP-1-0-keep-alive连接"><a href="#HTTP-1-0-keep-alive连接" class="headerlink" title="HTTP/1.0+   keep-alive连接"></a>HTTP/1.0+   keep-alive连接</h3><p>客户端通过包含Connection：Keep-Alive首部请求，将一条连接保持在打开状态。如果服务器可以，就在响应中包含相同的首部，否则说明服务器不支keep-alive，会在发回响应报文之后关闭连接。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，有多部件媒体类型，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>Keep-Alive通用首部中指定的、由逗号分隔的选项来调节keep-alive的行为：</p>
<pre><code>1. 参数**timeout**在Keep-Alive响应首部发送，服务器希望将连接保持在活跃状态的时间。
2. 参数**max**在Keep-Alive响应首部发送，服务器希望为多少个事务保持此连接的活跃状态。
3. Keep-Alive首部支持任意未经处理的属性，用于诊断和调试。语法为name[=value]。</code></pre>
<h4 id="哑代理"><a href="#哑代理" class="headerlink" title="哑代理"></a>哑代理</h4><p>老的或简单的代理都是<strong>盲中继</strong>（blind relay），只是将字节从一个连接转发到另一个连接中去，不对Connection首部进行特殊的处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/EBTdTrTeWy3Jfd15.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>后果：客户端和服务器都认为它们在进行keep-alive对话，但代理等待源端服务器关闭连接，源端服务器认为连接保持在打开状态，所以不会去关闭连接，反而立即转向下一条请求。而代理并不认为同一条连接上会有其他请求，<strong>请求被忽略</strong>。这会使浏览器<strong>一直处于挂起状态</strong>，直到客户端或服务器将连接超时，并将其关闭为止。</p>
<p>有几个不能作为Connection首部值列出，包括Proxy-Authenticate、Proxy-Connection、</p>
<p>Transfer-Encoding和Upgrade。</p>
<h4 id="插入Proxy-Connection解决哑代理"><a href="#插入Proxy-Connection解决哑代理" class="headerlink" title="插入Proxy-Connection解决哑代理"></a>插入Proxy-Connection解决哑代理</h4><p>浏览器向代理发送非标准的Proxy-Connection扩展首部，而不是官方支持的Connection首部。如果代理是盲中继，将无意义的Proxy-Connection首部转发给Web服务器，服务器会忽略此首部，否则就用Connection首部取代Proxy-Connection首部，然后将其发送给服务器。</p>
<p>对有多层次代理的情况，Proxy-Connection 仍然无法解决问题。</p>
<h3 id="HTTP-1-1-持久连接"><a href="#HTTP-1-1-持久连接" class="headerlink" title="HTTP/1.1  持久连接"></a>HTTP/1.1  持久连接</h3><p><strong>持久连接（</strong>persistent connection），在默认情况下是激活的。除非向报文中显式地添加一个Connection：close首部。但客户端和服务器仍然可以随时关闭空闲的连接。不发送Connection:close并不意味着服务器承诺永远将连接保持在打开状态。</p>
<p>只有当连接上的报文，实体主体部分的长度都和相应的Content-Length一致，或是用分块传输编码方式编码的，连接才能持久保持。</p>
<p>一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。</p>
<h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p>HTTP/1.1允许在持久连接上可选地使用<strong>请求管道</strong>。在响应到达之前，可以将多条请求放入队列。当第一条请求流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/SmB3DWYPPxzXolFI.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<p>管道化连接的限制：</p>
<ol>
<li>HTTP客户端确认是持久连接，才能使用管道。</li>
<li>必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了。</li>
<li>HTTP客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2></li>
</ol>
<h3 id="任意解除连接"><a href="#任意解除连接" class="headerlink" title="任意解除连接"></a>任意解除连接</h3><p>所有HTTP客户端、服务器或代理都可以在任意时刻关闭一条TCP传输连接。通常会在一条报文结束时关闭连接，但也有可能出错，对管道化持久连接来说，这种情形是很常见的。</p>
<h3 id="Content-Length及截尾操作"><a href="#Content-Length及截尾操作" class="headerlink" title="Content-Length及截尾操作"></a>Content-Length及截尾操作</h3><p>每条HTTP响应都应该有Content-Length首部。一些老的HTTP服务器会省略或者包含错误的长度指示，这就要依赖服务器发出的连接关闭来说明数据的真实末尾。</p>
<p>客户端或代理收到一条随连接关闭而结束的HTTP响应，且实际传输的实体长度与Content-Length并不匹配或没有Content-Length时，接收端应该质疑长度的正确性。</p>
<p>如果接收端是个缓存代理，不应该缓存这条响应（以降低今后将潜在的错误报文混合起来的可能），而是原封不动地转发出去，以维护语义的透明性。</p>
<h3 id="连接关闭容限、重试、幂等性"><a href="#连接关闭容限、重试、幂等性" class="headerlink" title="连接关闭容限、重试、幂等性"></a>连接关闭容限、重试、幂等性</h3><p>如果在客户端执行事务的过程中，传输连接关闭了，除非事务处理会带来副作用，否则客户端就应该重新打开连接，并重试一次。对管道化连接来说，源端服务器关闭连接，就会留下大量未处理的请求，需要重新调度。</p>
<p>如果一个事务，不管是执行几次，得到的结果都相同，这个事务就是<strong>幂等</strong>的。要发送一条非幂等请求，需要等待来自前一条请求的响应状态。</p>
<p>用户Agent代理一定不能自动重试非幂等方法或序列。比如post订单，大多数浏览器都会提供一个对话框，询问用户是否希望再次发起事务处理。</p>
<h3 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h3><h4 id="完全关闭与半关闭"><a href="#完全关闭与半关闭" class="headerlink" title="完全关闭与半关闭"></a>完全关闭与半关闭</h4><p>应用程序可以关闭TCP输入和输出信道中的任意一个或两者。</p>
<p>套接字调用<strong>close（）</strong>将TCP连接的输入输出信道都关闭了，称作“<strong>完全关闭</strong>”，如图a所示。</p>
<p>套接字调用<strong>shutdown（）</strong>单独关闭输入或输出信道，这被称为<strong>“半关闭”</strong>，如图b所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/HqfJNF2eliisLFNQ.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<h4 id="TCP关闭及重置错误"><a href="#TCP关闭及重置错误" class="headerlink" title="TCP关闭及重置错误"></a>TCP关闭及重置错误</h4><p>当应用程序开始与很多其他类型的HTTP客户端、服务器和代理进行对话且使用管道化持久连接时，使用半关闭来防止对等实体收到非预期的写入错误。</p>
<p>关闭连接的输出信道总是安全的。连接另一端的对等实体会在从其缓冲区中读出所有数据之后收到一条通知，说明流结束了，知道连接关闭了。</p>
<p>关闭连接的输入信道比较危险，除非知道另一端不再发送数据。如果向已关闭的输入信道发送数据，操作系统会回送一条TCP“<strong>连接被对端重置</strong>”报文，删除对端还未读取的所有缓存数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://uploader.shimo.im/f/DZvhKCeOgaAwmwKW.png!thumbnail?fileGuid=gO3ox1d0dvCW5lqD"
                      alt="图片"
                ></p>
<h4 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h4><p>应用程序首先应该关闭它们的输出信道，然后等待另一端的对等实体关闭它的输出信道。当两端都知道不再发送数据（比如关闭输出信道）后，连接就会被完全关闭，不会有重置的危险。</p>
<p>但不无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该先半关闭其输出信道，然后周期性地检查其输入信道的状态（查找数据，或流的末尾）。如果在一定的时间区间内对端没有关闭输入信道，应用程序可以强制关闭连接，以节省资源。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：</li>
        <li>本文作者：胡倚豪</li>
        <li>创建时间：2021-01-22 19:32:59</li>
        <li>
            本文链接：huonenumber.github.io/2021/01/22/note/HTTP/第四章 链接管理/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/01/22/note/HTTP/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20URL%E4%B8%8E%E8%B5%84%E6%BA%90/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item"></span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    
        
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'oRtabIpmHUsCjAVoocAuRiR6-gzGzoHsz',
                    appKey: '8MQB6tSReJAP6eYmI5OGVpTo',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请尽情吐槽吧~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {

                        let author = '胡倚豪';
                        author && (author = author.toLocaleLowerCase());

                        for (let vcard of vcards) {
                            const vnick = vcard.querySelector('.vhead .vnick');
                            if (vnick.innerHTML.toLocaleLowerCase() === author) {
                                vnick.innerHTML = `${author} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>


    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span> -
            
            2021 &nbsp; <a href="/">胡倚豪</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数 <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量 <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <!-- <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.3.0</a>
        </div> -->
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E9%93%BE%E6%8E%A5"><span class="nav-text">TCP链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E7%AE%A1%E9%81%93"><span class="nav-text">TCP的可靠数据管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%B5%81%E3%80%81IP%E5%88%86%E7%BB%84"><span class="nav-text">TCP流、IP分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%BF%90%E8%A1%8C"><span class="nav-text">TCP连接的正确运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-text">TCP套接字编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E6%80%A7%E8%83%BD"><span class="nav-text">TCP性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%97%B6%E5%BB%B6"><span class="nav-text">HTTP事务的时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9B%B8%E5%85%B3%E6%97%B6%E5%BB%B6"><span class="nav-text">TCP相关时延</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6"><span class="nav-text">TCP连接的握手时延</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="nav-text">延迟确认</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-text">TCP慢启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nagle%E7%AE%97%E6%B3%95%E4%B8%8ETCP-NODELAY"><span class="nav-text">Nagle算法与TCP_NODELAY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME-WAIT%E7%B4%AF%E7%A7%AF%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%80%97%E5%B0%BD"><span class="nav-text">TIME__WAIT累积与端口耗尽</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E9%93%BE%E6%8E%A5%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">HTTP链接的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#connection%E9%A6%96%E9%83%A8"><span class="nav-text">connection首部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6"><span class="nav-text">串行事务处理时延</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E9%93%BE%E6%8E%A5"><span class="nav-text">并行链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-text"></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E9%93%BE%E6%8E%A5"><span class="nav-text">持久链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-0-keep-alive%E8%BF%9E%E6%8E%A5"><span class="nav-text">HTTP&#x2F;1.0+   keep-alive连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%91%E4%BB%A3%E7%90%86"><span class="nav-text">哑代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5Proxy-Connection%E8%A7%A3%E5%86%B3%E5%93%91%E4%BB%A3%E7%90%86"><span class="nav-text">插入Proxy-Connection解决哑代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-1-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="nav-text">HTTP&#x2F;1.1  持久连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E5%8C%96%E8%BF%9E%E6%8E%A5"><span class="nav-text">管道化连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-text">关闭连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E8%A7%A3%E9%99%A4%E8%BF%9E%E6%8E%A5"><span class="nav-text">任意解除连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Content-Length%E5%8F%8A%E6%88%AA%E5%B0%BE%E6%93%8D%E4%BD%9C"><span class="nav-text">Content-Length及截尾操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E5%AE%B9%E9%99%90%E3%80%81%E9%87%8D%E8%AF%95%E3%80%81%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-text">连接关闭容限、重试、幂等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-text">正常关闭连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%85%B3%E9%97%AD%E4%B8%8E%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="nav-text">完全关闭与半关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%85%B3%E9%97%AD%E5%8F%8A%E9%87%8D%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="nav-text">TCP关闭及重置错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD"><span class="nav-text">正常关闭</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.3.0/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
