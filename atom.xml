<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>别着急，慢慢来</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-22T08:46:16.746Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>胡倚豪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第四章 资源加载和网络栈</title>
    <link href="http://example.com/2021/01/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%A0%88/"/>
    <id>http://example.com/2021/01/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%A0%88/</id>
    <published>2021-01-21T14:15:03.917Z</published>
    <updated>2021-01-22T08:46:16.746Z</updated>
    
    <content type="html"><![CDATA[<p>使用网络栈下载网页和网页中的资源是渲染引擎工作过程的第一步，也是非常消耗时间的步骤。</p><h2 id="4-1-WebKit资源加载机制"><a href="#4-1-WebKit资源加载机制" class="headerlink" title="4.1 WebKit资源加载机制"></a>4.1 WebKit资源加载机制</h2><h3 id="4-1-1资源"><a href="#4-1-1资源" class="headerlink" title="4.1.1资源"></a>4.1.1资源</h3><p>网页本身就是一种资源，而且网页还需要依赖很多其他类型的资源，例如图片、视频等。</p><p>HTML支持的资源主要包括以下类型。</p><ol><li><strong>HTML</strong>：HTML页面，包括各式各样的HTML元素。</li><li><strong>JavaScript</strong>：JavaScript 代码，可以内嵌在HTML文件中，也可以以单独的文件存在。</li><li><strong>CSS样式表</strong>：CSS样式资源，可以内嵌在HTML文件之外，也可以以单独文件存在。</li><li><strong>图片</strong>：各种编码格式的图片资源，还有一些特殊的图片资源，例如SVG中所需的图片资源。</li><li><strong>SVG</strong>：用于绘制SVG的2D矢量图形表示。</li><li><strong>CSS Shader</strong>：支持CSS Shader文件，目前WebKit支持该功能。</li><li><strong>视频、音频和字幕</strong>：多媒体资源及支持音视频的字幕文件（TextTrack）。</li><li><strong>字体文件</strong>：CSS支持自定义字体，CSS3引入的自定义字体文件。</li><li><strong>XSL样式表</strong>：使用XSLT语言编写的XSLT代码文件。</li></ol><p>上面这些资源在WebKit 中有不同的类来表示它们，它们的公共基类是<strong>CachedResource</strong>。其中HTML文本的类型叫MainResource类，与其对应的资源类型叫CachedRawResource类。</p><p>资源类的前面的Cached字样，是因为效率问题而引入的缓存机制，所有对资源的请求都会先获取缓存中的信息，以决定是否向服务器提出资源请求。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/0daCvmpdLOgUMBoZ.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><h3 id="4-1-2-资源缓存"><a href="#4-1-2-资源缓存" class="headerlink" title="4.1.2 资源缓存"></a>4.1.2 资源缓存</h3><p>资源的缓存机制的基本思想是建立一个资源的缓存池，当WebKit需要请求资源的时候，先从资源池中查找是否存在相应的资源。WebKit从资源池中查找资源的关键字是URL。如果没有，WebKit创建一个新的CachedResource子类的对象，并发送真正的请求给服务器，WebKit收到资源后将其设置到该资源类的对象中去，以便于缓存后下次使用。这里的缓存指的是内存缓存，而不同于在网络栈部分的磁盘缓存。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/DADmcG38TQhFjPbK.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><h3 id="4-1-3-资源加载器"><a href="#4-1-3-资源加载器" class="headerlink" title="4.1.3 资源加载器"></a>4.1.3 资源加载器</h3><p>按照加载器的类型来分，WebKit 总共有三种类型的加载器。</p><ol><li>针对每种资源类型的<strong>特定加载器</strong>，特点是仅加载某一种资源。这些资源加载器没有公共基类，作用就是当需要请求资源时，由资源加载器负责加载并隐藏背后复杂的逻辑。加载器属于它的调用者。例如image元素需要图片资源，对应的特定资源加载器是ImageLoader类。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/3IcXzyYa57u2Lz0U.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><ol start="2"><li><strong>资源缓存机制的资源加载器</strong>，特点是所有特定加载器都共享它来查找并插入缓存资源——<strong>CachedResourceLoader类</strong>。特定加载器先是通过缓存机制的资源加载器来查找是否有缓存资源，它属于HTML的文档对象。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/Lql2quYaEeTXRUBf.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><ol start="3"><li><strong>通用的资源加载器</strong>——ResourceLoader类，是在WebKit需要从网络或者文件系统获取资源的时候使用该类只负责获得资源的数据，因此被所有特定资源加载器所共享。它属于CachedResource类，但它同CachedResourceLoader类没有继承关系，这容易混淆。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/yxLtJhDragnUUhta.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><h3 id="4-1-4-过程"><a href="#4-1-4-过程" class="headerlink" title="4.1.4 过程"></a>4.1.4 过程</h3><p>下图是一个带有资源缓存机制的资源加载的全过程，包括资源已经在缓存中和不在缓存中两种情况。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/gVXqqiTMWy0JHXYe.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><p>通常一些资源的加载是异步执行的，资源的获取和加载不会阻碍当前WebKit的渲染过程，例如图片、CSS文件。但网页也存在某些特别的资源会阻碍主线程的渲染过程，例如JavaScript代码文件。这会严重影响WebKit下载资源的效率，因为后面可能还有许多需要下载的资源。</p><p>webkit的解决方案：当前的主线程被阻碍时，WebKit 会启动另外一个线程去遍历后面的HTML网页，收集需要的资源URL，然后发送请求，避免被阻碍。同时WebKit 能够并发下载这些资源，甚至并发下载JavaScript代码资源。</p><h3 id="4-1-5-资源的生命周期"><a href="#4-1-5-资源的生命周期" class="headerlink" title="4.1.5 资源的生命周期"></a>4.1.5 资源的生命周期</h3><p>同CachedResourceLoader对象一样，资源池也属于HTML文档对象。资源池采用LRU（Least Recent Used）算法来替换其中的资源，从而加入新的资源。</p><p>另一方面，当一个资源加载后，通常它会被放入资源池，以便之后使用。在HTTP协议的规范中规定，浏览器可以发送消息确认是否需要更新，如果有，浏览器则重新获取该资源；否则就需要利用该资源。</p><h2 id="4-2-Chromium多进程资源加载"><a href="#4-2-Chromium多进程资源加载" class="headerlink" title="4.2 Chromium多进程资源加载"></a>4.2 Chromium多进程资源加载</h2><h3 id="4-2-1-多进程"><a href="#4-2-1-多进程" class="headerlink" title="4.2.1 多进程"></a>4.2.1 多进程</h3><p>在带有资源缓存机制的资源加载过程描述中，ResourceHandle类之下的部分，是不同移植对获取资源的不同实现。在Chromium中，获取资源的方式是利用多进程的资源加载架构。下图描述了关于Chromium如何利用多进程架构来完成资源的加载，主要是多个Renderer进程和Browser 进程之间的调用栈涉及的主要类。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/sqo0VXyFsDg0m6zY.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><p>Renderer进程在网页的加载过程中需要获取资源，但是由于安全性（当沙箱模型打开的时候，Renderer进程是没有权限去获取资源的）和效率上（资源共享等问题）的考虑，Renderer进程的资源获取实际上是通过进程间通信将任务交给Browser进程来完成，Browser 进程有权限从网络或者本地获取资源。</p><p>在Chromium架构的Renderer进程中，ResourceHandleInternal 类通过IPCResource-LoaderBridge类同Browser进程通信。IPCResourceL oaderBridge类继承自ResourceL oaderBridge类，其作用是负责发起请求的对象和回复结果的解释工作，实际消息的接收和派发交给ResourceDispatcher类来处理。</p><p>在Browser进程中，首先由ResourceMessageFilter类来过滤Renderer进程的消息，如果与资源请求相关，则该过滤类转发请求给ResourceDispatcherHostImpl类，随即ResourceDispatcherHostlmpl类创建Browser进程中的ResourceLoader 对象来处理。</p><p>ResourceLoader类是Chromium浏览器实际的资源加载类，它负责管理向网络发起的请求、从网络接收过来的认证请求、请求的回复管理等工作。因为这其中每项都有专门的类来负责，但都是由ResourceLoader 类统一管理。从网络或者本地文件读取信息的是URLRequest类，实际上它承担了建立网络连接、发送请求数据和接受回复数据的任务，URLRequest 之后的工作将在“网络栈”章节中来解读。</p><h3 id="4-2-2-工作方式和资源共享"><a href="#4-2-2-工作方式和资源共享" class="headerlink" title="4.2.2 工作方式和资源共享"></a>4.2.2 工作方式和资源共享</h3><p>资源请求有同步和异步两种方式。前面说了ResourceLoader类承担了Browser进程中有关资源的总体管理任务，对于同步和异步两种资源请求方式，ResourceLoader类使用SyncResourceHandle类和AsyncResourceHandle类来向Renderer进程发送状态消息，并接收Renderer进程对这些消息的反馈，下图描述了这些类之间的关系。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/byBPW6KAwIpeU5mS.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><p>图中还有两个ResourceHandle子类，第一个是LayeredResourceHandle类，它同SyncResourceHandle类和AsyncResourceHandle类不一样，自己不直接参与资源的处理，而是将处理转给另一个ResourceHandle对象。LayeredResourceHandle 类没有实际意义，仅是BufferedResourceHandle的父类。该缓冲类用来缓冲网络或者文件传过来的数据，直到数据足够满足需求然后转给设置的另一个ResourceHandle对象。Throttling-ResourceHandle类是在面对很多个资源请求时仅使用一个URLRequest对象来获取资源，这可以有效地减少网络的开销，因为不需要重新建立多个网络连接。</p><p>此外，在Chromium中还有很多ResourceHandle的子类，它们的作用各异。</p><ol><li><strong>RedirectToFileResourceHandler</strong>：继承自LayeredResourceHandle类，在接收到的数据转给另一个ResourceHandler类的同时，转存到文件。</li><li><strong>treamResourceHandler</strong>：继承自LayeredResourceHandle 类，在接收到的数据转给另一个ResourceHandler的同时，转存到数据流。</li><li><strong>CertificateResourceHandler</strong>：主要处理证书类的资源请求。</li></ol><p>资源统一交由Browser进程来处理，这使得资源在不同网页间的共享变得很容易。接下来面临一个问题，因为每个Renderer 进程某段时间内可能有多个请求，同时还有多个Renderer进程，Browser进程需要处理大量的资源请求，这就需要一个处理这些请求的调度器，这就是Chromium中的ResourceScheduler.</p><h2 id="4-3-网络栈"><a href="#4-3-网络栈" class="headerlink" title="4.3 网络栈"></a>4.3 网络栈</h2><h3 id="4-3-1-WebKit的网络设施"><a href="#4-3-1-WebKit的网络设施" class="headerlink" title="4.3.1 WebKit的网络设施"></a>4.3.1 WebKit的网络设施</h3><p>WebKit的资源加载其实是交由各个移植来实现的，所以WebCore其实并没有什么特别的基础设施，每个移植的网络实现是非常不一样的。</p><p>在WebKit的代码结构中，网络部分代码在“WebKit/Source/WebCore/platform/network”中。主要是一些HTTP消息头、MIME消息、状态码等信息的描述和处理，没有实质的网络连接和各种针对网络的优化。</p><h3 id="4-3-2-Chromium网络栈"><a href="#4-3-2-Chromium网络栈" class="headerlink" title="4.3.2 Chromium网络栈"></a>4.3.2 Chromium网络栈</h3><p>前面讲到资源加载，描述到URLRequest类的时候戛然而止，这是因为URLRequest类之下的部分是网络栈的内容。</p><h4 id="4-3-2-1-网络栈基本组成"><a href="#4-3-2-1-网络栈基本组成" class="headerlink" title="4.3.2.1 网络栈基本组成"></a>4.3.2.1 网络栈基本组成</h4><p>下图是“net”所包括的主要子目录，也是Chromium网络栈的主要模块。这里面除了一些基础的部分，例如HTTP协议、DNS解析等模块，还包含了Chromium为了减少网络时间而引入的新技术，例如SPDY、QUIC等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/i4uSsMXfcjQTaa2X.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><h4 id="4-3-2-2-网络栈结构"><a href="#4-3-2-2-网络栈结构" class="headerlink" title="4.3.2.2 网络栈结构"></a>4.3.2.2 网络栈结构</h4><p>下图描述了从URLRequest类到Socket类之间的调用过程。以HTTP协议为例，图中列出建立TCP的socket连接过程中涉及的类。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/icP92vja3jnJnFsb.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><p>首先是URLRequest类被上层调用并启动请求的时候，它会根据URL的“scheme”来决定需要创建什么类型的请求。“scheme”也就是URL的协议类型，例如“http://”、“fle://”，也可以是自定义的scheme，例如Android系统的“fle://android asset/”。URLRequest对象创建的是一个URLRequestJob子类的一个对象，例如图中的URLRequestHttpJob类。为了支持自定义的scheme：处理方式，Chromium使用工厂模式。URLRequestJob 类和它的工厂类URLRequestJobFactory 的管理工作都由URLRequestJlobManager类负责。基本的思路是，用户可以在该类中注册多个工厂，当有URLRequest请求时，先由工厂检查它是否需要处理该“scheme”，如果没有，工厂管理类继续交给下一个工厂“类来处理。最后，如果没有任何工厂能够处理，Chromium则交给内置的工厂来检查和处理是否为“http://“、“http:/“或者“fle://”</p><p>等，图4-15用来描述这些类的关系。.</p><p>其次，当URLRequestHttpJob对象被创建后，该对象首先从Cookie管理器中获取与该URL相关联的信息。之后，它同样借助于HttpTransactionFactory对象创建一个HttpTransaction 对象来表示开启一-个 HTTP连接的事务（当然这里的概念不同于数据库中的事务概念）。通常情况下，HtpTransactionFactory 对象对应的是一个它的子类HtpCache对象。HtpCache类使用本地磁盘缓存机制（稍后会介绍），如果该请求对应的回复已经在磁盘缓存中，那么Chromium无需再建立HttpTransaction来发起连接，而是直接从磁盘中获取即可。如果磁盘中没有该URL的缓存，同时如果目前该URL请求对应的HttpTransaction已经建立，那么只要等待它的回复即可。当这些条件都不满足的时候，Chromium 实际上才会真正创建HttpTransaction对象。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/3x9ruL4MGbG59Khg.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><p>再次，HttpNetworkTransaction 类使用HttpNetworkSession 类来管理连接会话。</p><p>HttpNetworkSession类通过它的成员HttpStreamFactory 对象来建立TCP Socket连接，之后Chromium创建HttpStream对象。HttpStreamFactory对象将和网络之间的数据读写交给自己新创建的一一个HttpStream子类的对象来处理。</p><p>最后是套接字的建立。Chromium中与服务器建立连接的套接字是StreamSocket类，它是一一个抽象类，在POSIX系统和Windows系统上有着分别不同的实现。同时，为了支持SSL机制，StreamSocket类还有-一个子类一SSLSocket。图4-16显示了这些类和它们之间的关系。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/Ssn77qEXGwUk9Sqv.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><h4 id="4-3-2-3-代理"><a href="#4-3-2-3-代理" class="headerlink" title="4.3.2.3 代理"></a>4.3.2.3 代理</h4><p>当用户设置代理时，上面的网络栈结构是如何组织的呢？用户代理依赖以下类来处理。</p><ol><li>ProxyService：对于一个URL，HttpStreamFactory 类使用ProxyService类来获取代理信息。ProxyService类首先会检查当前的代理设置是不是最新的，如果不是，它依赖ProxyConfigService来重新获取代理信息。该类不处理实际任务，而是使用ProxyResolver类来做实际的代理工作。</li><li>ProxyConfigService：获取代理信息的类，可获取平台上的代理设置，在Linux、Windows.上有不同的实现。</li><li>ProxyScriptFetcher：Chromium 支持代理的JavaScript脚本，该类负责从代理的URL中获取该脚本。</li><li>ProxyResolver：实际负责代理的解释和执行，通常启用新的线程来处理，因为当前可能会被域名的解析所阻碍。</li><li>ProxyResolverV8：ProxyResolver的子类，使用V8引擎来解析和执行脚本。</li></ol><p>下图不仅描述上面这些类，也描述了Chromium中获取网络代理的过程。图中数字代表获取网络代理的次序，其中的分支3.1和4.1分别表示简单的代理设置和代理脚本设置的处理过程。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/Fb9e4AescqSYA2fZ.png!thumbnail?fileGuid=KlkKVeM5GGcJWqdr"                      alt="图片"                ></p><h4 id="4-3-2-4-域名解析（DNS）"><a href="#4-3-2-4-域名解析（DNS）" class="headerlink" title="4.3.2.4 域名解析（DNS）"></a>4.3.2.4 域名解析（DNS）</h4><p>通常情况下，用户都是使用域名来访问网络资源的，所以在建立TCP连接前需要解析域名。Chromium中使用HostResolverImpl类来解析域名，具体调用的函数是“getaddrinfo（）”，该函数是一个阻塞式的函数，所以Chromium理所当然使用单独的线程来处理它，这是Chromium的原则之一。因此当调试Chromium的进程时，会看到很多线程被创建然后退出。</p><p>为了考虑效率，使用HostCache类来保存解析后的域名，最多时会有多达1000个的域名和地址映射关系会被存储起来。看起来DNS的解析很简单，好像也没有什么值得深究的，其实不然，域名解析也可以有优化的空间，因为优化可以有效的减少用户等待的时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用网络栈下载网页和网页中的资源是渲染引擎工作过程的第一步，也是非常消耗时间的步骤。&lt;/p&gt;
&lt;h2 id=&quot;4-1-WebKit资源加载机制&quot;&gt;&lt;a href=&quot;#4-1-WebKit资源加载机制&quot; class=&quot;headerlink&quot; title=&quot;4.1 WebKit</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="WebKit技术内幕" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/WebKit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    
    <category term="第四章 资源加载和网络栈" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/WebKit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BD%91%E7%BB%9C%E6%A0%88/"/>
    
    
    <category term="WebKit" scheme="http://example.com/tags/WebKit/"/>
    
  </entry>
  
  <entry>
    <title>第三章 WebKit架构和模块</title>
    <link href="http://example.com/2021/01/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E4%B8%89%E7%AB%A0%20WebKit%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2021/01/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E4%B8%89%E7%AB%A0%20WebKit%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9D%97/</id>
    <published>2021-01-21T14:15:00.913Z</published>
    <updated>2021-01-22T08:46:04.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-WebKit-架构及模块"><a href="#3-1-WebKit-架构及模块" class="headerlink" title="3.1 WebKit 架构及模块"></a>3.1 WebKit 架构及模块</h2><h3 id="3-1-1-获取WebKit"><a href="#3-1-1-获取WebKit" class="headerlink" title="3.1.1 获取WebKit"></a>3.1.1 获取WebKit</h3><p>WebKit是一个开源项目，可以从<a class="link"   href="http://www.webkit.org官方网站下载源代码./" >www.webkit.org官方网站下载源代码。<i class="fas fa-external-link-alt"></i></a></p><h3 id="3-1-2-WebKit-架构"><a href="#3-1-2-WebKit-架构" class="headerlink" title="3.1.2 WebKit 架构"></a>3.1.2 WebKit 架构</h3><p>WebKit支持不同的浏览器，因为不同浏览器的需求不同，所以在WebKit中，一些代码可以共享，另外一部分不同的被称为WebKit的移植（Ports）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/3NEAHZuv3WuglE3I.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></p><p>图中的WebKit架构，虚线框表示该部分模块在不同浏览器使用的WebKit内核中的实现不是普遍共享的，实线框标记的模块表示它们基本上是共享的，但是否共享可以通过不同的编译配置改变它们的行为。</p><p>图中最下面的是“<strong>操作系统</strong>”，WebKit可以在不同的操作系统上工作。不同浏览器可能会依赖不同的操作系统，同一个浏览器使用的WebKit也可能依赖不同的操作系统。</p><p>在“操作系统”层之上的就是WebKit赖以工作的<strong>第三方库</strong>，这些库是WebKit运行的基础。通常来讲，它们包括<strong>图形库</strong>、<strong>网络库</strong>、<strong>视频库</strong>等。</p><p>在它们二者之上的就是WebKit项目，图中把它细分为两层，每层包含很多模块，由于图的大小限制，略去了其中一些次要模块。这些模块支撑网页加载和渲染过程。</p><p><strong>WebCore</strong>是加载和渲染网页的基础部分，包括<strong>HTML解释器</strong>、<strong>CSS解释器</strong>、<strong>SVG</strong>、<strong>DOM</strong>、<strong>渲染树</strong>（RenderObject树、RenderLayer树等），以及<strong>Inspector</strong>（Web Inspector、调试网页）。这些共享部分有些是基础框架，其背后的支持也需要各个平台的不同实现。WebCore这些部分主要被加载和渲染过程的第一、二阶段所使用。</p><p><strong>JavaScriptCore引擎</strong>是WebKit中的默认JavaScript 引擎，WebKit 中对JavaScript 引擎的调用是独立于引擎的。</p><p><strong>WebKit Ports</strong>指的是WebKit中的非共享部分，包括<strong>硬件加速架构</strong>、<strong>网络栈</strong>、<strong>视频解码</strong>、<strong>图片解码</strong>等。这些模块由于平台差异、依赖的第三方库和需求不同等方面原因，就产生了移植部分，导致众多WebKit版本的行为并非一致。</p><p>在WebCore和WebKit Ports之上的层主要是提供嵌入式编程接口，是提供给浏览器调用的。图中左右两个部分分别是<strong>狭义WebKit的接口</strong>和<strong>WebKit2的接口</strong>。因为接口与具体的移植有关，所以有一个与浏览器相关的<strong>绑定层，</strong>绑定层上面就是WebKit项目对外暴露的接口层。接口层的定义也是与移植密切相关的。</p><p>WebKit还有一个部分<strong>测试用例</strong>在图中没有展现出来，包括<strong>布局测试用例</strong>（Layout Tests）和<strong>性能测试用例</strong>（Performance Tests），这两类测试包含了大量的测试用例和期望结果。总体上来讲WebKit移植还是共享大量的用例。这些用例被用来验证渲染结果的正确性。每个浏览器所用的WebKit必须保证能够编译出来一个可执行程序，称为DumpRenderTree，它被用来运行测试用例并将渲染结果同期望结果对比。</p><h2 id="3-2-基于Blink的Chromium浏览器结构"><a href="#3-2-基于Blink的Chromium浏览器结构" class="headerlink" title="3.2 基于Blink的Chromium浏览器结构"></a>3.2 基于Blink的Chromium浏览器结构</h2><h3 id="3-2-1-Chromium浏览器的架构及模块"><a href="#3-2-1-Chromium浏览器的架构及模块" class="headerlink" title="3.2.1 Chromium浏览器的架构及模块"></a>3.2.1 Chromium浏览器的架构及模块</h3><p>Chromium也是基于WebKit（Blink）的。</p><h4 id="3-2-1-1-架构和模块"><a href="#3-2-1-1-架构和模块" class="headerlink" title="3.2.1.1 架构和模块"></a>3.2.1.1 架构和模块</h4><h3 id=""><a href="#" class="headerlink" title=""></a><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/IinKReweDux5nZou.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></h3><p>Chromium的架构和主要的模块中，Blink 只是其中的一块，和它并列的还有众多的Chromium模块，包括<strong>GPU/CommandBuffer</strong>（硬件加速架构）、<strong>V8 JavaScript引擎</strong>、<strong>沙箱模型</strong>、<strong>CC</strong>（Chromium Compositor）、<strong>IPC</strong>、<strong>UI</strong>等。</p><p><strong>Content 模块</strong>和<strong>Content API</strong>（接口）是Chromium对渲染网页功能的抽象。Content这里是指用来渲染网页内容的模块，没有Content模块，浏览器的开发者也可以在WebKit的Chromium移植上渲染网页内容，但是却没有办法获得沙箱模型、跨进程的GPU硬件加速机制、众多的HTML5功能，因为这些功能很多是在Content层里实现的。</p><p>Content模块和Content API将下面的渲染机制、安全机制和插件机制等隐藏起来，提供一个接口层。该接口目前被上层模块或者其他项目使用，内部调用者包括Chromium浏览器、Content Shell 等，外部包括<strong>CEF</strong>（Chromium Embedded Framework）、Opera 浏览器等。</p><p><strong>Chromium浏览器</strong>和<strong>Content Shell</strong>是构建在Content API之上的两个“浏览器”，Chromium具有浏览器完整的功能，而Content Shell是使用Content API来包装的一层简单的“壳”，但也是一个简单的“浏览器”，用户可以使用Content模块来渲染和显示网页内容。Content Shell的作用，其一可以用来测试Content模块很多功能的正确性，例如渲染、硬件加速等；其二是一个参考，可以被很多外部的项目参考来开发基于Content API的浏览器或者各种类型的项目。</p><p>在Android系统上，ContentShell的作用更大，这是因为同它并排的左侧的Chromium浏览器的代码没有开源，导致开发者只能依赖Content Shell。</p><p><strong>Android WebView</strong>是为了满足Android系统上的WebView而设计的，其思想是利用Chromium的实现来替换原来Android系统默认的WebView。</p><h4 id="3-2-1-2-多进程模型"><a href="#3-2-1-2-多进程模型" class="headerlink" title="3.2.1.2 多进程模型"></a>3.2.1.2 多进程模型</h4><p>多进程模型的好处：</p><ol><li>避免因单个页面的不响应或者崩溃而影响整个浏览器的稳定性，特别是对用户界面的影响；</li><li>当第三方插件崩溃时不会影响页面或者浏览器的稳定性，因为第三方插件也被使用单独的进程来运行；</li><li>方便了安全模型的实施，也就是沙箱模型是基于多进程架构的。这很大程度上也是WebKit2 产生的原因。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/qT1uN6gND8xF5hwh.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></p><p>Chromium架构设计的灵活性，使用者还可以通过设置来改变它的进程模型方式。图中方框代表进程，连接线代表IPC进程间通信。</p><p><strong>Browser进程</strong>：浏览器的主进程，负责浏览器界面的显示、各个页面的管理，是所有其他类型进程的祖先，负责它们的创建和销毁等工作，它有且仅有一个。</p><p><strong>Renderer进程</strong>：网页的渲染进程，负责页面的渲染工作，Blink/WebKit 的渲染工作主要在这个进程中完成，可能有多个，但是Renderer 进程的数量与用户打开的网页数量不一定一致。因为Chromium允许用户配置，此外在沙箱模型启动的情况下，该进程可能会发生一些改变。</p><p><strong>NPAPI插件进程</strong>：该进程是为NPAPI 类型的插件而创建的。其创建的基本原则是每种类型的插件只会被创建一次，而且仅当使用时才被创建。当多个网页使用同一种类型的插件的时候，进程会为每个使用者创建一个实例，所以插件进程是被共享的。</p><p><strong>GPU进程</strong>：最多只有一个，当且仅当GPU硬件加速打开的时候才会被创建，主要用于对3D图形加速调用的实现。</p><p><strong>Pepper插件进程</strong>：同NPAPI插件进程，不同的是为Pepper 插件而创建的进程。</p><p><strong>其他类型的进程</strong>：图中还有一些其他类型的进程在之后介绍。</p><p>对于桌面系统（Windows、Linux、Mac OS）中的Chromium浏览器，它们的进程模型总结后包括以下一些特征：</p><ol><li>Browser进程和页面的渲染是分开的，页面渲染导致的崩溃不会导致浏览器主界面的崩溃。</li><li>每个网页是独立的进程，这保证了页面之间相互不影响。</li><li>插件进程也是独立的，插件本身的问题不会影响浏览器主界面和网页。</li><li>GPU 硬件加速进程也是独立的。</li></ol><p>对于Chromium的Android版，主体进程模型大致相同，不同主要指：</p><ol><li><strong>GPU进程，</strong>GPU进程演变成Browser进程的一个线程，目的之一是节省资源。</li><li><strong>Renderer进程，</strong>Android版不支持插件，所以没有插件进程，Renderer也是独立的进程，但是会演变成Android上的服务（service）进程。而且由于Android系统的局限性，Renderer进程的数目会被严格限制，这就涉及到了影子（Phantom）标签的议题。影子标签就是浏览器会将后台的网页所使用的渲染设施都清除，只是原来的一个影子，当用户再次切换的时候，网页需要重新加载和渲染。</li></ol><p>Chromium允许用户配置Renderer 进程被创建的方式，模型的类型有：</p><ol><li><strong>Process-per-site-instance</strong>：该类型的含义是为每一个页面都创建一个独立的Render进程，不管这些页面是否来自于同一域。好处是每个页面互不影响，坏处是资源的浪费。</li><li><strong>Process-per-site</strong>：该类型的含义是属于同一个域的页面共享同一个进程，而不同属一个域的页面则分属不同的进程。好处是对于相同的域，进程可以共享，内存消耗相对较小，坏处是可能会有特别大的Renderer 进程。</li><li><strong>Process-per-tab</strong>：该类型的含义是为每个标签页都创建一个独立的进程，而不管它们是否是不同域不同实例，这也是Chromium的默认行为，但会浪费资源。</li><li><strong>Single process</strong>：该类型的含义是不为页面创建任何独立的进程，所有渲染工作都在Browser进程中进行，它们是Browser进程中的多个线程。这个类型在桌面系统上一般不推荐使用，只有在比较单进程和多进程时相对有用，但在Chromium的Android版本上，在Android WebView中，该模式被采用。<h4 id="3-2-1-3-Browser进程和Renderer进程"><a href="#3-2-1-3-Browser进程和Renderer进程" class="headerlink" title="3.2.1.3 Browser进程和Renderer进程"></a>3.2.1.3 Browser进程和Renderer进程</h4></li></ol><p>Browser进程和Renderer进程都是在WebKit的接口之外由Chromium引入的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/CTnRBqgG4ElY7uhV.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></p><p><strong>WebKit接口层</strong>，一般基于WebKit接口层的浏览器直接在上面构建，而没有引入复杂的多进程架构。</p><p><strong>WebKit黏附层</strong>，因为Chromium中一些类型和WebKit内部不一致，所以需要一个桥接层。</p><p><strong>Renderer</strong>，主要处理进程间通信，接受来自Browser进程的请求，并调用相应的WebKit接口层。同时将WebKit的处理结果发送回去。上面这些层都是在Renderer进程中工作的。</p><p><strong>RendererHost</strong>，目的也是处理同Renderer进程之间的通信，不过RendererHost是给Renderer进程发送请求并接收来自Renderer进程的结果。</p><p><strong>Web Contents</strong>表示的是网页的内容，它同时包括显示网页内容的子窗口，子窗口最后被嵌入浏览器的用户界面，作为它的一个标签页。</p><h4 id="3-2-1-4-多线程模型"><a href="#3-2-1-4-多线程模型" class="headerlink" title="3.2.1.4 多线程模型"></a>3.2.1.4 多线程模型</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/vbkdMTBjTVYMog53.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></p><p>网页的加载和渲染过程在图中模型下的基本工作方式如以下步骤：</p><ol><li>Browser进程收到用户的请求，首先由UI线程处理，而且将相应的任务转给IO线程，它随即将该任务传递给Renderer进程。</li><li>Renderer进程的IO线程经过解释后交给渲染线程。渲染线程接受请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。最后Renderer进程将结果由IO线程传递给Browser进程。</li><li>最后，Browser进程接收到结果并将结果绘制出来。</li></ol><p>Chromium为了保持线程间通信和同步，同时避免造成死锁或者资源的竞争冲突等问题，在绝大多数的场景，使用事件和一种Chromium新创建的任务传递机制，仅在非用不可的情况下才使用锁或者线程安全对象。</p><h4 id="3-2-1-5-Content接口"><a href="#3-2-1-5-Content接口" class="headerlink" title="3.2.1.5 Content接口"></a>3.2.1.5 Content接口</h4><p>Content接口不仅提供了一层对多进程进行渲染的抽象接口，而且它支持所有的HTML5功能、GPU硬件加速功能和沙箱机制。Content接口按照功能分成六个部分，每个部分的接口一般也可以分成两类，第一类是嵌入者（可以是Chromium浏览器、CEF3和Content Shell）调用的接口，另一类是嵌入者应该实现的回调接口，被Content接口的内部实现所调用，用来参与具体实现的逻辑或者事件的监听等。</p><ol><li><strong>App</strong>。这部分主要与应用程序或者进程的创建和初始化相关，它被所有的进程使用，用来处理一些进程的公共操作。包括两种类型，第一类主要包括进程创建的初始化函数，也就是Content模块的初始化和关闭动作；第二类主要是各种回调函数，用来告诉嵌入者启动完成，进程启动、退出，沙盒模型初始化开始和结束等。</li><li><strong>Browser</strong>。第一类包括对一些HTML5功能和其他高级功能实现的参与。第二类主要是实现部分的逻辑，被Browser进程调用，还有就是一些事件的函数回调。</li><li><strong>Common</strong>。主要定义一些公共的接口，这些被Renderer和Browser共享，例如一些进程相关、参数、GPU相关等。</li><li><strong>Plugin</strong>。仅有一个接口类，通知嵌入者Plugin进程何时被创建。</li><li><strong>Renderer</strong>。第一类包含获取RenderThread的消息循环、注册V8Extension、计算JavaScript表达式等。第二类包括ContentRendererClient，主要是实现部分逻辑，被Browser端（或者进程）调用，还有就是一些事件的函数回调。</li><li><strong>Utility</strong>。工具类接口，主要包括让嵌入者参与Content接口中的线程创建和消息的过滤。<h2 id="3-3-WebKit2"><a href="#3-3-WebKit2" class="headerlink" title="3.3 WebKit2"></a>3.3 WebKit2</h2></li></ol><h3 id="3-3-1-WebKit2架构及模块"><a href="#3-3-1-WebKit2架构及模块" class="headerlink" title="3.3.1 WebKit2架构及模块"></a>3.3.1 WebKit2架构及模块</h3><p>相比于狭义的WebKit，WebKit2是一套全新的结构和接口。它主要目的和思想同Chromium类似，就是将渲染过程放在单独的进程中来完成，独立于用户界面。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/DcFsDgQUQEzoXb3W.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></p><p>WebKit2中也引入了插件进程和网络进程。Web进程对应于Chromium中的Renderer进程，主要是渲染网页。UI进程对应于Chromium中的Browser进程。接口就暴露在该进程中，应用程序只需调用该接口即可。应用程序指的是浏览器或者任何使用该接口的程序。</p><h3 id="3-3-2-WebKit-和WebKit2嵌入式接口"><a href="#3-3-2-WebKit-和WebKit2嵌入式接口" class="headerlink" title="3.3.2 WebKit 和WebKit2嵌入式接口"></a>3.3.2 WebKit 和WebKit2嵌入式接口</h3><p>WebKit提供嵌入式接口，该接口表示其他程序可以将网页渲染嵌入在程序中作为其中的一部分，或用户界面的一部分。对于WebKit的Chromium移植来说，它的接口主要用于Chromium浏览器，而不是嵌入式的使用方式。</p><p>在WebKit项目中，狭义WebKit的接口主要思想是将网页的渲染结果作为用户界面中的一个窗口部件，它用来显示网页的内容。按功能大致可以把所有接口分成六种类型：</p><ol><li>设置加载网页、获取加载进度、停止加载、重新加载等；</li><li>遍历前后浏览记录类，可以前进、后退等；</li><li>网页的很多设置，例如缩放、主题、背景、模式、编码等；</li><li>查找网页的内容、高亮等；</li><li>触控事件、鼠标事件处理；</li><li>查看网页源代码、显示调试窗口等与开发者相关的接口，是通常的嵌入式接口提供的功能。</li></ol><p>WebKit2接口不同于WebKit的接口，它们是不兼容的，但目的都是提供嵌入式的应用接口。WebKit2接口大致可以分为两个大的部分，</p><ol><li><strong>WebView相关的接口</strong>，表示渲染的设置、渲染过程、界面等，其中大多数跟各个移植紧密相关。有三个主要的类，它们被各个移植所共享。<ol><li>WKView[Ref]：表示的是一个与平台相关的视图，例如在Windows上它表示的就是一个窗口的句柄。</li><li>WKContextRef：所有页面的上下文，这些被共享的信息包括local storage、设置等。</li><li>WKPageRef：表示网页，也就是浏览的基本单位。</li></ol></li><li>上面<strong>接口依赖的基础类</strong>，它们被各个移植所共享，既包括容器、字符串等基础类，也包括跟网页相关的基础类，例如URL、请求、网页设置等。</li></ol><p>WebKit2还有WebBundle接口，在Web进程里，其目的是让某些移植访问DOM，目前还没有明确的需求。</p><h3 id="3-3-3-比较WebKit2和Chromium的多进程模型以及接口"><a href="#3-3-3-比较WebKit2和Chromium的多进程模型以及接口" class="headerlink" title="3.3.3 比较WebKit2和Chromium的多进程模型以及接口"></a>3.3.3 比较WebKit2和Chromium的多进程模型以及接口</h3><p>下图详细描述了WebKit 接口和Chromium的多进程的关系，以及和Content接口的关系。前面笔者也介绍了一些，例如Renderer进程直接调用WebKit接口，以及和Content接口允许应用程序注入并参与Content之下各个进程的内部逻辑。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://uploader.shimo.im/f/IZ9qB9RUHmSwUfSc.png!thumbnail?fileGuid=9030MK2NX4Te8Pqw"                      alt="图片"                ></p><p>首先，Chromium使用的仍然是WebKit接口，而不是WebKit2接口，也就是说Chromium是在WebKit接口之上构建的多进程架构。</p><p>其次，WebKit2 的接口希望尽量将多进程结构隐藏起来，但对Chromium来说，它的主要目的是给Chromium提供Content接口以便构建浏览器，其本身目标不是提供嵌入式接口，虽然有CEF项目基于它构建了嵌入式接口。</p><p>最后，Chromium中每个进程都是从相同的二进制可执行文件启动，而基于WebKit2的进程则未必如此。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-WebKit-架构及模块&quot;&gt;&lt;a href=&quot;#3-1-WebKit-架构及模块&quot; class=&quot;headerlink&quot; title=&quot;3.1 WebKit 架构及模块&quot;&gt;&lt;/a&gt;3.1 WebKit 架构及模块&lt;/h2&gt;&lt;h3 id=&quot;3-1-1-获取W</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="WebKit技术内幕" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/WebKit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    
    <category term="第三章 WebKit架构和模块" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/WebKit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E4%B8%89%E7%AB%A0-WebKit%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    
    
    <category term="WebKit" scheme="http://example.com/tags/WebKit/"/>
    
  </entry>
  
  <entry>
    <title>第二章 HTML网页和结构</title>
    <link href="http://example.com/2021/01/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20HTML%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/01/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/webkit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20HTML%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BB%93%E6%9E%84/</id>
    <published>2021-01-21T14:14:56.404Z</published>
    <updated>2021-01-22T10:39:27.813Z</updated>
    
    <content type="html"><![CDATA[<p>HTML网页是利用HTML语言编写的文档，它是一种半结构化的数据表现方式。它的结构特征可以归纳为三种：树状结构、层次结构和框结构。</p><h2 id="2-1-网页构成"><a href="#2-1-网页构成" class="headerlink" title="2.1 网页构成"></a>2.1 网页构成</h2><h3 id="2-1-1-基本元素和树状结构"><a href="#2-1-1-基本元素和树状结构" class="headerlink" title="2.1.1 基本元素和树状结构"></a>2.1.1 基本元素和树状结构</h3><p>现在的网页基本上都是动态网页（Dynamic HTML），这就需要JavaScript代码用来控制网页内部的逻辑，CSS用来描述网页的显示信息。</p><p>整个网页可以看成一种树状结构，其树根是html，这是网页的根元素（或称节点）。根下面包含两个子节点head和body。</p><h3 id="2-1-2-HTML-5新特性"><a href="#2-1-2-HTML-5新特性" class="headerlink" title="2.1.2 HTML.5新特性"></a>2.1.2 HTML.5新特性</h3><p>HTML5引入的对2D和3D图形以及多媒体方面的支持，将彻底改变网页的渲染方式和复杂度，包括但是不限于：</p><ol><li><strong>video元素</strong>，支持在网页中播放视频。</li><li><strong>Canvas 2D</strong>，Canvas 2D通过定义一个新的“canvas”元素，网页开发者利用该元素的2D绘图上下文（graphics context）调用标准定义的接口，绘制常见的2D图形，例如点、线、矩形、多边形等。</li><li><strong>WebGL</strong>（也就是Canvas 3D）。WebGL则是使用“canvas”元素的3D绘图上下文调用标准定义的接口，绘制3D图形，这些接口类似于OpenGL ES的接口。</li><li><strong>CSS3 3D变换</strong>（transform）和<strong>转换</strong>（transition）。CSS3 3D的变换和转换则可以作用于HTML的任意可视元素，制造出各种炫丽的3D效果。<h2 id="2-2-网页结构"><a href="#2-2-网页结构" class="headerlink" title="2.2 网页结构"></a>2.2 网页结构</h2></li></ol><h3 id="2-2-1-框结构"><a href="#2-2-1-框结构" class="headerlink" title="2.2.1 框结构"></a>2.2.1 框结构</h3><p>框结构可以用来对网页的布局进行分割，将网页分成几个框。网页开发者也可以让网页嵌入其他的网页，frameset、frame和iframe可以用来在当前网页中嵌入新的框结构。多框结构的网页非常不适合移动领域，因为该结构对触控操作来说是不方便的。</p><h3 id="2-2-2-层次结构"><a href="#2-2-2-层次结构" class="headerlink" title="2.2.2 层次结构"></a>2.2.2 层次结构</h3><p>网页的层次结构是指网页中的元素可能分布在不同的层次中，也就是某些元素可能不同于它的父元素所在的层次，同时CSS部分的代码也会对网页的分层策略产生重要影响。</p><p>对于需要复杂变换和处理的元素，WebKit 为它们构建新层其实是为了渲染引擎在处理上的方便和高效。</p><h2 id="2-3-WebKit的网页渲染过程"><a href="#2-3-WebKit的网页渲染过程" class="headerlink" title="2.3 WebKit的网页渲染过程"></a>2.3 WebKit的网页渲染过程</h2><h3 id="2-3-1-加载和渲染"><a href="#2-3-1-加载和渲染" class="headerlink" title="2.3.1 加载和渲染"></a>2.3.1 加载和渲染</h3><p>浏览器的主要作用就是将用户输入的“URL”转变成可视化的图像，包含两个过程，一是网页加载过程，就是从“URL”到构建DOM树；二是网页渲染过程，从DOM树到生成可视化图像。这两个过程也会交叉，统称这两个过程为网页的渲染过程。</p><p>网页通常比我们的屏幕可视面积要大，当前可见的区域称为<strong>视图</strong>（viewport），浏览器在渲染网页的时候，一般会加入滚动条以帮助翻滚网页。</p><h3 id="2-3-2-WebKit的渲染过程"><a href="#2-3-2-WebKit的渲染过程" class="headerlink" title="2.3.2 WebKit的渲染过程"></a>2.3.2 WebKit的渲染过程</h3><p>网页的一般渲染过程中的数据包括网页内容、DOM、内部表示和图像，模块则包括HTML解释器、CSS解释器、JavaScript 引擎以及布局和绘图模块。</p><p>根据数据的流向，将渲染过程分成三个阶段，第一个阶段是从网页的URL到构建DOM树，第二个阶段是从DOM树到构建WebKit的绘图上下文，第三个阶段是从绘图上下文到生成最终的图像。</p><h4 id="2-3-2-1-第一个阶段：从网页的URL到构建DOM树"><a href="#2-3-2-1-第一个阶段：从网页的URL到构建DOM树" class="headerlink" title="2.3.2.1 第一个阶段：从网页的URL到构建DOM树"></a>2.3.2.1 第一个阶段：从网页的URL到构建DOM树</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/uSXBGLwftTz59OfO__thumbnail.png"                      alt="图片"                ></p><p>具体的过程如下：</p><ol><li>当用户输入网页URL的时候，WebKit调用其资源加载器加载该URL对应的网页。</li><li>加载器依赖网络模块建立连接，发送请求并接收答复。</li><li>WebKit接收到各种网页或者资源的数据，某些资源可能是同步或异步获取的。</li><li>网页被交给HTML解释器转变成一系列的词语（Token）。</li><li>解释器根据词语构建节点（Node），形成DOM树。</li><li>如果节点是JavaScript代码的话，调用JavaScript引擎解释并执行。</li><li>JavaScript代码可能会修改DOM树的结构。</li><li>如果节点需要依赖其他资源，例如图片、CSS、视频等，调用资源加载器来加载它们，但是它们是异步的，不会阻碍当前DOM树的继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol><p>在上述的过程中，网页在加载和渲染过程中会发出“DOMConent”事件和DOM的“onload”事件，分别在DOM树构建完之后，以及DOM树建完并且网页所依赖的资源都加载完之后发生，因为某些资源的加载并不会阻碍DOM树的创建，所以这两个事件多数时候不是同时发生的。</p><h4 id="2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文"><a href="#2-3-2-2-第二个阶段：从DOM树到构建完WebKit的绘图上下文" class="headerlink" title="2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文"></a>2.3.2.2 第二个阶段：从DOM树到构建完WebKit的绘图上下文</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/5zAmE3T5IrREBagI__thumbnail.png"                      alt="图片"                ></p><p>这一阶段的具体过程如下。</p><ol><li>CSS文件被CSS解释器解释成内部表示结构。</li><li>CSS解释器工作完之后，在DOM树上附加解释后的样式信息，这就是RenderObject树。</li><li>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文，这中间还有复杂的内部过程。</li></ol><p>RenderObject树的建立并不表示DOM树会被销毁，图中的四个内部表示结构一直存在，直到网页被销毁。</p><h4 id="2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。"><a href="#2-3-2-3-第三个阶段：是从绘图上下文到生成最终的图像。" class="headerlink" title="2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。"></a>2.3.2.3 第三个阶段：是从绘图上下文到生成最终的图像。</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/3oObbcPTpx9gzPCi__thumbnail.png"                      alt="图片"                ></p><p>图中这一阶段对应的具体过程如下。</p><ol><li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的绘图具体实现类。</li><li>绘图实现类有简单或复杂的实现。在Chromium中，它的实现相当复杂，需要Chromium的合成器来完成复杂的多进程和GPU加速机制。</li><li>绘图实现类将 2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来同浏览器界面一起显示。</li></ol><p>现代浏览器为了绘图上的高效性和安全性，可能会在这一过程中引入复杂的机制。而且，绘图也从之前单纯的软件渲染，到现在的GPU硬件渲染、混合渲染模型等方式。</p><p>现代网页很多是动态网页，这意味着在渲染完成之后，由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTML网页是利用HTML语言编写的文档，它是一种半结构化的数据表现方式。它的结构特征可以归纳为三种：树状结构、层次结构和框结构。&lt;/p&gt;
&lt;h2 id=&quot;2-1-网页构成&quot;&gt;&lt;a href=&quot;#2-1-网页构成&quot; class=&quot;headerlink&quot; title=&quot;2.1</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="WebKit技术内幕" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/WebKit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    
    <category term="第二章 HTML网页和结构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/WebKit%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0-HTML%E7%BD%91%E9%A1%B5%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="WebKit" scheme="http://example.com/tags/WebKit/"/>
    
  </entry>
  
</feed>
