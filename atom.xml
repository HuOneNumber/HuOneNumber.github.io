<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>别着急，慢慢来</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-08T12:42:37.181Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>胡倚豪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The elements of HTML（四）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-03-08T12:31:19.780Z</published>
    <updated>2021-03-08T12:42:37.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>表单</strong>是一种网页组件，可以包含表单控件如文本，按钮，复选框，范围或颜色选择器控件。 用户可以与这样的表单进行交互并提供数据，随后这些数据被发送到服务器用于进一步处理 （例如返回搜索或计算结果）。</p><p>编写表单的步骤（没有顺序）：编写用户界面、实现服务器端的处理、用户界面与服务器端通信的配置。</p><h1 id="用户界面的编写"><a href="#用户界面的编写" class="headerlink" title="用户界面的编写"></a>用户界面的编写</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Customer name: <span class="tag">&lt;<span class="name">input</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Telephone: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">tel</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>E-mail address: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">email</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span> Pizza Size <span class="tag">&lt;/<span class="name">legend</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span>&gt;</span> Small <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span>&gt;</span> Medium <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span>&gt;</span> Large <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">legend</span>&gt;</span> Pizza Toppings <span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">checkbox</span>&gt;</span> Bacon <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">checkbox</span>&gt;</span> Extra Cheese <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">checkbox</span>&gt;</span> Onion <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">checkbox</span>&gt;</span> Mushroom <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Preferred delivery time: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">time</span> <span class="attr">min</span>=<span class="string">&quot;11:00&quot;</span> <span class="attr">max</span>=<span class="string">&quot;21:00&quot;</span> <span class="attr">step</span>=<span class="string">&quot;900&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Delivery instructions: <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Submit order<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">**简要说明：**</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>表单都以****form 元素开始。多数控件都由 input 元素表示，它默认提供一个文本控件。</li><li>使用 label 元素来描述控件，标签文本和控件自己都会进入 label 元素内。</li><li>表单的每一部分都是一个段落，一般用 p 元素来与其他部分分隔。</li><li>单选按钮用 input 元素，设置 type 属性，值为 radio。 name属性值一样让单选按钮成组。</li><li>fieldset 元素让一批控件成为一组，控件组的标题由 fieldset 中的 legend 表示。</li><li>这些复选框使用 input 元素， type 属性值为 checkbox：。</li><li>电话号码的表单控件（type 属性设为 tel 的 input 元素）， e-mail 地址（type 属性设为 email 的 input 元素）：</li><li>type 属性设为 time 的 input 元素来询问配送时间。 很多控件都可以设置可选值的范围；这个例子中的属性是 min, max 和step。这些属性分别用来设置最小时间，最大时间， 以及允许的值之间的间隔（单位为秒）。</li><li>textarea 元素可以用来提供多行文本。</li><li>为了让表单可以提交，用一个 button 元素。<h1 id="用户界面与服务器端通信的配置"><a href="#用户界面与服务器端通信的配置" class="headerlink" title="用户界面与服务器端通信的配置"></a>用户界面与服务器端通信的配置</h1></li></ol><p>表单提交通常是GET 或 POST 请求。在 form 元素上使用 method 属性来指定使用哪种方法。 指定编码方式要使用 enctype 属性。action 属性来指定处理提交的数据服务的 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot;</span><br><span class="line">      enctype&#x3D;&quot;application&#x2F;x-www-form-urlencoded&quot;</span><br><span class="line">      action&#x3D;&quot;https:&#x2F;&#x2F;pizza.example.com&#x2F;order.cgi&quot;&gt;</span><br></pre></td></tr></table></figure><p>每个需要提交的表单控件都要有一个名字来对应提交的数据。属性name指定了提交的名字。他们之间可以通过 value 属性给它们不同的值来区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size value&#x3D;&quot;small&quot;&gt; Small &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;label&gt;&lt;input type&#x3D;radio name&#x3D;size value&#x3D;&quot;medium&quot;&gt; Medium &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;&lt;label&gt;&lt;input type&#x3D;radio name&#x3D;size value&#x3D;&quot;large&quot;&gt; Large &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h1 id="客户端表单验证"><a href="#客户端表单验证" class="headerlink" title="客户端表单验证"></a>客户端表单验证</h1><p>通过表单标记使得用户代理可以在表单提交之前检查用户输入，但服务器仍然必须校验输入是有效的（因为恶意用户可以很容易绕过表单验证）， 但这使我们可以避免因为只能在服务器上检查而造成用户等待。input 元素上的required 属性，表示只有给出值之后表单才可以提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;label&gt;Customer name: &lt;input name&#x3D;&quot;custname&quot; required&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>使用 maxlength 属性来限制输入的长度。 把这个属性添加到 textarea 元素上，我们可以限制用户输入到 1000 字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;label&gt;Delivery instructions: &lt;textarea name&#x3D;&quot;comments&quot; maxlength&#x3D;1000&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>提交表单时，每个不合法的表单控件上，以及 form 元素上都会触发 invalid 事件， 这个事件可以用来显示表单存在哪些问题的一个描述。</p><h1 id="启用表单控件的客户端自动填充"><a href="#启用表单控件的客户端自动填充" class="headerlink" title="启用表单控件的客户端自动填充"></a>启用表单控件的客户端自动填充</h1><p>浏览器可以帮助用户自动填充表单控件，避免让用户每次重新输入。为了帮助用户代理做自动填充，可以使用 autocomplete 属性来描述字段的用途。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;label&gt;Customer name: &lt;input name&#x3D;&quot;custname&quot; required autocomplete&#x3D;&quot;shipping name&quot;&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h1 id="提高用户手机端体验"><a href="#提高用户手机端体验" class="headerlink" title="提高用户手机端体验"></a>提高用户手机端体验</h1><p>有些设备使用inputmode属性为用户提供多种输入方式。例如，在输入信用卡号码时，用户可能希望只看到0-9数字键，而在输入姓名时，用户可能希望看到每个单词默认大写的表单字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;p&gt;&lt;label&gt;Buzzer code: &lt;input name&#x3D;&quot;custbuzz&quot; inputmode&#x3D;&quot;number&quot;&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h1 id="type-autocomplete-inputmode之间的区别"><a href="#type-autocomplete-inputmode之间的区别" class="headerlink" title="type, autocomplete, inputmode之间的区别"></a>type, autocomplete, inputmode之间的区别</h1><p>input元素上的type属性决定用户代理将使用哪种控件来公开字段。</p><p>autocomplete属性描述了用户将输入的值实际表示的内容。</p><p>当控件是文本控件时，inputmode属性决定使用哪种输入方式。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>|<strong>element</strong>|<strong>meaning</strong>|<strong>Categories</strong>|<strong>Contexts in which this element can be used</strong>|<strong>Content model</strong>|<strong>Tag omission in text/html</strong>|<strong>Content attributes</strong>|<strong>remark</strong>|<br>|:—-:|:—-|:—-:|:—-|:—-|:—-|:—-:|:—-|:—-:|:—-|:—-:|:—-|:—-|:—-|:—-|<br>|form|表单|Flow content.<br>Palpable content|flow content|Flow content,但没有form元素后代|不可省略|accept-charset—服务器处理表单数据的字符集<br>action — 表单提交的url<br>autocomplete—form内控件设置自动填充<br>enctype—发送表单数据之前如何对其进行编码<br>method —表单提交使用的HTTP方法<br>name — 用于使用API时的名称<br>novalidate —表单提交时不用进行验证<br>target —表单提交的上下文<br>rel|    |<br>|label|为 input 元素定义标注|Flow content<br>Phrasing content<br>Interactive content<br>Palpable content|phrasing content|Phrasing content，但没有后代labelable元素，除非它是元素的 labeled control且没有后代label。|不可省略|for — 绑定到哪个表单元素|1.要么通过for属性（属性值和需要绑定控件id一样），要么将控件放在label元素内。|</p><h1 id="Input-type"><a href="#Input-type" class="headerlink" title="Input type"></a>Input type</h1><p>|||button定义可单击的按钮（主要与JavaScript一起使用以激活脚本）|<br>|:—-|:—-|:—-:|:—-|<br>|||checkbox定义一个复选框|<br>|color<br>||定义颜色选择器|<br>|date<br>||定义日期控件（年，月，日（无时间））|<br>|datetime-local<br>||定义日期和时间控件（年，月，日，时间（无时区）|<br>|||file定义文件选择字段和“浏览”按钮（用于文件上载）|<br>|||image将图像定义为提交按钮|<br>|||month定义月份和年份控件（无时区）|<br>|||number定义用于输入数字的字段|<br>|||password定义密码字段|<br>|||radio定义单选按钮|<br>|||range定义范围控件（如滑块控件）|<br>|||reset定义重置按钮|<br>|||submit定义提交按钮|<br>|||time定义用于输入时间的控件（无时区）|<br>|week<br>||定义周和年控制（无时区）|<br>|||hidden定义隐藏的输入字段禁止进行约束验证；|<br>|||如果那么name和_charset_值相同，必须省略value属性。text定义单行文本字段没有指定type值或无效，默认为文本控件。|<br>|||输入值和value值禁止使用回车符或换行符。search定义用于输入搜索字符串的文本字段|<br>|||tel定义用于输入电话号码的字段输入值和value值禁止使用回车符或换行符。|<br>|||不强制使用特定规则。url定义用于输入URL的字段可以为空字符串，但不能使用回车符或换行符。|<br>|当元素的值既不是空字符串，也不是有效的绝对URL，元素的类型不匹配email<br>|||</p><h1 id="定义电子邮件地址的字段当设置了multiple属性：Input-attribute"><a href="#定义电子邮件地址的字段当设置了multiple属性：Input-attribute" class="headerlink" title="定义电子邮件地址的字段当设置了multiple属性：Input attribute"></a>定义电子邮件地址的字段当设置了multiple属性：Input attribute</h1><table><thead><tr><th align="left">accept</th><th align="left">规定通过文件上传来提交</th></tr></thead><tbody><tr><td align="left">alt</td><td align="left">图像不可用的替代文本</td></tr><tr><td align="left">autocomplete</td><td align="left">是否使用输入字段的自动</td></tr><tr><td align="left">checked</td><td align="left">首次加载时是否被选中</td></tr><tr><td align="left">dirname</td><td align="left">输入字段的文本方向</td></tr><tr><td align="left">disabled</td><td align="left">是否禁用此元素</td></tr><tr><td align="left">form</td><td align="left">规定输入字段所属的一个</td></tr><tr><td align="left">formaction</td><td align="left">覆盖表单的 action 属性</td></tr><tr><td align="left">formenctype</td><td align="left">覆盖表单的 enctype 属性</td></tr><tr><td align="left">formmethod</td><td align="left">覆盖表单的 method 属性</td></tr><tr><td align="left">formnovalidate</td><td align="left">覆盖表单的 novalidate</td></tr><tr><td align="left">formtarget</td><td align="left">覆盖表单的 target 属性n</td></tr><tr><td align="left">height</td><td align="left">高</td></tr><tr><td align="left">list</td><td align="left">预定义的选项列表</td></tr><tr><td align="left">max</td><td align="left">输入字段的最大值</td></tr><tr><td align="left">maxlength</td><td align="left">输入字段的最大长度</td></tr><tr><td align="left">min</td><td align="left">输入字段的最小值</td></tr><tr><td align="left">minlength</td><td align="left">输入字段的最小长度</td></tr><tr><td align="left">multiple</td><td align="left">是否允许多个值</td></tr><tr><td align="left">name</td><td align="left">元素名称</td></tr><tr><td align="left">pattern</td><td align="left">输入字段的值的格式</td></tr><tr><td align="left">placeholder</td><td align="left">用户填写输入字段的提示</td></tr><tr><td align="left">readonly</td><td align="left">是否允许用户修改</td></tr><tr><td align="left">required</td><td align="left">是否必须填写</td></tr><tr><td align="left">size</td><td align="left">控件尺寸</td></tr><tr><td align="left">src</td><td align="left">资源地址</td></tr><tr><td align="left">step</td><td align="left">输入的间隔</td></tr><tr><td align="left">type</td><td align="left">控件类型</td></tr><tr><td align="left">value</td><td align="left">元素的值</td></tr><tr><td align="left">width</td><td align="left">宽</td></tr><tr><td align="left">title</td><td align="left">pattern的描述</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;表单&lt;/strong&gt;是一种网页组件，可以包</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    <category term="The elements of HTML（四）" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/The-elements-of-HTML%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（三）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-03-08T12:31:17.696Z</published>
    <updated>2021-03-08T12:42:14.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="area元素"><a href="#area元素" class="headerlink" title="area元素"></a><strong>area元素</strong></h2><p>图像映射上文本和对应区域的超链接或图像映射上的dead area</p><p><strong>Categories</strong>:Flow content、Phrasing content.</p><p><strong>Contexts in which this element can be used</strong>:仅当有一个map祖先，phrasing content</p><p><strong>Content model</strong>:无</p><p><strong>Tag omission in text/html</strong>:没有结束标签</p><p><strong>Content attributes:</strong></p><p>Global attributes</p><p>alt —定义此区域的替换文本。</p><p>coords — 可点击区域的坐标</p><p>shape —定义区域的形状</p><p>href — 超链接地址</p><p>target — 在何处打开 href 属性指定的目标 URL</p><p>download — 是否下载资源后不是导航</p><p>ping — URLs to ping</p><p>rel —超链接的文档中的位置与目标资源之间的关系</p><p>referrerpolicy — Referrer policy</p><p>1、area的父元素一定是map</p><p>2、area有href属性，代表超链接，这种情况下，必须有alt属性。如果没有href属性，alt属性可以省略，target, download, ping, rel, referrerpolicy 必须省略。</p><p>3、shape</p><p>|State|Keywords|Notes|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|Circle state|circle|必须有 coords  属性（3个整数，最后一个非负）|<br>|    |circ|    |<br>|Default state|default|不能有 coords  属性|<br>|Polygon state|poly|必须有 coords  属性（至少6个整数，且是偶数）|<br>|    |polygon|    |<br>|Rectangle state|rect|必须有 coords  属性（4个整数，第一个小于第三个，第二个小于第四个）|<br>|    |rectangle|    |</p><p>4、如果area有itemprop属性，则也必须设置href属性</p><h2 id="MathML"><a href="#MathML" class="headerlink" title="MathML"></a><strong>MathML</strong></h2><p>MathML 是数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言。</p><math><p><mi>x</mi></p><p><mo>=</mo></p><mfrac><mrow><p><mo form="prefix">−</mo> <mi>b</mi></p><p><mo>±</mo></p><msqrt><p><msup> <mi>b</mi> <mn>2</mn> </msup></p><p><mo>−</mo></p><p><mn>4</mn> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mi>c</mi></p></msqrt></mrow><mrow><p><mn>2</mn> <mo>⁢</mo> <mi>a</mi></p></mrow></mfrac></math><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a><strong>SVG</strong></h2><p>是一种用于描述二维的矢量图形，基于 XML 的标记语言。SVG 相对于图像，就好比 HTML 相对于文本。</p><p>doc = iframe . getSVGDocument()</p><p>doc = embed . getSVGDocument()</p><p>doc = object . getSVGDocument()</p><p>如果iframe、embed或object元素用于嵌入SVG，则返回Document对象。</p><hr><h2 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h2><p>coords/coordinate  坐标值</p><p>rectangle 矩形</p><p>polygon 多边形</p><p>negative 负数；消极的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;area元素&quot;&gt;&lt;a href=&quot;#area元素&quot; class=&quot;headerlink&quot; title=&quot;area元素&quot;&gt;&lt;/a&gt;&lt;strong&gt;area元素&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;图像映射上文本和对应区域的超链接或图像映射上的dead area&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    <category term="The elements of HTML（三）" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/The-elements-of-HTML%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（二）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-03-08T12:31:15.086Z</published>
    <updated>2021-03-08T12:41:42.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>基于设备像素比。</strong>缩放级别和屏幕像素密度（上一点）都会影响单个CSS pixel 上的物理屏幕像素。适用当图片的于染大小固定的情况下，在 img 元素上用 src 和 srcset 属性， 使用 x 描述符来提供多个只有大小不同的图片（小图是大图的缩略版）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于视口的选择：</strong>作者可能要显示同一张图片，但渲染大小根据 viewport 宽度有所不同。 可以使用 srcset 和 sizes 属性，使用 w 描述符来提供多个只有大小不同的图片 （小图是大图的缩略版）。 用户代理将会根据指定的 w 描述符和 sizes 属性指定的渲染大小为每个图片计算等效像素密度。 然后它可以根据用户屏幕的像素密度、缩放级别和任何可能的其他因素（比如用户网络状态）选择任何一个资源。  通过使用 w 描述符和 sizes 属性， 不论用户设备有多大用户代理都可以选择下载正确的图片资源。 在新的用户代理中，当 srcset 属性使用 w 描述符时， src 属性会被忽略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">sizes</span>=<span class="string">&quot;100vw&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w&quot;</span>   <span class="attr">src</span>=<span class="string">&quot;wolf-400.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The rad wolf&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于艺术选择：</strong>作者可能会根据图片的渲染大小显示不同的图片内容。可以用 picture 元素和 source 元素和 media 属性提供多张内容不同的图片 （例如小的图片是大图的裁剪版）。 用户代理会选择 media 属性中的媒体查询匹配的第一个 source 元素，然后从它的 srcset 属性中选择一个合适的 URL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 45em)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;large.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 32em)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;med.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;small.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The wolf runs through the snow.&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于图片格式的选择：</strong>作者可能希望显示同样的图片内容但根据用户代理的支持情况使用不同的图片格式。 可以使用 source 元素上的 type 属性来提供多种格式的图片。在这个例子中，用户代理会选择第一个 type 属性为支持的 MIME 类型的源。 如果用户代理支持 WebP 就会选择第一个 source 元素。 如果不支持 WebP，但支持 JPEG XR 就会选择第二个 source 元素。 如果这两种都不支持，就会选择 img 元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/100-marie-lloyd.webp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jxr&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/vnd.ms-photo&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a><strong>Decoding</strong></h2><table><thead><tr><th align="left">Keyword</th><th align="left">State</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">sync</td><td align="left">Sync</td><td align="left">表示优先同步解码此图像，以便与其他内容进行原子表示。</td></tr><tr><td align="left">async</td><td align="left">Async</td><td align="left">指示优先选择异步解码此图像，以避免延迟其他内容的呈现。</td></tr><tr><td align="left">auto</td><td align="left">Auto</td><td align="left">表示默认值，用户代理可以自由选择任何解码行为。</td></tr></tbody></table><p>可以使用该decode()方法来控制解码行为。由于该decode()方法独立于负责将内容呈现到屏幕的过程执行解码，因此它不受decoding属性的影响</p><h2 id="alt使用"><a href="#alt使用" class="headerlink" title="alt使用"></a><strong>alt使用</strong></h2><p>除非另有说明，必须指定 alt 属性且它的值不能为空，且必须适合替代图片。 对 alt 属性具体的要求取决于它要表示什么图片.编写替代文本时要考虑的最一般规则如下：1、 alt 属性的文本替换每个图像不会改变页面的含义。2、 alt 属性的值不应该包含图片的 caption, title 或 legend 文本。3、 应该包含的替代文本是用于替代图片的，而不是图片的补充， 用 title 属性可以提供补充信息。5、 alt 属性的值不应该重复已经由后面的文字提供的信息。</p><p><strong>使用情况：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、当创建 超链接 的 a 元素或 button 元素没有文本内容只包含一个或更多图片时，alt 属性必须包含一些文字来传达链接或按钮的用途。</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;green.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;green.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>2、具有替代图形表示形式的短语或段落：图表，图表，图形，地图，插图，文本必须在alt属性中给出，并且必须传达与src 属性中指定的图像相同的消息。重要的是要意识到替代文本是图像的替代品，而不是图像的描述。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;house.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The house is white, with a boarded front door.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、一个文档可以包含图标信息，图标是为了帮助视觉浏览器的用户一目了然地识别功能。有些情况下，图标是文本标签的补充，它们传达同样的含义。 那些情况下，alt 属性必须存在且为空。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/help/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/icons/help.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span> Help<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外一些情况下，图标旁边没有文字来描述它的含义；这样的图标就应该解释自己的含义。 那些情况下，同等的文本标签必须通过alt 属性给出。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;movies.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、图像仅由文本组成，并且图像的目的是不是突出显示用于渲染文本的实际印刷效果，而是传达文本本身。在这种情况下，alt必须存在属性，但属性必须包含与图像本身相同的文本。在这种情况下，替代文本就是图像所代表的字符。（ps:如果由于作者的默认系统字体不支持给定字符而使他们倾向于使用图像，那么考虑Web字体。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;initials/o.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;O&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5、图像实际上只是补充，它的存在只会增强周围的文本。在这些情况下，alt必须存在该属性，但其值必须为空字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>According to a study covering several billion pages,about 9% triggered the Standards mode.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;rendering-mode-pie-chart.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6、辅助图像。图像对内容并不重要，但它既不是纯粹的装饰，也不是文本的全部多余。在这些情况下，该alt属性必须存在，并且其值应为空字符串或图像传达的信息的文本表示形式。</p><p>7、纯装饰性图像，这样的图像是装饰性的，但仍构成内容的一部分。alt必须存在该属性，但其值必须为空字符串。</p><p>8、组成但个没有链接的大图的图片组，当一张图片被切分为若干个小图片文件，用来拼装成原来的大图时，这些图片中要有一个的 alt 属性按照相关规则设置为大图的替代文本。 然后其他所有剩余图片必须把 alt 属性设为空字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;XYZ Corp&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo2.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>9、组成单个有链接的大图的图片组。通常带连接的图片应该使用 图片映射 而不是切分图片。但是，如果图片确实已经被切分了，而且切分后的部分是链接的唯一内容， 那么每个链接必须有一个图片必须把它的 alt 属性设置为表示链接用途的替代文本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?go=left&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-left.png&quot;</span>  <span class="attr">alt</span>=<span class="string">&quot;Left side. &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-middle.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?go=right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-right.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Right side.&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>10、内容的关键部分，图片是内容的关键部分。比如照片库页面中的图片，如何为内容关键的图片提供替代文本，取决于图片的出处。</p><p>通常情况：通过 alt 属性给出替代图片的文字。</p><p>难以提供完整描述的图片： alt 属性也必须包含一些适当的替代文本， 但可以比较简短。</p><p>未知内容的图片：alt 属性可以忽略，但必须符合以下条件之一：（1）img 元素在 包含 figcaption 的 figure 元素中， 且这个 figcaption 元素包含除元素间空白的内容，而且忽略 figcaption 元素及其后代节点后， figure 元素没有其他 流式内容 后代， 元素间空白 和 img 元素除外。（2）title 属性存在且值非空。</p><p>11、不是给用户看的图片，首先应该避免使用不用来显示的 img 元素。如果一个 img 元素不是用于显示的，比如用于计算页面浏览量的服务。 那么 alt 属性必须为空字符串。在这些场景下，width 和 height 属性必须设为 0。</p><p>12、给特定的、已知一定可以查看图片的人的 e-mail 或私人文档中的图片，可以省略alt 属性。但是，即使在这种情况下，也强烈建议作者包括替代文本，如上所示。</p><p>13、标记生成器指引</p><p>标记生成器应尽可能从用户那里获取替代文本。但是在许多情况下这是不可能的。</p><p>对于仅作为链接内容的图像，标记生成器应检查链接目标以确定目标标题或目标URL，并将以此方式获得的信息用作替代文本。</p><p>对于具有标题的图像，标记生成器应使用figure和 figcaption元素或title属性来提供图像的标题。</p><p>作为最后的选择，实现者应在图像为纯装饰性图像下（第7条），将alt 属性设置为空字符串，或假设图像是内容的关键部分（第10条未知内容的图片）完全省略alt属性。</p><p>标记生成器可以 在img元素上指定generator-unable-to-provide-required-alt 属性，这些元素他们无法为其获取替代文本，因此为其省略了该alt属性。</p><p>14、规范检查工具指引</p><p>规范检查工具必须把缺少 alt 属性报告为错误， 以下除外：上面第10条、12条、13条所举特殊情况。</p><h1 id="Media"><a href="#Media" class="headerlink" title="Media"></a><strong>Media</strong></h1><p>audio和video元素，都可用于音频和视频。主要区别只是audio元素没有视觉内容（例如视频或字幕）的播放区域，而video元素却有 。</p><h2 id="error-codes"><a href="#error-codes" class="headerlink" title="error codes"></a><strong>error codes</strong></h2><p>media.error  返回一个表示该元素当前错误状态的MediaError 对象。如无，返回null</p><p>media.error.code   返回当错错误状态的代码</p><p>media.error.message返回有关遇到的错误情况的特定信息诊断消息。消息和消息格式通常在不同的用户代理之间不一致。如果没有此类消息，则返回空字符串。</p><ul><li>1 = MEDIA_ERR_ABORTED - 取回过程被用户中止</li><li>2 = MEDIA_ERR_NETWORK - 当下载时某种网络发生错误</li><li>3 = MEDIA_ERR_DECODE - 当解码时发生错误</li><li>4 = MEDIA_ERR_SRC_NOT_SUPPORTED - 不支持音频/视频<h2 id="媒体资源位置"><a href="#媒体资源位置" class="headerlink" title="媒体资源位置"></a><strong>媒体资源位置</strong></h2></li></ul><p>media . srcObject [ = source ]    允许为media元素分配一个media provider对象。</p><p>media . currentSrc 返回当前媒体资源的URL。没有媒体资源或没有 URL时返回空字符串。</p><p>有三种方法可以指定媒体资源（优先级从大到小）：srcObjectIDL属性，src内容属性和source元素。</p><h2 id="MIME-types"><a href="#MIME-types" class="headerlink" title="MIME types"></a><strong>MIME types</strong></h2><p>只有不带参数的 application/octet-stream”MIME类型 “是特殊情况；如果出现任何参数，则将其与任何其他MIME type一样对待。</p><p>media . canPlayType(type)    检测浏览器是否能播放指定的音频/视频类型</p><p>返回值：</p><ol><li>“probably” - 浏览器最可能支持该音频/视频类型</li><li>“maybe” - 浏览器也许支持该音频/视频类型</li><li>“” - （空字符串）浏览器不支持该音频/视频类型</li></ol><p>source元素的type属性允许用户代理避免下载使用其无法呈现的格式的资源。</p><h2 id="Network-states"><a href="#Network-states" class="headerlink" title="Network states"></a><strong>Network states</strong></h2><p>media . networkState  从下面的代码列表中，返回该元素网络活动的当前状态。</p><ol><li>0 = NETWORK_EMPTY - 音频/视频尚未初始化</li><li>1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络</li><li>2 = NETWORK_LOADING - 浏览器正在下载数据</li><li>3 = NETWORK_NO_SOURCE - 未找到音频/视频来源<h2 id="Loading-the-media-resource"><a href="#Loading-the-media-resource" class="headerlink" title="Loading the media resource"></a><strong>Loading the media resource</strong></h2></li></ol><p>media . load()    重新加载音频/视频元素。</p><p>media . buffered  属性返回 TimeRanges 对象，表示用户的音视频缓冲范围。</p><p>TimeRanges 对象属性：</p><ol><li>length - 获得音视频中已缓冲范围的数量</li><li>start(index) - 获得某个已缓冲范围的开始位置</li><li>end(index) - 获得某个已缓冲范围的结束位置<h2 id="Offsets-into-the-media-resource"><a href="#Offsets-into-the-media-resource" class="headerlink" title="Offsets into the media resource"></a><strong>Offsets into the media resource</strong></h2></li></ol><p>media . duration  返回当前音频/视频的长度，以秒计。如果未设置音频/视频，则返回NaN，如果是无限流，返回 Infinity</p><p>media . currentTime [ = value ]    设置或返回音频/视频播放的当前位置</p><h2 id="Playing-the-media-resource"><a href="#Playing-the-media-resource" class="headerlink" title="Playing the media resource"></a><strong>Playing the media resource</strong></h2><p>media . paused   返回音频/视频是否已暂停。true 指示音频/视频已暂停。否则为 false。</p><p>media . ended  返回音频/视频是否已结束。如果播放已结束，则返回 true。否则返回 false。</p><p>media . defaultPlaybackRate [ = value ]  设置或返回音频/视频的默认播放速度。</p><p>media . playbackRate [ = value ]   属性设置或返回音频/视频的当前播放速度。</p><p>media . played   返回TimeRanges 对象。TimeRanges 对象表示用户已经播放或看到的音频/视频范围。</p><p>media . play() 开始播放当前的音频或视频。</p><p>media . pause()  暂停当前播放的音频/视频</p><h2 id="Seeking"><a href="#Seeking" class="headerlink" title="Seeking"></a><strong>Seeking</strong></h2><p>media . seeking  返回用户目前是否在音频/视频中寻址，如果用户正在寻址，则为 true。否则为 false。</p><p>media . seekable  返回TimeRanges对象。表示音频/视频中用户可寻址的范围。</p><ol><li>length - 获得音频/视频中可寻址范围的数量</li><li>start(<em>index</em>) - 获得可寻址范围的开始位置</li><li>end(<em>index</em>) - 获得可寻址范围的结束位置</li></ol><p>media . fastSeek( time )  寻求尽可能快地接近给定的时间，以精度换取速度。（要查找精确的时间，使用currentTime属性。）如果媒体资源尚未加载，则不执行任何操作。</p><h2 id="Media-resources-with-multiple-media-tracks"><a href="#Media-resources-with-multiple-media-tracks" class="headerlink" title="Media resources with multiple media tracks"></a><strong>Media resources with multiple media tracks</strong></h2><p>media . audioTracks返回一个表示该媒体资源可用的音频轨的AudioTrackList对象(包含有audioTrack对象)</p><p>media . videoTracks   返回一个表示该媒体资源可用的视频轨道的 videoTrackList对象。(包含有videoTrack对象)</p><p>media . audioTracks . length           media . videoTracks . length</p><p>返回可用音轨的数量</p><p>audioTrack=media.audioTracks[index]       videoTrack=media.videoTracks[index]</p><p>通过 index 来获得 AudioTrack或VideoTrack 对象</p><p>audioTrack=media.audioTracks.getTrackById(id)</p><p>videoTrack=media.videoTracks.getTrackById(id)</p><p>通过 id 来获得AudioTrack或VideoTrack 对象</p><p>audioTrack . id           videoTrack . id</p><p>获得音轨、视频轨道的 id</p><p>audioTrack . kind      videoTrack . kind</p><p>获得音轨、视频轨道的类型</p><p>audioTrack . label          videoTrack . label</p><p>获得音轨、视频轨道的标签</p><p>audioTrack . language          videoTrack . language</p><p>获得音轨、视频轨道的语言</p><p>audioTrack . enabled [ = value ]    获得或设置音轨是否是活动的 (true|false)</p><p>videoTrack . selected [ = value ]    获得或设置视频轨道是否是活动的 (true|false)</p><p>media . videoTracks . selectedIndex获得当前 VideoTrack 对象的下标，没有返回-1</p><h2 id="AudioTrack和VideoTrack的kind-关键字"><a href="#AudioTrack和VideoTrack的kind-关键字" class="headerlink" title="AudioTrack和VideoTrack的kind 关键字"></a>AudioTrack和VideoTrack的kind 关键字</h2><p>|类别|定义|适用于|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|“ alternative”|主音轨的一种替代，例如不同的歌曲（音频）或不同的角度（视频）。|音频和视频。|<br>|“ captions”|带有字幕的主视频轨道的版本。（对于旧内容，新内容将使用文本轨道。）|仅视频。|<br>|“ descriptions”|视频轨道的音频描述。|仅音频。|<br>|“ main”|主要音频或视频轨道。|音频和视频。|<br>|“ main-desc”|主要音轨，混合有音频说明。|仅音频。|<br>|“ sign”|音轨的手语解释。|仅视频。|<br>|“ subtitles”|带有字幕的主视频轨道版本。（对于旧内容，新内容将使用文本轨道。）|仅视频。|<br>|“ translation”|主音轨的翻译版本。|仅音频。|<br>|“ commentary”|有关主要音频或视频轨道的评论，例如导演的评论。|音频和视频。|<br>|“ ”|用户代理无法识别任何明确的种类或轨道的元数据给出的种类。|音频和视频。<br>|</p><h2 id="Text-track-API"><a href="#Text-track-API" class="headerlink" title="Text track API"></a><strong>Text track API</strong></h2><p>media . textTracks . length    获得音频/视频中可用的文本轨道的数量</p><p>media . textTracks[ n ]    返回TextTrack对象，表示媒体元素的文本轨道列表中的第n个文本轨道。</p><p>textTrack = media . textTracks . getTrackById( id )     返回给定id的TextTrack对象，如果没有，则返回null。</p><p>textTrack = media . addTextTrack( kind [, label [, language ] ] )</p><p>创建和返回新的文本轨道。新的TextTrack对象会被添加到视频/音频元素的文本轨道列表中。</p><p>textTrack . kind    返回文本轨道的类型。</p><p>textTrack . label   返回文本轨道的标签。</p><p>textTrack . language    返回文本轨道的语言。</p><p>textTrack . id    返回文本轨道的id</p><p>textTrack.inBandMetadataTrackDispatchType     返回文本轨道 in-band metadata track dispatch type字符串。</p><p>textTrack.mode [=value]</p><p>获得或设置该轨道是否是活动的(“disabled”|”hidden”|”showing”)</p><p>textTrack . cues        获得 TextTrackCueList 对象的 cues 列表</p><p>textTrack . activeCues       获得 TextTrackCueList 对象形式的当前活动文本轨道 cues</p><p>textTrack . addCue( cue )          向 cues 列表添加一个 cue</p><p>textTrack . removeCue( cue )      向 cues 列表删除一个 cue</p><p>cuelist . length    返回cuse列表的cue数量</p><p>cuelist[index]        返回给定index的cue</p><p>cuelist . getCueById( id )   返回给定id的cue</p><p>cue . track    返回属于文本轨道cue的TextTract</p><p>cue . id [ = value ]   返回或设置cue的id</p><p>cue . startTime [ = value ]   返回或设置cue的开始时间的id</p><p>cue . endTime [ = value ]    返回或设置cue的结束时间的id</p><p>cue . pauseOnExit [ = value ]   是否设置暂停或退出标志，是则返回true,否则为false</p><h2 id="User-interface"><a href="#User-interface" class="headerlink" title="User interface"></a><strong>User interface</strong></h2><p>media . volume [ = value ]</p><p>设置或返回音频/视频的当前音量,必须是介于 0.0 与 1.0 之间的数字。0是静音，1最大</p><p>media . muted [ = value ]</p><p>设置或返回音频/视频是否应该被静音（true）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Image&quot;&gt;&lt;a href=&quot;#Image&quot; class=&quot;headerlink&quot; title=&quot;Image&quot;&gt;&lt;/a&gt;Image&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    <category term="The elements of HTML（二）" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/The-elements-of-HTML%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（一）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-03-08T12:31:12.775Z</published>
    <updated>2021-03-08T12:40:51.209Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>element</strong></th><th><strong>meaning</strong></th><th align="center"><strong>Categories</strong></th><th align="left"><strong>Contexts in which this element can be used</strong></th><th align="center"><strong>Content model</strong></th><th align="left"><strong>Tag omission in text/html</strong></th><th align="center"><strong>Content attributes</strong></th><th align="left"><strong>remark</strong></th></tr></thead><tbody><tr><td align="center">html</td><td>文档的根</td><td align="center">none</td><td align="left">document、子片段</td><td align="center">head后面跟一个body</td><td align="left">第一个子元素不是注释，可以省略起始标签。html后没有紧跟注释，可以省略结束标签</td><td align="center">manifest （现已不建议使用）</td><td align="left">建议在htm添加lang属性</td></tr><tr><td align="center">head</td><td>metadata的集合（title、link、script、meta）</td><td align="center">none</td><td align="left">html内的第一个元素</td><td align="center">如果是 iframe srcdoc 文档，可以有没有或多个元数据，title和base最多各有一个,其他类型，至少有一个以上的元数据，且必须有且只有一个title，最多一个base</td><td align="left">head内为空可以省略起始标签，结束标签没有紧跟空格或者注释可以省略</td><td align="center">Global attributes</td><td align="left">大多数情况必须含title,除非html用作电子邮件格式</td></tr><tr><td align="center">titile</td><td>文档标题或名称</td><td align="center">Metadata content</td><td align="left">head内</td><td align="center">text文本</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">text属性的getter方法返回title元素的子文本内容，text属性的setter方法用该元素内的给定值替换所有字符串title。用户代理在其用户界面中引用文档时，应使用文档标题。在用户界面titile的directionality应该设置为文档title的directionality（directionality暂未理解）</td></tr><tr><td align="center">base</td><td>页面上的所有链接规定默认地址或默认目标</td><td align="center">Metadata content</td><td align="left">head内</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">href— 文档基本URL<br>target— 用于超链接导航和表单提交的默认浏览上下文</td><td align="left">target、href两个属性至少有一个。多个base的href,只有第一个有效果。href如果指定了content属性，则该属性必须包含一个有效的URL。base如果有href属性，必须在其他有定义获取url属性的元素之前（除了html元素，它的maifest不受影响）。target的frozen base URL这个概念不理解，那里一坨都没看懂</td></tr><tr><td align="center">link</td><td>文档链接到其他资源</td><td align="center">Metadata content</td><td align="left">head内、在noscript 元素作为head元素的子元素、allowed in the body:phrasing content元素</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">href— 超链接的地址<br>crossorigin —元素如何处理跨域请求<br>rel—包含超链接的文档和目标资源之间的关系<br>media —适用媒体<br>integrity—子资源完整性检查中使用的完整性元数据<br>hreflang —链接资源的语言<br>type —提示所引用资源的类型<br>referrerpolicy-  Referrer policy的取发起由元素<br>sizes—图标的大小（用于“ rel=“ icon”）<br>imagesrcset —在不同情况下使用的图像（例如，高分辨率显示器，小型显示器等）<br>imagesizes —不同页面布局的图像大小<br>as— 预加载请求的Potential destination（对于rel=“ preload”和rel=“ modulepreload”）<br>color—自定义网站图标时使用的颜色（对于rel=“ mask-icon”）<br>disabled —是否禁用链接<br>title —链接的标题；CSS样式表集名称。</td><td align="left">必须有rel或者itemprop属性，不能同时使用。如果link元素具有itemprop属性，或者仅包含关键字的rel属性 ，也就是body-ok.link元素可以创建外部资源链接（stylesheet）和超链接(next)，链接类型和数量取决于rel属性的关键字,每个链接对会被单独处理。link创建的超链接和rel属性作用于全文档，a和area相反。</td></tr><tr><td align="center">meta</td><td>提供有关页面的元信息</td><td align="center">Metadata content</td><td align="left">如果charset存在，或者元素的http-equiv属性处于Encoding声明状态：head内。<br>如果http-equiv存在但不处于Encoding声明状态：head内。<br>如果http-equiv存在，但不处于Encoding声明状态：在作为head元素的子元素的noscript元素中。<br>如果name存在： metadata content。<br>如果itemprop存在： metadata content。<br>如果itemprop属性存在： phrasing content。</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">name —元数据名称<br>http-equiv —编译指示指令<br>content —元素的值<br>charset— 字符编码声明</td><td align="left">每个文档meta的charset属性不得超过一个。name的值：application-name（提供页面代表的Web应用程序的名称）、author（作者）、description（描述页面）、generator（标识用于生成文档的软件包）、keywords（关键字，许多搜索引擎不考虑）、referrer（没懂）、theme-color（定义建议的颜色），以及其他自己定义的。http-equiv：content-language（设置编译设定的默认语言,鼓励使用lang）、content-type（字符编码声明）、default-style（设置默认 CSS样式表集的名称）、refresh（定义文档自动刷新的时间间隔）、set-cookie（此实用程序不符合要求，没有任何效果）、    x-ua-compatible（指定网页的兼容性模式设置）、content-security-policy（启用CSP内容安全策略）。</td></tr><tr><td align="center">style</td><td>将CSS样式表嵌入其文档中</td><td align="center">Metadata content</td><td align="left">metadata content、在作为head元素的子元素的noscript元素中</td><td align="center">Text that gives a conformant style sheet</td><td align="left">不可省略</td><td align="center">media —适用媒体<br>title属性–CSS样式表集名称</td><td align="left">如果media 省略该属性，则默认值为“ all”，这意味着默认情况下样式适用于所有媒体</td></tr><tr><td align="center">body</td><td>文档的内容</td><td align="center">Sectioning root</td><td align="left">html内的第二个元素</td><td align="center">Flow content</td><td align="left">如果元素为空，或第一个子元素不是空格或注释，除非第一个子元素是meta, link, script, style, 或者 template元素，起始标签可以省略。如果元素后面没有紧跟注释，可以省略结束标签。</td><td align="center">onafterprint<br>onbeforeprint<br>onbeforeunload<br>onhashchange<br>onlanguagechange<br>onmessage<br>onmessageerror<br>onoffline<br>ononline<br>onpagehide<br>onpageshow<br>onpopstate<br>onrejectionhandled<br>onstorage<br>onunhandledrejection<br>onunload</td><td align="left">文档只能有一个body元素。onerror事件将从目标冒泡到body、html、document、window，而body上的事件处理程序监视的是window而不是body。但是，使用addEventListener（）添加的事件侦听器将在事件冒泡通过body时运行，而不是在事件到达window对象时运行。</td></tr><tr><td align="center">article</td><td>规定独立的自包含内容，比如论坛帖子、报纸文章、博客条目、用户评论</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">与article元素关联的作者信息不适用于嵌套的article元素。</td></tr><tr><td align="center">scetion</td><td>文档或应用的通用部分，比如比如章节、页眉、页脚等</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当需要syndicate元素内容时，使用article而不是section.使用section时可以一直使h1</td></tr><tr><td align="center">nav</td><td>定义导航链接的部分</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">用于服务条款、版权信息的链接一般放在底部的footer而不是nav</td></tr><tr><td align="center">aside</td><td>与页面主内容无关，比如侧边栏，广告、拉引号</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">aside仅将元素用于括号是不合适的</td></tr><tr><td align="center">h1、h2、h3……</td><td>定义标题</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">作为hgroup的子元素，flow content 、heading content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">不要因为字体大小，来选择不同的h,一般css里改</td></tr><tr><td align="center">hgroup</td><td>标题部分，比如副标题、标语等</td><td align="center">Flow content<br>Heading conten<br>Palpable content</td><td align="left">flow content、heading content</td><td align="center">包含一个以上h1-h6，并可以选择性的与支持脚本的元素（script、template）一起使用</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">hgroup的rank是其包含的h标签里的最高的一个。hgroup对两个标题进行分组，即便都是同等级的h标签，也是不对等的</td></tr><tr><td align="center">header</td><td>定义文档的页眉（介绍信息、导航辅助）</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">没有footer和header子代的flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">header不会引入新的部分</td></tr><tr><td align="center">footer</td><td>义文档或节的页脚，通常包含文档的作者、版权信息、使用条款链接、联系信息等等</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">没有footer和header子代的flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">通常在底部，但不是绝对的。比如像联系信息等有可能在footer也可以在address</td></tr><tr><td align="center">address</td><td>定义文档或文章作者的联系信息</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">没有heading content 、sectioning content 、header, footer,  address 子代的Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">address可以在articel内，也可以在body内(引用于整个文档)。address不能用于任何地址比如邮政地址（通常用P标签）,也不得用于除联系方式以外的信息，通常和其他信息包含在footer内。</td></tr><tr><td align="center">p</td><td>段落</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">Phrasing content</td><td align="left">结束标签省略：p后紧跟address, p, aside, div, 等，或父元素没有内容，且父元素不是 a, audio, del, ins, map, noscript, video或自定义元素</td><td align="center">Global attributes</td><td align="left">当有更适用的标签时，不应该使用p。p 元素会自动在其前后创建一些空白。列表元素特别是ol、ul不能作为p的子元素。设计由多个结构段落组成的逻辑段落时，用div来代替p。</td></tr><tr><td align="center">hr</td><td>水平线</td><td align="center">Flow content</td><td align="left">Flow content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">Global attributes</td><td align="left">hr不影响文档的轮廓</td></tr><tr><td align="center">pre</td><td>预格式化的文本块</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">Phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">pre的结构是由印刷规定而不是元素来表示。常用于表示：电子邮件、代码块（与code、samp、kbd一起使用）、ASCII文字</td></tr><tr><td align="center">blockquote</td><td>引用块</td><td align="center">Flow content<br>Sectioning root<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes<br>cite —链接引用和编辑信息资源</td><td align="left">blockquote中的内容是引用的其他资源， blockquote中的内容可以缩写，也可以按照文本语言的传统方式添加上下文。引用内容的属性必须放在blockquote外部。</td></tr><tr><td align="center">ol</td><td>有序列表</td><td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td><td align="left">flow content</td><td align="center">li和脚本支持元素</td><td align="left">不可省略</td><td align="center">reversed —降序<br>start— 列表的起始值<br>type —列表标记的类型</td><td align="left">type关键字：1（十进制数）、a（小写拉丁字母）、A（大写拉丁字母）、i（小写罗马数字）、I（大写罗马数字）</td></tr><tr><td align="center">ul</td><td>无序列表</td><td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td><td align="left">flow content</td><td align="center">li和脚本支持元素</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">menu</td><td>代表命令的工具栏</td><td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td><td align="left">flow content</td><td align="center">li和脚本支持元素</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">li</td><td>列表项</td><td align="center">none</td><td align="left">ol、ul、menu内</td><td align="center">Flow content</td><td align="left">如果li后紧跟另一个li元素或者其父元素没有内容，则结束标签可以省略</td><td align="center">value—只有在ol内情况下，代表列表项的顺序值，必须为整数</td><td align="left">不建议在li内放入h1元素</td></tr><tr><td align="center">dl</td><td>描述性列表</td><td align="center">Flow content、Palpable content</td><td align="left">flow content</td><td align="center">一个以上的dt后面跟着一个以上的dd，或者一个以上的div,可以和脚本支持的元素搭配使用</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">在单个dl元素中，每个名称不应该有多个dt元素。dl可以被包含在div内</td></tr><tr><td align="center">dt</td><td>列表中的项目（术语部分、名称）</td><td align="center">none</td><td align="left">在dl内的dd、dt之前，或者在div内的dd、dt之前</td><td align="center">Flow content(没有footer、header、 sectioning content、heading content后代)</td><td align="left">dt元素后面紧跟其他dd、dt，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">可以使用dfn元素表示术语的定义</td></tr><tr><td align="center">dd</td><td>条目的定义部分</td><td align="center">none</td><td align="left">在dl内的dd、dt之后，或者在div内的dd、dt之后</td><td align="center">Flow content</td><td align="left">dd元素后面紧跟其他dd、dt，或父元素没有内容，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">figure</td><td>独立的流内容（图表，图片，代码）</td><td align="center">Flow content<br>Sectioning root<br>Palpable content</td><td align="left">Flow content</td><td align="center">Flow content 或Flow content后跟figcaption，或者figcaption前跟Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">figure被删除后，不能对文档流产生影响</td></tr><tr><td align="center">figcaption</td><td>figure的标题</td><td align="center">none</td><td align="left">figure内的第一个或最后一个元素</td><td align="center">Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">mian</td><td>文档的主要内容</td><td align="center">Flow content<br>Palpable content</td><td align="left">Flow content，但只能有一个</td><td align="center">Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">如果有多个main必须有hidden属性。main的父元素只能是html, body, div, form</td></tr><tr><td align="center">div</td><td>块级元素，无特殊含义</td><td align="center">Flow content<br>Palpable content</td><td align="left">Flow content，或作为dl的子元素</td><td align="center">如果是dl的子元素：一个以上的dt后跟一个以上dd，且可以与脚本支持元素使用。否则，Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当没有元素适合，建议使用div</td></tr><tr><td align="center">a</td><td>如果有href属性，代表资源的超链接。没有则表示为占位符。</td><td align="center">Flow content.<br>Phrasing content.<br>Interactive content:如果存在href属性.<br>Palpable content.</td><td align="left">phrasing content</td><td align="center">不能有交互式内容的子代，a元素子代，或者带有tabindex属性的子代</td><td align="left">不可省略</td><td align="center">href — 超链接的地址<br>target — 在何处打开链接文档<br>download — 被下载的超链接目标<br>ping — ping 的URL地址<br>rel —当前文档与被链接文档之间的关系<br>hreflang — 被链接资源的语言<br>type —提示被链接资源的的 MIME 类型<br>referrerpolicy— Referrer policy for fetches initiated by the element</td><td align="left">如果没有href属性，则a元素其他属性必须省略。如果有 itemprop 属性，则必须有href属性。</td></tr><tr><td align="center">em</td><td>强调重点的内容</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">强调的级别由em数量决定。</td></tr><tr><td align="center">strong</td><td>对内容极其强调</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">strong通常强调标题、段落、警告、危险标志、用户更需要长时间看见的内容等，比em强调程度更大。</td></tr><tr><td align="center">small</td><td>小号字体</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">常用于免责声明、警告、法律限制、版权信息、属性、许可要求等。使用small并不代表内容不重要，不重要只需不使用em、strong即可，small和strong、em也可嵌套使用。small不适用于大篇幅如段落、列表等。只用于小段文本，也不适用于副标题。</td></tr><tr><td align="center">s</td><td>无关或不准确的内容（文本添加删除线）</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">更推荐使用del元素。</td></tr><tr><td align="center">cite</td><td>引用或参考的内容，也可以是顺带提及的内容，通常是论文、文章、杂志等的标题</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">不能用于人名。</td></tr><tr><td align="center">q</td><td>引用了其他资源的phrasing content</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">cite — 引用的资源链接</td><td align="left">不需要添加标点符号，UA会渲染添加。引用的资源可以是虚构的，不适合引用单独一个单词。不能用q代替不表示引用的引用（讽刺语句，通常会加标点符号，但这并不是引用）</td></tr><tr><td align="center">dfn</td><td>定义术语</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content，不包含dfn的子代</td><td align="left">不可省略</td><td align="center">title— 显示完整的术语或缩写的扩展</td><td align="left">dfn的父元素需包含dfn内术语的定义，且其title属性不影响dfn。title只能是这个术语的定义，不能包含其他。</td></tr><tr><td align="center">abbr</td><td>简称或缩写</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">title— 显示完整的术语或缩写的扩展</td><td align="left">适用情况：开发者想要解释缩写的含义；用户不熟悉的术语；存在需要进行语义注释的缩写。有title的abbr与没有title的abbr不会影响。</td></tr><tr><td align="center">ruby</td><td>定义 ruby 注释（有注音或其他注释）</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">Phrasing content，不包含ruby或ruby子元素。单独的ruby,且自身不喊ruby。一个或多个rt。一个rb包含一个或多个rt</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">在没有ruby父元素的ruby中，内容被分为三段：基本文本片段；注释片段；可忽略片段（空格或rp）。其中tr对应注释片段，通常只有一个。</td></tr><tr><td align="center">rt</td><td>标记ruby注释的ruby文本组件</td><td align="center">none</td><td align="left">ruby的子元素</td><td align="center">Phrasing content</td><td align="left">rt后紧跟rt或tp，或其父元素没有内容，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">当它是ruby元素的子元素时，它本身并不表示任何东西，但是ruby元素使用它来确定它所代表的内容。</td></tr><tr><td align="center">rp</td><td>在ruby注释的ruby文本组件周围提供括号或其他内容</td><td align="center">none</td><td align="left">ruby的子元素，紧跟在rt之前或之后</td><td align="center">Text</td><td align="left">tp后紧跟tr或rp，或其父元素没有内容，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">由不支持ruby注释的UA显示。</td></tr><tr><td align="center">data</td><td>本身的内容及其value的值</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">value — 机器可读的值</td><td align="left">value属性必须存在，并且是以机器可读的格式来代表元素的内容。当内容与时间有关，使用time。适用于：当与微格式或微数据属性相结合时，元素用于提供用于数据处理的机器可读值和用于在Web浏览器中呈现的人可读值。在这种情况下，value的格式由所使用的微格式或微数据决定；当脚本有一个文本值要与人可读的值一起存储时，可以与页面中的脚本一起使用，value格式只取决于脚本的需要。</td></tr><tr><td align="center">time</td><td>时间相关的内容及其value的值</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">当有datatime属性：phrasing content ，否则为Text</td><td align="left">不可省略</td><td align="center">datetime — 机器可读的值</td><td align="left">time的datetime值是datetime内容属性的值，否则为time元素的子文本内容。没有datetime属性的time元素不能有子元素。</td></tr><tr><td align="center">code</td><td>计算机代码片段</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">可以添加一个值为“language-XX”的class属性来指示所使用的语言。</td></tr><tr><td align="center">var</td><td>变量</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">samp</td><td>样本；程序或计算机输出的引用</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">kbd</td><td>用户输入（通常是键盘文本）</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当kbd嵌套在samp中，表示系统回显的输入；当包含samp，表示基于系统输出的输入，例如调用菜单项；当kbd嵌套在另一个kbd中，表示一个实际的键或其他适合输入机制的单个输入单元。code、var、samp、kbd这些常与pre一起使用。</td></tr><tr><td align="center">sub/sup</td><td>上标/下标</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">特殊的排版要求才使用。</td></tr><tr><td align="center">i</td><td>斜体文本效果</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">适用于i的情况，要考虑是否用em和dfn更合适。</td></tr><tr><td align="center">b</td><td>粗体</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当没有其他元素适合时，才考虑用b。并非有重要的语义。</td></tr><tr><td align="center">u</td><td>下划线</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">注意避免导致用户错认为超链接。</td></tr><tr><td align="center">mark</td><td>突出显示文本</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">bdi</td><td>从周围的文本格式设置中隔离</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">dir –默认为auto,不会继承父元素的样式</td><td align="left">在发布用户生成的内容时，该标签很有用。</td></tr><tr><td align="center">bdo</td><td>可覆盖默认的文本方向</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">dir –定义文字的方向（ltr<br>、rtl）</td><td align="left">必须设置dir属性，不能设置为auto。</td></tr><tr><td align="center">sapn</td><td>行内元素</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">br</td><td>换行符</td><td align="center">Flow content<br>Phrasing content</td><td align="left">phrasing content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">Global attributes</td><td align="left">当段落只有br元素，代表占位符空行</td></tr><tr><td align="center">wbr</td><td>换行符的时机</td><td align="center">Flow content<br>Phrasing content</td><td align="left">phrasing content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">Global attributes</td><td align="left">如果文本过长，可能会导致换行，浏览器会按照wbr来换行，避免语义混乱。</td></tr><tr><td align="center">ins</td><td>文档新的添加</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">Transparent</td><td align="left">不可省略</td><td align="center">cite —引用文档的URL（解释变动原因）。<br>datetime —变化的日期和时间</td><td align="left">ins 不应该跨越 implied paragraph边界</td></tr><tr><td align="center">del</td><td>文档的删除部分</td><td align="center">Flow content<br>Phrasing content</td><td align="left">phrasing content</td><td align="center">Transparent</td><td align="left">不可省略</td><td align="center">cite —引用文档的URL（解释变动原因）。<br>datetime —变化的日期和时间</td><td align="left">ins和del不能作为ul、ol的子元素。</td></tr><tr><td align="center">img</td><td>图片的展示</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Form-associated element<br>Interactive content(有usemap属性)<br>Palpable content</td><td align="left">embedded content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">alt —不能正常显示时的替代文本<br>src —资源的地址<br>srcset — 图片应用的场景<br>sizes —图片设置的尺寸<br>crossorigin — 如何处理跨域请求<br>usemap—定义为客户器端图像映射<br>ismap—定义为服务器端图像映射<br>width — 宽度<br>height — 高度<br>referrerpolicy— 设置引用策略<br>decoding —图像解码的首选方法<br>loading — 确定懒加载时使用</td><td align="left">建议懒加载的图片设置宽高属性，防止加载后页面布局改变。img元素不能当做页面的布局工具或展示透明的图片。设置了src和alt属性，但alt属性值为空字符串，图片是内容的装饰或补充，没有设置alt属性，代表图片是内容的关键部分，但没有可替换的文本内容。</td></tr><tr><td align="center">iframe</td><td>嵌套的浏览上下文</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content<br>Palpable content</td><td align="left">embedded content</td><td align="center">无</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>srcdoc —需要渲染的html文档<br>name — 名称<br>sandbox — 嵌套内容的安全规则<br>allow — iframe内容的功能策略<br>allowfullscreen—允许使用requestFullscreen()方法<br>allowpaymentrequest—允许使用PaymentRequest 界面处理支付请求<br>width — 宽度<br>height — 高度<br>referrerpolicy —引用策略</td><td align="left">1、srcdoc属性“”内的&amp;和‘“”符号必须转义的,否则会提前结束，沙盒内容中提到的原始&amp;必须双重转义，以便在最初解析srcdoc属性时保留&amp;，防止再一次解析沙盒内容时误解&amp;。<br>2、同时有src和srcdoc属性，则后者的优先级更高。<br>3、iframe可能会延迟load事件。<br>4、如果没有设置src和srcdoc,或设置了不能解析，浏览上下文会保持在原始的about:blank页面。<br>5、sandbox属性值： allow-forms（重启表单）, allow-modals（重启模态对话框）, allow-orientation-lock（重启屏幕方向锁）, allow-pointer-lock（重启pointer lock API）, allow-popups（重启弹出框）, allow-popups-to-escape-sandbox（重新创建无沙箱的auxiliary浏览器上下文）, allow-presentation（重启presentation API）, allow-same-origin（使得内容被视为来自真实来源，而不是强制其进入唯一的来源）, allow-scripts（重启脚本）, allow-top-navigation（允许内容导航到顶级浏览器上下文）, allow-top-navigation-by-user-activation（只有当浏览器上下文的 active window短暂的激活时）, and allow-downloads。 allow-top-navigation 和allow-top-navigation-by-user-activation不能通知指定，否则只有前者起作用。</td></tr><tr><td align="center">embed</td><td>额外的程序或交互内容</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content<br>Palpable content</td><td align="left">embedded content</td><td align="center">无</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>type —嵌套资源的类型<br>width — 宽度<br>height — 高度</td><td align="left">1、如果跳转到其他浏览器上下文，src属性不会改变<br>2、没有回退内容，子元素会被忽略。</td></tr><tr><td align="center">object</td><td>表示外部资源</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content（如果有usemap属性）<br>Listed and submittable form-associated element.<br>Palpable content.</td><td align="left">embedded content</td><td align="center">没有或多个param元素</td><td align="left">不可省略</td><td align="center">data — 资源地址<br>type —嵌套资源的类型<br>name — 名称<br>usemap —规定与对象一同使用的客户端图像映射的 URL<br>form — 规定对象所属的一个表单<br>width — 宽度<br>height — 高度</td><td align="left">可以插入HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。</td></tr><tr><td align="center">param</td><td>作为脚本，嵌套在object的参数</td><td align="center">None</td><td align="left">在flow content前面的object子元素</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">name —参数名称<br>value — 参数的值</td><td align="left">两个属性都必须存在。</td></tr><tr><td align="center">video</td><td>播放视频、电影，或带字幕的音频文件</td><td align="center">Flow content.<br>Phrasing content.<br>Embedded content.<br>Interactive content(如果有controls属性 )<br>Palpable content.</td><td align="left">embedded content</td><td align="center">如果有src属性：没有或多个track,并且是透明的，没有媒体子元素。<br>没有src属性：没有或多个source，接着没有或多个track,并且是透明的，没有媒体子元素。</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>crossorigin — 如何处理跨域请求<br>poster — 播放前显示的画面url<br>preload—页面加载时视频也加载<br>autoplay—页面加载好后自动播放<br>playsinline —内联形式播放<br>loop —循环播放<br>muted —默认静音<br>controls —展示控件<br>width —宽<br>height — 高</td><td align="left">1、可以在video内插入文本，当浏览器不支持时，用于提供一些帮助信息。<br>2、字幕、手语、音频描述可以直接嵌入到视频，其中字幕也可以用track外引文件，音频描述可以以文本通过WebVTT 文件，track会将文本合成语音，WebVTT也可以提供章节信息。<br>3、视频中的每一帧对应哪个播放位置由视频流的格式决定。</td></tr><tr><td align="center">audio</td><td>音频</td><td align="center">Flow content.<br>Phrasing content.<br>Embedded content.<br>Interactive content、Palpable content(如果有controls属性 )</td><td align="left">embedded content</td><td align="center">如果有src属性：没有或多个track,并且是透明的，没有媒体子元素。<br>没有src属性：没有或多个source，接着没有或多个track,并且是透明的，没有媒体子元素。</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>crossorigin — 如何处理跨域请求<br>preload—页面加载时音频也加载<br>autoplay—页面加载好后自动播放<br>loop —循环播放<br>muted —默认静音<br>controls —展示控件</td><td align="left">当字幕和手语视频可以使用时，video可以代替audio.</td></tr><tr><td align="center">track</td><td></td><td align="center">none</td><td align="left">在flow content前面的媒体子元素</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">kind — 轨道的文本类型<br>src — 资源地址<br>srclang — 轨道语言<br>label — 标签<br>default — 默认的轨道</td><td align="left">1、kind关键字（可以省略，缺失默认 subtitles ，无效默认 metadata）<br>captions：播放器中显示的简短说明<br>chapters：定义章节，用于导航媒介资源<br>descriptions：定描述，用于通过音频描述媒介的内容<br>metadata：定义脚本使用的内容<br>subtitles：定义字幕，用于在视频中显示字幕<br>2、媒体元素的最多有一个这样的track（kind属性除metadata以外，并且指定了default）<br>3、track的readstatus：<br>0：未加载<br>1：正在加载<br>2：加载完成<br>3：加载失败</td></tr><tr><td align="center">table</td><td>表格</td><td align="center">Flow content.<br>Palpable content.</td><td align="left">flow content</td><td align="center">顺序如下：caption（可选）、colgroup(0个或多个)、thead 、tbody 或tr（0个或多个）、tfoot0个或多个）、脚本支持元素（可选）</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">1、table不能用于布局的工具<br>2、如果一个表格不以第一行和第一列作为标题，或着其他特殊情况，应该引入介绍该表格的解释性信息。</td></tr><tr><td align="center">caption</td><td>表格标题</td><td align="center">none</td><td align="left">table内的第一个元素</td><td align="center">没有子代table元素的Flow content</td><td align="left">如果caption后没有紧跟空格或注释，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">1、当figure元素除了figurecaption以外，只有table元素，应该省略caption而使用figurecaption。<br>2、caption可以用来解释表格内容，使得其更容易理解</td></tr><tr><td align="center">colgroup</td><td>对表格中的列进行组合，以便对其进行格式化</td><td align="center">none</td><td align="left">table内，在caption后，在thead, tbody, tfoot或tr前.</td><td align="center">有span属性，nothing，否则，零个或多个col和template元素</td><td align="left">起始标签省略：colgroup内是一个元素col，或元素前面没有紧跟另一个已省略结束标签的colgroup，如元素为空，则不可省略<br>结束标签省略：colgroup后没有紧跟空格或注释</td><td align="center">Global attributes<br>span —列组应该横跨的列数</td><td align="left">1、colgroup内没有col,则应该在元素上设置span属性，值在1—1000之间。</td></tr><tr><td align="center">col</td><td>为表格中一个或多个列定义属性值</td><td align="center">none</td><td align="left">作为没有span属性的colgroup子元素</td><td align="center">nothing</td><td align="left">没有结束标签</td><td align="center">Global attributes<br>span —列组应该横跨的列数</td><td align="left"></td></tr><tr><td align="center">tbody</td><td>表格主体</td><td align="center">none</td><td align="left">table的子元素，在caption、colgroup和thead之后，但前提是没有作为table子元素的tr。</td><td align="center">零个或多个tr以及支持脚本的元素</td><td align="left">起始标签省略：tbody内的第一个元素是tr，或没有紧在省略了结束标签的tbody、thead、tfoot之前，元素内为空时不能省略。<br>结束标签省略：tbody后紧跟tbody、tfoot，或父元素没有内容</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">thead</td><td>表格的表头</td><td align="center">none</td><td align="left">table的子元素，在caption、colgroup之后，在tbody、tfoot之前，但前提是没有其他head。</td><td align="center">零个或多个tr以及支持脚本的元素</td><td align="left">如果thead元素后紧跟tbody或tfoot元素，结束标签可以省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">tfoot</td><td>表格的页脚</td><td align="center">none</td><td align="left">table的子元素，在caption、colgroup和thead、tbody、tr之后，但前提是没有其他tfoot。</td><td align="center">零个或多个tr以及支持脚本的元素</td><td align="left">父元素没有内容，可以省略结束标签</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">tr</td><td>表格中的行</td><td align="center">none</td><td align="left">thead的子元素.<br>tbody的子元素.<br>tfoot 的子元素.<br>table的子元素，在caption, colgroup,thead之后，前提是没有作为table子元素的tbody</td><td align="center">零个或多个 td, th，或支持脚本的元素</td><td align="left">tr后紧跟另一个tr，或父元素没有内容，结束标签可以省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">td</td><td>表格的标准单元格</td><td align="center">Sectioning root</td><td align="left">tr的子元素</td><td align="center">Flow content</td><td align="left">td后紧跟td或th，或父元素没有内容，结束标签可以省略</td><td align="center">colspan — 单元格可横跨的列数<br>rowspan — 单元格可横跨的行数<br>headers — 与单元格相关的表头</td><td align="left">用户代理，特别是在非可视环境中，或者在无法将表显示为2D网格的情况下，当呈现单元格的内容时，可能会提供单元格的用户上下文；例如，给出单元格在表模型中的位置，或列出单元格的标题单元格（由分配标题单元格的算法确定）。</td></tr><tr><td align="center">th</td><td>表头单元格</td><td align="center">none</td><td align="left">th的子元素</td><td align="center">Flow content,但没有header,footer,sectioning content,heading content后代</td><td align="left">th后紧跟td或th，或父元素没有内容，结束标签可以省略</td><td align="center">colspan — 单元格可横跨的列数<br>rowspan — 单元格可横跨的行数<br>headers — 与单元格相关的表头<br>scope — 表头数据与单元数据相关联的方法<br>abbr — 单元格中内容的缩写版本</td><td align="left">scope属性值字：<br>1、col   规定单元格是列的表头。<br>2、row    规定单元格是行的表头。<br>3、colgroup    规定单元格是列组的表头。<br>4、rowgroup    规定单元格是行组的表头。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;element&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;meaning&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;Categorie</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    <category term="The elements of HTML（一）" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/The-elements-of-HTML%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Semantics, structure, and APIs of HTML documents</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/Semantics_%20structure_%20and%20APIs%20of%20HTML%20documents/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/Semantics_%20structure_%20and%20APIs%20of%20HTML%20documents/</id>
    <published>2021-03-08T12:31:08.694Z</published>
    <updated>2021-03-08T12:54:59.903Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Document object</strong>:包含<strong>HTTPS state，</strong>代表传输数据的网络信道的安全属性，<strong>referrer policy、module ma、feature policy、CSP list</strong>包含了内容安全策略</p><p>Semantics ，元素、属性、属性值规范都定义了语义，不能用于定义语义以外的目的，不得使用规范以外的元素、属性、属性值。html具有描述进度条的progresss元素。</p><p><strong>Elements in the DOM，</strong>HTML元素必须实现规范列出的接口，并将这些接口expose to 脚本。</p><p><strong>Element definitions</strong>，每一个元素包含以下信息的定义：类别、Contexts in which this element can be used、内容模型、Tag omission in text/html、内容属性、Accessibility considerations、DOM 接口。</p><p><strong>Content models，</strong>每一个元素都内容模型，即对元素预期内容的描述，元素的内容是其dom中的子元素。元素之间允许有空格，元素之间的字符表示为Text，DOM节点，空Text节点和 Text仅由这些字符的序列组成的节点被视为 元素间空格。 在确定元素的内容是否与元素的内容模型匹配时，以及遵循定义文档和元素语义的算法时，必须忽略元素间空格，注释节点和处理指令节点（处理指令节点没懂）。HTML元素可以没有父节点。当元素的内容模型为空，该元素不包含任何Text节点（元素间空格除外）且不包含元素节点。</p><p><strong>Kinds of content，</strong>元素可以属于一个或者多个类别，甚至有些元素不属于任何特定类别，</p><ol><li><strong>Metadata content：</strong>设置其余内容的表示形式或行为、是指文档与其他文档的关系、传达其他 “out of band” 信息的内容。</li><li><strong>Flow content：</strong>大多元素都属于这个类别，常见的a、div、table……。</li><li>**Sectioning content: **用于定义内容标题和页脚，比如article、aside、nav、section。</li><li><strong>Heading content：</strong>h1、h2…。</li><li><strong>Phrasing content：</strong>分类为Phrasing content的大多元素只能包含Phrasing content的元素。3.2.5.2.5后面一节暂未理解。</li><li><strong>Embedded content，</strong>将另一个资源导入文档中的内容，或来自插入到文档中的另一个词汇表中的内容，如audio、video,有些有 fallback content，比如外部资源的格式不支持所显示的内容</li><li><strong>Interactive content，</strong>a、button、input。。。。</li><li><strong>Palpable content，</strong>没理解</li><li><strong>Script-supporting elements，</strong>script、template</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Document object&lt;/strong&gt;:包含&lt;strong&gt;HTTPS state，&lt;/strong&gt;代表传输数据的网络信道的安全属性，&lt;strong&gt;referrer policy、module ma、feature policy、CSP lis</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    <category term="Semantics, structure, and APIs of HTML documents" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/Semantics-structure-and-APIs-of-HTML-documents/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Common infrastructure</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/Common%20infrastructure/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/Common%20infrastructure/</id>
    <published>2021-03-08T12:19:42.450Z</published>
    <updated>2021-03-08T12:36:08.666Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Parallelism</strong>并行性，指不同的进程可以同时进行，同时为了避免对相同的数据进行不同的操作，这里使用队列(先进先出)来解决。但所举的例子，没怎么懂。。</p><p><strong>Resources</strong>资源，资源能否被支持，取决于资源的格式，是否为critical资源由资源格式的规范来定义，对于CSS样式表，关键子资源是通过@import 规则导入的样式表及其间接导入的样式表。</p><p><strong>element type 元素类型，</strong>有local name 和 namespace命名空间，如果属性名称与XML中Name定义的生产匹配，且不包含：，则该属性名称能与XML兼容。</p><p><strong>DOM trees</strong>，当有些element和 attribute没有指定值时，会有默认值，比如div标签的display属性默认值就是block，有时呢格局需要我们又会设置为none。当一个node作为插入时的参数时，将连接 browsing-context，remove时，断开 browsing-context连接。<strong>browsing context</strong>是指呈现给用户的document对象内的一个环境。shadowroot 这个概念目前没怎么能理解到，查询得知是 DOM 子树的根节点</p><p><strong>Scripting</strong>，foo 更为精确的说应该是interface object</p><p><strong>Plugins</strong>，是content handlers 的 implementation-defined set</p><p><strong>Character encodings</strong>，字符编码， 是 byte streams 和 Unicode strings之间转换的方式，其中utf-16不兼容ASCII.</p><p><strong>Conformance classes</strong>，<strong>Conforming documents</strong>是指遵守 conformance criteria的文档，user agent 无权处理不符合标准的文档。用户代理可以分为Web browsers and other interactive 用户代理、Non-interactive presentation 用户代理、support the suggested default rendering 的Visual 用户代理、不支持 scripting 的用户代理，<strong>UA</strong>使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等</p><p><strong>Conformance checkers，</strong>在进行检查时，没有 browsing context和脚本的运行，<strong>conformance criteria</strong>分为三种：通过DTD，通过machine，通过人检查，conformance checker必须满足检查前两种。</p><p><strong>Data mining tools，</strong>处理HTML和XML文档的工具和程序<strong>，</strong>除了渲染文档和检查其符合性以外，还要根据其处理的文档语义进行处理。</p><p><strong>Authoring tools and markup generators，</strong>Authoring tools 分为两类。一种是 tools that work from structure or semantic data，还有一种tools that work on a WYSIWYG（所见即所得） media-specific editing basis，创作工具 应该能让用户能够创建结构良好，语义丰富，独立于媒体的内容， 规范描述了两种 authoring formats，一种基于XML,另一种， custom format inspired by SGML(标准通用标记语言)，也就是HTML。一些 conformance requirements是对元素、属性、方法、对象的要求，分为两类，一种是内容模型限制的要求（ documents and authoring tools），一种是实现行为的要求（UA） 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Parallelism&lt;/strong&gt;并行性，指不同的进程可以同时进行，同时为了避免对相同的数据进行不同的操作，这里使用队列(先进先出)来解决。但所举的例子，没怎么懂。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;资源，资源能否被支</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    <category term="Common infrastructure" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/Common-infrastructure/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>21-日志记录与使用情况跟踪</title>
    <link href="http://example.com/2021/03/08/note/HTTP/21-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E8%B7%9F%E8%B8%AA/"/>
    <id>http://example.com/2021/03/08/note/HTTP/21-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E8%B7%9F%E8%B8%AA/</id>
    <published>2021-03-08T07:17:09.275Z</published>
    <updated>2021-03-08T07:19:40.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-1-记录内容"><a href="#21-1-记录内容" class="headerlink" title="21.1 记录内容"></a>21.1 记录内容</h2><p>日志的记录出于两种原因：查找服务器或代理中存在的问题，生成Web站点访问方式的统计信息,统计数据用于市场营销、计费和容量规划等。</p><h2 id="21-2-日志格式"><a href="#21-2-日志格式" class="headerlink" title="21.2 日志格式"></a>21.2 日志格式</h2><h3 id="21-2-1-常见日志格式"><a href="#21-2-1-常见日志格式" class="headerlink" title="21.2.1 常见日志格式"></a>21.2.1 常见日志格式</h3><p>很多服务器在默认情况下都会使用这种日志格式。表21-1按序列出了常用日志格式中的字段。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/xukbWo6RMaAL3fg.png"                      alt="image.png"                ></p><h3 id="21-2-2-组合日志格式"><a href="#21-2-2-组合日志格式" class="headerlink" title="21.2.2 组合日志格式"></a>21.2.2 组合日志格式</h3><p>另一种常用日志格式为组合日志格式（Combined Log Format）。实际上，它就是常用日志格式的基础上添加了两个字段。</p><ol><li><strong>User-Agent字段</strong>，用于说明是哪个HTTP客户端应用程序在发起已被记录的请求。</li><li><strong>Referer字段</strong>，则提供了更多与请求端在何处找到这个URL的有关信息。<h2 id="21-3-命中率测量"><a href="#21-3-命中率测量" class="headerlink" title="21.3 命中率测量"></a>21.3 命中率测量</h2></li></ol><p>由于缓存服务器的存在，在不访问原始服务器的情况下就能满足客户端的请求，服务器中没有客户端访问其内容的记录，导致日志文件中出现遗漏。</p><p>因此，内容提供者会对其最重要的页面进行缓存清除（cache bust），将某些内容设置为无法缓存，这样所有对此内容的请求都会被导向原始服务器。</p><p>由于代理缓存（以及一些客户端）都会保留自己的日志，所以如果服务器能够访问这些日志，就可以避免使用缓存清除。命中率测量协议是对HTTP的一种扩展，命中率测量协议要求缓存周期性地向原始服务器汇报缓存访问的统计数据。</p><h3 id="21-3-2-Meter首部"><a href="#21-3-2-Meter首部" class="headerlink" title="21.3.2 Meter首部"></a>21.3.2 Meter首部</h3><p>命中率测量扩展建议使用新增加的首部Meter，缓存和服务器可以通过它在相互间传输与用法和报告有关的指令，这与用来进行缓存指令交换的Cache-Control首部很类似。</p><p>表21-10列出了定义的各种指令和谁可以在Meter首部传输这些指令。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/aj7EQXtpW3odUwf.png"                      alt="image _1_.png"                ></h2><p>事务的第一部分就是客户端和代理缓存之间一个普通的HTTP事务，但在代理请求中，要注意有插入的Meter首部和来自服务器的响应。这里，代理正在通知服务器它可以进行命中率测量，作为回应，服务器则请求代理报告它的命中次数。</p><p>从客户端的角度看，请求正常结束了，代理开始代表服务器跟踪该请求资源的命中次数。稍后代理尝试与服务器再次验证资源，代理会在发送给服务器的条件请求中嵌入它跟踪记录的计量信息。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/TV3AS9Gt5NdgCkD.png"                      alt="image _2_.png"                ></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;21-1-记录内容&quot;&gt;&lt;a href=&quot;#21-1-记录内容&quot; class=&quot;headerlink&quot; title=&quot;21.1 记录内容&quot;&gt;&lt;/a&gt;21.1 记录内容&lt;/h2&gt;&lt;p&gt;日志的记录出于两种原因：查找服务器或代理中存在的问题，生成Web站点访问方式的统计信</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="21-日志记录与使用情况跟踪" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/21-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E8%B7%9F%E8%B8%AA/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Backgrounds and Borders Level 3</title>
    <link href="http://example.com/2021/03/07/note/W3C%20CSS/Backgrounds%20and%20Borders%20Level%203/"/>
    <id>http://example.com/2021/03/07/note/W3C%20CSS/Backgrounds%20and%20Borders%20Level%203/</id>
    <published>2021-03-07T08:21:21.773Z</published>
    <updated>2021-03-08T08:53:10.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>每一个盒有一个背景层，可以是透明的（默认）也可以以某个颜色或一个以上的图像填满。背景属性可以用来指定背景使用的颜色（background-color）与图像（background-image）及图像如何伸缩、定位、铺设等等。背景属性不继承。</p><h3 id="1-1-多个背景图像的层叠"><a href="#1-1-多个背景图像的层叠" class="headerlink" title="1.1 多个背景图像的层叠"></a>1.1 多个背景图像的层叠</h3><p>盒的背景可以有多个背景图像层，数目由 background-image 属性逗号分隔的取值数目而定。取值 none 也产生一个层。</p><p>每一个图像依照其他背景属性里相应的值伸缩、定位、层迭。各属性的列从第一个取值开始配对 ，不使用结尾多余的取值。若属性用逗号分隔的取值比背景图像层的数目还少，UA 必须以重复列里面的取值直到取值数足够的方式计算使用值。</p><h3 id="1-2-背景颜色-―-background-color-属性"><a href="#1-2-背景颜色-―-background-color-属性" class="headerlink" title="1.2 背景颜色 ― background-color 属性"></a>1.2 背景颜色 ― background-color 属性</h3><p>本属性决定元素的背景色。背景色在任何背景图像之下。初始值为transparent。</p><p>底色层依照最底层的背景图像层对应的 background-clip 值剪裁。</p><p>Example:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">background-color</span>: <span class="number">#F00</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-图像源-―-background-image-属性"><a href="#1-3-图像源-―-background-image-属性" class="headerlink" title="1.3 图像源 ― background-image 属性"></a>1.3 图像源 ― background-image 属性</h3><p>为一个元素设置一个或者多个背景图像</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123; background-image: url(&quot;marble.svg&quot;) &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-图像铺成-―-background-repeat-属性"><a href="#1-4-图像铺成-―-background-repeat-属性" class="headerlink" title="1.4 图像铺成 ― background-repeat 属性"></a>1.4 图像铺成 ― background-repeat 属性</h3><p>在双值语法中, 第一个值表示水平重复行为, 第二个值表示垂直重复行为.</p><p>|单值|等价于双值|<br>|:—-:|:—-|:—-:|:—-|<br>|repeat-x（水平方向重复）|repeat no-repeat|<br>|repeat-y（垂直方向重复）|no-repeat repeat|<br>|repeat（图像会按需重复来覆盖整个背景图片所在的区域. 最后一个图像会被裁剪, 如果它的大小不合适的话）|repeat repeat|<br>|space（图像会尽可能得重复, 但是不会裁剪. 第一个和最后一个图像会被固定在元素(element)的相应的边上, 同时空白会均匀地分布在图像之间）|space space|<br>|round（随着允许的空间在尺寸上的增长, 被重复的图像将会伸展(没有空隙), 直到有足够的空间来添加一个图像.）|round round|<br>|no-repeat（图像不会被重复）|no-repeat no-repeat|</p><h3 id="1-5-图像固定-―-background-attachment-属性"><a href="#1-5-图像固定-―-background-attachment-属性" class="headerlink" title="1.5 图像固定 ― background-attachment 属性"></a>1.5 图像固定 ― background-attachment 属性</h3><p>决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p><table><thead><tr><th align="left">fixed</th><th align="left">背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动</th></tr></thead><tbody><tr><td align="left">local</td><td align="left">背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。</td></tr><tr><td align="left">scroll</td><td align="left">表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）</td></tr></tbody></table><h3 id="1-6-图像定位-―-background-position-属性"><a href="#1-6-图像定位-―-background-position-属性" class="headerlink" title="1.6 图像定位 ― background-position 属性"></a>1.6 图像定位 ― background-position 属性</h3><p>若指定了背景图像，本属性可以用来指定图像（伸缩之后）在对应的背景定位区域的初始位置。</p><p>|center|居中背景图片|<br>|:—-:|:—-|:—-:|:—-|<br>|top, left, bottom, right|如果是单个值，图片在指定边缘的中间位置，|<br>|百分比|(容器宽 - 图片宽) * (position x%) = x方向偏移值<br>(容器高 - 图片高) * (position y%) = y方向偏移值|<br>|长度值|长度值是元素向指定边缘偏移|</p><p>Example:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">top</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">left</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: 25% 75%;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">bottom</span> 50<span class="selector-tag">px</span> <span class="selector-tag">right</span> 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">right</span> 35% <span class="selector-tag">bottom</span> 45%;</span><br></pre></td></tr></table></figure><h3 id="1-7-描绘区域-―-background-clip-属性"><a href="#1-7-描绘区域-―-background-clip-属性" class="headerlink" title="1.7 描绘区域 ― background-clip 属性"></a>1.7 描绘区域 ― background-clip 属性</h3><p>元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。</p><p>|border-box<br>|背景延伸至边框外沿（但是在边框下层）|<br>|:—-:|:—-|:—-:|:—-|<br>|padding-box|背景延伸至内边距（padding）外沿。不会绘制到边框处|<br>|content-box|背景被裁剪至内容区（content box）外沿|</p><h3 id="1-8-定位区域-―-background-origin-属性"><a href="#1-8-定位区域-―-background-origin-属性" class="headerlink" title="1.8 定位区域 ― background-origin 属性"></a>1.8 定位区域 ― background-origin 属性</h3><p>指定背景图片background-image 属性的原点位置的背景相对区域。</p><p>|border-box|背景图片的摆放以border区域为参考|<br>|:—-:|:—-|:—-:|:—-|<br>|padding-box（默认值）|背景图片的摆放以padding区域为参考|<br>|content-box|背景图片的摆放以content区域为参考|</p><h3 id="1-9-图像伸缩-―-background-sizing-属性"><a href="#1-9-图像伸缩-―-background-sizing-属性" class="headerlink" title="1.9 图像伸缩 ― background-sizing 属性"></a>1.9 图像伸缩 ― background-sizing 属性</h3><p>设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。</p><p>|length|设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。|<br>|:—-:|:—-|:—-:|:—-|<br>|百分比|以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。|<br>|cover|把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。|<br>|contain|把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。|</p><h3 id="1-10-背景缩写-―-background-属性"><a href="#1-10-背景缩写-―-background-属性" class="headerlink" title="1.10 背景缩写 ― background 属性"></a>1.10 背景缩写 ― background 属性</h3><p>一次性集中定义各种背景属性，包括 color, image, origin 与 size, repeat 方式等等。对于所有简写属性，任何没有被指定的值都会被设定为它们的 初始值。</p><p>background-color 只能在background的最后一个属性上定义。background-size 必须紧跟在 background-position后面，并用“/”分隔。</p><h3 id="1-11-特殊元素的背景"><a href="#1-11-特殊元素的背景" class="headerlink" title="1.11 特殊元素的背景"></a>1.11 特殊元素的背景</h3><p>当html标签没有设置背景色时，我们看见的是作用在浏览器画布上的背景色，不是body上的；</p><p>当html标签被设置了背景色时，我们看见的是真正作用在body上的背景色。</p><p>CSS根据根元素（html/body）给文档画布渲染背景颜色，同时背景色的定位区域就是根元素的区域；</p><p>根元素不再绘制该背景色，即根元素背景的使用值是透明的</p><h2 id="2-边框"><a href="#2-边框" class="headerlink" title="2 边框"></a>2 边框</h2><h3 id="2-1-边框颜色-―-border-color-属性"><a href="#2-1-边框颜色-―-border-color-属性" class="headerlink" title="2.1 边框颜色 ― border-color 属性"></a>2.1 边框颜色 ― border-color 属性</h3><p>border-color 是一个用于设置元素四个边框颜色的快捷属性： border-top-color, border-right-color, border-bottom-color, border-left-color</p><h3 id="2-2-边框样式-―-border-style-属性"><a href="#2-2-边框样式-―-border-style-属性" class="headerlink" title="2.2 边框样式 ―  border-style 属性"></a>2.2 边框样式 ―  border-style 属性</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/q9he18OyK3IpLMf.png"                      alt="ChxDSvz4EdQEY2sF__thumbnail.png"                ></p><h3 id="2-3-边框宽度-―-border-width-属性"><a href="#2-3-边框宽度-―-border-width-属性" class="headerlink" title="2.3 边框宽度 ― border-width 属性"></a>2.3 边框宽度 ― border-width 属性</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当给定一个宽度时，该宽度作用于选定元素的所有边框 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line"><span class="comment">/* 当给定两个宽度时，该宽度分别依次作用于选定元素的横边与纵边 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 2<span class="selector-tag">px</span> 1.5<span class="selector-tag">em</span>;</span><br><span class="line"><span class="comment">/* 当给定三个宽度时，该宽度分别依次作用于选定元素的上横边、纵边、下横边 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span> 2<span class="selector-tag">em</span> 1.5<span class="selector-tag">cm</span>;</span><br><span class="line"><span class="comment">/* 当给定四个宽度时，该宽度分别依次作用于选定元素的上横边、右纵边、下横边、左纵边 （即按顺时针依次作用） */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: 1<span class="selector-tag">px</span> 2<span class="selector-tag">em</span> 0 4<span class="selector-tag">rem</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用的全局关键字有：inherit(继承),initial（初始值）,unset（不设置） */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="comment">/* 使用作用于 border-width 的关键字 */</span></span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">thin</span>;</span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">medium</span>;</span><br><span class="line"><span class="selector-tag">border-width</span>: <span class="selector-tag">thick</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-边框缩写属性"><a href="#2-4-边框缩写属性" class="headerlink" title="2.4 边框缩写属性"></a>2.4 边框缩写属性</h3><p>用于设置各种单独的边界属性的简写属性。border可以用于设置一个或多个以下属性的值： border-width, border-style, border-color ,无顺序，只接受三个参数，分别是宽度、风格和颜色，所以这样会使得四条边的边框相同。</p><h2 id="3-圆角"><a href="#3-圆角" class="headerlink" title="3 圆角"></a>3 圆角</h2><h3 id="3-1-曲线半径-―-border-radius-属性"><a href="#3-1-曲线半径-―-border-radius-属性" class="headerlink" title="3.1 曲线半径 ― border-radius 属性"></a>3.1 曲线半径 ― border-radius 属性</h3><p>border-*-radius 属性的两个长度或百分比值决定了作为边框外边形状的四分之一椭圆的半径。第一个取值是水平半径，第二个是垂直半径。若没有第二个取值，和第一个值相同。若其中一个长度为零，则角落垂直，不是圆角。</p><p>作为水平半径的百分比值，取值相对于边框盒的宽度，作为垂直半径的百分比值，取值相对于边框盒的高度。</p><p>border-radius’缩写可以用来设定四个 ‘border-*-radius’。若指定的值包含斜线，则斜线前面的取值会设定水平半径，斜线后面的取值会设定垂直半径，若没有斜线，则取值同时用来设定两个半径。</p><p>每个半径的四个值按照左上、右上、右下、左下的顺序，若没有左下取值则使用右上取值，若没有右下取值则使用左上取值，若没有右上取值则使用左上取值。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/rMPEAo5hlJaORH3.png"                      alt="frIxaJtah6iUhkL6__thumbnail.png"                ></p><h3 id="3-2-Corner-Shaping"><a href="#3-2-Corner-Shaping" class="headerlink" title="3.2 Corner Shaping"></a>3.2 Corner Shaping</h3><p>边距边（内边框）的半径是外边框半径减掉对应的边框粗细的结果。若这个结果是负值，内半径为零。（在这种情况下边距边的圆心可能不与外边框曲线的圆心重叠。）同样地，内容边半径是边距边半径减掉对应边距，或是零（前面结果为负值的情形）。使用者代理透过插值计算在曲线区域中边框与边距的粗细，也因此当相邻边框的粗细不同的时候，角落会是粗细边框之间的平滑转场。</p><p>如果外曲线超过了相邻角落的边距边，内曲线可能不是完整的四分之一椭圆。</p><p>所有边框样式（‘solid’ 、‘dotted’ 、‘inset’ 等等）跟者边框的曲线走。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/YF2eBGnv1amVl9A.png"                      alt="wne9FIO17lzvrUbe__thumbnail.png"                ></p><p>当圆角连接的两个边框的粗细不同时圆角的效果（左）与边框宽度比角落半径还粗的时候的圆角效果（右）</p><h3 id="3-3-Corner-Clipping"><a href="#3-3-Corner-Clipping" class="headerlink" title="3.3 Corner Clipping"></a>3.3 Corner Clipping</h3><p>使用者代理使用适当的曲线（以 ‘background-clip’ 决定）剪裁一个盒的背景（但不剪裁边框图像）。其他使用边框边或边距边（像是 ‘overflow’ 属性 ‘visible’ 以外的值）剪裁达到的效果也必须改用曲线剪裁。使用者代理总是用内容边曲线修剪置换元素。</p><p>边框边的曲线外的区域不接受以该元素为目标的pointer事件。</p><h3 id="3-4-Color-and-Style-Transitions"><a href="#3-4-Color-and-Style-Transitions" class="headerlink" title="3.4 Color and Style Transitions"></a>3.4 Color and Style Transitions</h3><p>颜色与样式变化必须发生在同时包含边框半径与内曲线中心（如果边框半径小于边框宽度，这是指边距边角落的点）的最小长方形与边框相交的片段。</p><p>若其中一个边框的宽度为零，则另一个边框的颜色与样式会佔满整个变化区域。不然，相邻边框间的颜色与样式转场的中心点必须正比于边框宽度的比例，使得中心点的位置函数是这个比例的连续函数。然而，本规范没有定义转场的长相或是「正比」如何对应到曲线上的点。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/fwurvComZgIl5jL.png"                      alt="mVbdbNd2w1ZiqJNy__thumbnail.png"                ></p><p>在这些角落的图形中，颜色与样式转场必须发生在绿色的区域。D 例中边框半径决定的长方形不包括内曲线（是个直角）的中心，因此转场范围扩张到角落之处。转场可发生在整个转场区域之中，但是本规范没有这样的要求：举例来说，两个实心边框之间的渐层颜色转场可能只发生在由外半径的尖端内半径的尖端包源的区域（在 D 例中以深绿色表示）。</p><h3 id="3-5-Overlapping-Curves"><a href="#3-5-Overlapping-Curves" class="headerlink" title="3.5 Overlapping Curves"></a>3.5 Overlapping Curves</h3><p>圆角曲线不能重叠：当任两个相邻边的半径和超过边框合的大小时，UA 必须以同样比例收缩所有边框半径直到曲线彼此不重叠。半径的收缩演算法如下：</p><p>设 f = min(Li/Si)，其中 i ∈ {顶, 右, 底, 左}，Si 是在 i 边的两个角的对应的两个半径的和，L顶 = L底 = 盒的宽度，L左 = L右 = 盒的高度。若 f &lt; 1，则所有角落半径同乘 f。</p><p>这个公式确保在收缩之后，四分之一圆形还是四分之一圆形、大的半径还是比小的大。但是这个作法可能收缩本来就很小的角落，让附近应该看起来一样的元素看起来不一样。</p><p>若曲线干扰到捲轴等等的 UI 元素，UA 在有必要的限度内（不得超过）可再缩小受影响的边框半径（只限受影响的边框半径）。</p><p>盒的渲染结果必须和以缩小的圆角值当作指定值一样。</p><h3 id="3-6-表格上的效果"><a href="#3-6-表格上的效果" class="headerlink" title="3.6 表格上的效果"></a>3.6 表格上的效果</h3><p>‘border-radius’ 属性适用于 ‘table’ 与 ‘inline-table’ 元素。当 ‘border-collapse’ 为 ‘collapse’，border-radius 属性不会被应用到表格。</p><h2 id="4-图像边框"><a href="#4-图像边框" class="headerlink" title="4 图像边框"></a>4 图像边框</h2><h3 id="4-1-图像源-―-border-image-source-属性"><a href="#4-1-图像源-―-border-image-source-属性" class="headerlink" title="4.1 图像源 ― border-image-source 属性"></a>4.1 图像源 ― border-image-source 属性</h3><p>元素的边框图片（border-image）的资源</p><p>Example:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-source: url(&#x27;/media/examples/border-diamonds.png&#x27;);</span><br></pre></td></tr></table></figure><h3 id="4-2-图像分割-―-border-image-slice-属性"><a href="#4-2-图像分割-―-border-image-slice-属性" class="headerlink" title="4.2 图像分割 ― border-image-slice 属性"></a>4.2 图像分割 ― border-image-slice 属性</h3><p>border-image-slice属性会将图片分割为9个区域：图像被分割为九个区域：四个角、四条边以及一个中间区域。除非使用了关键词 fill，否则中间的图像部分会被丢弃。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/T9UILsbuPq276f5.png"                      alt="XV72AIIGYEUs0q2Y__thumbnail.png"                ></p><p>|number|数字值，代表图像中像素）或矢量坐标|<br>|:—-:|:—-|:—-:|:—-|<br>|%|相对于图像尺寸的百分比值：图像的宽度影响水平偏移，高度影响垂直偏移|<br>|fill|保留边框图像的中间部分|</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所有的边 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 30%; </span><br><span class="line"><span class="comment">/* 垂直方向 | 水平方向 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 10% 30%;</span><br><span class="line"><span class="comment">/* 顶部 | 水平方向 | 底部 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 30 30% 45;</span><br><span class="line"><span class="comment">/* 上 右 下 左 */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 7 12 14 5; </span><br><span class="line"><span class="comment">/* 使用fill（fill可以放在任意位置） */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: 10% <span class="selector-tag">fill</span> 7 12;</span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">border-image-slice</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">border-image-slice</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">border-image-slice</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-绘制区域-―-border-image-width-属性"><a href="#4-3-绘制区域-―-border-image-width-属性" class="headerlink" title="4.3 绘制区域 ― border-image-width 属性"></a>4.3 绘制区域 ― border-image-width 属性</h3><p>规定图像边框的宽度</p><p>|<em>length</em>|    |<br>|:—-:|:—-|:—-:|:—-|<br>|number|代表对应的 border-width 倍数|<br>|%|区域的高度影响水平偏移，宽度影响垂直偏移|<br>|auto|如果规定该属性，则宽度为对应的图像切片的固有宽度|</p><h3 id="4-4-边扩展-―-border-image-outset-属性"><a href="#4-4-边扩展-―-border-image-outset-属性" class="headerlink" title="4.4 边扩展 ― border-image-outset 属性"></a>4.4 边扩展 ― border-image-outset 属性</h3><p>规定边框图像超出边框盒的量。在上、右、下、左侧。如果忽略第四个值，则与第二个值相同。如果省略第三个值，则与第一个值相同。如果省略第二个值，则与第一个值相同。不允许任何负值作为 border-image-outset 值。</p><p>|length|    |<br>|:—-:|:—-|:—-:|:—-|<br>|number|代表对应的 border-width 的倍数|</p><h3 id="4-5-图像铺成-―-background-image-repeat-属性"><a href="#4-5-图像铺成-―-background-image-repeat-属性" class="headerlink" title="4.5 图像铺成 ― background-image-repeat 属性"></a>4.5 图像铺成 ― background-image-repeat 属性</h3><p>定图像边框是否应该被重复（repeated）、拉伸（stretched）或铺满（rounded）。</p><p>|stretch|拉伸图像来填充区域|<br>|:—-:|:—-|:—-:|:—-|<br>|repeat|平铺（重复）图像来填充区域|<br>|round|类似 repeat 值。如果无法完整平铺所有图像，则对图像进行缩放以适应区域|</p><h3 id="4-6-图像边框缩写-―-border-image-属性"><a href="#4-6-图像边框缩写-―-border-image-属性" class="headerlink" title="4.6 图像边框缩写 ― border-image 属性"></a>4.6 图像边框缩写 ― border-image 属性</h3><p>border-image 属性是一个简写属性，用于设置以下属性：</p><p>|border-image-source|用在边框的图片的路径。|<br>|:—-:|:—-|:—-:|:—-|<br>|border-image-slice|图片边框向内偏移。|<br>|border-image-width|图片边框的宽度。|<br>|border-image-outset|边框图像区域超出边框的量。|<br>|border-image-repeat|图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。|</p><h2 id="5-Drop-Shadows-the-box-shadow-property"><a href="#5-Drop-Shadows-the-box-shadow-property" class="headerlink" title="5 Drop Shadows: the box-shadow property"></a>5 Drop Shadows: the box-shadow property</h2><p>在元素的框架上添加阴影效果，可以在同一个元素上设置多个阴影效果，并用逗号将他们分隔开。该属性可设置的值包括阴影的X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色。</p><p>如果只给出两个值, 那么这两个值将会被当作 <offset-x><offset-y> 来解释。</p><p>如果给出了第三个值, 那么第三个值将会被当作<blur-radius>解释。</p><p>如果给出了第四个值, 那么第四个值将会被当作<spread-radius>来解释。</p><p>|<em>h-shadow</em>|必需。水平阴影的位置。允许负值。|<br>|:—-:|:—-|:—-:|:—-|<br>|<em>v-shadow</em>|必需。垂直阴影的位置。允许负值。|<br>|<em>blur</em>|可选。模糊距离。|<br>|<em>spread</em>|可选。阴影的尺寸。|<br>|<em>color</em>|可选。阴影的颜色。|<br>|inset|可选。将外部阴影 (outset) 改为内部阴影。|</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/vWIH2DkhayP94Lq.png"                      alt="iGP0Sj73DZ5MyOkG__thumbnail.png"                ></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 60<span class="selector-tag">px</span> <span class="selector-tag">-16px</span> <span class="selector-tag">teal</span>;</span><br><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-tag">black</span>;</span><br><span class="line"><span class="comment">/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, 0.2);</span><br><span class="line"><span class="comment">/* 插页(阴影向内) | x偏移量 | y偏移量 | 阴影颜色 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inset</span> 5<span class="selector-tag">em</span> 1<span class="selector-tag">em</span> <span class="selector-tag">gold</span>;</span><br><span class="line"><span class="comment">/* 任意数量的阴影，以逗号分隔 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: 3<span class="selector-tag">px</span> 3<span class="selector-tag">px</span> <span class="selector-tag">red</span>, <span class="selector-tag">-1em</span> 0 0.4<span class="selector-tag">em</span> <span class="selector-tag">olive</span>;</span><br><span class="line"><span class="comment">/* 全局关键字 */</span></span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h2&gt;&lt;p&gt;每一个盒有一个背景层，可以是透明的（默认）也可以以某个颜色或一个以上的图像填满。背景属性可以用来指定背景使用的颜色（back</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="W3C CSS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/"/>
    
    <category term="Backgrounds and Borders Level 3" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/Backgrounds-and-Borders-Level-3/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="W3C" scheme="http://example.com/tags/W3C/"/>
    
  </entry>
  
  <entry>
    <title>Flexible Box Layout Module Level 1</title>
    <link href="http://example.com/2021/03/07/note/W3C%20CSS/Flexible%20Box%20Layout%20Module%20Level%201/"/>
    <id>http://example.com/2021/03/07/note/W3C%20CSS/Flexible%20Box%20Layout%20Module%20Level%201/</id>
    <published>2021-03-07T08:21:17.277Z</published>
    <updated>2021-03-08T08:56:06.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-伸缩布局盒模型和术语"><a href="#1-伸缩布局盒模型和术语" class="headerlink" title="1 伸缩布局盒模型和术语"></a>1 伸缩布局盒模型和术语</h2><p>一个设有display:flex或display:inline-flex的元素是叫做flex容器 ，flex容器的子元素被称为 flex items，这些子元素使用伸缩布局模型来排版。</p><p>块布局与行内布局的布局计算偏向使用书写模式方向，伸缩布局偏向使用flex directions。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/KfP81wsm5OzxFrL.png"                      alt="4uiZCCmxjzPvhtDD__thumbnail.png"                ></p><p><strong>main axis（主轴）main dimension（主轴方向）</strong></p><p><strong>main-start（主轴起点）main-end（主轴终点）</strong></p><p><strong>main size（主轴长度）main size property（主轴长度属性）</strong></p><p><strong>cross axis（侧轴）cross dimension（侧轴方向）</strong></p><p><strong>cross-start（侧轴起点）cross-end（侧轴长度）</strong></p><p><strong>cross size（侧轴长度）cross size property（侧轴长度属性）</strong></p><h2 id="2-flex容器-―display的flex、inline-flex值"><a href="#2-flex容器-―display的flex、inline-flex值" class="headerlink" title="2 flex容器 ―display的flex、inline-flex值"></a>2 flex容器 ―display的flex、inline-flex值</h2><p>flex   元素产生块级flex容器盒。inline-flex  元素产生行内级flex容器盒。</p><p>flex容器会为其内容建立新的<strong>伸缩格式化上下文</strong>(flex formatting context)。 浮动不会闯入flex容器，且flex容器的边界不与其内容的边界叠加。flex容器不是block容器，因此有些用来控制block布局的属性，在伸缩布局中不适用。如：</p><ol><li>多栏(column)的所有column-*属性；</li><li>float与clear；（“float”属性仍然会影响flex容器子容器上的“display”的计算值)</li><li>vertical-align。</li><li>::first-line 和::first-letter，且flex container元素也不会成为它祖先的::first-line和::first-letter。</li></ol><p>若元素display的值是inline-flex且元素是一个浮动或绝对定位元素，则display的计算值是flex。</p><h2 id="3-flex-item"><a href="#3-flex-item" class="headerlink" title="3 flex item"></a>3 flex item</h2><p>一个flex容器的内容具有零个以上的flex item ，flex容器的每一个子元素都会成为一个flex item，且在flex容器里的连续文字块会被包起来成为匿名的block container flex item，若匿名flex item仅包含空白，则该flex item不会渲染，如同视为display: none。</p><p>匿名的item box是不能设置style的，因为没有元素去设置，它只能从flex container继承styles。</p><p>一个flex item为它的内容建立了一个独立的格式化上下文。然而flex items它本身是一个flex-level盒子，而不是block-level盒子：它们参与的是flex格式化上下文，而不是块级格式化上下文。</p><p>一些display值通常会在原始盒子周围创建匿名的盒子，但对于flex item来说，它首先被块级化，所以不会创建匿名盒子，例如两个连续的flex items的display值被设置为table-cell将会创建两个分开的块级flex items,而不是被包装为一个单独的匿名table。</p><p>对于display值被指定为table的flex item，表格包装盒子成为一个flex item，order和align-self适用于它，任何标题框的内容都有助于计算表格盒子的最小和最大宽度。</p><p>对于width和height采用以下规则计算：flex items的最终尺寸是在执行布局的时候计算的，就好像表格盒子和表格内容的间隔是表格盒子的border+padding区域一样。</p><h3 id="3-1-绝对定位的伸缩子元素"><a href="#3-1-绝对定位的伸缩子元素" class="headerlink" title="3.1 绝对定位的伸缩子元素"></a>3.1 绝对定位的伸缩子元素</h3><p>因为它脱离了文档流，所以绝对定位的child不参与flex布局。</p><p>flex container中的绝对定位元素的位置被计算就好像它是flex container中仅有的唯一元素一样，并且假设flexcontainer和flex item都是固定大小的尺寸。所以为了此目的，automargin被视为0。换句话说，flex容器中的定位元素是相对于flex容器的contentbox定位的。</p><p>如果对flex container中的绝对定位的元素设置align-self: center;,自动offset将会让它在flex容器的cross axis居中。然而因为一个绝对定位的flex item是固定尺寸的，stretch属性被视为和flex start相同。</p><h3 id="3-2-Flex-itemMargins-and-Paddings"><a href="#3-2-Flex-itemMargins-and-Paddings" class="headerlink" title="3.2 Flex itemMargins and Paddings"></a>3.2 Flex itemMargins and Paddings</h3><p>相邻flex items的margins不会合并。</p><p>百分比的margins和paddings和block boxes一样，相对于它们的containing block计算。</p><p>auto margins会扩展去吸收相应区域额外的空间，它们被用于对齐或者使相邻的flex items分离。</p><h3 id="3-3-Flex-Item-Z-Ordering"><a href="#3-3-Flex-Item-Z-Ordering" class="headerlink" title="3.3 Flex Item Z-Ordering"></a>3.3 Flex Item Z-Ordering</h3><p>flex items的渲染和inline block类似，除了order属性会改变源文档的顺序，不是auto值的z-index会创建一个堆叠上下文，甚至是position被设置static的时候也一样（表现的好像是position是relative一样）。</p><p>位于flex item外部的后代仍然参与flex item建立的的任何堆叠上下文。</p><h3 id="3-4-Collapsed-Items"><a href="#3-4-Collapsed-Items" class="headerlink" title="3.4 Collapsed Items"></a>3.4 Collapsed Items</h3><p>在flex item上指定visibility:collapse会引发它成为一个折叠flex item，产生一种类似在table-row或table-column上设置visibility:collapse的效果：折叠的flex item完全从渲染中移除，但是留下一个桩来保持flex line的cross size的稳定。因此，如果一个flex容器只有一个flex line，动态折叠或者不折叠items可能会改变flex容器的main size，但是不会对它的cross size产生影响，也不会导致页面其余部分“摇晃”，然而flex line的换行是折叠之后重做的，所以具有多line的flex容器的cross size可能会也可能不会改变。</p><p>尽管折叠flex item没有被渲染，但它确实出现在formatting structure，因此不像设置了display: none的items。依赖于formatting structure的盒子的效果（例如递增计数器，运行动画或者过渡）仍然对折叠items产生作用。</p><h3 id="3-5-flex-item的自动最小尺寸"><a href="#3-5-flex-item的自动最小尺寸" class="headerlink" title="3.5 flex item的自动最小尺寸"></a>3.5 flex item的自动最小尺寸</h3><p>为了为flex items提供一个更加合理的默认最小尺寸，对于一个不是滚动容器的主轴中的flex items的最小尺寸的值就是它的基于内容的最小尺寸，对于滚动容器，自动最小尺寸通常是0。</p><p>通常来说，flex items的基于内容的最小尺寸是content size suggestion和specified size suggestion中的较小值。然而，如果一个盒子具有宽高比但是没有specified size，它的基于内容的最小尺寸就是content size suggestion和transferred size suggestion中的较小值。如果盒子既没有specified size suggestion也没有宽高比，它的基于内容的最小尺寸就是content size suggestion。</p><p><strong>specified size suggestion</strong></p><p>如果item的计算main size property是有定义的，specified size suggestion就是该大小（如果它是被定义的，则由其最大main size property限制），否则是undefined。</p><p><strong>transferred size suggestion</strong></p><p>如果item具有固有的宽高比并且它的计算的cross size property是有定义的，transferred size suggestion就是那个大小（如果它们是有定义的，则由其最小和最大cross size properties限制），通过宽高比转化，否则是undefined。</p><p><strong>content size suggestion</strong></p><p>content size suggestion就是主轴上的最小内容大小，如果它具有宽高比，通过任何定义的min and max cross peoperties转化宽高比，那么它是受限制的，然后进一步受限制如果它定义了max main size property.</p><p>为了计算盒子的固有大小（例如盒子的最小内容大小），基于内容的最小大小使得该轴中盒子的大小变得不确定（即使例如其宽度属性指定了确定的大小），这意味着根据此大小计算的百分比将表现为auto。</p><h2 id="4-顺序与方向"><a href="#4-顺序与方向" class="headerlink" title="4 顺序与方向"></a>4 顺序与方向</h2><p>flex container的内容可以沿着任意方向和任意顺序布局，这个功能通过使用flex-direction,flex-wrap和order属性实现。</p><h3 id="4-1-flex流的方向：flex-direction属性"><a href="#4-1-flex流的方向：flex-direction属性" class="headerlink" title="4.1 flex流的方向：flex-direction属性"></a>4.1 flex流的方向：flex-direction属性</h3><p>|flex-direction属性值|flex-direction决定了flex items在主轴上沿着什么方向布局|<br>|:—-:|:—-|:—-:|:—-|<br>|row（默认）|主轴的方向和inline axis相同，main-start和main-end分别和inline-start和inline-end方向相同|<br>|row-reverse|和row相似，但main-start和main-end调转过来|<br>|column|主轴的方向和block axis一致，main-start和main-end分别和block-start和block-end方向相同|<br>|column-reverse|和column相似，但main-start和main-end调转过来|</p><h3 id="4-2-flex行换行-：flex-wrap属性"><a href="#4-2-flex行换行-：flex-wrap属性" class="headerlink" title="4.2 flex行换行 ：flex-wrap属性"></a>4.2 flex行换行 ：flex-wrap属性</h3><p>|flex-wrap属性值|flex wrap属性控制flex containers是单行的还是多行的，以及侧轴的方向。侧轴的方向决定了新行被叠加的方向。|<br>|:—-:|:—-|:—-:|:—-|<br>|nowrap（默认）|flex containers是单行的|<br>|wrap|flex containers是多行的。|<br>|wrap-reverse|和wrap一样，不过方向相反。|</p><h3 id="4-3-flex方向与换行-：flex-flow缩写"><a href="#4-3-flex方向与换行-：flex-flow缩写" class="headerlink" title="4.3 flex方向与换行 ：flex-flow缩写"></a>4.3 flex方向与换行 ：flex-flow缩写</h3><p>flex-flow是flex-directive和flex-wrap的简写形式，定义了flex container的主轴和侧轴。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/G87MglOH1UqaeSr.png"                      alt="7w6xAn53Yd7j7pwQ__thumbnail.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/IY4lrixyNtMsP89.png"                      alt="HdIWBm2MS37XVzeN__thumbnail.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/JPRzlABt3qQxY8g.png"                      alt="oOMZpxlmZTIx2Vn3__thumbnail.png"                ></p><p>flex-flow是和writing mode相关的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/7zfqoyTVSUYLA9R.png"                      alt="d7uQWKnXZubXdt5O__thumbnail.png"                ></p><h3 id="4-4-display顺序-order属性"><a href="#4-4-display顺序-order属性" class="headerlink" title="4.4 display顺序 :order属性"></a>4.4 display顺序 :order属性</h3><p>flex item默认的展示顺序和源文档一样，order属性可以改变这种顺序。</p><p>order接受一个整数值，从最低的值开始排列，值相同的按源文档的顺序排序，绝对布局的flex items被视为order: 0。</p><p>order仅仅影响视觉上的顺序，而不会影响逻辑源代码的顺序和非视觉媒体或者不支持css的设备的顺序。</p><h2 id="5-FlexLines"><a href="#5-FlexLines" class="headerlink" title="5 FlexLines"></a>5 FlexLines</h2><p>flex items在flex容器中排列在flex lines中。一个flex container可以是单行的或者多行的，这取决于flex-wrap属性。</p><p>single-line flex容器：（设置了flex-wrap: nowrap），所有的item布局在一个单行，即使会引起内容溢出。</p><p>multi-line flex容器：（设置了flex-wrap: wrap或者flex-wrap: wrap-reverse），分割它的flex items成为多line。当额外的line被创建，它们在容器的侧轴上按照flex-wrap属性的值堆叠，每一个line至少包含一个item，除非容器是空的。</p><p>一旦内容被分割为多行，每一行就是独立布局的，弹性长度和justify-content,align-self属性一次只考虑在一行中的items。</p><p>在一个多行的flex container中（甚至只有一行），每行的侧轴尺寸就是能够包含下该行的items的最小尺寸（通过align-self属性排列后），行在flex container中的排列使用align-content属性设置。在单行的flex container中，行的侧轴尺寸就是flex container的侧轴尺寸，align-content没有效果。每一行的主轴的尺寸总是和flex container内容盒子的主轴尺寸相同的。</p><h2 id="6-伸缩性"><a href="#6-伸缩性" class="headerlink" title="6 伸缩性"></a>6 伸缩性</h2><p>flex布局的定义方面是能够使flex items弹性，改变它们的宽度/高度去填充main dimension剩余的空间，这可以通过flex属性实现。flex container分配剩余空间给它的items（通过设置flex-grow ）来填充填充容器，或者收缩它们（通过设置flex-shrink）来阻止溢出。</p><p>如果flex item的flex-grow和flex-shrink都是0，是完全没有弹性的，否则是伸缩的。</p><h3 id="6-1-flex缩写"><a href="#6-1-flex缩写" class="headerlink" title="6.1 flex缩写"></a>6.1 flex缩写</h3><p>flex属性规定了flex元素如何伸长或缩短以适应flex容器中的可用空间。这是一个简写属性，用来设置 flex-grow, flex-shrink 与 flex-basis。</p><ol><li><strong>flex-grow</strong></li></ol><p>指定了flex的增长因子，当有正的剩余空间的时候，增长因子决定了flex item相对于容器中其他的flex items的增长程度，默认值为1。当line上的flex值之和小于1时，它们将占用小于100％的可用空间。</p><ol start="2"><li><strong>flex-shrink</strong></li></ol><p>决定了flex item相对于容器中其他的flex items的收缩程度，默认值为1，不能为负数。仅在默认宽度之和大于容器的时候才会发生收缩。</p><ol start="3"><li><strong>flex-basis</strong></li></ol><p>指定了 flex 元素在主轴方向上的初始大小。flex-basis接受和width,height一样的值（除了auto被视为不同的），以及content关键字。</p><pre><code>1. auto</code></pre><p>当在flex item使用该值时，auto关键字将item的main size property设为它的flex-basis。若那个值是也是auto，就使用值就是content。<br>    2. content<br>表示基于flex item内容的自动尺寸</p><h3 id="6-2-flex的常见值"><a href="#6-2-flex的常见值" class="headerlink" title="6.2 flex的常见值"></a>6.2 flex的常见值</h3><ol><li><strong>flex: initial</strong></li></ol><p>等效于flex: 0 1 auto，基于它的width/height来设置它的尺寸（若item的main size property被设置为auto,它的尺寸将会基于它的内容），在正的剩余空间的时候flex item没有弹性，但是没有充足空间的时候会收缩到它的最小尺寸，alignment abilities或者auto margin在主轴上排列flex items。</p><ol start="2"><li><strong>flex: auto</strong></li></ol><p>等效于flex: 1 1 auto,基于它的width/height来设置它的尺寸，并且使它完全弹性的，它会吸收任何多余的空间。</p><ol start="3"><li><strong>flex: none</strong></li></ol><p>等效于flex: 0 0 auto, 基于它的width/height来设置它的尺寸，并且使它完全不可弹性的。甚至在溢出的情况也不会收缩。</p><ol start="4"><li><strong>flex: positive-number</strong></li></ol><p>等效于flex: <positive-number> 1 0，使flex item弹性的，并且设置flex basis为0。</p><p>默认情况下flex items并不会缩减到它的最小尺寸以下（最大的text长度或者固定尺寸的元素），改变这个可以通过设置min-width或者min-height属性</p><h2 id="7-对齐"><a href="#7-对齐" class="headerlink" title="7 对齐"></a>7 对齐</h2><h3 id="7-1-auto-margin对齐"><a href="#7-1-auto-margin对齐" class="headerlink" title="7.1 auto margin对齐"></a>7.1 auto margin对齐</h3><p>flex item 和 block流的auto margin非常类似：</p><ol><li>在计算flex bases和伸缩长度的时候，auto margin被视为0</li><li>优先于通过justify-content和align-self设置的对齐属性，在那个区域的任何正的空间的都被分配给auto margin。</li><li>溢出的盒子会忽略它们的auto margin，并且在end方向溢出<h3 id="7-2-主轴对齐-justify-content属性"><a href="#7-2-主轴对齐-justify-content属性" class="headerlink" title="7.2 主轴对齐 :justify-content属性"></a>7.2 主轴对齐 :justify-content属性</h3></li></ol><table><thead><tr><th align="left">justify-content属性值</th><th align="left">定义了项目在主轴上的对齐方式</th></tr></thead><tbody><tr><td align="left">flex-start（默认）</td><td align="left"></td></tr><tr><td align="left">flex-end</td><td align="left"></td></tr><tr><td align="left">center</td><td align="left"></td></tr><tr><td align="left">space-between</td><td align="left"></td></tr><tr><td align="left">space-around</td><td align="left"></td></tr></tbody></table><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/Q6k15IzBNuJGbvn.png"                      alt="HGyMlU07TRUL0xu2__thumbnail.png"                ></p><h3 id="7-3-侧轴对齐-align-items与align-self属性"><a href="#7-3-侧轴对齐-align-items与align-self属性" class="headerlink" title="7.3 侧轴对齐 :align-items与align-self属性"></a>7.3 侧轴对齐 :align-items与align-self属性</h3><p>flex items可以在当前容器的当前行的侧轴上对齐，align-items设置flex容器中所有项的默认对齐方式，包括匿名flex items，align-self为单个flex items设置对齐方式，会覆盖它的默认对齐方式，对于匿名的flex items，align-self始终匹配它们相关联的flex容器的align-items值。</p><p>如果任何flex-items的margin的值为auto。则align-self无效。</p><p>如果flex容器的高度受到约束，stretch值可能导致flex item的内容溢出item</p><table><thead><tr><th align="left">align-items和align-self属性值</th><th align="left">定义了项目在主轴上的对齐方式</th></tr></thead><tbody><tr><td align="left">auto（align-self的属性值，且默认）</td><td align="left"></td></tr><tr><td align="left">flex-start</td><td align="left"></td></tr><tr><td align="left">flex-end</td><td align="left"></td></tr><tr><td align="left">center</td><td align="left"></td></tr><tr><td align="left">baseline</td><td align="left"></td></tr><tr><td align="left">stretch</td><td align="left"></td></tr></tbody></table><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/FRKW1quDNZtfUzM.png"                      alt="kmOo5IYgu9TesAUd__thumbnail.png"                ></p><h3 id="7-4-堆栈伸缩行-：align-content属性"><a href="#7-4-堆栈伸缩行-：align-content属性" class="headerlink" title="7.4 堆栈伸缩行 ：align-content属性"></a>7.4 堆栈伸缩行 ：align-content属性</h3><p>当cross-axis有额外空间的时候，align-content排列flex容器中的lines，类似justity-content在主轴排列单独的item，这个属性对于单行的flex容器没有效果。单行flex容器的line会自动拉伸填充空间。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/oGZzPy8RMfkYTtC.png"                      alt="H98ydaeN2I2CiLn8__thumbnail.png"                ></p><h2 id="8-Flex容器基线"><a href="#8-Flex容器基线" class="headerlink" title="8 Flex容器基线"></a>8 Flex容器基线</h2><p>为了使flex容器本身参与基线对齐（例如，当flex容器本身是外部flex容器的flex item时），它需要提交最能代表其内容的基线位置。为此，flex容器基线的位置被决定如下（使用order重排后并将flex-direction考虑在内）：</p><p><strong>first/last 主轴基线集</strong></p><p>当flex容器的inline axis匹配它的main axis，它的基线被决定如下：</p><ol><li>如果flex容器的最开始/最末尾的flex line中的任何flex items参与基线对齐，flex容器的first/last主轴基线集则从那些flex items的共享对齐基线生成。</li><li>否则，如果flex容器至少有一个flex item，则flex容器的first/last基线集是从最开始/最末尾的flex item的对齐基线生成。（如果该item没有与flex容器主轴平行的对齐基线，则首先从其边界边缘合成一个）。</li><li>否则，flex容器没有first/last主轴基线集，并且根据其对齐上下文规则在需要时合成一个。</li></ol><p><strong>first/last侧轴基线集</strong></p><p>当flex容器的inline axis匹配它的cross axis，它的基线被决定如下：</p><ol><li>如果flex容器至少有一个flex item，则flex容器的first/last基线集是从最开始/最末尾的flex item的对齐基线生成。（如果该item没有与flex容器交叉轴平行的对齐基线，则首先从其边界边缘合成一个）。</li><li>否则，flex容器没有first/last主轴基线集，并且根据其对齐上下文规则在需要时合成一个。</li></ol><p>根据上述规则计算基线时，如果贡献基线的框具有允许滚动的overflow值，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-伸缩布局盒模型和术语&quot;&gt;&lt;a href=&quot;#1-伸缩布局盒模型和术语&quot; class=&quot;headerlink&quot; title=&quot;1 伸缩布局盒模型和术语&quot;&gt;&lt;/a&gt;1 伸缩布局盒模型和术语&lt;/h2&gt;&lt;p&gt;一个设有display:flex或display:inlin</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="W3C CSS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/"/>
    
    <category term="Flexible Box Layout Module Level 1" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/Flexible-Box-Layout-Module-Level-1/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="W3C" scheme="http://example.com/tags/W3C/"/>
    
  </entry>
  
  <entry>
    <title>Positioned Layout Module Level 3</title>
    <link href="http://example.com/2021/03/07/note/W3C%20CSS/Positioned%20Layout%20Module%20Level%203/"/>
    <id>http://example.com/2021/03/07/note/W3C%20CSS/Positioned%20Layout%20Module%20Level%203/</id>
    <published>2021-03-07T08:21:14.897Z</published>
    <updated>2021-03-08T08:09:30.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>|name|postion|<br>|:—-:|:—-|:—-:|:—-|<br>|Value:|static<a class="link"   href="https://www.w3.org/TR/css-values-4/#comb-one" >|<i class="fas fa-external-link-alt"></i></a>relative | absolute | sticky | fixed|<br>|Initial:|static|<br>|Applies to:|除了table-column-group 和table-column以外的所有元素|<br>|Inherited:|不继承|</p><h1 id="2-static-定位"><a href="#2-static-定位" class="headerlink" title="2 static 定位"></a>2 static 定位</h1><p>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</p><p>静态定位的元素不会受到 top, bottom, left, right影响。</p><h1 id="3-relative-定位"><a href="#3-relative-定位" class="headerlink" title="3 relative 定位"></a>3 relative 定位</h1><p>相对定位元素的定位是相对其正常位置。</p><h1 id="4-absolute-定位"><a href="#4-absolute-定位" class="headerlink" title="4 absolute 定位"></a>4 absolute 定位</h1><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>:</p><h1 id="5-sticky-定位"><a href="#5-sticky-定位" class="headerlink" title="5 sticky 定位"></a>5 sticky 定位</h1><p>sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。</p><p>position: sticky; 基于用户的滚动位置来定位。</p><p>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</p><p>它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</p><p>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p><p>这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h1 id="6-fixed-定位"><a href="#6-fixed-定位" class="headerlink" title="6 fixed 定位"></a>6 fixed 定位</h1><p>元素的位置相对于浏览器窗口是固定位置。</p><p>即使窗口是滚动的它也不会移动：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1 Introduction&quot;&gt;&lt;/a&gt;1 Introduction&lt;/h1&gt;&lt;p&gt;|name|postion|&lt;br&gt;|:—-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="W3C CSS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/"/>
    
    <category term="Positioned Layout Module Level 3" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/Positioned-Layout-Module-Level-3/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="W3C" scheme="http://example.com/tags/W3C/"/>
    
  </entry>
  
  <entry>
    <title>Selectors Level 3</title>
    <link href="http://example.com/2021/03/07/note/W3C%20CSS/Selectors%20Level%203/"/>
    <id>http://example.com/2021/03/07/note/W3C%20CSS/Selectors%20Level%203/</id>
    <published>2021-03-07T08:21:11.952Z</published>
    <updated>2021-03-08T08:09:35.491Z</updated>
    
    <content type="html"><![CDATA[<p>**CSS(层叠样式表)**是一个描述HTML和XML文档在屏幕等上呈现的语言。CSS使用选择器将样式属性绑定到文档中的元素，选择器是与树中的元素相匹配的模式，在语法上不区分大小写，</p><h2 id="1-选择器介绍"><a href="#1-选择器介绍" class="headerlink" title="1 选择器介绍"></a>1 选择器介绍</h2><table><thead><tr><th align="center">Pattern</th><th align="left">Represents</th><th align="center">Description</th><th align="left">Level</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">所有元素</td><td align="center">通用选择器</td><td align="left">2</td></tr><tr><td align="center">E</td><td align="left">所有E元素</td><td align="center">类型选择器</td><td align="left">1</td></tr><tr><td align="center">E[foo]</td><td align="left">定义了 “foo”属性的E元素</td><td align="center">属性选择器</td><td align="left">2</td></tr><tr><td align="center">E[foo=”bar”]</td><td align="left">定义了”foo”属性且值为”bar”的E元素</td><td align="center">属性选择器</td><td align="left">2</td></tr><tr><td align="center">E[foo~=”bar”]</td><td align="left">定义了”foo”属性且属性值是一个以空格分隔的列表，其中一个列表的值为”bar”。</td><td align="center">属性选择器</td><td align="left">2</td></tr><tr><td align="center">E[foo^=”bar”]</td><td align="left">定义了“foo”属性且值以“bar”开头的E元素</td><td align="center">属性选择器</td><td align="left">3</td></tr><tr><td align="center">E[foo$=”bar”]</td><td align="left">定义了“foo”属性且值以“bar”结尾的E元素</td><td align="center">属性选择器</td><td align="left">3</td></tr><tr><td align="center">E[foo*=”bar”]</td><td align="left">定义了“foo”属性且值包含“bar”的E元素</td><td align="center">属性选择器</td><td align="left">3</td></tr><tr><td align="center">E[foo|=”en”]</td><td align="left">定义了“foo”属性且属性值是用连字符（-）分隔的列表，值开头的字符为”en”的E元素</td><td align="center">属性选择器</td><td align="left">2</td></tr><tr><td align="center">E:root</td><td align="left">文档的根元素，对于HTML文档就是HTML元素</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:nth-child(n)</td><td align="left">E元素的父元素中的第n个子元素</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:nth-last-child(n)</td><td align="left">E元素的父元素中的倒数第n个子元素（只匹配同种的E元素）</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:nth-of-type(n)</td><td align="left">E元素的父元素中的第n个子代E元素</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:nth-last-of-type(n)</td><td align="left">E元素的父元素中的倒数第n个子元素（只匹配同种的E元素）</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:first-child</td><td align="left">E元素的父元素中的第一个子代E元素</td><td align="center">结构伪类</td><td align="left">2</td></tr><tr><td align="center">E:last-child</td><td align="left">E元素的父元素中的最后一个子代E元素</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:first-of-type</td><td align="left">E元素的父元素中的第一个子代E元素（只匹配相同的E元素）</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:last-of-type</td><td align="left">E元素的父元素中的最后一个子代E元素（只匹配相同的E元素）</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:only-child</td><td align="left">匹配父元素仅有的这个E元素</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:only-of-type</td><td align="left">匹配父元素仅有一个的E元素（只匹配相同的E元素）</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:empty</td><td align="left">匹配一个不包含任何元素的元素（文本结点也被看做子元素）</td><td align="center">结构伪类</td><td align="left">3</td></tr><tr><td align="center">E:link<br>E:visited</td><td align="left">作为超链接的E元素，其目标尚未访问（：link）或已访问（：visited）</td><td align="center">链接伪类</td><td align="left">1</td></tr><tr><td align="center"></td><td align="left"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">E:active<br>E:hover<br>E:focus</td><td align="left">在某些用户操作期间的E元素</td><td align="center">用户操作伪类</td><td align="left">1 and 2</td></tr><tr><td align="center">E:target</td><td align="left">相关URL指向的E元素</td><td align="center">目标伪类</td><td align="left">3</td></tr><tr><td align="center">E:lang(fr)</td><td align="left">语言为”fr”的E元素</td><td align="center">:lang() 伪类</td><td align="left">2</td></tr><tr><td align="center">E:enabled<br>E:disabled</td><td align="left">用户界面上处于可用或禁用状态的E元素</td><td align="center">UI元素声明伪类</td><td align="left">3</td></tr><tr><td align="center"></td><td align="left"></td><td align="center"></td><td align="left"></td></tr><tr><td align="center">E:checked</td><td align="left">用户界面上处于选中状态的E元素(用于input type为radio与checkbox时)</td><td align="center">UI元素声明伪类</td><td align="left">3</td></tr><tr><td align="center">E::first-line</td><td align="left">设置E元素内的第一行样式</td><td align="center">::first-line伪元素</td><td align="left">1</td></tr><tr><td align="center">E::first-letter</td><td align="left">设置E元素内的第一个字符</td><td align="center">::first-letter伪元素</td><td align="left">1</td></tr><tr><td align="center">E::before</td><td align="left">设置在对象前发生的内容</td><td align="center">::before伪元素</td><td align="left">2</td></tr><tr><td align="center">E::after</td><td align="left">设置在对象后发生的内容</td><td align="center">after伪元素</td><td align="left">2</td></tr><tr><td align="center">E.warning</td><td align="left">class属性值为warning的E元素</td><td align="center">类选择器</td><td align="left">1</td></tr><tr><td align="center">E#myid</td><td align="left">ID为”myid”的E元素</td><td align="center">ID选择器</td><td align="left">1</td></tr><tr><td align="center">E:not(s)</td><td align="left">不含有S选择器的元素</td><td align="center">相反伪类</td><td align="left">3</td></tr><tr><td align="center">E F</td><td align="left">所有属于E元素后代F元素</td><td align="center">后代组合器</td><td align="left">1</td></tr><tr><td align="center">E &gt; F</td><td align="left">所有属于E元素的子代F元素</td><td align="center">子代组合器</td><td align="left">2</td></tr><tr><td align="center">E + F</td><td align="left">紧贴在E元素之后的F元素</td><td align="center">相邻兄弟组合器</td><td align="left">2</td></tr><tr><td align="center">E ~ F</td><td align="left">在E元素之后的F元素</td><td align="center">兄弟组合器</td><td align="left">3</td></tr></tbody></table><h2 id="2-选择器语法"><a href="#2-选择器语法" class="headerlink" title="2 选择器语法"></a><strong>2 选择器语法</strong></h2><p><strong>选择器</strong>是由一个或多个简单选择器序列组成并由组合器分隔的链。一个伪元素可以附加到选择器中的最后一个简单选择器序。</p><p><strong>简单选择器序列</strong>是不被组合器分割的简单选择器链，它总是以类型选择器或通用选择器开始，序列中不允许使用其他类型选择器或通用选择器。</p><p><strong>简单选择器</strong>：类型选择器，通用选择器、属性选择器、类选择器、ID选择器、伪类选择器。</p><p><strong>组合器</strong>有：空格、“&gt;”（greater-than sign）、“+”（plus sign）和“~”（tilde）。组合器和它周围的简单选择器之间可以出现空白。空白中只能出现“空格”、“制表符”、“换行符”、“回车符”和“换页符”。其他类似空格的字符，例如“em space”（全角空格）和“ideographic space”（表意空格），都不是空白的一部分。</p><p>由选择器表示的文档树的元素是选择器的主题。由单个简单选择器序列组成的选择器表示满足其要求的任何元素。将另一个简单选择器序列和一个组合器添加到一个简单选择器序列前，会产生额外的匹配约束，因此选择器的主题始终是最后一个简单选择器序列所表示的元素的子集。</p><p><strong>空选择器</strong>（不包含简单选择器序列和伪元素）是无效的选择器。</p><p>选择器中的字符可以用反斜杠转义。</p><p>某些选择器支持命名空间前缀。声明命名空间前缀的机制应该由使用选择器的语言指定。如果没有指定，则不声明前缀。在CSS中，命名空间前缀使用@namespace规则声明。</p><h2 id="3-选择器组"><a href="#3-选择器组" class="headerlink" title="3 选择器组"></a>3 选择器组</h2><p>一个由逗号分隔的选择器列表表示列表中每个单独的选择器所选择的所有元素的联合，它们共享相同的声明。注意：如果其中一个选择器无效，则整个选择器组都将无效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1, h2, h3 &#123; font-family: sans-serif &#125;</span><br></pre></td></tr></table></figure><h2 id="4-类型选择器"><a href="#4-类型选择器" class="headerlink" title="4 类型选择器"></a>4 类型选择器</h2><p>类型选择器匹配文档语言元素类型的名称。类型选择器匹配文档树中该元素类型的每一个实例。如果命名空间前缀没有提前声明，此类型选择器是无效的。</p><p>|<strong>ns|E</strong>|表示命名空间 ns 中的 E 元素|<br>|:—-:|:—-|:—-:|:—-|<br>|*<strong>|E</strong>|表示任何命名空间中的 E 元素(包括没有命名空间的元素)|<br>|<strong>|E</strong>|若有默认命名空间，表示默认命名空间中的 E 元素，否则表示没有命名空间的 E 元素|<br>|<strong>E</strong>|如果没有默认命名空间的情况下，等同于<strong>|E</strong>，否则等同于 ns|E|</p><p>CSS examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> foo url(<span class="attribute">http:</span>//www.example.com);</span><br><span class="line"> </span><br><span class="line">foo|h1 &#123;color: blue&#125;/* 只匹配在命名空间&quot;http://www.example.com&quot;中的 h1 元素 */</span><br><span class="line">foo|* &#123;color: yellow&#125;/* 匹配在命名空间&quot;http://www.example.com&quot;中的所有元素 */</span><br><span class="line">|h1 &#123; color: red &#125; /* 匹配没有命名空间的 h1 元素 */</span><br><span class="line">*|h1 &#123; color: green &#125;/* 匹配所有命名空间（包括没有命名空间）的 h1 元素 */ </span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: green &#125;<span class="comment">/* 因为没有默认命名空间，所以同上 */</span></span><br></pre></td></tr></table></figure><h2 id="5-通用选择器"><a href="#5-通用选择器" class="headerlink" title="5 通用选择器"></a>5 通用选择器</h2><p>如果没有为选择器指定默认名称空间，则它表示文档树中任何名称空间(包括没有名称空间的元素)中的任何元素。如果命名空间前缀没有提前声明，此通用选择器是无效的</p><p>如果通用选择器后面还有其他简单选择器，或者紧跟着一个伪元素，那么*可能被省略，并且暗示了通用选择器的存在。</p><p>不要省略 *，因为可以减少两者之间的混淆，比如 div  :first-child 和 div:first-child，在这里，div *:first-child 更具可读性。</p><p>Examples:</p><ul><li><code>*[hreflang|=en]</code>and<code>[hreflang|=en]</code>are equivalent,</li><li><code>*.warning</code>and<code>.warning</code>are equivalent,</li><li><code>*#myid</code>and<code>#myid</code>are equivalent.</li></ul><p>通用选择器允许有命名空间。使用如下:</p><p>|<strong>ns|**<em>|表示命名空间 ns 中的所有元素|<br>|:—-:|:—-|:—-:|:—-|<br>|</em></strong>|<strong><em>|任何元素|<br>|**|</em></strong>|如果有默认命名空间，表示默认命名空间中的任何元素，如果有，则表示没有命名空间的任何元素|<br>|<strong>**<em>|如果没有默认命名空间的情况下，等同于</em></strong>|**<em>，否则等同于 ns|</em>|</p><h2 id="6-属性选择器"><a href="#6-属性选择器" class="headerlink" title="6 属性选择器"></a>6 属性选择器</h2><p>根据元素的属性和属性值来匹配元素。通用语法由方括号[ ] 组成，其中包含属性名称，后跟可选条件以匹配属性的值。</p><p>|<strong>[att]</strong>|表示定义了att属性的元素，无论属性值是什么|<br>|:—-:|:—-|:—-:|:—-|<br>|<strong>[att=val]</strong>|表示定义了att属性且属性值是val的元素|<br>|<strong>[att~=val]</strong>|表示定义了att属性且属性值在一个以空格分隔的列表中的值为val的元素,如果val中有空格或为空字符串，则不代表任何元素|<br>|<strong>[att|=val]</strong>|表示定义了att属性且值在以连字符（-）分隔的列表中以val开头或就是val|<br>|<strong>[att^=val]</strong>|表示定义了att属性且值以val开头的元素,如果val为空字符串，则不代表任何元素|<br>|<strong>[att$=val]</strong>|表示定义了att属性且值以val结尾的元素,如果val为空字符串，则不代表任何元素|<br>|*<em>[att</em>=val]**|表示定义了att属性且值含有val的元素,如果val为空字符串，则不代表任何元素|</p><p>属性选择器中的属性名是一个CSS限定名:之前声明的命名空间前缀可以被前置到属性名前，默认名称空间不适用于属性，因此没有名称空间组件的属性选择器只适用于没有名称空间的属性(相当于“|attr”)。如果命名空间前缀没有提前声明，此属性选择器是无效的</p><p>CSS examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> foo <span class="string">&quot;http://www.example.com&quot;</span>;</span><br><span class="line"><span class="selector-attr">[foo|att=val]</span>&#123;<span class="attribute">color</span>:blue&#125;<span class="comment">/* 匹配定义的att属性在&quot;http://www.example.</span></span><br><span class="line"><span class="comment">com&quot;命名空间值中，且其值为val的元素 */</span></span><br><span class="line"><span class="selector-attr">[*|att]</span> &#123;<span class="attribute">color</span>: yellow&#125;<span class="comment">/* 只匹配定义了att属性的元素 */</span></span><br><span class="line"><span class="selector-attr">[|att]</span> &#123;<span class="attribute">color</span>: green&#125;<span class="comment">/* 匹配属性没有命名空间的元素 */</span></span><br><span class="line"><span class="selector-attr">[att]</span> &#123;<span class="attribute">color</span>: green&#125;<span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><h3 id="6-1-DTD文档中属性默认值"><a href="#6-1-DTD文档中属性默认值" class="headerlink" title="6.1 DTD文档中属性默认值"></a>6.1 DTD文档中属性默认值</h3><p>在某些文档格式中，默认属性值可以在DTD或其他地方定义，如果他们存在于文档树中，只能被属性选择器选中。</p><p>例如，XML UA需要在文档的“内部子集”中查找默认属性值。根据UA的不同，在DTD的外部子集中定义的默认属性值可能会也可能不会出现在文档树中。</p><p>Example:</p><p>一个定义了radix属性，且默认属性值为”decimal”的EXAMPLE元素，DTD片段如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ATTLIST <span class="meta-keyword">EXAMPLE</span> <span class="meta-keyword">radix</span> (<span class="meta-keyword">decimal</span>,<span class="meta-keyword">octal</span>) <span class="meta-string">&quot;decimal&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果样式表包含规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">EXAMPLE</span><span class="selector-attr">[radix=decimal]</span> &#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span><br><span class="line"><span class="selector-tag">EXAMPLE</span><span class="selector-attr">[radix=octal]</span>   &#123; <span class="comment">/*... other settings...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>第一条规则可能不会匹配radix属性为默认值的元素，也就是没有被明确设置。为了应对所有情形，对默认属性的属性选择器必须被取消掉：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">EXAMPLE</span>                &#123; <span class="comment">/*... default property settings ...*/</span> &#125;</span><br><span class="line"><span class="selector-tag">EXAMPLE</span><span class="selector-attr">[radix=octal]</span>   &#123; <span class="comment">/*... other settings...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>这里，因为选择器EXAMPLE[radix=octal]更加具体，第二条规则的样式声明会覆盖第一条规则。注意所有针对默认情况的属性声明都会被非默认情况下的样式规则覆盖。</p><h2 id="7-类选择器"><a href="#7-类选择器" class="headerlink" title="7 类选择器"></a>7 类选择器</h2><p>类选择器允许以一种独立于文档元素的方式来指定样式。通过，可以代替“~=”  符号来表示，    该属性值必须紧跟在“.”符号后面。</p><p>CSS examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-class">.pastoral</span> &#123; <span class="attribute">color</span>: green  &#125;<span class="comment">/* all elements with class~=pastoral */</span></span><br><span class="line"><span class="selector-class">.pastoral</span> &#123; <span class="attribute">color</span>: green &#125;  <span class="comment">/* all elements with class~=pastoral */</span></span><br><span class="line"><span class="selector-tag">H1</span><span class="selector-class">.pastoral</span> &#123; <span class="attribute">color</span>: green &#125;  <span class="comment">/* H1 elements with class~=pastoral */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.pastoral</span><span class="selector-class">.marine</span> &#123; <span class="attribute">color</span>: green &#125; <span class="selector-tag">l</span><span class="comment">/* class属性值同时有pastoral和marine且以空格隔开 */</span></span><br></pre></td></tr></table></figure><h2 id="8-ID选择器"><a href="#8-ID选择器" class="headerlink" title="8 ID选择器"></a>8 ID选择器</h2><p>ID选择器表示具有与ID选择器中的标识符匹配的标识符的元素实例。选择器不会指定UA如何知道元素的ID类型属性。ID属性在同一文档中是唯一的</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-id">#chapter1</span> <span class="comment">/* 表示一个h1元素，其ID类型属性值为“chapter1” */</span></span><br><span class="line"><span class="selector-id">#chapter1</span> <span class="comment">/* 表示ID类型属性值为“chapter1”的任何元素 */</span></span><br><span class="line">*<span class="selector-id">#z98y</span> <span class="comment">/* 表示其ID类型属性值为“z98y”的任何元 */</span></span><br></pre></td></tr></table></figure><h2 id="9-伪类"><a href="#9-伪类" class="headerlink" title="9 伪类"></a>9 伪类</h2><p>伪类的概念被引入以允许选择位于该文档树以外或者使用其他简单选择器不能表达的信息。</p><p>伪类允许出现在选择器中的所有简单选择器序列中。伪类可以出现在简单选择器序列的任何地方。伪类的名字是不区分大小写的。一些伪类是互相排斥的，伪类可能是动态的，当用户操作文档时一个元素可能获得或失去一个伪类。</p><h3 id="9-1-动态伪类"><a href="#9-1-动态伪类" class="headerlink" title="9.1 动态伪类"></a>9.1 动态伪类</h3><p>动态伪类根据元素特征分类，不同于他们的名称、属性和内容，原则上特征不能从文档树得出，动态伪类不会出现在文档源或文档树中。</p><h4 id="9-1-1-链接伪类-link-和-visited"><a href="#9-1-1-链接伪类-link-和-visited" class="headerlink" title="9.1.1 链接伪类*:link 和:visited*"></a>9.1.1 链接伪类*:link 和:visited*</h4><p>用户代理一般将已访问过的链接和未访问的链接分开表示。选择器提供伪类:link 和 :visited来区分他们。</p><p><strong>:link</strong>伪类表示还没有访问过的链接</p><p><strong>:visited</strong>伪类表示已经访问过的链接</p><p>经过一定的时间，用户代理可能选择返回一个访问过的链接为:link状态。这两种状态是互斥的 。</p><p>这可能让样式表开发者在未经用户同意的情况下探测用户已经访问过哪些网站。UA可能因此将所有链接设置为未访问，或实现其他策略去避免用户隐私泄露。</p><h4 id="9-1-2-用户动作伪类-hover-active-focus"><a href="#9-1-2-用户动作伪类-hover-active-focus" class="headerlink" title="9.1.2 用户动作伪类 :hover, :active,:focus"></a>9.1.2 用户动作伪类 :hover, :active,:focus</h4><p>交互性用户代理时有会改变渲染以响应用户操作。选择器提供三个伪类来响应用户操作。</p><p><strong>:hover伪类</strong>：当用户通过指针设备指定一个元素，但不一定激活它。例如，当光标（鼠标指针）停在元素上方时可视化用户代理可以激活这个伪类。不支持交互式媒体的用户代理不必支持这个伪类。</p><p><strong>:active伪类</strong>：用户激活元素时激活这个伪类。例如用户在元素上单击鼠标。</p><p><strong>:focus伪类</strong>：当元素获取焦点时这个伪类被激活（从键盘或鼠标或其他设备获取输入）。</p><p>文档语言或特殊实现会限制某些元素能够捕获:active或:focus。这些伪类不是互相排斥的。一个元素可能同时匹配到多个伪类。</p><p>当一个元素处于:active或:hover时，选择器没有定义其父元素是否也处于同样的状态。如果一个元素处于:hover作用是因为它的子元素被指针设备所指向，这时这个父元素可能并没有被指针元素所指向。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>    <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> <span class="comment">/* 已访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>   <span class="comment">/* 用户悬停 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>  <span class="comment">/* 活动中的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>   <span class="comment">/* 获取焦点 */</span> </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:hover</span> <span class="comment">/* 动态伪类的组合 */</span></span><br><span class="line"><span class="comment">/* 一个元素可以同时处在:visited和:active（或 :link 和 :active) */</span></span><br></pre></td></tr></table></figure><h3 id="9-2-目标伪类-target"><a href="#9-2-目标伪类-target" class="headerlink" title="9.2 目标伪类:target"></a>9.2 目标伪类:target</h3><p>有些URI引用一个资源中的一个地址。这类URI以井号（#）结束并跟着一个锚标识符（被称作片段标识符 fragment identifier）。</p><p>具有片段标识符的URI链接到文档内的某一个元素，就是目标元素。例如这个URI指向HTML文档内叫做section_2的锚点：<a href="http://example.com/html/top.html#section_2">http://example.com/html/top.html#section_2</a></p><p>一个目标元素可以被:target伪类表示。如果文档的URI没有片段标识符，那么文档不存在目标元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.note</span><span class="selector-pseudo">:target</span> <span class="comment">/* 一个做为文档目标元素且class为note的p元素 */</span></span><br><span class="line"><span class="comment">/* 下面，:target伪类用来将目标元素变成红色并且在它之前放置一个图像： */</span></span><br><span class="line">*<span class="selector-pseudo">:target</span> &#123; <span class="attribute">color </span>: red &#125;</span><br><span class="line">*<span class="selector-pseudo">:target</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content </span>: <span class="built_in">url</span>(target.png) &#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-语言伪类-lang"><a href="#9-3-语言伪类-lang" class="headerlink" title="9.3 语言伪类:lang"></a>9.3 语言伪类:lang</h3><p>如果文档语言描述了如何确定一个元素的自然语言，那么将有可能实现一个表示特定语言的元素的选择器。例如，在HTML中语言可以被lang属性和meta元素中的可能存在的一些信息组合表示或在协议中（例如HTTP头部）表示。XML使用叫做xml:lang的属性，并且其他文档语言可能使用其他方法来确定语言。</p><p>伪类**:lang(C)**表示一个使用语言C的元素。无论元素的语言值等于C，或是以C开头跟随“ - ”都将被匹配。    对C和元素语言值的匹配是不区分大小写的。C不必是一个有效的语言名。</p><p>C必须是一个有效的CSS标识符并且不可以为空，否则，选择器是无效的。</p><p>Examples:</p><p>前两个选择器表示一个应用Belgian French 或 German语言的HTML文档。后两个选择器表示任意Belgian French 或 German语言元素中的q元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html:lang(fr-be)</span><br><span class="line">html:lang(de)</span><br><span class="line">:lang(fr-be) &gt; q</span><br><span class="line">:lang(de) &gt; </span><br></pre></td></tr></table></figure><p>:lang(C)与 |= 操作符的区别在于： |= 操作符仅仅表示对元素指定属性的比较，而:lang(C)伪类使用UA的知识在文档语义上进行比较。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*仅仅body匹配[lang|=fr]（因为它具有LANG属性）但是body和P都匹配:lang(fr)（因为他们都使用法语）。P不匹配[lang|=fr]因为它没有LANG属性：*/</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">lang</span>=<span class="string">fr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Je suis français.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-4-UI元素状态伪类"><a href="#9-4-UI元素状态伪类" class="headerlink" title="9.4 UI元素状态伪类"></a>9.4 UI元素状态伪类</h3><h4 id="9-4-1-enabled和-disabled伪类"><a href="#9-4-1-enabled和-disabled伪类" class="headerlink" title="9.4.1 :enabled和:disabled伪类"></a>9.4.1 :enabled和:disabled伪类</h4><p><strong>:enabled</strong>伪类表示处在可用状态下的用户接口元素。这些元素具有与不可用相对的状态。</p><p>:<strong>disabled</strong>伪类表示用户接口元素在不可用状态。这些元素具有与可用相对的状态。</p><p>用户接口元素、可用与不可用的状态是依赖于语言的。在一个典型的文档中大多数元素既不是:enabled也不是:disabled的。（常用于input、textarea）</p><p>CSS中可能影响用户与UI元素交互的属性不会影响:enabled或:disabled的匹配。例如display和visibility属性不会影响元素的enabled/disabled状态。</p><h4 id="9-4-2-checked伪类"><a href="#9-4-2-checked伪类" class="headerlink" title="9.4.2 :checked伪类"></a>9.4.2 :checked伪类</h4><p>单选和多选元素可以被用户开关。一些菜单项目在用户选择他们时会处在选中状态。例如:checked伪类最初匹配HTML4中具有selected和checked的元素。:checked伪类本质上是动态的，他们随着用户操作而改，。因为它可以以文档中存在的语义属性作为依据，所以它可以匹配所有的媒体。用户可以关闭(toggle “off”)这些元素，这将使:checked伪类不再匹配。（常用于    checkbox    、radio、option ）</p><h4 id="9-4-3-indeterminate伪类"><a href="#9-4-3-indeterminate伪类" class="headerlink" title="9.4.3 :indeterminate伪类"></a>9.4.3 :indeterminate伪类</h4><p>单选和多选元素可以被用户开关，但一些时候它们处在不确定状态，既不是选中也不是非选中。元素属性和DOM操作可能导致这种情况。</p><h3 id="9-5-结构伪类"><a href="#9-5-结构伪类" class="headerlink" title="9.5 结构伪类"></a>9.5 结构伪类</h3><p>选择器通过结构化伪类的概念来进行基于文档中额外信息的不能被其他简单选择器或组合器表示的匹配。</p><p>在计算元素位于其父元素的子元素列表中的位置时，独立的文字或其他非元素节点是不被计算的且索引是从1开始的。</p><h4 id="9-5-1-root伪类"><a href="#9-5-1-root伪类" class="headerlink" title="9.5.1 :root伪类"></a>9.5.1 :root伪类</h4><p>:root伪类表示作为文档根的元素。在HTML 4中总是HTML元素。</p><h4 id="9-5-2-nth-child-伪类"><a href="#9-5-2-nth-child-伪类" class="headerlink" title="9.5.2 :nth-child()伪类"></a>9.5.2 :nth-child()伪类</h4><p>:nth-child(an+b)伪类表示一个元素它在文档树中有an+b-1个前兄弟节点，n可以为任何正数或0，并且有一个父元素。a和b要大于0。这有效的将子元素按a个元素进行分组（最后一组包含余数个元素），并且选择每一组的第b个元素。a和b必须为整数（正数，负数或0）。第一个子元素的索引是1。</p><p>:nth-child()可以用odd和even作为参数。odd相当于2n+1，even相当于2n。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n+1)</span> <span class="comment">/* 表示HTML中table的奇数行 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(odd)</span>  <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n+0)</span> <span class="comment">/* 表示HTML中table的偶数行 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(even)</span> <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="comment">/* 通过CSS修改段落颜色 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+1)</span> &#123; <span class="attribute">color</span>: navy; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+2)</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+3)</span> &#123; <span class="attribute">color</span>: maroon; &#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(4n+4)</span> &#123; <span class="attribute">color</span>: purple; &#125;</span><br></pre></td></tr></table></figure><p>当b前面存在负号，那么正号必须被移除，也就是说被负号替代以表示b是个负数。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child(10n-1)</span>  <span class="comment">/* 表示第9，第19，第29以此类推的元素 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-child(10n+9)</span>  <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-pseudo">:nth-child(10n+-1)</span> <span class="comment">/* 无效的语法，会被忽略 */</span></span><br></pre></td></tr></table></figure><p>当a=0时ab部分应被忽略（除非b部分已经被忽略了）。当an不存在并且b是非负数，b前的正号（当存在时）可以被忽略。这类似于:nth-child(b)。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">foo</span><span class="selector-pseudo">:nth-child(0n+5)</span>   <span class="comment">/* 表示一个处在第五个的foo元素 */</span></span><br><span class="line"><span class="selector-tag">foo</span><span class="selector-pseudo">:nth-child(5)</span>      <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><p>当a=1或a=-1，这个数字可以被省略。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面的选择器等价: */</span></span><br><span class="line"><span class="selector-tag">bar</span><span class="selector-pseudo">:nth-child(1n+0)</span>   <span class="comment">/* 选择所有bar元素, 优先级 (0,1,1) */</span></span><br><span class="line"><span class="selector-tag">bar</span><span class="selector-pseudo">:nth-child(n+0)</span>    <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-tag">bar</span><span class="selector-pseudo">:nth-child(n)</span>      <span class="comment">/* 同上 */</span></span><br><span class="line"><span class="selector-tag">bar</span>                   <span class="comment">/* 同上，但是优先级更低 (0,0,1) */</span></span><br></pre></td></tr></table></figure><p>如果b=0，那么每一个第a个元素被选取。这种情况下，+b(或-b)部分可能被省略除非a部分已经被省略了。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n+0)</span> <span class="comment">/* 示HTML中table的每一个偶数行 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(2n)</span> <span class="comment">/* 同上 */</span></span><br></pre></td></tr></table></figure><p>空白符被允许出现在 左括号“(” 后和右括号 “)” 前，并且当an和b同时出现时空白符可以出现在“+”或“-”的两边。</p><p>Valid Examples with white space:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child(</span> 3<span class="selector-tag">n</span> + 1 )</span><br><span class="line"><span class="selector-pseudo">:nth-child(</span> +3<span class="selector-tag">n</span> <span class="selector-tag">-</span> 2 )</span><br><span class="line"><span class="selector-pseudo">:nth-child(</span> <span class="selector-tag">-n</span>+ 6)</span><br><span class="line"><span class="selector-pseudo">:nth-child(</span> +6 )</span><br></pre></td></tr></table></figure><p>Invalid Examples with white space:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child(3</span> <span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-pseudo">:nth-child(+</span> 2<span class="selector-tag">n</span>)</span><br><span class="line"><span class="selector-pseudo">:nth-child(+</span> 2)</span><br></pre></td></tr></table></figure><p>a和b都为0时，这个伪类不表示文档树中的任何元素。</p><p>a可以是负数，但是an+b只能是正数，对于n&gt;=0，可能表示文档树中的一个元素。</p><p>Example:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html|tr:nth-child(-n+6)  /* 表示XHTML中table的前6行 */</span><br></pre></td></tr></table></figure><h4 id="9-5-3-nth-last-child-伪类"><a href="#9-5-3-nth-last-child-伪类" class="headerlink" title="9.5.3 :nth-last-child() 伪类"></a>9.5.3 :nth-last-child() 伪类</h4><p>:nth-of-type(an+b)伪类表示一个元素在文档树中在这个元素之前具有an+b-1个和此元素相同元素名的兄弟元素，n可以为任何正数或0，并且具有父元素。 参数的定义参照:nth-child()。同样可以接受odd和even作为参数。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-last-child(-n+2)</span>  <span class="comment">/* 表示HTML中table的最后2行 */</span></span><br><span class="line"><span class="selector-tag">foo</span><span class="selector-pseudo">:nth-last-child(odd)</span>  <span class="comment">/* 表示父元素中的所有奇数元素，从后往前计算 */</span></span><br></pre></td></tr></table></figure><h4 id="9-5-4-nth-of-type-伪类"><a href="#9-5-4-nth-of-type-伪类" class="headerlink" title="9.5.4 :nth-of-type() 伪类"></a>9.5.4 :nth-of-type() 伪类</h4><p>:nth-of-type(an+b)伪类表示一个元素在文档树中在这个元素之前具有an+b-1个和此元素相同元素名的兄弟元素，n可以为任何正数或0，并且具有父元素。 参数的定义参照:nth-child()。同样可以接受odd和even作为参数。</p><p>CSS example:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:nth-of-type(2n+1)</span> &#123; <span class="attribute">float</span>: right; &#125;</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:nth-of-type(2n)</span> &#123; <span class="attribute">float</span>: left; &#125;</span><br></pre></td></tr></table></figure><h4 id="9-5-5-nth-last-of-type-伪类"><a href="#9-5-5-nth-last-of-type-伪类" class="headerlink" title="9.5.5 :nth-last-of-type()伪类"></a>9.5.5 :nth-last-of-type()伪类</h4><p>:nth-last-of-type(an+b)伪类表示一个元素在文档树中在这个元素之后具有an+b-1个和此元素相同元素名的兄弟元素，n可以为任何正数或0，并且具有父元素。 参数的定义参照:nth-child()。同样可以接受odd和even作为参数。</p><p>Example:</p><p>表示body中所有h2元素，除了第一个和最后一个</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">h2</span><span class="selector-pseudo">:nth-of-type(n+2)</span><span class="selector-pseudo">:nth-last-of-type(n+2)</span></span><br></pre></td></tr></table></figure><p>在这个示例中，用样可以使用:not(),虽然选择器是一样长的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &gt; <span class="selector-tag">h2</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:first-of-type)</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-of-type)</span></span><br></pre></td></tr></table></figure><h4 id="9-5-6-first-child伪类"><a href="#9-5-6-first-child伪类" class="headerlink" title="9.5.6 :first-child伪类"></a>9.5.6 :first-child伪类</h4><p>与:nth-child(1)相同。:first-child表示第一个子元素。</p><p>Examples:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span><span class="comment">/*表示div元素中的p元素，且这个p元素是第一个子元素 */</span></span><br></pre></td></tr></table></figure><p>这个选择器表示下面片段中div中的p元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">last</span> <span class="selector-tag">P</span> <span class="selector-tag">before</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;div class=&quot;note&quot;&gt;</span><br><span class="line">   &lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">first</span> <span class="selector-tag">P</span> <span class="selector-tag">inside</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>但是不表示下面片段中的第二个p元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">last</span> <span class="selector-tag">P</span> <span class="selector-tag">before</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;div class=&quot;note&quot;&gt;</span><br><span class="line">   &lt;<span class="selector-tag">h2</span>&gt; <span class="selector-tag">Note</span> &lt;/<span class="selector-tag">h2</span>&gt;</span><br><span class="line">   &lt;<span class="selector-tag">p</span>&gt; <span class="selector-tag">The</span> <span class="selector-tag">first</span> <span class="selector-tag">P</span> <span class="selector-tag">inside</span> <span class="selector-tag">the</span> <span class="selector-tag">note</span>.&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>下面的两个选择器一般是等价的:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:first-child</span> <span class="comment">/* a是任何元素的第一个子元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:first-child</span> <span class="comment">/* 当a不是根元素时同上 */</span></span><br></pre></td></tr></table></figure><h4 id="9-5-7-last-child伪类"><a href="#9-5-7-last-child伪类" class="headerlink" title="9.5.7 :last-child伪类"></a>9.5.7 :last-child伪类</h4><p>同:nth-last-child(1)。:last-child表示一个元素中的最后一个子元素。</p><p>Example:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> <span class="comment">/* 表示一个有序列表ol中的最后一个条目li */</span> </span><br></pre></td></tr></table></figure><h4 id="9-5-8-first-of-type-伪类"><a href="#9-5-8-first-of-type-伪类" class="headerlink" title="9.5.8 :first-of-type 伪类"></a>9.5.8 :first-of-type 伪类</h4><p>同:nth-of-type(1)。:first-of-type伪类表示具有相同元素类型的兄弟节点中的第一个节点。</p><p>Example:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示一个在列表dl中的标题dt，这个dt是与它相同类型的兄弟节点中的第一个节点： */</span></span><br><span class="line"><span class="selector-tag">dl</span> <span class="selector-tag">dt</span><span class="selector-pseudo">:first-of-type</span></span><br></pre></td></tr></table></figure><p>这表示了下面的头两个dt元素，但不能表示第三个dt元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dt</span>&gt;</span>gigogne<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>fusée<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>multistage rocket<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>table<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>   /* 不能被表示到 */</span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>nest of tables<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-5-9-last-of-type"><a href="#9-5-9-last-of-type" class="headerlink" title="9.5.9 :last-of-type"></a>9.5.9 :last-of-type</h4><p>同:nth-last-of-type(1)。:last-of-type伪类表示具有相同元素类型的兄弟节点中的最后一个节点。</p><p>Example:</p><p>下面的选择器表示table行tr中的最后一个数据单元td：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tr</span> &gt; <span class="selector-tag">td</span><span class="selector-pseudo">:last-of-type</span></span><br></pre></td></tr></table></figure><h4 id="9-5-10-only-child伪类"><a href="#9-5-10-only-child伪类" class="headerlink" title="9.5.10 :only-child伪类"></a>9.5.10 :only-child伪类</h4><p>表示某个是其父元素中的唯一元素的元素。同:first-child:last-child 或 :nth-child(1):nth-last-child(1), 但是具有更低的优先级。</p><h4 id="9-5-11-only-of-type伪类"><a href="#9-5-11-only-of-type伪类" class="headerlink" title="9.5.11 :only-of-type伪类"></a>9.5.11 :only-of-type伪类</h4><p>表示某个父元素中子元素，父元素不存在与此子元素同类的子元素。同:first-of-type:last-of-type 或 :nth-of-type(1):nth-last-of-type(1)，但是具有更低的优先级。</p><h4 id="9-5-12-empty伪类"><a href="#9-5-12-empty伪类" class="headerlink" title="9.5.12 :empty伪类"></a>9.5.12 :empty伪类</h4><p>:empty伪类表示一个元素根本没有子元素。在文档树中，仅仅元素节点和内容节点具有非0长度的数据时，会影响是否为空。注释，处理指令和其他节点不会产生影响。</p><p>Examples:</p><p>p:empty 对下面的片段是有效的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foo:empty 对下面的片段是无效的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="tag">&lt;<span class="name">bar</span>&gt;</span>bla<span class="tag">&lt;/<span class="name">bar</span>&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>this is not <span class="tag">&lt;<span class="name">bar</span>&gt;</span>:empty<span class="tag">&lt;/<span class="name">bar</span>&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-6-空白"><a href="#9-6-空白" class="headerlink" title="9.6 空白"></a>9.6 空白</h3><p>这一节是故意留白的，之前是:contains()伪类。</p><h3 id="9-7-否定伪类"><a href="#9-7-否定伪类" class="headerlink" title="9.7 否定伪类"></a>9.7 否定伪类</h3><p>否定伪类:not(X)是一个将简单选择器作为参数的功能符。它表示不是它的参数所表示的元素。</p><p>否定伪类不可嵌套，:not(:not(…))是无效的。注意因为伪元素不是简单选择器，所以他们不可以作为:not()的参数。</p><p>Examples:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[DISABLED]</span>) <span class="comment">/* 表示不是disabled状态以外的所有button */</span></span><br><span class="line">*<span class="selector-pseudo">:not(FOO)</span><span class="comment">/* 表示不是FOO元素以外的所有元素 */</span></span><br><span class="line">html|*:not(:link):not(:visited) /* 表示除了链接以外所有HTML元素 */</span><br></pre></td></tr></table></figure><p>默认命名空间声明不会影响否定伪类的参数，除非参数是个全局选择器或一个类型选择器。<br>Examples:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果默认命名空间是&quot;http://example.com/&quot;，下面的选择器表示所有不在这个命名空间中的元素 */</span></span><br><span class="line">*|*:not(*)</span><br><span class="line"><span class="comment">/* 下面的选择器匹配任何没有被指向的元素，不管它的命名空间是什么 */</span></span><br><span class="line">*|*:not(:hover)</span><br></pre></td></tr></table></figure><p>:not()伪类允许表示没有价值的选择器，例如:not(<em>|</em>)，这不表示任何元素，或者foo:not(bar)，这等价于foo但是具有更高优先级。</p><h2 id="10-伪元素"><a href="#10-伪元素" class="headerlink" title="10 伪元素"></a>10 伪元素</h2><p>伪元素创建超越文档语言定义的文档树的抽象概念。伪元素允许开发者访问这些原本难以访问的信息，以及访问源文档中不存在内容。</p><p>伪元素由两个冒号::及紧跟伪元素的名字组成。 为了兼容性，单冒号也被允许。伪元素必须在简单选择器序列的最后。</p><h3 id="10-1-first-line伪元素"><a href="#10-1-first-line伪元素" class="headerlink" title="10.1 ::first-line伪元素"></a>10.1 ::first-line伪元素</h3><p><strong>::first-line</strong>伪元素表示元素中的第一个格式化行 .</p><p>选择器P::first-line不匹配任何真正的文档元素。用户代理会添加虚拟标签序列（fictional tag sequence）到文档中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P&gt;&lt;P::first-line&gt; This is a somewhat long HTML paragraph that &lt;&#x2F;P::first-line&gt; will be broken into several lines. The first line will be identified by a fictional tag sequence.&lt;&#x2F;P&gt;</span><br></pre></td></tr></table></figure><h4 id="10-1-1-CSS中定义的第一个格式化行"><a href="#10-1-1-CSS中定义的第一个格式化行" class="headerlink" title="10.1.1 CSS中定义的第一个格式化行"></a>10.1.1 CSS中定义的第一个格式化行</h4><p>在CSS中，::first-line伪元素在块容器时才有效。元素的第一个格式化行可能出现在块级后代中。例如，<DIV><P>This line…</P></DIV>中DIV的第一行就是P的第一行（假定P和DIV都是块级）。</p><p>table-cell或 inline-block不能作为祖先元素的第一个格式化行。因此，<DIV><P STYLE="display: inline-block">Hello<BR>Goodbye</P> etcetera</DIV>中DIV的第一个格式化行不是“Hello”，而是 etcetera。</p><p>在片段<p><br>First…中p的第一个格式化行不包含任何字母（假定使用HTML4中br的默认样式），因为由br的存在。</p><p>UA应该将::first-line的虚拟开始标签嵌套于最内部的闭合块级元素中。 （只是应该而已，因为css1和css2没有要求）</p><p>例如，下面段落</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">  &lt;P&gt;First paragraph&lt;&#x2F;P&gt;</span><br><span class="line">  &lt;P&gt;Second paragraph&lt;&#x2F;P&gt;</span><br><span class="line">&lt;&#x2F;DIV&gt;</span><br></pre></td></tr></table></figure><p>虚拟标签序列是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">  &lt;P&gt;&lt;DIV::first-line&gt;&lt;P::first-line&gt;First paragraph&lt;&#x2F;P::first-line&gt;&lt;&#x2F;DIV::first-line&gt;&lt;&#x2F;P&gt;</span><br><span class="line">  &lt;P&gt;&lt;P::first-line&gt;Second paragraph&lt;&#x2F;P::first-line&gt;&lt;&#x2F;P&gt;</span><br><span class="line">&lt;&#x2F;DIV&gt;</span><br></pre></td></tr></table></figure><p>::first-line伪元素类似于一个 inline-level元素，但是具有一些约束。下面的CSS属性可以作用于一个::first-line伪元素：字体属性，颜色属性，背景属性，word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, line-height。UA可能实现其他属性。<br>在CSS继承中，出现在第一行的子元素的某些部分仅从::first-line伪元素继承适用于::first-line伪元素的属性。其他属性继承于第一行伪元素的非伪元素父元素。（子元素的不出现在第一行的部分总是继承于父元素）。这里太绕了。。。</p><h3 id="10-2-first-letter伪元素"><a href="#10-2-first-letter伪元素" class="headerlink" title="10.2 :first-letter伪元素"></a>10.2 :first-letter伪元素</h3><p>::first-letter伪元素，如果在这行上它前面没有任何其他内容（例如图片和 inline tables），表示元素的第一个字母，::first-letter伪元素通常被用于开头字母大写和首字下沉这些通用的印刷效果。</p><p>如果标点符号出现在在首字母之前或之后也应该被包括进去，数字也同样生效。</p><p>如果组成::first-letter的字母不在一个元素中，例如<p>‘<em>T…中的“’T”，UA可能为其中一个或两个字母创建::first-letter伪元素，或都不创建。</p><p>首字母必须出现在第一个格式化行上。例如，在<p><br>First…第一行不包含任何字母并且::first-letter不匹配任何东西。</p><h4 id="10-2-1-CSS中的应用"><a href="#10-2-1-CSS中的应用" class="headerlink" title="10.2.1 CSS中的应用"></a>10.2.1 CSS中的应用</h4><p>在CSS中，::first-letter伪元素在 block-like 容器中生效，例如block，list-item，table-cell，table-caption和inline-block元素。</p><p>在CSS中t，able-cell或inline-block的第一个字母不能作为祖先元素的第一个字母。</p><p>如果元素是list item (‘display: list-item’), ::first-letter 应用在主体盒子标记后的第一个字母。    用户代理将忽略该列表项的    ::first-letter。如果元素有::b=efore和::after内容，::first-letter应用的时候应该包含它们的内容。比如，在p::before {content: “Note: “}生效时， p::first-letter 匹配“Note”中的“N”。</p><p>在CSS中,当float属性是none时::first-line伪元素相当于一个inline-level元素 ,否则它是浮动元素。</p><h3 id="10-3-before-和-after伪类"><a href="#10-3-before-和-after伪类" class="headerlink" title="10.3 ::before 和 ::after伪类"></a>10.3 ::before 和 ::after伪类</h3><p><strong>::before</strong>和**::after**伪类用来描述在元素内容之前或之后生成内容。</p><p>当::first-letter和::first-line被用在包含::before或::after生成元素的对象时，第一个字母或第一行包含这些生成内容。</p><h2 id="11-组合器"><a href="#11-组合器" class="headerlink" title="11 组合器"></a>11 组合器</h2><h3 id="11-1-后代组合器"><a href="#11-1-后代组合器" class="headerlink" title="11.1 后代组合器"></a>11.1 后代组合器</h3><p>选择器“A B”表示一个元素B是祖先A的任意后代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div * p</span><br></pre></td></tr></table></figure><p>表示了p元素是div元素之后的第二代或更多代元素。*两侧的空白符不属于全局选择器。空白符是一个组合器表示div是某个元素的祖先，并且这个元素是p的祖先。<br>表示一个元素具有href属性并且是p的后代，p在div之中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div p *[href]</span><br></pre></td></tr></table></figure><h3 id="11-2-子代组合器"><a href="#11-2-子代组合器" class="headerlink" title="11.2 子代组合器"></a>11.2 子代组合器</h3><p>子代组合器描述了两个元素间的父子关系。</p><h3 id="11-3-兄弟选择器"><a href="#11-3-兄弟选择器" class="headerlink" title="11.3 兄弟选择器"></a>11.3 兄弟选择器</h3><p>有两个兄弟组合器：next-sibling combinator和subsequent-sibling combinator。他们都会忽略非元素节点（例如元素间的文字）。</p><h4 id="11-4-相邻兄弟组合器"><a href="#11-4-相邻兄弟组合器" class="headerlink" title="11.4 相邻兄弟组合器"></a>11.4 相邻兄弟组合器</h4><p>相邻兄弟组合器用“+”表示，它分割两个简单选择器序列。在文档树中这两个序列具有相同的父节点并且第一个序列表示的元素紧紧在第二个序列表示的元素前。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">math</span> + <span class="selector-tag">p</span>  <span class="comment">/* 表示跟在一个math元素后的p元素 */</span></span><br></pre></td></tr></table></figure><h4 id="11-5-一般兄弟选择器"><a href="#11-5-一般兄弟选择器" class="headerlink" title="11.5 一般兄弟选择器"></a>11.5 一般兄弟选择器</h4><p>一般兄弟选择器通过“~”表示，它分割两个简单选择器序列。两个序列表示的元素要在同一个父元素下并且第一个序列表示的元素要在第二个序列表示的元素前（但不必是紧紧挨着）。</p><h2 id="12-选择器优先级计算"><a href="#12-选择器优先级计算" class="headerlink" title="12 选择器优先级计算"></a>12 选择器优先级计算</h2><p>规则如下：</p><pre><code>    1. ID选择器的数量 (= a)    2. 类选择器、属性选择器和伪类的数量 (= b)    3. 类型选择器和伪元素的数量(= c)</code></pre><p>忽略通用选择器，否定伪类参与计算，但不当做伪类计算。把三个数字连起来a-b-c（在具有大基数的数字系统中）作为优先级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;**CSS(层叠样式表)**是一个描述HTML和XML文档在屏幕等上呈现的语言。CSS使用选择器将样式属性绑定到文档中的元素，选择器是与树中的元素相匹配的模式，在语法上不区分大小写，&lt;/p&gt;
&lt;h2 id=&quot;1-选择器介绍&quot;&gt;&lt;a href=&quot;#1-选择器介绍&quot; class</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="W3C CSS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/"/>
    
    <category term="Selectors Level 3" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/W3C-CSS/Selectors-Level-3/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="W3C" scheme="http://example.com/tags/W3C/"/>
    
  </entry>
  
  <entry>
    <title>20-重定向与负载均衡</title>
    <link href="http://example.com/2021/03/05/note/HTTP/20-%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2021/03/05/note/HTTP/20-%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2021-03-05T04:04:27.183Z</published>
    <updated>2021-03-08T03:03:37.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20-1-为什么要重定向"><a href="#20-1-为什么要重定向" class="headerlink" title="20.1 为什么要重定向"></a>20.1 为什么要重定向</h2><p>由于HTTP应用程序需要可靠地执行HTTP事务、最小化时延、节约网络带宽，Web内容通常分布在很多地方。可以将重定向当作一组有助于找到“最佳”分布式内容的技术。</p><p>多数重定向部署都包含了某些形式的负载均衡。也就是它们可以将输入报文的负载分摊到一组服务器中去。反之，因为输入报文一定会在分担负荷的服务器之间进行某种分布，所以任意形式的负载均衡中都包含了重定向。</p><h2 id="20-2-重定向到何地"><a href="#20-2-重定向到何地" class="headerlink" title="20.2 重定向到何地"></a>20.2 重定向到何地</h2><p>从很多重定向技术都可用于服务器、代理、缓存和网关。一些重定向技术是专门为特定类型的端点设计的，没有通用性。</p><p>Web服务器会根据每个IP来处理请求，把对某特定URL的每条请求都发送到最佳的Web服务器上去（最靠近客户端的、或负载最轻的或采用其他优化策略选择的服务器）。</p><h2 id="20-3-重定向协议概览"><a href="#20-3-重定向协议概览" class="headerlink" title="20.3 重定向协议概览"></a>20.3 重定向协议概览</h2><p>重定向的目标是尽快地将HTTP报文发送到最佳的Web服务器上去。HTTP报文传输的方向会受到HTTP应用程序和报文经由的路由设备的影响，浏览器配置、DNS，TCP/P路由以及HTTP都提供了重定向报文的机制。比如。</p><ol><li>配置创建客户端报文的浏览器应用程序，使其将报文发送给代理服务器。</li><li>DNS解析程序会选择用于报文寻址的IP地址。</li><li>报文经过网络传输时，会被划分为一些带有地址的分组，交换机和路由器会检查分组中的TCP/IP地址，并据此来确定分组的发送路线。</li><li>Web服务器可以通过HTTP重定向将请求反弹给不同的Web服务器。</li></ol><p>20.4 通用的重定向方法</p><h3 id="20-4-1-HTTP重定向"><a href="#20-4-1-HTTP重定向" class="headerlink" title="20.4.1 HTTP重定向"></a>20.4.1 HTTP重定向</h3><p>处理重定向的服务器（重定向服务器）找到可用的负载最小的内容服务器，并将浏览器重定向到那台服务器上去。HTTP重定向的优点之一就是重定向服务器知道客户端的IP地址；理论上来讲，它可以做出更合理的选择。</p><p>HTTP重定向可以在服务器间导引请求，但它有以下几个缺点。</p><ol><li>需要原始服务器进行大量处理来判断要重定向到哪台服务器上去。</li><li>增加了用户时延，因为访问页面时要进行两次往返。</li><li>如果重定向服务器出故障，站点就会瘫痪。</li></ol><p>由于存在这些弱点，HTTP重定向通常都会与其他一种或多种重定向技术结合使用。</p><h3 id="20-4-2-DNS重定向"><a href="#20-4-2-DNS重定向" class="headerlink" title="20.4.2 DNS重定向"></a>20.4.2 DNS重定向</h3><p>DNS允许将几个IP地址关联到一个域中，可以配置DNS解析程序，以返回可变的IP地址。</p><p><strong>DNS轮转</strong>:DNS服务器都会在每次完成查询之后对地址进行轮转。由于大多数DNS客户端只会使用多地址集中的第一个地址，所以DNS轮转可以在多台服务器间提供负载均衡。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/Al9KaUwCZBNSx7G.png"                      alt="image.png"                ></p><p>DNS局限性：没有考虑任何与客户端和服务器的相对位置，或者服务器当前负载有关的因素。其次很多Web浏览器或操作系统都会进行DNS缓存，以减少DNS查找的开销。DNS轮转通常都不会平衡单个客户端的负载。</p><p>因此有些增强的DNS服务器会使用其他一些技术来选择地址的顺序。</p><ol><li><strong>负载均衡算法。</strong>使DNS服务器跟踪服务器上的负载，将最佳Web服务器放在列表最前面。</li><li><strong>邻接路由算法。</strong>使DNS服务器尝试着将用户导向最近的服务器。</li><li><strong>故障屏蔽算法。</strong>使DNS服务器监视网络状况，将请求绕过出现服务中断或其他故障的地方。</li></ol><p>通常，运行复杂服务器跟踪算法的DNS服务器就是在内容提供者控制之下的一个权威服务器。</p><p>但是，对于那些要查找附近服务器的服务来说，缺点就是权威DNS服务器只能用本地DNS服务器的IP地址决定，而非客户端的IP地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/2Il5cpGM38WotJH.png"                      alt="image _1_.png"                ></p><h3 id="20-4-3-任播寻址"><a href="#20-4-3-任播寻址" class="headerlink" title="20.4.3 任播寻址"></a>20.4.3 任播寻址</h3><p>在任播寻址中，几个地理上分散的服务器拥有完全相同的IP地址，而且会通过骨干路由器的“最短路径”路由功能将客户端的请求发送给离它最近的服务器。这种方法需要，每台服务器都要向邻近的骨干路由器广告，服务器会通过路由器通信协议与其邻近的骨干路由器通信。骨干路由器收到发送给任播地址的分组时，会像平常一样寻找接受那个IP地址的最近的“路由器”。由于服务器是将自己作为那个地址的路由器广告出去的，所以骨干路由器会将分组发送给服务器。</p><p>任播寻址仍是项实验性技术。要使用分布式任播技术，服务器须使用“路由器语言”，且路由器必须能够处理可能出现的地址冲突，因为因特网地址基本都是假定一台服务器只有一个地址的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/Nrh85dgCUJTPGFI.png"                      alt="image _2_.png"                ></p><h3 id="20-4-4IP-MAC转发"><a href="#20-4-4IP-MAC转发" class="headerlink" title="20.4.4IP MAC转发"></a>20.4.4IP MAC转发</h3><p>在以太网中，HTTP报文都是以携带地址的数据分组的形式发送的。每个分组有一个的MAC地址，这是第二层设备（通常是交换机和HUB）会接收具有特定输入MAC地址的分组，然后将其转发到特定的输出MAC地址上去。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/VEoGWqiDmRNaLZB.png"                      alt="image _3_.png"                ></p><p>通常，如果缓存中没有请求需要的HTTP内容，代理缓存就会代表客户端向此内容的原始服务器发送一条HTTP请求。交换机会将端口80的请求从代理（MAC6）发送给因特网网关（MAC5）</p><p>支持MAC转发的第四层交换机通常会将请求转发给几个代理缓存，并在它们之间平衡负载。因为MAC地址转发只是点对点的，所以服务器或代理只能位于离交换机一跳远的地方。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/2TdyikbQZLY1IWJ.png"                      alt="QQ截图20210304204846.png"                ></p><h3 id="20-4-5-IP地址转发"><a href="#20-4-5-IP地址转发" class="headerlink" title="20.4.5 IP地址转发"></a>20.4.5 IP地址转发</h3><p>在IP地址转发中，交换机或其他第四层设备会检测输入分组中的TCP/IP地址，并通过修改目的IP地址，对分组进行相应的转发。与MAC转发相比，优点是目标服务器只要位于交换机的上游就行，而非一跳远的地方，而且通常第三层的端到端因特网路由都会将分组传送到正确的地方。</p><p>这种类型的转发也称为NAT（Network Address Translation，网络地址转换）。</p><p>缺点在于，因为从客户端接受输入TCP连接的交换机管理着连接，交换机必须通过那条TCP连接将响应回送给客户端。这样，所有来自目标服务器或代理的响应都必须返回给交换机。服务器或代理可能看不到真正的客户端IP地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/pyioQk2YVaBXsEc.png"                      alt="image _4_.png"                ></p><p>有以下两种方式可以控制响应的返回路径。</p><ol><li>将分组的源IP地址改成交换机的IP地址。这种方式被称为完全NAT（full NAT），其中的IP转发设备会对目的IP地址和源IP地址都进行转换。缺点是服务器不知道客户端的IP地址（当涉及到认证和计费），因为从客户端接受输入TCP连接的交换机管理着连接，交换机必须通过那条TCP连接将响应回送给客户端，所有来自目标服务器或代理的响应都必须返回给交换机。</li><li>如果源IP地址仍然是客户端的IP地址，就要确保没有从服务器到客户端的直接路由（绕过交换机的）。这种方式被称为半NAT（half NAT），这种方法的优点是服务器知道客户端的IP地址，但缺点是要对客户端和服务器之间的整个网络都有某种程度的控制。<h3 id="20-4-6-网元控制协议"><a href="#20-4-6-网元控制协议" class="headerlink" title="20.4.6 网元控制协议"></a>20.4.6 网元控制协议</h3></li></ol><p>NECP（Network Element Control Protocol，网元控制协议）允许网元（NE，路由器和交换机等负责转发IP分组的设备）与服务器元素（SE，web服务器和代理缓存等提供应用层请求的设备）进行交互。NECP并未显式提供对负载均衡的支持；它只是为SE提供了一种发送负载均衡信息给NE的方式，这样NE就可以在它认为合适的情况下进行负载均衡了。与WCCP一样，NECP也提供了几种转发分组的方式：MAC转发、GRE封装和NAT.</p><p>NECP支持例外。SE可以决定它不能为某些特定的源IP地址提供服务，并将这些地址发送给NE，然后，NE可以将来自这些IP地址的请求转发给原始服务器。</p><h2 id="20-5-代理的重定向方法"><a href="#20-5-代理的重定向方法" class="headerlink" title="20.5 代理的重定向方法"></a>20.5 代理的重定向方法</h2><p>客户端如何知道要连接到某个代理，可以用3种方法来判断：显式的浏览器配置，动态自动配置以及透明拦截。</p><h3 id="20-5-1-显式浏览器配置"><a href="#20-5-1-显式浏览器配置" class="headerlink" title="20.5.1 显式浏览器配置"></a>20.5.1 显式浏览器配置</h3><p>用户可以在大多数浏览器中输入代理的名字或IP地址以及端口号。但有些服务提供商不允许用户配置普通浏览器来使用代理，它们会要求用户下载事先配置好的浏览器。</p><p>显式浏览器配置有以下两个主要的缺点。</p><ol><li>在代理无法响应的情况下或浏览器配置代理错误，也不会去联系原始服务器。</li><li>如果代理出现网络架构方面的变动，用户都要修改浏览器代理设置。<h3 id="20-5-2-代理自动配置"><a href="#20-5-2-代理自动配置" class="headerlink" title="20.5.2 代理自动配置"></a>20.5.2 代理自动配置</h3></li></ol><p>代理自动配置（PAC）协议：自动的动态配置浏览器，连接到正确的代理服务器，可以解决上面提出的问题。PAC的基本思想是让浏览器去获取一个称为PAC的特殊文件，这个文件说明了每个URL所关联的代理。缺点是必须要对浏览器进行配置，让它知道要从哪个服务器获取PAC文件。</p><h2 id="20-5-3-Web代理自动发现协议（略）"><a href="#20-5-3-Web代理自动发现协议（略）" class="headerlink" title="20.5.3 Web代理自动发现协议（略）"></a>20.5.3 Web代理自动发现协议（略）</h2><p>WPAD（Web代理自动发现协议）的目标是在不要求终端用户手工配置代理设置，而且不依赖透明流量拦截的情况下，为Web浏览器提供一种发现并使用附近代理的方式。</p><p>实现WPAD协议的HTTP客户端：用WPAD找到PAC文件的配置URL（CURL），根据这个CURL获取PAC文件，执行PAC文件来确定代理服务器，向那个代理服务器发送HTTP请求。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/FOXqjtdfATC1lBo.png"                      alt="image _5_.png"                ></p><h2 id="20-6-缓存重定向方法"><a href="#20-6-缓存重定向方法" class="headerlink" title="20.6 缓存重定向方法"></a>20.6 缓存重定向方法</h2><p>WCCP协议可以使路由器将Web流量重定向到代理缓存中去。WCCP负责路由器和缓存服务器之间的通信，这样路由器就可以对缓存进行验证（确保启动且运行），在缓存之间进行负载均衡，并将特定类型的流量发送给特定的缓存了。</p><p>下面是WCCP重定向在HTTP上工作过程的概述。</p><ol><li>启动包含了一些支持WCCP的路由器和缓存的网络，这些路由器和缓存之间可以相互通信。</li><li>一组路由器及其目标缓存构成一个WCCP服务组。服务组的配置说明了要将何种流量发往何处、流量是如何发送的以及如何在服务组的缓存之间进行负载均衡。</li><li>若服务组配置为重定向HTTP流量，服务组中路由器就将HTTP请求发送给服务组中的缓存。</li><li>HTTP请求抵达服务组中的路由器时，路由器会（根据对请求IP地址的散列，或者“掩码/值”的配对策略）选择服务组中的某个缓存为请求提供服务。</li><li>路由器向缓存发送请求分组，可以用缓存的IP地址来封装分组，也可通过IP MAC转发实现。</li><li>如果缓存无法为请求提供服务，就将分组返回给路由器进行普通的转发。</li><li>服务组中的成员会互相交换心跳报文，不断验证对方的可用性。<h2 id="20-7-因特网缓存协议"><a href="#20-7-因特网缓存协议" class="headerlink" title="20.7 因特网缓存协议"></a>20.7 因特网缓存协议</h2></li></ol><p>ICP（因特网缓存协议）允许缓存在自身没有请求的内容的情况下，在其兄弟缓存中查找命中内容，以避免查询原始服务器而带来的更多开销。</p><p>ICP会同时去询问附近的多个缓存，看看它们的缓存中是否有特定的URL，附近的缓存如果有就会返回一个简短的报文HIT，否则返回MISS。缓存就可以打开一条到拥有此对象的邻居缓存的HTTP连接。但ICP请求内容时只使用了URL，所以会降低缓存命中率。</p><p>ICP报文是一个以网络字节序表示的32位封装结构，为提高效率，可由UDP数据报承载其报文。但UDP是一种不可靠的因特网协议，因此使用ICP的程序要具有超时功能，以检测丢失的数据报。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/54XhGHIWUtJS1cz.png"                      alt="image _6_.png"                ></p><h2 id="20-8-缓存阵列路由协议"><a href="#20-8-缓存阵列路由协议" class="headerlink" title="20.8 缓存阵列路由协议"></a>20.8 缓存阵列路由协议</h2><p>通过CARP（缓存阵列路由协议）协议来管理一组代理服务器，多个代理服务器的负载分散到一组服务器上。CARP是ICP的一个替代品。它们都允许管理者通过使用多个代理服务器来提高性能。</p><p>通过ICP协议连接起来的每个代理服务器都是将内容进行了冗余镜像的独立缓存服务器，在不同的代理服务器之间复制Web对象条目是可行的。相反，用CARP连接起来的一组服务器会被当作一个大型的缓存服务器，其中每个组件服务器都只包含全部缓存文档中的一部分。</p><p>通过对某个Web对象的URL应用散列函数，CARP就可以将此对象映射到特定的代理服务器上去，所以可以通过单次查找确定对象的位置，无须去查询集合中配置的每个代理服务器。</p><p>但CARP的缺点是，如果某个代理服务器不可用了，就要重新修改散列表，而且必须重新配置现存代理服务器上的内容。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/GYDefJaBXAbCdS4.png"                      alt="image _7_.png"                ></p><h2 id="20-9-超文本缓存协议（略）"><a href="#20-9-超文本缓存协议（略）" class="headerlink" title="20.9 超文本缓存协议（略）"></a>20.9 超文本缓存协议（略）</h2><p>HTCP（超文本缓存协议）允许兄弟缓存之间通过URL和所有的请求及响应首部来相互查询文档是否存在，以降低错误命中的可能。而且HTCP允许兄弟缓存监视或请求在对方的缓存中添加或删除所选中的文档，并修改对方已缓存文档的缓存策略。ICP和HTCP事务之间的区别体现在请求和响应细节上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;20-1-为什么要重定向&quot;&gt;&lt;a href=&quot;#20-1-为什么要重定向&quot; class=&quot;headerlink&quot; title=&quot;20.1 为什么要重定向&quot;&gt;&lt;/a&gt;20.1 为什么要重定向&lt;/h2&gt;&lt;p&gt;由于HTTP应用程序需要可靠地执行HTTP事务、最小化时延、</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="20-重定向与负载均衡" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/20-%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>18-Web主机托管</title>
    <link href="http://example.com/2021/03/05/note/HTTP/18-Web%E4%B8%BB%E6%9C%BA%E6%89%98%E7%AE%A1/"/>
    <id>http://example.com/2021/03/05/note/HTTP/18-Web%E4%B8%BB%E6%9C%BA%E6%89%98%E7%AE%A1/</id>
    <published>2021-03-05T04:04:24.782Z</published>
    <updated>2021-03-08T02:59:54.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="18-1-主机托管服务"><a href="#18-1-主机托管服务" class="headerlink" title="18.1 主机托管服务"></a>18.1 主机托管服务</h2><p>对内容资源的存储、协调以及管理的职责统称为Web主机托管。如果不想自行管理服务器所需的软硬件，就需要主机托管服务。</p><h2 id="18-2-虚拟主机托管"><a href="#18-2-虚拟主机托管" class="headerlink" title="18.2 虚拟主机托管"></a>18.2 虚拟主机托管</h2><p>Web托管者通过让一些顾客共享一台计算机来提供便宜的Web主机托管服务。这称为共享主机托管或虚拟主机托管。每个网站看起来是托管在不同的服务器上，但实际上是托管在同一个物理服务器上。但这不一定意味着上千个网站是用一台PC机来提供服务的。托管者可以创建同样的服务器，称为服务器集群（server farm），把负载分摊在群里的服务器上。</p><h3 id="18-2-1-虚拟服务器请求缺乏主机信息"><a href="#18-2-1-虚拟服务器请求缺乏主机信息" class="headerlink" title="18.2.1 虚拟服务器请求缺乏主机信息"></a>18.2.1 虚拟服务器请求缺乏主机信息</h3><p>HTTP/1.0请求没有包含主机名信息，因此不能支持托管了多个网站的Web服务器。HTТP/1.1支持Host首部解决了这个问题.</p><h3 id="18-2-2-设法让虚拟主机托管正常工作"><a href="#18-2-2-设法让虚拟主机托管正常工作" class="headerlink" title="18.2.2 设法让虚拟主机托管正常工作"></a>18.2.2 设法让虚拟主机托管正常工作</h3><p>原始HTTP规范错误地假设了每个Web服务器上只托管了一个网站，正因为如此，URL中的主机名信息被当作冗余信息剥离了，只要求发送路径部分。但将现存的应用程序都升级到HTTP/1.1规范还需要很长时间。在此期间，涌现了以下4种技术。</p><ol><li><strong>通过URL路径进行虚拟主机托管</strong></li></ol><p>在URL中增添专门的路径部分，以便服务器判断是哪个网站，但这不是一个好办法。</p><ol start="2"><li><strong>通过端口号进行主机托管</strong></li></ol><p>为每个站点分配不同的端口号，这样请求就由Web服务器的单独实例来处理。但终端用户不乐意在URL中指定非标准的端口号。</p><ol start="3"><li><strong>通过IP地址进行主机托管</strong></li></ol><p>为不同的虚拟站点分配专门的IP地址，把这些地址都绑定到一台单独的机器上。</p><ol start="4"><li><strong>通过Host首部进行主机托管</strong></li></ol><p>HTTP/1.0的增强版和HTTP/1.1的正式版定义了Host请求首部来携带网站名称。</p><h3 id="18-2-3-HTТP-1-1的нost首部"><a href="#18-2-3-HTТP-1-1的нost首部" class="headerlink" title="18.2.3 HTТP/1.1的нost首部"></a>18.2.3 HTТP/1.1的нost首部</h3><p>对于没有进行虚拟主机托管，且不允许资源随请求主机的不同而变化的原始服务器来说，可以忽略Host首部字段的值，否则都必须判断其所请求的资源时使用下列规则。</p><p>（1）如果HTTP请求报文中的URL是绝对的（包含方案和主机部分），就忽略Host首部的值。</p><p>（2）如果HTTP请求报文中的URL没有主机部分，而请求带有Host首部，则主机/端口的值就从Host首部中取。</p><p>（3）如果前两部都无法获得有效的主机，就向客户端返回400 Bad Request响应。</p><p>如果客户端显式地使用代理服务器，客户端必须把原始服务器，而非代理服务器的名字和端口放在Host首部中。</p><h2 id="18-3-使网站更可靠和更快"><a href="#18-3-使网站更可靠和更快" class="headerlink" title="18.3 使网站更可靠和更快"></a>18.3 使网站更可靠和更快</h2><p>服务器集群和分布式代理缓存或反向代理服务器分散网络流量，避免拥塞。分发内容使之更靠近终端用户，传输时间更短。客户端和服务器间传输的方式是影响资源访问速度最主要的因素。加速网站访问的另一种方法是对内容进行编码以便更快地传输。</p><h3 id="18-3-1镜像的服务器集群"><a href="#18-3-1镜像的服务器集群" class="headerlink" title="18.3.1镜像的服务器集群"></a>18.3.1镜像的服务器集群</h3><p>服务器集群是一排配置相同的Web服务器，互相可以替换。每个服务器上的内容可以通过镜像复制，这样当某个服务器出问题的时候，其他的可以顶上。</p><p>镜像的服务器常常组成层次化的关系。某个服务器它含有原始内容，这个服务器称为<strong>主原始服务器</strong>（master origin server），从主原始服务器接收内容的镜像服务器称为<strong>复制原始服务器</strong>（replica origin server）。镜像Web服务器可以在不同的地点包含同样内容的副本。</p><p>一种简单的部署服务器集群的方法是用网络交换机把请求分发给服务器。托管在服务器上的每个网站的IP地址就设置为交换机的IP地址。</p><p>在图18-6显示的镜像服务器集群中，主原始服务器负责把内容发送给复制原始服务器。对集群外部来说，内容所在的IP地址就是交换机的IP地址。交换机负责把请求发送到服务器上去。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/iPrAHfGDqR8Mesd.png"                      alt="image _2_.png"                ></p><p>有以下两种方法把客户端的请求导向特定的服务器。</p><ol><li><strong>HTTP重定向</strong></li></ol><p>该内容的URL会解析到主服务器的IP地址，然后它会发送重定向到复制服务器。</p><ol start="2"><li><strong>DNS重定向</strong></li></ol><p>该内容的URL会解析到4个IP地址，DNS服务器可以选择发送给客户端的IP地址。</p><h3 id="18-3-2-内容分发网络"><a href="#18-3-2-内容分发网络" class="headerlink" title="18.3.2 内容分发网络"></a>18.3.2 内容分发网络</h3><p>内容分发网络（CDN）就是对特定内容进行分发的专门网络。这个网络中的节点可以是Web服务器、反向代理或缓存。</p><h3 id="18-3-3-CDN中的反向代理缓存"><a href="#18-3-3-CDN中的反向代理缓存" class="headerlink" title="18.3.3 CDN中的反向代理缓存"></a>18.3.3 CDN中的反向代理缓存</h3><p>上图中，复制原始服务器可以用反向代理（也称为替代物）缓存来代替。反向代理缓存可以像镜像服务器一样接受服务器请求。它们代表原始服务器中的一个特定集合来接收服务器请求。</p><p>反向代理和镜像服务器之间的区别在于反向代理通常是需求驱动的。它们不保存原始服务器的全部内容副本，而是客户端请求的那部分内容。为了更容易地访问就是高请求率的内容，有些反向代理可以在用户请求之前就从服务器上载入内容。</p><h3 id="18-3-4-CDN中的代理缓存"><a href="#18-3-4-CDN中的代理缓存" class="headerlink" title="18.3.4 CDN中的代理缓存"></a>18.3.4 CDN中的代理缓存</h3><p>与反向代理不同，传统的代理缓存能收到发往任何Web服务器的请求。（代理缓存与原始服务器之间不需要有任何工作关系或IP地址约定。）。某些代理缓存也可以预先载入热点内容。</p><p>按需驱动的代理缓存也可以部署在拦截环境，在这种情况下，交换机或路由器会拦截Web流量并将其发送给代理缓存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;18-1-主机托管服务&quot;&gt;&lt;a href=&quot;#18-1-主机托管服务&quot; class=&quot;headerlink&quot; title=&quot;18.1 主机托管服务&quot;&gt;&lt;/a&gt;18.1 主机托管服务&lt;/h2&gt;&lt;p&gt;对内容资源的存储、协调以及管理的职责统称为Web主机托管。如果不想自</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="18-Web主机托管" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/18-Web%E4%B8%BB%E6%9C%BA%E6%89%98%E7%AE%A1/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>17-内容协商与转码</title>
    <link href="http://example.com/2021/03/05/note/HTTP/17-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E8%BD%AC%E7%A0%81/"/>
    <id>http://example.com/2021/03/05/note/HTTP/17-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E8%BD%AC%E7%A0%81/</id>
    <published>2021-03-05T04:04:22.341Z</published>
    <updated>2021-03-08T02:59:07.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="17-1-内容协商技术"><a href="#17-1-内容协商技术" class="headerlink" title="17.1 内容协商技术"></a>17.1 内容协商技术</h2><p>有3种方法可以决定服务器上哪个页面最适合客户端：让客户端来选择、服务器自动判定，或让中间代理来选。这3种技术分别称为客户端驱动的协商、服务器驱动的协商以及透明协商。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/5zJXLQxF7H2j8Em.png"                      alt="image.png"                ></p><h2 id="17-2-客户端驱动的协商"><a href="#17-2-客户端驱动的协商" class="headerlink" title="17.2 客户端驱动的协商"></a>17.2 客户端驱动的协商</h2><p>从实现原理上来说，服务器实际上有两种方法为客户端提供选项：一是发送回一个HTML文档，里面有到该页面的各种版本的链接和每个版本的描述信息，另一种方法是发送回HTTP/1.1响应时，使用300 Multiple Choices响应代码。</p><p>除了增加时延且对每个页面都要进行繁琐的多次请求之外，这种方法还有一个缺点：它需要多个URL：公共页面要一个，其他每种特殊页面也都要一个。</p><h2 id="17-3-服务器驱动的协商"><a href="#17-3-服务器驱动的协商" class="headerlink" title="17.3 服务器驱动的协商"></a>17.3 服务器驱动的协商</h2><p>有两种机制可供HTTP服务器评估发送什么响应给客户端比较合适。</p><ol><li><strong>检查内容协商首部集</strong>。服务器察看客户端发送的Accept首部集，设法用相应的响应首部与之匹配。</li><li><strong>根据其他（非内容协商）首部进行变通</strong>。例如，服务器根据客户端发送的User-Agent首部来发送响应。<h3 id="17-3-1-内容协商首部集"><a href="#17-3-1-内容协商首部集" class="headerlink" title="17.3.1 内容协商首部集"></a>17.3.1 内容协商首部集</h3></li></ol><p>服务器用表17-3中列出的实体首部集来匹配客户端的Accept首部集。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/wDq85RTpac23ZUE.png"                      alt="image _1_.png"                ></p><p>注意，由于HTTP是无状态的协议（表示服务器不会在不同的请求之间追踪客户端的偏好），所以客户端必须在每个请求中都发送其偏好信息。</p><h3 id="17-3-2-内容协商首部中的质量值"><a href="#17-3-2-内容协商首部中的质量值" class="headerlink" title="17.3.2 内容协商首部中的质量值"></a>17.3.2 内容协商首部中的质量值</h3><p>HTTP协议中定义了质量值q，允许客户端为每种偏好类别列出多种选项，并为每种偏好选项关联一个优先次序。如果服务器依旧匹配客户端的任何偏好的情况下，服务器可以修改文档，也就是对文档进行转码，以匹配客户端的偏好。</p><h3 id="17-3-3-随其他首部集而变化"><a href="#17-3-3-随其他首部集而变化" class="headerlink" title="17.3.3 随其他首部集而变化"></a>17.3.3 随其他首部集而变化</h3><p>比如User-Agent首部。侈如，服务器知道老版本的浏览器不支持JavaScript语言，这样就可以向其发送不含有JavaScript的页面版本。</p><p>由于缓存需要尽力提供所缓存文档中正确的“最佳”版本，HTTP协议定义了服务器在响应中发送的Vary首部。这个首部告知缓存（还有客户端和所有下游的代理）服务器根据哪些首部来决定发送响应的最佳版本。</p><h2 id="17-4-透明协商"><a href="#17-4-透明协商" class="headerlink" title="17.4 透明协商"></a>17.4 透明协商</h2><p>HTTP/1.1规范中没有定义任何透明协商机制，但定义了vary首部。服务器在响应中发送了vary首部，以告知中间节点需要使用哪些请求首部进行内容协商。</p><p>代理缓存可以为通过单个URL访问的文档保存不同的副本。如果服务器把它们的决策过程传给缓存，这些代理就能代表服务器与客户端进行协商。同时缓存也是进行内容转码的地方，因为部署在缓存里的通用转码器能对任意服务器，而不仅仅是一台服务器传来的内容进行转码。</p><h3 id="17-4-1-进行缓存与备用候选"><a href="#17-4-1-进行缓存与备用候选" class="headerlink" title="17.4.1 进行缓存与备用候选"></a>17.4.1 进行缓存与备用候选</h3><p>服务器使用的与这些首部集匹配的相应实体首部集。缓存也必须使用相同的首部集来决定回送哪个版本的已缓存的响应，从而确保对客户端请求回送的是正确的已缓存响应。</p><p>若缓存保存了同一个URL的两份不同的文档，与服务器一样。这些不同的版本称为<strong>变体</strong>（variant）或<strong>备用候选</strong>（alternate）。</p><p>当新的请求到达时，缓存会根据内容协商首部集来寻找最佳匹配。但在把文档提供给客户端之前，须检查在已缓存响应中有无发送vary首部。如果有，那么新请求中那些首部的值必须与旧的已缓存请求里相应的首部相同，如果无法匹配，缓存就从原始服务器获取文档。因此为实现透明协商，缓存必须为每个已缓存变体保存客户端请求首部和相应的服务器响应首部。</p><h2 id="17-5-转码"><a href="#17-5-转码" class="headerlink" title="17.5 转码"></a>17.5 转码</h2><p>如果服务器没有能满足客户端需求的文档，可以给出一个错误响应。但理论上，服务器可以把现存的文档转换成某种客户端可用的文档。这种选项称为<strong>转码</strong>。有3种类别的转码：<strong>格式转换</strong>、<strong>信息综合</strong>以及<strong>内容注入</strong>。</p><h3 id="17-5-1-格式转换"><a href="#17-5-1-格式转换" class="headerlink" title="17.5.1 格式转换"></a>17.5.1 格式转换</h3><p>格式转换是指将数据从一种格式转换成另一种格式，使之可以被客户端查看。注意，内容转换或转码与内容编码或传输编码不同，后两者一般用于更高效或安全地传输内容，而前两者则为访问设备能够查看内容。</p><h3 id="17-5-2-信息综合"><a href="#17-5-2-信息综合" class="headerlink" title="17.5.2 信息综合"></a>17.5.2 信息综合</h3><p>从文档中提取关键的信息片段称为信息综合（information synthesis）。这种操作的例子包括根据小节标题生成文档的大纲，或者从页面中删除广告和商标。</p><h3 id="17-5-3-内容注入"><a href="#17-5-3-内容注入" class="headerlink" title="17.5.3 内容注入"></a>17.5.3 内容注入</h3><p>前面描述的两类转码通常会减少Web文档的内容，而内容注入转码会增加文档的内容。例子有自动广告生成器和用户追踪系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;17-1-内容协商技术&quot;&gt;&lt;a href=&quot;#17-1-内容协商技术&quot; class=&quot;headerlink&quot; title=&quot;17.1 内容协商技术&quot;&gt;&lt;/a&gt;17.1 内容协商技术&lt;/h2&gt;&lt;p&gt;有3种方法可以决定服务器上哪个页面最适合客户端：让客户端来选择、服务</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="17-内容协商与转码" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/17-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E8%BD%AC%E7%A0%81/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>16-国际化</title>
    <link href="http://example.com/2021/03/05/note/HTTP/16-%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>http://example.com/2021/03/05/note/HTTP/16-%E5%9B%BD%E9%99%85%E5%8C%96/</id>
    <published>2021-03-05T04:04:19.315Z</published>
    <updated>2021-03-08T02:58:18.684Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP应用程序使用字符集编码请求和显示不同字母表中的文本，它们使用语言标记根据用户所理解的语言来说明并限制内容。</p><h2 id="16-1-HTTP对国际性内容的支持"><a href="#16-1-HTTP对国际性内容的支持" class="headerlink" title="16.1 HTTP对国际性内容的支持"></a>16.1 HTTP对国际性内容的支持</h2><p>服务器通过Content-Type首部中的charset参数和content-Language首部告知客户端文档的字母表和语言。</p><p>客户端发送Accept-Charset首部和Accept-Language首部，告知服务器它理解哪些字符集编码算法和语言以及其中的优先顺序。</p><h2 id="16-2-字符集与HTTP"><a href="#16-2-字符集与HTTP" class="headerlink" title="16.2 字符集与HTTP"></a>16.2 字符集与HTTP</h2><h3 id="16-2-1-字符集是把字符转换为二进制码的编码"><a href="#16-2-1-字符集是把字符转换为二进制码的编码" class="headerlink" title="16.2.1 字符集是把字符转换为二进制码的编码"></a>16.2.1 字符集是把字符转换为二进制码的编码</h3><p>HTTP字符集的值说明如何把实体内容的二进制码转换为特定字母表中的字符。每个字符集标记都命名了一种把二进制码转换为字符的算法（反之亦然）。</p><h3 id="16-2-2-字符集和编码如何工作"><a href="#16-2-2-字符集和编码如何工作" class="headerlink" title="16.2.2 字符集和编码如何工作"></a>16.2.2 字符集和编码如何工作</h3><p>在图16-2a中，文档中的二进制码被转换成字符代码，它表示了特定编码字符集中某个特定编号的字符。在这个例子里，解码后的字符代码是数字编号225.</p><p>在图16-2b中，字符代码用于从编码的字符集中选择特定的元素。在iso-8859-6中，值225对应阿拉伯字母”FEH”。在步骤a和b中使用的算法取决于MIME的charset标记。</p><p>国际化字符系统的关键目标是把语义和表示隔离开来。HTTP只关心字符数据和相关语言及字符集标签的传输。字符形状的显示是由用户的图形显示软件完成的，如图16-2c所示。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/YQCaD1G28o5Swdz.png"                      alt="image.png"                ></p><h2 id="16-3-多语言字符编码入门"><a href="#16-3-多语言字符编码入门" class="headerlink" title="16.3 多语言字符编码入门"></a>16.3 多语言字符编码入门</h2><h3 id="16-3-1-字符集术语"><a href="#16-3-1-字符集术语" class="headerlink" title="16.3.1 字符集术语"></a>16.3.1 字符集术语</h3><p>以下是应当了解的电子化字符系统的8个术语。</p><ol><li><strong>字符。</strong>字符是指字母、数字、标点、表意文字、符号，或其他文本形式的唯一书写“原子”。由统一字符集（Universal Character Set，UCS，非正式名字Unicode）首创。</li><li><strong>字形。</strong>描述字符的笔画图案或唯一的图形化形状，每个字符可以有很多不同的字形。</li><li><strong>编码后的字符。</strong>分配给字符的唯一数字编号。</li><li><strong>代码空间。</strong>计划用于字符代码值的整数范围。</li><li><strong>代码宽度。</strong>每个（固定大小的）字符代码所用的位数。</li><li><strong>字符库。</strong>特定的工作字符集（全体字符的一个子集）。</li><li><strong>编码后的字符集。</strong>组成字符库的已编码字符集，并为每个字符分配代码空间中的一个代码。</li><li><strong>字符编码方案。</strong>把数字化的字符代码编码成一系列二进制码（并能相应地反向解码）的算法。字符编码方案可用来减少识别字符所需要的数据总量（压缩）、解决传输限制、统一重叠編码字符集。<h3 id="16-3-2-字符集的命名很糟糕"><a href="#16-3-2-字符集的命名很糟糕" class="headerlink" title="16.3.2 字符集的命名很糟糕"></a>16.3.2 字符集的命名很糟糕</h3></li></ol><p>从技术上说，MIME中的charset标记描述的是把数据位映射为唯一的字符的一整套算法。它是字符编码方案（character encoding scheme）和编码后的字符集（coded character set）这两种概念的组合。</p><h3 id="16-3-3-编码后的字符集"><a href="#16-3-3-编码后的字符集" class="headerlink" title="16.3.3 编码后的字符集"></a>16.3.3 编码后的字符集</h3><p>码后的字符集把整数映射到字符。编码后的字符集经常用数组来实现，通过代码数值来索引，数组的元素就是字符。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/9CWXzZRbD7iJGdN.png"                      alt="image _1_.png"                ></p><h3 id="16-3-4-字符编码方案"><a href="#16-3-4-字符编码方案" class="headerlink" title="16.3.4 字符编码方案"></a>16.3.4 字符编码方案</h3><p>字符编码方案规定如何把字符的代码数字打包装入内容比特，以及在另一端如何将其解包回字符代码（参见图16-7）。字符编码方案有以下3种主要类型。</p><ol><li><strong>固定宽度。</strong>固定宽度方式的编码用固定数量的比特表示每个编码后的字符。它们能被快速处理，但可能会浪费空间。如8位。</li><li><strong>可变宽度（无模态）。</strong>可变宽度方式的编码对不同的字符代码数字采用不同数量的比特。对于常用字符，这样可以减少需要的位数，而且还能在允许使用多字节来表示国际性字符的同时，保持对传统8位字符集的兼容性。如UTF-8。</li><li><strong>可变宽度（有模态）。</strong>有模态的编码使用特殊的“转义”模式在不同的模态之间切换。例如，可以用有模态的编码在文本中使用多个互相有重叠的字符集。有模态的编码处理起来比较复杂，但它们可以有效地支持复杂的书写系统。如iso-2022-jp。<h2 id="16-4-语言标记与HTTP"><a href="#16-4-语言标记与HTTP" class="headerlink" title="16.4 语言标记与HTTP"></a>16.4 语言标记与HTTP</h2></li></ol><p>语言标记有一个或多个部分，用连字号分隔，称为子标记：第一个子标记称为主子标记，其值是标准化的en、zh，第二个子标记是可选的，遵循它的命名标准；其他尾随的子标记都是未注册的。主子标记中只能含有字母（A-z），其后的子标记可以含有字母和数字，长度最多8个字符。</p><h2 id="16-5-国际的URI"><a href="#16-5-国际的URI" class="headerlink" title="16.5 国际的URI"></a>16.5 国际的URI</h2><h3 id="16-5-1-URI字符集合"><a href="#16-5-1-URI字符集合" class="headerlink" title="16.5.1 URI字符集合"></a>16.5.1 URI字符集合</h3><p>URI中允许出现的US-ASCI字符的子集，可以被分成<strong>保留</strong>、<strong>未保留</strong>以及<strong>转义字符</strong>这几类。未保留的字符可用于URI允许其出现的任何部分。保留的字符在很多URI中都有特殊的含义，因此一般来说不能使用它们。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/gNGEMCxcHwLW9sy.png"                      alt="image _2_.png"                ></p><h3 id="16-5-3-转义和反转义"><a href="#16-5-3-转义和反转义" class="headerlink" title="16.5.3 转义和反转义"></a>16.5.3 转义和反转义</h3><p>可以在URI内部插入保留字符以及原本不支持的字符，每个转义是一组3字符序列，由百分号（%）后面跟上两个十六进制数字的字符。这两个十六进制数字就表示一个US-ASCI字符的代码。例如，要在URL中插入一个空白（ASCII 32），可以用转义%20，</p><p>在内部处理时，HTTP应用程序应当在传输和转发URI的时候保持转义不变,HTTP应用程序应该仅在需要数据的时候才对URI进行转义。需要注意，要转义的值本身应该在US-ASCI代码值的范围内（0~127）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTTP应用程序使用字符集编码请求和显示不同字母表中的文本，它们使用语言标记根据用户所理解的语言来说明并限制内容。&lt;/p&gt;
&lt;h2 id=&quot;16-1-HTTP对国际性内容的支持&quot;&gt;&lt;a href=&quot;#16-1-HTTP对国际性内容的支持&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="16-国际化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/16-%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>09-Web机器人</title>
    <link href="http://example.com/2021/03/02/note/HTTP/09-Web%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>http://example.com/2021/03/02/note/HTTP/09-Web%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2021-03-02T12:20:16.313Z</published>
    <updated>2021-03-08T01:54:54.525Z</updated>
    
    <content type="html"><![CDATA[<p>Web机器人是能够在无需人类干预的情况下自动进行一系列Web事务处理的软件程序。</p><h2 id="9-1-爬虫及爬行方式"><a href="#9-1-爬虫及爬行方式" class="headerlink" title="9.1 爬虫及爬行方式"></a>9.1 爬虫及爬行方式</h2><p>Web爬虫会递归地对各种信息性Web站点进行遍历，获取第一个Web页面，然后获取那个页面指向的所有Web页面，然后是那些页面指向的所有Web页面，依此类推。</p><h3 id="9-1-1-从哪儿开始：根集"><a href="#9-1-1-从哪儿开始：根集" class="headerlink" title="9.1.1 从哪儿开始：根集"></a>9.1.1 从哪儿开始：根集</h3><p>爬虫开始访问的URL初始集合被称作根集（root set），挑选根集时，应该从足够多不同的站点中选择URL，这样才能爬遍尽可能多的链接,从而获取大部分页面。</p><p>通常，一个好的根集会包括一些大的流行Web站点、一个新创建页面的列表和一个不经常被链接的无名页面列表。很多因特网搜索引擎使用的那些爬虫，都提供了向根集中提交新页面或无名页面的方式。这个根集会随时间推移而增长，是所有新爬虫的种子列表。</p><h3 id="9-1-2-链接的提取以及相对链接的标准化"><a href="#9-1-2-链接的提取以及相对链接的标准化" class="headerlink" title="9.1.2 链接的提取以及相对链接的标准化"></a>9.1.2 链接的提取以及相对链接的标准化</h3><p>爬虫在Web上移动时，会不停地对HTML页面进行解析。它要对所解析的每个页面上的URL链接进行分析，并将这些链接添加到需要爬行的页面列表中去。爬虫要将这些链接提取出来，并将相对URL转换为绝对形式。</p><h3 id="9-1-3-避免环路的出现及原因"><a href="#9-1-3-避免环路的出现及原因" class="headerlink" title="9.1.3 避免环路的出现及原因"></a>9.1.3 避免环路的出现及原因</h3><p>机器人在Web上爬行时，要特别小心不要陷入循环，或环路（cycle）之中，所以机器人必须知道它们到过何处，以避免环路的出现。</p><p>至少出于下列三个原因：</p><ol><li>不停地获取相同的页面上，消耗掉网络带宽。</li><li>爬虫不断地获取相同的页面时，可能击垮另一端的Web服务器。</li><li>爬虫应用程序会被重复的内容所充斥。<h3 id="9-1-4-URL管理的相关技术"><a href="#9-1-4-URL管理的相关技术" class="headerlink" title="9.1.4 URL管理的相关技术"></a>9.1.4 URL管理的相关技术</h3></li></ol><p>由于URL的数量巨大，所以使用复杂的数据结构以便快速判定哪些URL是曾经访问过的。以下列出了大规模Web爬虫对其访问过的地址进行管理时使用的一些有用的技术。</p><ol><li><strong>树和散列表</strong></li></ol><p>用搜索树或散列表来记录已访问的URL。这些是加速URL查找的软件数据结构。</p><ol start="2"><li><strong>有损的存在位图</strong></li></ol><p>为了减小空间，比如使用存在位数组。用一个散列函数将每个URL都转换成一个定长的数字，这个数字在数组中有个相关的“存在位”。爬行过一个URL时，就将相应的“存在位”置位。</p><ol start="3"><li><strong>检查点</strong></li></ol><p>一定要将已访问URL列表保存到硬盘上，以防机器人程序崩溃。</p><ol start="4"><li><strong>分类</strong></li></ol><p>为每个机器人分配一个特定的URL“片”，机器人个体之间可能需要相互通信，来回传送URL，以覆盖出故障的对等实体的爬行范围，或协调其工作。</p><h3 id="9-1-5-别名与机器人环路及解决方案"><a href="#9-1-5-别名与机器人环路及解决方案" class="headerlink" title="9.1.5 别名与机器人环路及解决方案"></a>9.1.5 别名与机器人环路及解决方案</h3><p>如果两个URL看起来不一样，但实际指向的是同一资源，就称这两个URL互为“别名”。由于URL“别名”的存在，即使使用正确的数据结构，有时也很难分辨出是否访问过。</p><p>表9-1列出了不同URL指向同一资源的几种简单方式。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/SqrtPoMVR6lBGa9.png"                      alt="image.png"                ></p><p>通过将URL“规范化”为标准格式来消除上面那些显而易见的别名。机器人首先可先通过下列步骤将每个URL都转化为规范化的格式。</p><p>（1）如果没有指定端口的话，就向主机名中舔加”：80”.</p><p>（2）将所有转义符%xx都转换成等价字符。</p><p>（3）删除#标签。</p><p>机器人需要知道Web服务器是否是大小写无关的才能避免表9-1d中的别名问题。</p><p>机器人需要知道Web服务器上这个目录下的索引页面配置才能知道表9-1e中的情况是否是别名。</p><p>即使机器人知道表9-1f中的主机名和IP地址都指向同一台计算机，它也还要知道Web服务器是否配置为进行虚拟主机操作，才能知道这个URL是不是别名。</p><h3 id="9-1-6-文件系统连接环路"><a href="#9-1-6-文件系统连接环路" class="headerlink" title="9.1.6 文件系统连接环路"></a>9.1.6 文件系统连接环路</h3><p>文件系统中的符号连接会造成特定的潜在环路。在图9-3a中，subdir是个普通的目录。在图9-3b中，subdir是个指回到”/”的符号连接。在这两个图中，都假设文件/index.html中包含了一个指向文件subdir/index.html的超链。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/l8ZcPbUIfi3pEnA.png"                      alt="image _1_.png"                ></p><h3 id="9-1-7-动态虚拟Web空间"><a href="#9-1-7-动态虚拟Web空间" class="headerlink" title="9.1.7 动态虚拟Web空间"></a>9.1.7 动态虚拟Web空间</h3><p>应用程序在传输中构造出包含了到同一服务器上虚构URL链接的HTML，请求这些虚构的URL时，服务器就会捏造出一个带有新的虚构URL的新HTML页面来。</p><h3 id="9-1-8-避免循环和重复"><a href="#9-1-8-避免循环和重复" class="headerlink" title="9.1.8 避免循环和重复"></a>9.1.8 避免循环和重复</h3><ol><li><strong>规范化URL</strong></li></ol><p>将URL转换为标准形式以避免语法上的别名</p><ol start="2"><li><strong>广度优先的爬行</strong></li></ol><p>以广度优先的方式来调度URL去访问Web站点，就可以将环路的影响最小化。</p><ol start="3"><li><strong>节流</strong></li></ol><p>限制一段时间内机器人可以从一个web站点获取的页面数量，也可以限制重复的页面总数和对服务器的访问总数。</p><ol start="4"><li><strong>限制URL的大小</strong></li></ol><p>机器人可能会拒绝爬行超出特定长度（通常是1KB）的URL，如果环路使URL的长度增加，长度限制就会最终终止这个环路。</p><ol start="5"><li><strong>URL/站点黑名单</strong></li></ol><p>维护一个与机器人环路和陷阱相对应的已知站点及URL列表，这就要求有人工进行干预。</p><ol start="6"><li><strong>模式检测</strong></li></ol><p>文件系统的符号连接和类似的错误配置所造成的环路会遵循某种模式，比如，URL会随着组件的复制逐渐增加。有些机器人会将具有重复组件的URL当作潜在的环路。</p><ol start="7"><li><strong>内容指纹</strong></li></ol><p>获取页面内容中的字节，并计算出一个校验和，这是页面内容的压缩表示形式。必须要求两个不同页面拥有相同校验和的几率非常低。如MD5这样的报文摘要函数。</p><p>有些Web服务器会在传输过程中对页面进行动态的修改（比如访问计数等），所以有时机器人会在校验和的计算中忽略Web页面内容中的某些部分，但仍可能会阻碍重复检测。</p><ol start="8"><li><strong>人工监视</strong></li></ol><p>诊断和日志功能，能很方便地监视机器人的进展。</p><h2 id="9-2-机器人的HTTP"><a href="#9-2-机器人的HTTP" class="headerlink" title="9.2 机器人的HTTP"></a>9.2 机器人的HTTP</h2><h3 id="9-2-1-识别请求首部"><a href="#9-2-1-识别请求首部" class="headerlink" title="9.2.1 识别请求首部"></a>9.2.1 识别请求首部</h3><p>机器人倾向于只支持最小的HTTP集，但鼓励机器人实现者们使用包括如下内容。</p><ol><li><strong>User-Agent</strong>，将发起请求的机器人名字告知服务器。</li><li><strong>From，</strong>提供机器人的用户/管理者的E-mail地址。</li><li><strong>Accept</strong>，告知服务器可以发送哪些媒体类型，有助于机器人能选择性接收（文本、图片等）</li><li><strong>Referer，</strong>提供包含了当前请求URL的文档的URL，有些站点管理者会记录机器人是如何找到指向其站点内容的链接。<h3 id="9-2-2-虚拟主机"><a href="#9-2-2-虚拟主机" class="headerlink" title="9.2.2 虚拟主机"></a>9.2.2 虚拟主机</h3></li></ol><p>在默认情况下，大多数服务器都被配置为提供一个特定的站点。随着虚拟主机的流行，不包含Host首部的话，爬虫向提供两个站点的服务器发起请求时，可能会使机器人将错误的内容与一个特定的URL关联起来。</p><h3 id="9-2-3-条件请求"><a href="#9-2-3-条件请求" class="headerlink" title="9.2.3 条件请求"></a>9.2.3 条件请求</h3><p>尽量减少机器人所要获取内容的数量，所以只在内容发生变化时才重新获取。通过对时间戳或实体标签进行比较。这与HTTP缓存查看已获取资源的本地副本是否有效的方法非常相似。</p><h3 id="9-2-4-对响应的处理"><a href="#9-2-4-对响应的处理" class="headerlink" title="9.2.4 对响应的处理"></a>9.2.4 对响应的处理</h3><p>使用了某些HTTP特性（比如条件请求）的机器人，以及那些想要更好地探索服务器，并与服务器进行交互的机器人则要能够对各种不同类型的HTTP响应进行处理。</p><ol><li>状态码</li></ol><p>机器人至少应该能够处理一些常见的，以及预期的状态码。它们还应该能够根据响应的一般类别对它并不十分理解的状态码进行处理。</p><p>2、实体</p><p>除了HTTP首部所嵌的信息之外，机器人也会在实体中查信息。有些服务器会在发送HTML页面之前先对其内容进行解析，并将元标签http-equiv指令作为首部包含进去。标签http-equiv为内容编写者提供了一种覆盖这些首部的方式。</p><h3 id="9-2-5-User-Agent导向"><a href="#9-2-5-User-Agent导向" class="headerlink" title="9.2.5 User-Agent导向"></a>9.2.5 User-Agent导向</h3><p>站点管理者应该设计一个处理机器人请求的策略。比如，为所有其他特性不太丰富的浏览器和机器人开发一些页面，而不是将其内容限定在特定浏览器所支持的范围。</p><h2 id="9-3-行为不当的机器人"><a href="#9-3-行为不当的机器人" class="headerlink" title="9.3 行为不当的机器人"></a>9.3 行为不当的机器人</h2><ol><li><strong>失控机器人</strong></li></ol><p>机器人发起HTTP请求的速度快，如果机器人存在编程逻辑错误，或陷入了环路，可能会使服务器过载，并拒绝为任何其他人提供服务。</p><ol start="2"><li><strong>失效的URL</strong></li></ol><p>有些机器人会去访问URL列表，这些列表可能有大量不存在的URL发起请求。</p><ol start="3"><li><strong>很长的错误URL</strong></li></ol><p>由于环路和编程错误的存在，机器人可能会向Web站点请求一些很大的、无意义的URL，降低Web服务器的性能，使Web服务器的访问日志杂乱不堪。</p><ol start="3"><li><strong>爱打听的机器人</strong></li></ol><p>有些机器人可能会得到一些指向私有数据的URL，敏感的数据站点的实现者可能不希望通过因特网能够访问到这些数据。</p><ol start="4"><li><strong>动态网关访问</strong></li></ol><p>机器人并不总是知道它们访问的是什么内容。机器人可能会获取一个内容来自网关应用程序的URL.在这种情况下，获取的数据可能会有特殊的目的，计算的开销可能很高。很多Web站点管理员并不喜欢那些去请求网关文档的幼稚机器人。</p><h2 id="9-4-拒绝机器人访问"><a href="#9-4-拒绝机器人访问" class="headerlink" title="9.4 拒绝机器人访问"></a>9.4 拒绝机器人访问</h2><p>“拒绝机器人访问标准”，有Web服务器都可以在服务器的文档根目录中提供一个可选的、名为robots.txt的文件，这个文件包含说明了机器人可以访问服务器的哪些部分。如果机器人遵循这个自愿约束标准，它会在访问那个站点的所有其他资源之前，从Web站点请求robots.txt文件。</p><h2 id="9-5-搜索引擎"><a href="#9-5-搜索引擎" class="headerlink" title="9.5 搜索引擎"></a>9.5 搜索引擎</h2><h3 id="9-5-1-现代搜索引擎结构"><a href="#9-5-1-现代搜索引擎结构" class="headerlink" title="9.5.1 现代搜索引擎结构"></a>9.5.1 现代搜索引擎结构</h3><p>现在的搜索引擎都构建了一些名为“全文索引”的复杂本地数据库，这些索引就像Web上所有文档的卡片目录一样。搜索引擎爬虫会搜集Web页面，并将其添加到全文索引中去。同时，搜索引擎用户会通过Google这样的Web搜索网关对全文索引进行查询。全文索引充其量也就是Web的一个快照。现代搜索引擎的高层结构如图所示。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/hOn2rbS9uoQZtAi.png"                      alt="image _2_.png"                ></p><h3 id="9-5-2-发布查询请求"><a href="#9-5-2-发布查询请求" class="headerlink" title="9.5.2 发布查询请求"></a>9.5.2 发布查询请求</h3><p>网关程序对搜索请求进行解析，并将查询转换成搜索全文索引所需的表达式。</p><h3 id="9-6-3-对结果进行排序，并提供查询结果"><a href="#9-6-3-对结果进行排序，并提供查询结果" class="headerlink" title="9.6.3 对结果进行排序，并提供查询结果"></a>9.6.3 对结果进行排序，并提供查询结果</h3><p>一旦搜索引擎通过其索引得到了查询结果，网关应用程序会获取结果，并将其拼成结果页面提供给终端用户，并尝试着对结果进行排名。相关性排名（relevancy ranking）是对一系列搜索结果的评分和排序处理。</p><p>为了更好地辅助这一进程，在爬行Web的过程中都会进行数据统计。比如，对指向指定页面的链接进行计数有助于判断其流行程度，还可以用此信息来衡量提供结果的顺序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Web机器人是能够在无需人类干预的情况下自动进行一系列Web事务处理的软件程序。&lt;/p&gt;
&lt;h2 id=&quot;9-1-爬虫及爬行方式&quot;&gt;&lt;a href=&quot;#9-1-爬虫及爬行方式&quot; class=&quot;headerlink&quot; title=&quot;9.1 爬虫及爬行方式&quot;&gt;&lt;/a&gt;9.1 爬</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="09-Web机器人" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/09-Web%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>04-变量、作用域与内存</title>
    <link href="http://example.com/2021/01/23/note/JavaScript/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2021/01/23/note/JavaScript/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</id>
    <published>2021-01-23T11:31:54.212Z</published>
    <updated>2021-03-08T03:14:29.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-原始值与引用值"><a href="#4-1-原始值与引用值" class="headerlink" title="4.1　原始值与引用值"></a>4.1　原始值与引用值</h2><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。<strong>原始值</strong>（primitive value）就是最简单的数据，<strong>引用值</strong>（reference value）则是由多个值构成的对象。</p><p>在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。保存原始值的变量是<strong>按值</strong>（by value）访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，操作的是对该对象的<strong>引用</strong>（reference）而非实际的对象本身。为此，保存引用值的变量是<strong>按引用</strong>（by reference）访问的。</p><blockquote><p><strong>注意</strong>在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。</p></blockquote><h3 id="4-1-1-动态属性"><a href="#4-1-1-动态属性" class="headerlink" title="4.1.1　动态属性"></a>4.1.1　动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方，直到对象被销毁或属性被显式地删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>只有引用值可以动态添加后面可以使用的属性。<br>原始类型的初始化可以只使用原始字面量形式。如果使用的是<code>new</code>关键字，则JavaScript会创建一个<code>Object</code>类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age);    <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age);    <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-复制值"><a href="#4-1-2-复制值" class="headerlink" title="4.1.2　复制值"></a>4.1.2　复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure><p>当把<code>num2</code>初始化为<code>num1</code>时，<code>num2</code>也会得到数值5。这个值跟存储在<code>num1</code>中的5是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/EQOZDYdHoXrpage.png"                      alt="Z3MwAaHFyTk7NBDe__thumbnail.png"                ></p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>下图展示了变量与堆内存中对象之间的关系。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/spkhyCGZXEOoWlt.png"                      alt="DThTdySREjpH3Zdg__thumbnail.png"                ></p><h3 id="4-1-3-传递参数（review）"><a href="#4-1-3-传递参数（review）" class="headerlink" title="4.1.3　传递参数（review）"></a>4.1.3　传递参数（review）</h3><p>ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。</p><p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，用ECMAScript的话说，就是<code>arguments</code>对象中的一个槽位）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>如果<code>num</code>是按引用传递的，那么<code>count</code>的值也会被修改为30。这个事实在使用数值这样的原始值时是非常明显的。但是如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>在函数内部，<code>obj</code>和<code>person</code>都指向同一个对象。结果就是，即使对象是按值传进函数的，<code>obj</code>也会通过引用访问对象。当函数内部给<code>obj</code>设置了<code>name</code>属性时，函数外部的对象也会反映这个变化，因为<code>obj</code>指向的对象保存在全局作用域的堆内存上。但这不意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>这个例子将<code>obj</code>重新定义为一个有着不同<code>name</code>的新对象。当<code>person</code>传入<code>setName()</code>时，其<code>name</code>属性被设置为<code>&quot;Nicholas&quot;</code>。然后变量<code>obj</code>被设置为一个新对象且<code>name</code>属性被设置为<code>&quot;Greg&quot;</code>。如果<code>person</code>是按引用传递的，那么<code>person</code>应该自动将指针改为指向<code>name</code>为<code>&quot;Greg&quot;</code>的对象。可是，当我们再次访问<code>person.name</code>时，它的值还是<code>&quot;Nicholas&quot;</code>，这表明函数中参数的值改变之后，原始的引用仍然没变。当<code>obj</code>在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p><blockquote><p><strong>注意</strong>ECMAScript中函数的参数就是局部变量。</p></blockquote><h3 id="4-1-4-确定类型"><a href="#4-1-4-确定类型" class="headerlink" title="4.1.4　确定类型"></a>4.1.4　确定类型</h3><p><code>typeof</code>操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或<code>undefined</code>的最好方式。如果值是对象或<code>null</code>，那么<code>typeof</code>返回<code>&quot;object&quot;</code>，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">let</span> u;</span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符，如果变量是给定引用类型（由其原型链决定）的实例，则<code>instanceof</code>操作符返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// 变量persion是Object吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);   <span class="comment">// 变量colors是Array吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量pattern是RegExp吗？</span></span><br></pre></td></tr></table></figure><p>因为按照定义，所有引用值都是<code>Object</code>的实例，因此通过<code>instanceof</code>操作符检测任何引用值和<code>Object</code>构造函数都会返回<code>true</code>。如果用<code>instanceof</code>检测原始值，则始终会返回<code>false</code>，因为原始值不是对象。</p><blockquote><p><strong>注意</strong><code>typeof</code>操作符在用于检测函数时会返回<code>&quot;function&quot;</code>。当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，<code>typeof</code>也会返回<code>&quot;function&quot;</code>。ECMA-262规定，任何实现内部<code>[[Call]]</code>方法的对象都应该在<code>typeof</code>检测时返回<code>&quot;function&quot;</code>。因为上述浏览器中的正则表达式实现了这个方法，所以<code>typeof</code>对正则表达式也返回<code>&quot;function&quot;</code>。在IE和Firefox中，<code>typeof</code>对正则表达式返回<code>&quot;object&quot;</code>。</p></blockquote><h2 id="4-2-执行上下文与作用域"><a href="#4-2-执行上下文与作用域" class="headerlink" title="4.2　执行上下文与作用域"></a>4.2　执行上下文与作用域</h2><p>变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象</strong>（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p><p>全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，就是<code>window</code>对象，因此所有通过<code>var</code>定义的全局变量和函数都会成为<code>window</code>对象的属性和方法。使用<code>let</code>和<code>const</code>的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p><p>上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其<strong>活动对象</strong>（activation object）用作变量对象。活动对象最初只有一个定义变量：<code>arguments</code>（全局上下文中没有这个变量）。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到，那么通常会报错。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (color === <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line">    color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>对这个例子而言，函数<code>changeColor()</code>的作用域链包含两个对象：一个是它自己的变量对象（就是定义<code>arguments</code>对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量<code>color</code>，就是因为可以在作用域链中找到它。<br>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">    <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以访问color和anotherColor，但访问不到tempColor</span></span><br><span class="line">  swapColors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure><p>以上代码涉及3个上下文：全局上下文、<code>changeColor()</code>和<code>swapColors()</code>的局部上下文。下图展示了这个例子的作用域链。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/Q6KyZFjctuAaSDV.png"                      alt="HNpFjNH3iS4j2ofk__thumbnail.png"                ></p><p>矩形表示不同的上下文。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。<code>swapColors()</code>局部上下文的作用域链中有3个对象：<code>swapColors()</code>的变量对象、<code>changeColor()</code>的变量对象和全局变量对象。<code>swapColors()</code>的局部上下文首先从自己的变量对象开始搜索变量和函数，搜不到就去搜索上一级变量对象。<code>changeColor()</code>上下文的作用域链中只有2个对象：它自己的变量对象和全局变量对象。因此，它不能访问<code>swapColors()</code>的上下文。</p><blockquote><p><strong>注意</strong>函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。</p></blockquote><h3 id="4-2-1-作用域链增强"><a href="#4-2-1-作用域链增强" class="headerlink" title="4.2.1　作用域链增强"></a>4.2.1　作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种（<code>eval()</code>调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常代码执行到下面任意一种情况时会出现这个现象，即：</p><ul><li><code>try</code>/<code>catch</code>语句的<code>catch</code>块</li><li><code>with</code>语句</li></ul><p>这两种情况下，都会在作用域链前端添加一个变量对象。对<code>with</code>语句来说，会向作用域链前端添加指定的对象；对<code>catch</code>语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">with</span>(<span class="params">location</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;<span class="comment">//未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>with</code>语句将<code>location</code>对象作为上下文，因此<code>location</code>会被添加到作用域链前端。<code>buildUrl()</code>函数中定义了一个变量<code>qs</code>。当<code>with</code>语句中的代码引用变量<code>href</code>时，实际上引用的是<code>location.href</code>，也就是自己变量对象的属性。在引用<code>qs</code>时，引用的则是定义在<code>buildUrl()</code>中的那个变量，它定义在函数上下文的变量对象上。而在<code>with</code>语句中使用<code>var</code>声明的变量<code>url</code>会成为函数上下文的一部分，可以作为函数的值被返回；但因为实际这里使用<code>let</code>声明的变量<code>url</code>，被限制在块级作用域，所以在<code>with</code>块之外没有定义。</p><blockquote><p><strong>注意</strong>IE的实现在IE8之前是有偏差的，即它们会将<code>catch</code>语句中捕获的错误添加到执行上下文的变量对象上，而不是<code>catch</code>语句的变量对象上，导致在<code>catch</code>块外部都可以访问到错误。IE9纠正了这个问题。</p></blockquote><h3 id="4-2-2-变量声明"><a href="#4-2-2-变量声明" class="headerlink" title="4.2.2　变量声明"></a>4.2.2　变量声明</h3><h4 id="4-2-2-1-使用var的函数作用域声明"><a href="#4-2-2-1-使用var的函数作用域声明" class="headerlink" title="4.2.2.1   使用var的函数作用域声明"></a><strong>4.2.2.1   使用</strong><code>var</code>的函数作用域声明</h4><p>在使用<code>var</code>声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在<code>with</code>语句中，最接近的上下文也是函数上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);         <span class="comment">// 报错：sum在这里不是有效变量</span></span><br></pre></td></tr></table></figure><p>如果省略上面例子中的关键字<code>var</code>，<code>sum</code>会被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)  </span>&#123;</span><br><span class="line">  sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum);         <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>未经声明而初始化变量是JavaScript编程中一个非常常见的错误，会导致很多问题。为此在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p></blockquote><p><code>var</code>声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。下面的例子展示了在全局作用域中两段等价的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name;</span><br></pre></td></tr></table></figure><p>下面是两个等价的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通声明的提升意味着会输出<code>undefined</code>而不是<code>Reference Error</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-2-使用let的块级作用域声明"><a href="#4-2-2-2-使用let的块级作用域声明" class="headerlink" title="4.2.2.2   使用let的块级作用域声明"></a><strong>4.2.2.2   使用</strong><code>let</code>的块级作用域声明</h4><p>ES6新增的<code>let</code>关键字的作用域是块级的。块级作用域由最近的一对包含花括号<code>&#123;&#125;</code>界定。<code>if</code>块、<code>while</code>块、<code>function</code>块，甚至连单独的块也是<code>let</code>声明变量的作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line">                <span class="comment">// var声明也会导致报错</span></span><br><span class="line"><span class="comment">// 这不是对象字面量，而是一个独立的块</span></span><br><span class="line"><span class="comment">// JavaScript解释器会根据其中内容识别出它来</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure><p><code>let</code>与<code>var</code>的另一个不同之处是在同一作用域内不能声明两次。重复的<code>var</code>声明会被忽略，而重复的<code>let</code>声明会抛出<code>SyntaxError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: 标识符b已经声明过了</span></span><br></pre></td></tr></table></figure><p><code>let</code>的行为非常适合在循环中声明迭代变量。使用<code>var</code>声明的迭代变量会泄漏到循环外部，这种情况应该避免。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError: j没有定义</span></span><br></pre></td></tr></table></figure><p>严格来讲，<code>let</code>在JavaScript运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用<code>let</code>变量。</p><h4 id="4-2-2-3-使用const的常量声明"><a href="#4-2-2-3-使用const的常量声明" class="headerlink" title="4.2.2.3   使用const的常量声明"></a><strong>4.2.2.3   使用</strong><code>const</code>的常量声明</h4><p>使用<code>const</code>声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure><p><code>const</code>除了要遵循以上规则，其他方面与<code>let</code>声明是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure><p><code>const</code>声明只应用到顶级原语或者对象。换句话说，赋值为对象的<code>const</code>变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure><p>如果想让整个对象都不能修改，可以使用<code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错，但会静默失败：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">o3.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o3.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于<code>const</code>声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化。</p><blockquote><p><strong>注意</strong>开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用<code>const</code>声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。</p><h4 id="4-2-2-4-标识符查找"><a href="#4-2-2-4-标识符查找" class="headerlink" title="4.2.2.4   标识符查找"></a><strong>4.2.2.4   标识符查找</strong></h4></blockquote><p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;blue&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，调用函数<code>getColor()</code>时会引用变量<code>color</code>。为确定<code>color</code>的值会进行两步搜索。第一步，搜索<code>getColor()</code>的变量对象，查找名为<code>color</code>的标识符。结果没找到，于是继续搜索下一个变量对象（来自全局上下文），然后就找到了名为<code>color</code>的标识符。因为全局变量对象上有<code>color</code>的定义，所以搜索结束。<br>对搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// &#x27;green&#x27;</span></span><br></pre></td></tr></table></figure><p><code>getColor()</code>内部声明了一个名为<code>color</code>的局部变量。在调用这个函数时，变量会被声明。在执行到函数返回语句时，代码引用了变量<code>color</code>。于是开始在局部上下文中搜索这个标识符，结果找到了值为<code>&#39;green&#39;</code>的变量<code>color</code>。因为变量已找到，搜索随即停止，所以就使用这个局部变量。这意味着函数会返回<code>&#39;green&#39;</code>。在局部变量<code>color</code>声明之后的任何代码都无法访问全局变量<code>color</code>，除非使用完全限定的写法<code>window.color</code>。</p><blockquote><p><strong>注意</strong>标识符查找有一定代价。访问局部变量比访问全局变量要快，因为不用切换作用域。</p></blockquote><h2 id="4-3-垃圾回收"><a href="#4-3-垃圾回收" class="headerlink" title="4.3　垃圾回收"></a>4.3　垃圾回收</h2><p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。JavaScript通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p><p>以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量有不同的实现方式，在浏览器的发展史上，主要用到过两种标记策略：标记清理和引用计数。</p><h3 id="4-3-1-标记清理"><a href="#4-3-1-标记清理" class="headerlink" title="4.3.1　标记清理"></a>4.3.1　标记清理</h3><p>JavaScript最常用的垃圾回收策略是<strong>标记清理</strong>（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p><p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量（标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次<strong>内存清理</strong>，销毁带标记的所有值并收回它们的内存。</p><h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2　引用计数"></a>4.3.2　引用计数</h3><p>另一种没那么常用的垃圾回收策略是<strong>引用计数</strong>（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p><p>引用计数会遇到了严重的问题：<strong>循环引用</strong>。就是对象A有一个指针指向对象B，而对象B也引用了对象A。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  objectA.someOtherObject = objectB;</span><br><span class="line">  objectB.anotherObject = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>objectA</code>和<code>objectB</code>通过各自的属性相互引用，意味着它们的引用数都是2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，<code>objectA</code>和<code>objectB</code>在函数结束后还会存在，因为它们的引用数永远不会变成0。如果函数被多次调用，则会导致大量内存永远不会被释放。<br>在IE8及更早版本的IE中，并非所有对象都是原生JavaScript对象。BOM和DOM中的对象是C++实现的组件对象模型（COM，Component Object Model）对象，而COM对象使用引用计数实现垃圾回收。因此，即使这些版本IE的JavaScript引擎使用标记清理，JavaScript存取的COM对象依旧使用引用计数。下面这个简单的例子展示了涉及COM对象的循环引用问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.element = element;</span><br><span class="line">element.someObject = myObject;</span><br></pre></td></tr></table></figure><p>这个例子在一个DOM对象（<code>element</code>）和一个原生JavaScript对象（<code>myObject</code>）之间制造了循环引用。因此DOM元素的内存永远不会被回收，即使它已经被从页面上删除了也是如此。<br>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生JavaScript对象与DOM元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.someObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>把变量设置为<code>null</code>实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。<br>为了补救这一点，IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。</p><h3 id="4-3-3-性能"><a href="#4-3-3-性能" class="headerlink" title="4.3.3　性能"></a>4.3.3　性能</h3><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。</p><p>现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，“在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”</p><p>由于调度垃圾回收程序方面的问题会导致性能下降，IE曾饱受诟病。它的策略是根据分配数，比如分配了256个变量、4096个对象/数组字面量和数组槽位（slot），或者64KB字符串。只要满足其中某个条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就会导致垃圾回收程序过于频繁地运行。</p><p>IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7的起始阈值都与IE6的相同。如果垃圾回收程序回收的内存不到已分配的15%，这些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存达到已分配的85%，则阈值重置为默认值。这么一个简单的修改，极大地提升了重度依赖JavaScript的网页在浏览器中的性能。</p><blockquote><p><strong>警告</strong>在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在IE中，<code>window.CollectGarbage()</code>方法会立即触发垃圾回收。在Opera 7及更高版本中，调用<code>window.opera.collect()</code>也会启动垃圾回收程序。</p></blockquote><h3 id="4-3-4-内存管理"><a href="#4-3-4-内存管理" class="headerlink" title="4.3.4　内存管理"></a>4.3.4　内存管理</h3><p>在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。</p><p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为<code>null</code>，从而释放其引用。这也可以叫作<strong>解除引用</strong>。这个建议最适合全局变量和全局对象的属性，因为局部变量在超出作用域后会被自动解除引用，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  localPerson.name = name;</span><br><span class="line">  <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> globalPerson = createPerson(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="comment">// 解除globalPerson对值的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>不过解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p><h4 id="4-3-4-1-通过const和let声明提升性能"><a href="#4-3-4-1-通过const和let声明提升性能" class="headerlink" title="4.3.4.1   通过const和let声明提升性能"></a><strong>4.3.4.1   通过</strong><code>const</code>和<code>let</code>声明提升性能</h4><p>ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为<code>const</code>和<code>let</code>都以块（而非函数）为作用域，所以相比于使用<code>var</code>，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。</p><h4 id="4-3-4-2-隐藏类和删除操作"><a href="#4-3-4-2-隐藏类和删除操作" class="headerlink" title="4.3.4.2   隐藏类和删除操作"></a><strong>4.3.4.2   隐藏类和删除操作</strong></h4><p>有时候需要根据浏览器使用的JavaScript引擎来采取不同的性能优化策略。V8 JavaScript引擎在将解释后的JavaScript代码编译为实际的机器码时会利用“隐藏类”。</p><p>运行期间，V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这种情况进行优化，但不一定总能够做到。比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br></pre></td></tr></table></figure><p>V8会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时两个<code>Article</code>实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。<br>解决方案就是避免JavaScript的“先创建再补充”（ready-fire-aim）式的动态属性赋值，在构造函数中一次性声明所有属性，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样两个实例基本上就一样了（不考虑<code>hasOwnProperty</code>的返回值），因此可以共享一个隐藏类，从而带来潜在的性能提升。不过使用<code>delete</code>关键字会导致生成相同的隐藏类片段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">delete</span> a1.author;</span><br></pre></td></tr></table></figure><p>这样即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为<code>null</code>。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.author = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article();</span><br><span class="line">a1.author = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-3-内存泄漏（review）"><a href="#4-3-4-3-内存泄漏（review）" class="headerlink" title="4.3.4.3   内存泄漏（review）"></a><strong>4.3.4.3   内存泄漏（review）</strong></h4><p>在内存有限的设备上或函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合理的引用导致的。</p><p>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时解释器会把变量<code>name</code>当作<code>window</code>的属性来创建（相当于<code>window.name = &#39;Jake&#39;</code>）。因为在<code>window</code>对象上创建的属性，导致<code>window</code>本身不被清理就不会消失。只要在变量声明前头加上<code>var</code>、<code>let</code>或<code>const</code>关键字即可解决。<br>定时器也可能会导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>只要定时器一直运行，回调函数中引用的<code>name</code>就会一直占用内存。垃圾回收程序当然知道这一点，因而就不会清理外部变量。<br>使用JavaScript闭包也很容易造成内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这会导致分配给<code>name</code>的内存被泄漏。以上代码创建了一个内部闭包，只要<code>outer</code>函数存在就不能清理<code>name</code>，因为闭包一直在引用着它。假如<code>name</code>的内容很大，那可能就是个大问题。</p><h4 id="4-3-4-4-静态分配与对象池-review"><a href="#4-3-4-4-静态分配与对象池-review" class="headerlink" title="4.3.4.4   静态分配与对象池(review)"></a><strong>4.3.4.4   静态分配与对象池(review)</strong></h4><p>为了提升JavaScript性能，最后要考虑的就是浏览器。关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。</p><p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。下面是一个计算二维矢量加法的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resultant = <span class="keyword">new</span> Vector();</span><br><span class="line">  resultant.x = a.x + b.x;</span><br><span class="line">  resultant.y = a.y + b.y;</span><br><span class="line">  <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。再加上这个矢量加法函数如果频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。<br>该问题的解决方案是不要动态创建矢量对象，让它使用一个已有的矢量对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b, resultant</span>) </span>&#123;</span><br><span class="line">  resultant.x = a.x + b.x;</span><br><span class="line">  resultant.y = a.y + b.y;</span><br><span class="line">  <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这需要在其他地方实例化矢量参数<code>resultant</code>，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？<br>一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectorPool是已有的对象池</span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.allocate();</span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.allocate();</span><br><span class="line">v1.x = <span class="number">10</span>;</span><br><span class="line">v1.y = <span class="number">5</span>;</span><br><span class="line">v2.x = -<span class="number">3</span>;</span><br><span class="line">v2.y = -<span class="number">6</span>;</span><br><span class="line">addVector(v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log([v3.x, v3.y]); <span class="comment">// [7, -1]</span></span><br><span class="line">vectorPool.free(v1);</span><br><span class="line">vectorPool.free(v2);</span><br><span class="line">vectorPool.free(v3);</span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象,则这里也需要把这些属性设置为null</span></span><br><span class="line">v1 = <span class="literal">null</span>;</span><br><span class="line">v2 = <span class="literal">null</span>;</span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收。比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vectorList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> vector = <span class="keyword">new</span> Vector();</span><br><span class="line">vectorList.push(vector);</span><br></pre></td></tr></table></figure><p>由于JavaScript数组的大小是动态可变的，引擎会删除大小为100的数组，再创建一个新的大小为200的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。</p><blockquote><p><strong>注意</strong>静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能，但并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p></blockquote><h2 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4　小结"></a>4.4　小结</h2><p>JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。原始值和引用值有以下特点。</p><ul><li>原始值大小固定，因此保存在栈内存上。</li><li>从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li><li>引用值是对象，存储在堆内存上。</li><li>包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</li><li>从一个变量到另一个变量复制引用值只会复制指针，因此两个变量都指向同一个对象。</li><li><code>typeof</code>操作符可以确定值的原始类型，而<code>instanceof</code>操作符用于确保值的引用类型。</li></ul><p>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。</p><ul><li>执行上下文分全局上下文、函数上下文和块级上下文。</li><li>代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li><li>函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。</li><li>全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。</li><li>变量的执行上下文用于确定什么时候释放内存。</li></ul><p>JavaScript的垃圾回收程序可以总结如下。</p><ul><li>离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。</li><li>主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回收它们的内存。</li><li>引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，某些旧版本的IE仍会受这种算法的影响，因为JavaScript会访问非原生JavaScript对象（如DOM元素）。</li><li>引用计数在代码中存在循环引用时会出现问题。</li><li>解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-原始值与引用值&quot;&gt;&lt;a href=&quot;#4-1-原始值与引用值&quot; class=&quot;headerlink&quot; title=&quot;4.1　原始值与引用值&quot;&gt;&lt;/a&gt;4.1　原始值与引用值&lt;/h2&gt;&lt;p&gt;ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    <category term="04-变量、作用域与内存" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/04-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>03-语言基础</title>
    <link href="http://example.com/2021/01/23/note/JavaScript/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/01/23/note/JavaScript/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2021-01-23T11:31:12.590Z</published>
    <updated>2021-03-08T03:14:21.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1　语法"></a>3.1　语法</h2><h3 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1　区分大小写"></a>3.1.1　区分大小写</h3><p>ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符。</p><h3 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2　标识符"></a>3.1.2　标识符</h3><p><strong>标识符</strong>，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p><ol><li>第一个字符必须是一个字母、下划线_或美元符号$；</li><li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li></ol><p>标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。</p><p>ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p><p>关键字、保留字、<code>true</code>、<code>false</code>和<code>null</code>不能作为标识符。</p><h3 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3　注释"></a>3.1.3　注释</h3><p>包括单行注释和块注释。单行注释以两个斜杠字符开头，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><p>块注释以一个斜杠和一个星号（<code>/*</code>）开头，以它们的反向组合（<code>*/</code>）结尾，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是多行</span></span><br><span class="line"><span class="comment">注释 */</span></span><br></pre></td></tr></table></figure><h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4　严格模式"></a>3.1.4　严格模式</h3><p>严格模式是一种不同的JavaScript解析和执行模型，要对整个脚本启用严格模式，在脚本开头加上：”use strict”;，它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。也可以单独指定一个函数在严格模式下执行，把这个预处理指令放到函数体开头即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5　语句"></a>3.1.5　语句</h3><p>ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sum &#x3D; a + b      &#x2F;&#x2F; 没有分号也有效，但不推荐</span><br></pre></td></tr></table></figure><p>加分号有助于防止省略造成的问题，比如避免输入内容不完整，也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误），也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。<br>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号（<code>&#123;</code>）标识开始，一个右花括号（<code>&#125;</code>）标识结束：</p><p>if之类的控制语句只在执行多条语句时要求必须有代码块。最好始终在控制语句中使用代码块，即使要执行的只有一条语句。</p><p>在控制语句中使用代码块可以让内容更清晰，在需要修改代码时也可以减少出错的可能性。</p><h2 id="3-2-关键字与保留字"><a href="#3-2-关键字与保留字" class="headerlink" title="3.2　关键字与保留字"></a>3.2　关键字与保留字</h2><p>保留的关键字不能用作标识符或属性名。ECMA-262第6版规定的所有关键字如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">break       do          in            typeof</span><br><span class="line">case        else        instanceof    var</span><br><span class="line">catch       export      new           void</span><br><span class="line">class       extends     return        while</span><br><span class="line">const       finally     super         with</span><br><span class="line">continue    for         switch        yield</span><br><span class="line">debugger    function    this</span><br><span class="line">default     if          throw</span><br><span class="line">delete      import      try</span><br></pre></td></tr></table></figure><p>规范中也描述了一组<strong>未来的保留字</strong>，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">始终保留:</span><br><span class="line">enum</span><br><span class="line">严格模式下保留:</span><br><span class="line">implements  package     public</span><br><span class="line">interface   protected   static</span><br><span class="line">let         private</span><br><span class="line">模块代码中保留:</span><br><span class="line">await</span><br></pre></td></tr></table></figure><p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。但最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的ECMAScript版本。</p><h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3　变量"></a>3.3　变量</h2><p>ECMAScript变量是松散类型的，变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量：<code>var</code>、<code>const</code>和<code>let</code>。其中，<code>var</code>在ECMAScript的所有版本中都可以使用，而<code>const</code>和<code>let</code>只能在ECMAScript 6及更晚的版本中使用。</p><h3 id="3-3-1var关键字"><a href="#3-3-1var关键字" class="headerlink" title="3.3.1var关键字"></a>3.3.1<code>var</code>关键字</h3><p>要定义变量，可以使用<code>var</code>操作符（注意<code>var</code>是一个关键字），后跟变量名（即标识符）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var message;</span><br></pre></td></tr></table></figure><p>（不初始化的情况下，变量会保存一个特殊值<code>undefined</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure><p>初始化变量不会将它标识为字符串类型，只是一个简单的赋值而已。随后不仅可以改变保存的值，也可以改变值的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">message = <span class="number">100</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure><h4 id="3-3-1-1var声明作用域"><a href="#3-3-1-1var声明作用域" class="headerlink" title="3.3.1.1var声明作用域"></a>3.3.1.1<code>var</code>声明作用域</h4><p><code>var</code>声明作用域关键的问题在于，使用<code>var</code>操作符定义的变量会成为包含它的函数的局部变量。使用<code>var</code>在一个函数内部定义一个变量，该变量将在函数退出时被销毁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><p>在函数内定义变量时省略<code>var</code>操作符，可以创建一个全局变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   message = <span class="string">&quot;hi&quot;</span>;     <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>虽然可以通过省略<code>var</code>操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出<code>ReferenceError</code>。</p></blockquote><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure><p>使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进并不是必需的，但这样有利于阅读理解。<br>在严格模式下，不能定义名为<code>eval</code>和<code>arguments</code>的变量，否则会导致语法错误。</p><h4 id="3-3-1-2var声明提升"><a href="#3-3-1-2var声明提升" class="headerlink" title="3.3.1.2var声明提升"></a>3.3.1.2<code>var</code>声明提升</h4><p>使用<code>var</code>时，声明的变量会自动提升到函数作用域顶部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>反复多次使用<code>var</code>声明同一个变量也没有问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 36</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2let声明"><a href="#3-3-2let声明" class="headerlink" title="3.3.2let声明"></a>3.3.2<code>let</code>声明</h3><p><code>let</code>跟<code>var</code>最明显的区别是<code>let</code>声明的范围是块作用域，而<code>var</code>声明的范围是函数作用域。它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于<code>var</code>的作用域限制同样也适用于<code>let</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);   <span class="comment">// Matt</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);   <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure><p><code>let</code>也不允许同一个块作用域中出现冗余声明。这样会导致报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age;  <span class="comment">// SyntaxError；标识符age已经声明过了</span></span><br></pre></td></tr></table></figure><p>JavaScript引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);    <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混用<code>let</code>和<code>var</code>同样可能会到冗余声明。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-1-暂时性死区"><a href="#3-3-2-1-暂时性死区" class="headerlink" title="3.3.2.1**暂时性死区**"></a><strong>3.3.2.1**</strong>暂时性死区**</h4><p><code>let</code>与<code>var</code>的另一个重要的区别，就是<code>let</code>声明的变量不会在作用域中被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="comment">// age不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure><p>在解析代码时，JavaScript引擎也会注意出现在块后面的<code>let</code>声明，只不过在此之前不能以任何方式来引用未声明的变量。在<code>let</code>声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出<code>ReferenceError</code>。</p><h4 id="3-3-2-2-全局声明"><a href="#3-3-2-2-全局声明" class="headerlink" title="3.3.2.2**全局声明**"></a><strong>3.3.2.2**</strong>全局声明**</h4><p>使用<code>let</code>在全局作用域中声明的变量不会成为<code>window</code>对象的属性（<code>var</code>声明的变量会）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>但<code>let</code>声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免<code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p><h4 id="3-3-2-3-条件声明（review）"><a href="#3-3-2-3-条件声明（review）" class="headerlink" title="3.3.2.3**条件声明（review）**"></a><strong>3.3.2.3**</strong>条件声明（review）**</h4><p>在使用<code>var</code>声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为<code>let</code>的作用域是块，所以不可能检查前面是否已经使用<code>let</code>声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line">  <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="comment">// 这里没问题，因为可以被作为一个提升声明来处理</span></span><br><span class="line">  <span class="comment">// 不需要检查之前是否声明过同名变量</span></span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line">  <span class="comment">// 如果age之前声明过，这里会报错</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用<code>try</code>/<code>catch</code>语句或<code>typeof</code>操作符也不能解决，因为<code>let</code>声明的作用域仅限于该条件块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">36</span>;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span><br><span class="line">  <span class="comment">// 那它可以假设还没有声明过</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// name被限制在if &#123;&#125; 块的作用域内</span></span><br><span class="line">  <span class="comment">// 因此这个赋值形同全局赋值</span></span><br><span class="line">  name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> (age) &#123;</span><br><span class="line">    <span class="comment">// 如果age没有声明过，则会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="keyword">let</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// age被限制在catch &#123;&#125;块的作用域内</span></span><br><span class="line">  <span class="comment">// 因此这个赋值形同全局赋值</span></span><br><span class="line">  age = <span class="number">26</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>为此，对于<code>let</code>声明关键字，不能依赖条件声明模式。</p><blockquote><p><strong>注意</strong>条件声明是一种反模式，它让程序变得更难理解。</p></blockquote><h4 id="3-3-2-4for循环中的let声明"><a href="#3-3-2-4for循环中的let声明" class="headerlink" title="3.3.2.4for循环中的let声明"></a>3.3.2.4<code>for</code>循环中的<code>let</code>声明</h4><p>在<code>let</code>出现之前，<code>for</code>循环定义的迭代变量会渗透到循环体外部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>改成使用<code>let</code>之后，这个问题就消失了，因为迭代变量的作用域仅限于<code>for</code>循环块内部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i没有定义</span></span><br></pre></td></tr></table></figure><p>在使用<code>var</code>的时候，最常见的问题是对迭代变量的奇特声明和修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 你可能以为会输出0、1、2、3、4</span></span><br><span class="line"><span class="comment">// 实际上会输出5、5、5、5、5</span></span><br></pre></td></tr></table></figure><p>在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的<code>i</code>都是同一个变量，因而输出的都是同一个最终值。<br>而在使用<code>let</code>声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个<code>setTimeout</code>引用的都是不同的变量实例，所以<code>console.log</code>输出的是循环执行过程中每个迭代变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会输出0、1、2、3、4</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3const声明"><a href="#3-3-3const声明" class="headerlink" title="3.3.3const声明"></a>3.3.3<code>const</code>声明</h3><p><code>const</code>的行为与<code>let</code>基本相同，唯一区别是用它声明变量时必须同时初始化变量，且修改<code>const</code>声明的变量会导致运行时错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="comment">// const也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// const声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure><p><code>const</code>声明的限制只适用于它指向的变量的引用。如果<code>const</code>变量引用的是一个对象，那么修改这个对象内部的属性并不违反<code>const</code>的限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>不能用<code>const</code>来声明迭代变量（因为迭代变量会自增）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError：给常量赋值</span></span><br></pre></td></tr></table></figure><p>可以用<code>const</code>声明一个不会被修改的<code>for</code>循环变量。因为和<code>let</code>声明一样JavaScript引擎会为<code>for</code>循环中的<code>const</code>声明分别创建独立的变量实例。这对<code>for-of</code>和<code>for-in</code>循环特别有意义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> j = <span class="number">7</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7, 7, 7, 7, 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure><h3 id="3-3-4-声明风格及最佳实践"><a href="#3-3-4-声明风格及最佳实践" class="headerlink" title="3.3.4　声明风格及最佳实践"></a>3.3.4　声明风格及最佳实践</h3><p>ECMAScript 6增加<code>let</code>和<code>const</code>从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的<code>var</code>所造成的各种问题，已经让JavaScript社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。</p><h4 id="3-3-4-1-不使用var"><a href="#3-3-4-1-不使用var" class="headerlink" title="3.3.4.1   不使用var"></a><strong>3.3.4.1   不使用</strong><code>var</code></h4><p>限制自己只使用<code>let</code>和<code>const</code>有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p><h4 id="3-3-4-2const优先，let次之"><a href="#3-3-4-2const优先，let次之" class="headerlink" title="3.3.4.2const优先，let次之"></a>3.3.4.2<code>const</code>优先，<code>let</code>次之</h4><p>使用<code>const</code>声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。只在提前知道未来会有修改时，再使用<code>let</code>。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p><h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4　数据类型"></a>3.4　数据类型</h2><p>ECMAScript有6种简单数据类型（也称为<strong>原始类型</strong>）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。还有一种复杂数据类型叫<code>Object</code>（对象）。<code>Object</code>是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。一种数据类型可以当作多种数据类型来使用。</p><h3 id="3-4-1typeof操作符"><a href="#3-4-1typeof操作符" class="headerlink" title="3.4.1typeof操作符"></a>3.4.1<code>typeof</code>操作符</h3><p>因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。<code>typeof</code>操作符就是为此而生的。对一个值使用<code>typeof</code>操作符会返回下列字符串之一：</p><ul><li><code>&quot;undefined&quot;</code>表示值未定义；</li><li><code>&quot;boolean&quot;</code>表示值为布尔值；</li><li><code>&quot;string&quot;</code>表示值为字符串；</li><li><code>&quot;number&quot;</code>表示值为数值；</li><li><code>&quot;object&quot;</code>表示值为对象（而不是函数）或<code>null</code>；</li><li><code>&quot;function&quot;</code>表示值为函数；</li><li><code>&quot;symbol&quot;</code>表示值为符号。</li></ul><p>下面是使用<code>typeof</code>操作符的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);    <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message));   <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);         <span class="comment">// &quot;number&quot;</span></span><br></pre></td></tr></table></figure><p>因为<code>typeof</code>是一个操作符而不是函数，所以不需要参数（但可以使用参数）。<br><code>typeof</code>在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用<code>typeof   null</code>返回的是<code>&quot;object&quot;</code>。这是因为特殊值<code>null</code>被认为是一个对空对象的引用。</p><blockquote><p><strong>注意</strong>严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此通过<code>typeof</code>操作符来区分函数和其他对象。</p></blockquote><h3 id="3-4-2Undefined类型"><a href="#3-4-2Undefined类型" class="headerlink" title="3.4.2Undefined类型"></a>3.4.2<code>Undefined</code>类型</h3><p><code>Undefined</code>类型只有一个值，就是特殊值<code>undefined</code>。当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>变量<code>message</code>和<code>undefined</code>的字面值是相等的。但变量<code>message</code>显式地以<code>undefined</code>来初始化是不必要的，因为默认情况下，任何未经初始化的变量都会取得<code>undefined</code>值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>永远不要显式地给某个变量设置<code>undefined</code>值。字面值<code>undefined</code>主要用于比较。增加这个特殊值的目的就是为了正式明确空对象指针（<code>null</code>）和未初始化变量的区别。</p></blockquote><p>包含<code>undefined</code>值的变量跟未定义变量是有区别的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;    <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age);     <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>对未声明的变量，只能对它调用<code>typeof</code>。（对未声明的变量调用<code>delete</code>也不会报错，但这个操作没什么用，且在严格模式下会抛出错误。）<br>在对未初始化的变量和对未声明的变量调用<code>typeof</code>时，返回的结果都是<code>&quot;undefined&quot;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// let age</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);     <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>从逻辑上讲，虽然严格来讲这两个变量存在根本性差异，但它对任何一个变量都不可能执行什么真正的操作。</p><blockquote><p><strong>注意</strong>即使未初始化的变量会被自动赋予<code>undefined</code>值，但建议在声明变量的同时进行初始化。这样，当<code>typeof</code>返回<code>&quot;undefined&quot;</code>时，会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p></blockquote><p><code>undefined</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为undefined</span></span><br><span class="line"><span class="comment">// age没有声明</span></span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="comment">// 这个块不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line">  <span class="comment">// 这个块会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line">  <span class="comment">// 这里会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3Null类型"><a href="#3-4-3Null类型" class="headerlink" title="3.4.3Null类型"></a>3.4.3<code>Null</code>类型</h3><p><code>Null</code>类型同样只有一个值，即特殊值<code>null</code>。逻辑上讲，<code>null</code>值表示一个空对象指针，这也是给<code>typeof</code>传一个<code>null</code>会返回<code>&quot;object&quot;</code>的原因：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> car);  <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>在定义将来要保存对象值的变量时，建议使用<code>null</code>来初始化，不要使用其他值。这样，只要检查这个变量的值是不是<code>null</code>就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// car是一个对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>undefined</code>值是由<code>null</code>值派生而来的，因此ECMA-262将它们定义为表面上相等。用等于操作符（<code>==</code>）会为了比较而转换它的操作数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>即使<code>null</code>和<code>undefined</code>有关系，它们的用途也是完全不一样的。只要变量要保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量。这样就可以保持<code>null</code>是空对象指针的语义，并进一步将其与<code>undefined</code>区分开来。<br><code>null</code>是一个假值。但也有很多其他可能的值同样是假值，所以一定要明确自己想检测的就是<code>undefined</code>这个字面值，而不仅仅是把它当假值使用。例子也如前面所示。</p><h3 id="3-4-4Boolean类型"><a href="#3-4-4Boolean类型" class="headerlink" title="3.4.4Boolean类型"></a>3.4.4<code>Boolean</code>类型</h3><p><code>Boolean</code>（布尔值）类型有两个字面值：<code>true</code>和<code>false</code>。这两个布尔值不同于数值，<code>true</code>不等于1，<code>false</code>不等于0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> lost = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>布尔值字面量<code>true</code>和<code>false</code>是区分大小写的，因此<code>True</code>和<code>False</code>（及其他大小混写形式）是有效的标识符，但不是布尔值。<br>虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。可以调用特定的<code>Boolean()</code>转型函数，将一个其他类型的值转换为布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure><p>在这个例子中，字符串<code>message</code>会被转换为布尔值并保存在变量<code>messageAsBoolean</code>中。<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为<code>true</code>或<code>false</code>的规则取决于数据类型和实际的值。<br>|数据类型|转换为true的值|转换为false的值|<br>|:—-|:—-|:—-|<br>|Boolean|true|false|<br>|String|非空字符串|””（空字符串）|<br>|Number|非零数值（包括无穷值）|0、NaN|<br>|Object|任意对象|null|<br>|Undefined|N/A（不存在）|undefined|</p><p><code>if</code>等流控制语句会自动执行其他类型值到布尔值的转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Value is true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。</p><h3 id="3-4-5Number类型"><a href="#3-4-5Number类型" class="headerlink" title="3.4.5Number类型"></a>3.4.5<code>Number</code>类型</h3><p><code>Number</code>类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p><p>最基本的数值字面量格式是十进制整数，直接写出来即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span>;  <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure><p>用八进制（以8为基数）字面量表示，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。<br>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。ECMAScript 2015或ES6中的八进制值通过前缀<code>0o</code>来表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>;  <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>;  <span class="comment">// 无效的八进制值，当成79处理</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span>;   <span class="comment">// 无效的八进制值，当成8处理</span></span><br></pre></td></tr></table></figure><p>整数也可以或十六进制（以16为基数）字面量表示。必须让真正的数值前缀<code>0x</code>（区分大小写），然后是十六进制数字（0<del>9以及A</del>F）。十六进制数字中的字母大小写均可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>;   <span class="comment">// 十六进制10</span></span><br><span class="line"><span class="keyword">let</span> hexNum2 = <span class="number">0x1f</span>;  <span class="comment">// 十六进制31</span></span><br></pre></td></tr></table></figure><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><blockquote><p><strong>注意</strong>由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的。</p><h4 id="3-4-5-1-浮点值"><a href="#3-4-5-1-浮点值" class="headerlink" title="3.4.5.1   浮点值"></a><strong>3.4.5.1   浮点值</strong></h4></blockquote><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">.1</span>;   <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span>;   <span class="comment">// 小数点后面没有数字，当成整数1处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">// 小数点后面是零，当成整数10处理</span></span><br></pre></td></tr></table></figure><p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure><p>科学记数法也可以用于表示非常小的数值。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为3e-7）。<br>浮点值的精确度最高可达17位小数，但在算术计算中不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123;      <span class="comment">// 别这么干！</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;You got 0.3.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个数值分别是0.05和0.25，或者0.15和0.15，没问题。但如果是0.1和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p><blockquote><p><strong>注意</strong>之所以存在这种舍入错误，是因为使用了IEEE 754数值。其他使用相同格式的语言也有这个问题。</p><h4 id="3-4-5-2-值的范围"><a href="#3-4-5-2-值的范围" class="headerlink" title="3.4.5.2   值的范围"></a><strong>3.4.5.2   值的范围</strong></h4></blockquote><p>由于内存的限制，ECMAScript可以表示的最小数值保存在<code>Number.MIN_VALUE</code>中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。</p><p>如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的<code>Infinity</code>（无穷）值。任何无法表示的负数以<code>-Infinity</code>（负无穷大）表示，任何无法表示的正数以<code>Infinity</code>（正无穷大）表示。</p><p>如果计算返回正<code>Infinity</code>或负<code>Infinity</code>，则该值将不能再进一步用于任何计算。这是因为<code>Infinity</code>没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用<code>isFinite()</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>使用<code>Number.NEGATIVE_INFINITY</code>和<code>Number.POSITIVE_INFINITY</code>也可以获取正、负<code>Infinity</code>。这两个属性包含的值分别就是<code>-Infinity</code>和<code>Infinity</code>。</p></blockquote><h4 id="3-4-5-3NaN"><a href="#3-4-5-3NaN" class="headerlink" title="3.4.5.3NaN"></a>3.4.5.3<code>NaN</code></h4><p>有一个特殊的数值叫<code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回<code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span>/+<span class="number">0</span>);  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>如果分子是非0值，分母是有符号0或无符号0，则会返回<code>Infinity</code>或<code>-Infinity</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/<span class="number">0</span>);   <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>/-<span class="number">0</span>);  <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><p><code>NaN</code>有几个独特的属性。首先，任何涉及<code>NaN</code>的操作始终返回<code>NaN</code>（如<code>NaN/10</code>），在连续多步计算时这可能是个问题。其次，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ECMAScript提供了<code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给<code>isNaN()</code>后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>));      <span class="comment">// false，10是数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>));    <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));    <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>虽然不常见，但<code>isNaN()</code>可以用于测试对象。首先会调用对象的<code>valueOf()</code>方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用<code>toString()</code>方法，并测试其返回值。这通常是ECMAScript内置函数和操作符的工作方式。</p><h4 id="3-4-5-4-数值转换"><a href="#3-4-5-4-数值转换" class="headerlink" title="3.4.5.4   数值转换"></a><strong>3.4.5.4   数值转换</strong></h4></blockquote><p>有3个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>和<code>parseFloat()</code>。<code>Number()</code>是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。</p><p><code>Number()</code>函数基于如下规则执行转换。</p><pre><code>1. 布尔值，`true`转换为1，`false`转换为0。2. 数值，直接返回。3. `null`，返回0。4. `undefined`，返回`NaN`。5. 字符串，应用以下规则。    1. 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，`Number(&quot;1&quot;)`返回1，`Number(&quot;123&quot;)`返回123，`Number(&quot;011&quot;)`返回11（忽略前面的零）。    2. 如果字符串包含有效的浮点值格式如`&quot;1.1&quot;`，则会转换为相应的浮点值（同样，忽略前面的零）。    3. 如果字符串包含有效的十六进制格式如`&quot;0xf&quot;`，则会转换为与该十六进制值对应的十进制整数值。    4. 如果是空字符串（不包含字符），则返回0。    5. 如果字符串包含除上述情况之外的其他字符，则返回`NaN`。6. 对象，调用`valueOf()`方法，并按照上述规则转换返回的值。如果转换结果是`NaN`，则调用`toString()`方法，再按照转换字符串的规则转换。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">Number</span>(<span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>);              <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">Number</span>(<span class="string">&quot;000011&quot;</span>);        <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);            <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>一元加操作符与<code>Number()</code>函数遵循相同的转换规则。</p></blockquote><p><code>Number()</code>函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用<code>parseInt()</code>函数。<code>parseInt()</code>函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code>立即返回<code>NaN</code>。这意味着空字符串也会返回<code>NaN</code>。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p><p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code>函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以<code>&quot;0x&quot;</code>开头，就会被解释为十六进制整数。如果字符串以<code>&quot;0&quot;</code>开头，且紧跟着数值字符，就会被解释为八进制整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>);          <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 10，解释为十六进制整数</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);        <span class="comment">// 22 因为小数点不是有效的整数字符</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>);        <span class="comment">// 70，解释为十进制值</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>);       <span class="comment">// 15，解释为十六进制整数</span></span><br></pre></td></tr></table></figure><p>不同的数值格式很容易混淆，因此<code>parseInt()</code>也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入16作为第二个参数，以便正确解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br></pre></td></tr></table></figure><p>事实上，如果提供了十六进制参数，那么字符串前面的<code>&quot;0x&quot;</code>可以省掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);  <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>);      <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>通过第二个参数，可以极大扩展转换后获得的结果类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>);   <span class="comment">// 2，按二进制解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);   <span class="comment">// 8，按八进制解析</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);  <span class="comment">// 10，按十进制解析</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>);  <span class="comment">// 16，按十六进制解析</span></span><br></pre></td></tr></table></figure><p>因为不传底数参数相当于让<code>parseInt()</code>自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p><blockquote><p><strong>注意</strong>多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。</p></blockquote><p><code>parseFloat()</code>函数的工作方式跟<code>parseInt()</code>函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p><p><code>parseFloat()</code>函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因为<code>parseFloat()</code>只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则<code>parseFloat()</code>返回整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>);  <span class="comment">// 1234，按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);       <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>);      <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>);   <span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0908.5&quot;</span>);    <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;3.125e7&quot;</span>);   <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure><h3 id="3-4-6String类型"><a href="#3-4-6String类型" class="headerlink" title="3.4.6String类型"></a>3.4.6<code>String</code>类型</h3><p><code>String</code>（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure><p>跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript语法中表示字符串的引号没有区别。并且以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&#x27;Nicholas&quot;; // 语法错误：开头和结尾的引号必须是同一种</span></span><br></pre></td></tr></table></figure><h4 id="3-4-6-1-字符字面量"><a href="#3-4-6-1-字符字面量" class="headerlink" title="3.4.6.1   字符字面量"></a><strong>3.4.6.1   字符字面量</strong></h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th align="left">字面量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\t</td><td align="left">制表</td></tr><tr><td align="left">\b</td><td align="left">退格</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\f</td><td align="left">换页</td></tr><tr><td align="left">\\</td><td align="left">反斜杠（\）</td></tr><tr><td align="left">&#39;</td><td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td></tr><tr><td align="left">&quot;</td><td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td></tr><tr><td align="left">\`</td><td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td></tr><tr><td align="left">\x<em>nn</em></td><td align="left">以十六进制编码<em>nn</em>表示的字符（其中<em>n</em>是十六进制数字0~F），例如\x41等于”A”</td></tr><tr><td align="left">\u<em>nnnn</em></td><td align="left">以十六进制编码<em>nnnn</em>表示的Unicode字符（其中<em>n</em>是十六进制数字0~F），例如\u03a3等于希腊字符”Σ”</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is the letter sigma: \u03a3.&quot;</span>;</span><br></pre></td></tr></table></figure><p>即使包含6个字符长的转义序列，变量<code>text</code>仍然是28个字符长。因为转义序列表示一个字符。<br>字符串的长度可以通过其<code>length</code>属性获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p></blockquote><h4 id="3-4-6-2字符串的特点"><a href="#3-4-6-2字符串的特点" class="headerlink" title="3.4.6.2字符串的特点"></a>3.4.6.2<strong>字符串的特点</strong></h4><p>ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-4-6-3-转换为字符串"><a href="#3-4-6-3-转换为字符串" class="headerlink" title="3.4.6.3   转换为字符串"></a><strong>3.4.6.3   转换为字符串</strong></h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的<code>toString()</code>方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.toString();      <span class="comment">// 字符串&quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.toString();  <span class="comment">// 字符串&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p><code>toString()</code>方法可见于数值、布尔值、对象和字符串值。（字符串值使用<code>toString()</code>方法只是简单地返回自身的一个副本。）<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法。<br>多数情况下，<code>toString()</code>不接收任何参数。但对数值调用这个方法时，<code>toString()</code>可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，<code>toString()</code>返回数值的十进制字符串表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());     <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));    <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));    <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));   <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));   <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>如果不确定一个值是不是<code>null</code>或<code>undefined</code>，可以使用<code>String()</code>转型函数，它始终会返回表示相应类型值的字符串。<code>String()</code>函数遵循如下规则。<br>    1. 如果值有<code>toString()</code>方法，则调用该方法（不传参数）并返回结果。<br>    2. 如果值是<code>null</code>，返回<code>&quot;null&quot;</code>。<br>    3. 如果值是<code>undefined</code>，返回<code>&quot;undefined&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> value4;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value1));  <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value2));  <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value3));  <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value4));  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>用加号操作符给一个值加上一个空字符串<code>&quot;&quot;</code>也可以将其转换为字符串。</p><h4 id="3-4-6-4-模板字面量（review）"><a href="#3-4-6-4-模板字面量（review）" class="headerlink" title="3.4.6.4   模板字面量（review）"></a><strong>3.4.6.4   模板字面量（review）</strong></h4></blockquote><p>ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineTemplateLiteral);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(myMultiLineString === myMultiLinetemplateLiteral); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>模板字面量在定义模板时特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pageHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;Jake&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br></pre></td></tr></table></figure><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意，格式正确的模板字符串可能反而会看起来缩进不当：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模板字面量在换行符之后有25个空格符</span></span><br><span class="line"><span class="keyword">let</span> myTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">                         second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myTemplateLiteral.length);  <span class="comment">// 47</span></span><br><span class="line"><span class="comment">// 这个模板字面量以一个换行符开头</span></span><br><span class="line"><span class="keyword">let</span> secondTemplateLiteral = <span class="string">`</span></span><br><span class="line"><span class="string">first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(secondTemplateLiteral[<span class="number">0</span>] === <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="3-4-6-5-字符串插值（review）"><a href="#3-4-6-5-字符串插值（review）" class="headerlink" title="3.4.6.5   字符串插值（review）"></a><strong>3.4.6.5   字符串插值（review）</strong></h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在<code>$&#123;&#125;</code>中使用一个JavaScript表达式实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedString =</span><br><span class="line">  value + <span class="string">&#x27; to the &#x27;</span> + exponent + <span class="string">&#x27; power is &#x27;</span> + (value * value);</span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral =</span><br><span class="line">  <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>;</span><br></pre></td></tr></table></figure><p>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; <span class="string">`World`</span> &#125;</span>!`</span>);  <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>将表达式转换为字符串时会调用<code>toString()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;World&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123; foo &#125;</span>!`</span>);      <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>在插值表达式中可以调用函数和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalize</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>模板也可以插入自己之前的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">append();  <span class="comment">// abc</span></span><br><span class="line">append();  <span class="comment">// abcabc</span></span><br><span class="line">append();  <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure><h4 id="3-4-6-6-模板字面量标签函数（review）"><a href="#3-4-6-6-模板字面量标签函数（review）" class="headerlink" title="3.4.6.6   模板字面量标签函数（review）"></a><strong>3.4.6.6   模板字面量标签函数（review）</strong></h4><p>模板字面量也支持定义<strong>标签函数</strong>（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p><p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="built_in">console</span>.log(aValExpression);</span><br><span class="line">  <span class="built_in">console</span>.log(bValExpression);</span><br><span class="line">  <span class="built_in">console</span>.log(sumExpression);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);   <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);     <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure><p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(expression);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);  <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure><p>对于有n个插值的模板字面量，传给标签函数的表达式参数的个数始终是n，而传给标签函数的第一个参数所包含的字符串个数则始终是n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zipTag</span>(<span class="params">strings, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strings[<span class="number">0</span>] +</span><br><span class="line">         expressions.map(<span class="function">(<span class="params">e, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;e&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">                    .join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> untaggedResult =    <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = zipTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult);  <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult);    <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-6-7-原始字符串-review"><a href="#3-4-6-7-原始字符串-review" class="headerlink" title="3.4.6.7   原始字符串(review)"></a><strong>3.4.6.7   原始字符串(review)</strong></h4><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的<code>String.raw</code>标签函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode示例</span></span><br><span class="line"><span class="comment">// \u00A9是版权符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>);            <span class="comment">// ©</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>);  <span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br><span class="line"><span class="comment">// 对实际的换行符来说是不行的</span></span><br><span class="line"><span class="comment">// 它们不会被转换成转义序列的形式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure><p>可以通过标签函数的第一个参数，即字符串数组的<code>.raw</code>属性取得每个字符串的原始内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRaw</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Actual characters:&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(string);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Escaped characters;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.raw) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rawString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure><h3 id="3-4-7Symbol类型"><a href="#3-4-7Symbol类型" class="headerlink" title="3.4.7Symbol类型"></a>3.4.7<code>Symbol</code>类型</h3><p><code>Symbol</code>（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><p>听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。</p><h4 id="3-4-7-1-符号的基本用法"><a href="#3-4-7-1-符号的基本用法" class="headerlink" title="3.4.7.1   符号的基本用法"></a><strong>3.4.7.1   符号的基本用法</strong></h4><p>符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型，所以<code>typeof</code>操作符对符号返回<code>symbol</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p>调用<code>Symbol()</code>函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是这个字符串参数与符号定义或标识完全无关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol == otherGenericSymbol);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol == otherFooSymbol);          <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，只要创建<code>Symbol()</code>实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(genericSymbol);  <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fooSymbol);      <span class="comment">// Symbol(foo);</span></span><br></pre></td></tr></table></figure><p><code>Symbol()</code>函数不能用作构造函数，与<code>new</code>关键字一起使用。这样是为了避免创建符号包装对象，像使用<code>Boolean</code>、<code>String</code>或<code>Number</code>那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myString);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myNumber);  <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>如果你确实想使用符号包装对象，可以借用<code>Object()</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="built_in">Object</span>(mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> myWrappedSymbol);   <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-2-使用全局符号注册表"><a href="#3-4-7-2-使用全局符号注册表" class="headerlink" title="3.4.7.2   使用全局符号注册表"></a><strong>3.4.7.2   使用全局符号注册表</strong></h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用<code>Symbol.for()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for()</code>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，就生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);       <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);  <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="built_in">console</span>.log(fooGlobalSymbol === otherFooGlobalSymbol);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用<code>Symbol()</code>定义的符号也不等同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给<code>Symbol.for()</code>的任何值都会被转换为字符串。注册表中使用的键同时也会被用作符号描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="built_in">Symbol</span>.for();</span><br><span class="line"><span class="built_in">console</span>.log(emptyGlobalSymbol);    <span class="comment">// Symbol(undefined)</span></span><br></pre></td></tr></table></figure><p>可以使用<code>Symbol.keyFor()</code>来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s));   <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果传给<code>Symbol.keyFor()</code>的不是符号，则该方法抛出<code>TypeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-3-使用符号作为属性-review"><a href="#3-4-7-3-使用符号作为属性-review" class="headerlink" title="3.4.7.3   使用符号作为属性(review)"></a><strong>3.4.7.3   使用符号作为属性(review)</strong></h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和<code>Object.defineProperty()</code>/<code>Object.definedProperties()</code>定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line">  [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">  [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val,</span></span><br><span class="line"><span class="comment">//  Symbol(baz): baz val, Symbol(qux): qux val&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组，<code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组。两个方法的返回值彼此互斥。<code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规和符号属性描述符的对象。<code>Reflect.ownKeys()</code>会返回两种类型的键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">  [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">  qux: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure><p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let o &#x3D; &#123;</span><br><span class="line">  [Symbol(&#39;foo&#39;)]: &#39;foo val&#39;,</span><br><span class="line">  [Symbol(&#39;bar&#39;)]: &#39;bar val&#39;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o);</span><br><span class="line">&#x2F;&#x2F; &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span><br><span class="line">let barSymbol &#x3D; Object.getOwnPropertySymbols(o)</span><br><span class="line">              .find((symbol) &#x3D;&gt; symbol.toString().match(&#x2F;bar&#x2F;));</span><br><span class="line">console.log(barSymbol);</span><br><span class="line">&#x2F;&#x2F; Symbol(bar)</span><br></pre></td></tr></table></figure><h4 id="3-4-7-4-常用内置符号"><a href="#3-4-7-4-常用内置符号" class="headerlink" title="3.4.7.4   常用内置符号"></a><strong>3.4.7.4   常用内置符号</strong></h4><p>ECMAScript 6引入了一批<strong>常用内置符号</strong>（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。它们以<code>Symbol</code>工厂函数字符串属性的形式存在。</p><p>内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道<code>for-of</code>循环会在相关对象上使用<code>Symbol.iterator</code>属性，那么就可以通过在自定义对象上重新定义<code>Symbol.iterator</code>的值，来改变<code>for-of</code>在迭代该对象时的行为。</p><p>这些内置符号也没有什么特别之处，它们就是全局函数<code>Symbol</code>的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p><blockquote><p><strong>注意</strong>在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为<code>@@</code>。比如，<code>@@iterator</code>指的就是<code>Symbol.iterator</code>。</p></blockquote><h4 id="3-4-7-5Symbol-asyncIterator（review）"><a href="#3-4-7-5Symbol-asyncIterator（review）" class="headerlink" title="3.4.7.5Symbol.asyncIterator（review）"></a><strong>3.4.7.5</strong><code>Symbol.asyncIterator（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的<code>AsyncIterator</code>，由<code>for-await-of</code>语句使用”。也就是这个符号表示实现异步迭代器API的函数。</p><p><code>for-await-of</code>循环会利用这个函数执行异步迭代操作。循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>AsyncGenerator</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.asyncIterator]());</span><br><span class="line"><span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>技术上，这个由<code>Symbol.asyncIterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回<code>Promise</code>实例。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过异步生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.asyncIdx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.asyncIdx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve(<span class="built_in">this</span>.asyncIdx++));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> <span class="function"><span class="title">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncCount();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong><code>Symbol.asyncIterator</code>是ES2018规范定义的，因此只有版本非常新的浏览器支持它。关于异步迭代和<code>for-await-of</code>循环的细节，参见附录A。</p></blockquote><h4 id="3-4-7-6Symbol-hasInstance"><a href="#3-4-7-6Symbol-hasInstance" class="headerlink" title="3.4.7.6Symbol.hasInstance"></a>3.4.7.6<code>Symbol.hasInstance</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用”。<code>instanceof</code>操作符可以用来确定一个对象实例的原型链上是否有原型。<code>instanceof</code>的典型使用场景如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在ES6中，<code>instanceof</code>操作符会使用<code>Symbol.hasInstance</code>函数来确定关系。以<code>Symbol.hasInstance</code>为键的函数会执行同样的操作，只是操作数对调了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](f)); <span class="comment">// true</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个属性定义在Function的原型上，因此默认在所有函数和类上都可以调用。由于instanceof操作符会在原型链上寻找这个属性定义，因此可以在继承的类上通过静态方法重新定义这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(Bar[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bar);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Baz[<span class="built_in">Symbol</span>.hasInstance](b)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Baz);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-7Symbol-isConcatSpreadable（review）"><a href="#3-4-7-7Symbol-isConcatSpreadable（review）" class="headerlink" title="3.4.7.7Symbol.isConcatSpreadable（review）"></a>3.4.7.7<code>Symbol.isConcatSpreadable（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是<code>true</code>，则对象应该用<code>Array.prototype.concat()</code>打平其数组元素”。ES6中的<code>Array.prototype.concat()</code>方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖<code>Symbol.isConcatSpreadable</code>的值可以修改这个行为。</p><p>数组对象默认情况下会被打平到已有的数组，<code>false</code>或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，<code>true</code>或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在<code>Symbol.isConcatSpreadable</code>被设置为<code>true</code>的情况下将被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(array));             <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line">arrayLikeObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(arrayLikeObject));             <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(initial.concat(otherObject));             <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-8Symbol-iterator（review）"><a href="#3-4-7-8Symbol-iterator（review）" class="headerlink" title="3.4.7.8Symbol.iterator（review）"></a>3.4.7.8<code>Symbol.iterator（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由<code>for-of</code>语句使用”。换句话说，这个符号表示实现迭代器API的函数。</p><p><code>for-of</code>循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以<code>Symbol.iterator</code>为键的函数，并默认这个函数会返回一个实现迭代器API的对象。很多时候，返回的对象是实现该API的<code>Generator</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f[<span class="built_in">Symbol</span>.iterator]());</span><br><span class="line"><span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>技术上，这个由<code>Symbol.iterator</code>函数生成的对象应该通过其<code>next()</code>方法陆续返回值。可以通过显式地调用<code>next()</code>方法返回，也可以隐式地通过生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">max</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.max = max;</span><br><span class="line">    <span class="built_in">this</span>.idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.idx &lt; <span class="built_in">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">this</span>.idx++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">count();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-9Symbol-match-（review）"><a href="#3-4-7-9Symbol-match-（review）" class="headerlink" title="3.4.7.9Symbol.match``（review）"></a>3.4.7.9<code>Symbol.match``（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用”。<code>String.prototype.match()</code>方法会使用以<code>Symbol.match</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]);</span><br><span class="line"><span class="comment">// f [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义<code>Symbol.match</code>函数以取代默认对正则表达式求值的行为，从而让<code>match()</code>方法使用非正则表达式实例。<code>Symbol.match</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooMatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(FooMatcher)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(FooMatcher)); <span class="comment">// false</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringMatcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.includes(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.match(<span class="keyword">new</span> StringMatcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-10Symbol-replace（review）"><a href="#3-4-7-10Symbol-replace（review）" class="headerlink" title="3.4.7.10Symbol.replace（review）"></a>3.4.7.10<code>Symbol.replace（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>方法使用”。<code>String.prototype.replace()</code>方法会使用以<code>Symbol.replace</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]);</span><br><span class="line"><span class="comment">// f [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.replace(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.replace</code>函数以取代默认对正则表达式求值的行为，从而让<code>replace()</code>方法使用非正则表达式实例。<code>Symbol.replace</code>函数接收两个参数，即调用<code>replace()</code>方法的字符串实例和替换字符串。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooReplacer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(FooReplacer, <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReplacer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str).join(replacement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.replace(<span class="keyword">new</span> StringReplacer(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-11Symbol-search（review）"><a href="#3-4-7-11Symbol-search（review）" class="headerlink" title="3.4.7.11Symbol.search（review）"></a>3.4.7.11<code>Symbol.search（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用”。<code>String.prototype.search()</code>方法会使用以<code>Symbol.search</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]);</span><br><span class="line"><span class="comment">// f [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.search</code>函数以取代默认对正则表达式求值的行为，从而让<code>search()</code>方法使用非正则表达式实例。<code>Symbol.search</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSearcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(FooSearcher)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(FooSearcher)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(FooSearcher)); <span class="comment">// -1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSearcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.indexOf(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoo&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barbaz&#x27;</span>.search(<span class="keyword">new</span> StringSearcher(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-12Symbol-species（review）"><a href="#3-4-7-12Symbol-species（review）" class="headerlink" title="3.4.7.12Symbol.species（review）"></a>3.4.7.12<code>Symbol.species（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用<code>Symbol.species</code>定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);   <span class="comment">// true</span></span><br><span class="line">bar = bar.concat(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(bar <span class="keyword">instanceof</span> Bar);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> Baz();</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// true</span></span><br><span class="line">baz = baz.concat(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(baz <span class="keyword">instanceof</span> Baz);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-13Symbol-split（review）"><a href="#3-4-7-13Symbol-split（review）" class="headerlink" title="3.4.7.13Symbol.split（review）"></a>3.4.7.13<code>Symbol.split（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用”。<code>String.prototype.split()</code>方法会使用以<code>Symbol.split</code>为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个<code>String</code>方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]);</span><br><span class="line"><span class="comment">// f [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foobarbaz&#x27;</span>.split(<span class="regexp">/bar/</span>));</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为<code>RegExp</code>对象。如果想改变这种行为，让方法直接使用参数，可以重新定义<code>Symbol.split</code>函数以取代默认对正则表达式求值的行为，从而让<code>split()</code>方法使用非正则表达式实例。<code>Symbol.split</code>函数接收一个参数，就是调用<code>match()</code>方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooSplitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(FooSplitter));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSplitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.str = str;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="built_in">this</span>.str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;barfoobaz&#x27;</span>.split(<span class="keyword">new</span> StringSplitter(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-14Symbol-toPrimitive（review）"><a href="#3-4-7-14Symbol-toPrimitive（review）" class="headerlink" title="3.4.7.14Symbol.toPrimitive（review）"></a>3.4.7.14<code>Symbol.toPrimitive（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的<code>Symbol.toPrimitive</code>属性上定义一个函数可以改变默认行为。</p><p>根据提供给这个函数的参数（<code>string</code>、<code>number</code>或<code>default</code>），可以控制返回的原始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo);       <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo);       <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo));   <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;string bar&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;default bar&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + bar);     <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - bar);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-15Symbol-toStringTag（review）"><a href="#3-4-7-15Symbol-toStringTag（review）" class="headerlink" title="3.4.7.15Symbol.toStringTag（review）"></a>3.4.7.15<code>Symbol.toStringTag（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用”。</p><p>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s);                      <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toString());           <span class="comment">// [object Set]</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Set</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo);                      <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString());           <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// undefined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="built_in">console</span>.log(bar);                      <span class="comment">// Bar &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString());           <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="built_in">Symbol</span>.toStringTag]);  <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-16Symbol-unscopables（review）"><a href="#3-4-7-16Symbol-unscopables（review）" class="headerlink" title="3.4.7.16Symbol.unscopables（review）"></a>3.4.7.16<code>Symbol.unscopables（review）</code></h4><p>根据ECMAScript规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的<code>with</code>环境绑定中排除”。设置这个符号并让其映射对应属性的键值为<code>true</code>，就可以阻止该属性出现在<code>with</code>环境绑定中，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">  foo: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>不推荐使用<code>with</code>，因此也不推荐使用<code>Symbol.unscopables</code>。</p></blockquote><h3 id="3-4-8Object类型"><a href="#3-4-8Object类型" class="headerlink" title="3.4.8Object类型"></a>3.4.8<code>Object</code>类型</h3><p>ECMAScript中的对象其实就是一组数据和功能的集合。对象通过<code>new</code>操作符后跟对象类型的名称来创建。开发者可以通过创建<code>Object</code>类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>这个语法类似Java，但ECMAScript只要求在给构造函数提供参数时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure><p><code>Object</code>的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java中的<code>java.lang.Object</code>，ECMAScript中的<code>Object</code>也是派生其他对象的基类。<code>Object</code>类型的所有属性和方法在派生的对象上同样存在。<br>每个<code>Object</code>实例都有如下属性和方法。</p><ul><li><code>constructor</code>：用于创建当前对象的函数。</li><li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如<code>o.hasOwnProperty(&quot;name&quot;)</code>）。</li><li><code>isPrototypeof(object)</code>：用于判断当前对象是否为另一个对象的原型。</li><li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用<code>for-in</code>语句枚举。与<code>hasOwnProperty()</code>一样，属性名必须是字符串。</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li></ul><p>因为在ECMAScript中<code>Object</code>是所有对象的基类，所以任何对象都有这些属性和方法。</p><blockquote><p><strong>注意</strong>严格来讲，ECMA-262中对象的行为不一定适合JavaScript中的其他对象。比如浏览器环境中的BOM和DOM对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ECMA-262约束，所以它们可能会也可能不会继承<code>Object</code>。</p></blockquote><h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5　操作符"></a>3.5　操作符</h2><p>ECMA-262描述了一组可用于操作数据值的<strong>操作符</strong>，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用<code>valueOf()</code>和<code>/</code>或<code>toString()</code>方法来取得可以计算的值。</p><h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1　一元操作符"></a>3.5.1　一元操作符</h3><p>只操作一个值的操作符叫<strong>一元操作符</strong>（unary operator），是ECMAScript中最简单的操作符。</p><h4 id="3-5-1-1-递增-递减操作符"><a href="#3-5-1-1-递增-递减操作符" class="headerlink" title="3.5.1.1   递增/递减操作符"></a><strong>3.5.1.1   递增/递减操作符</strong></h4><p>递增和递减操作符有两个版本：前缀版和后缀版。前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p><p>前缀递增操作符会给数值加1，把两个加号（<code>++</code>）放到变量前头即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">++age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>前缀递减操作符也类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">--age;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//28</span></span><br></pre></td></tr></table></figure><p>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有<strong>副作用</strong>。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);         <span class="comment">// 28</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherAge);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = --num1 + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>递增和递减的后缀版语法一样（分别是<code>++</code>和<code>--</code>），只不过要放在变量后面。后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。某些情况下，这种差异没影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line">age++;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2;</span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(num3);  <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num4);  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>这4个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。<br>    1. 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。<br>    2. 对于字符串，如果不是有效的数值形式，则将变量的值设置为<code>NaN</code>。变量类型从字符串变成数值。<br>    3. 对于布尔值，如果是<code>false</code>，则转换为0再应用改变。变量类型从布尔值变成数值。<br>    4. 对于布尔值，如果是<code>true</code>，则转换为1再应用改变。变量类型从布尔值变成数值。<br>    5. 对于浮点值，加1或减1。<br>    6. 如果是对象，则调用其<code>valueOf()</code>方法取得可以操作的值。对得到的值应用上述规则。如果是<code>NaN</code>，则调用<code>toString()</code>并再次应用其他规则。变量类型从对象变成数值。</p><p>下面的例子演示了这些规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++;  <span class="comment">// 值变成数值3</span></span><br><span class="line">s2++;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b++;   <span class="comment">// 值变成数值1</span></span><br><span class="line">f--;   <span class="comment">// 值变成0.10000000000000009（因为浮点数不精确）</span></span><br><span class="line">o--;   <span class="comment">// 值变成-2</span></span><br></pre></td></tr></table></figure><h4 id="3-5-1-2-一元加和减"><a href="#3-5-1-2-一元加和减" class="headerlink" title="3.5.1.2   一元加和减"></a><strong>3.5.1.2   一元加和减</strong></h4><p><strong>一元加和减操作符</strong>在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（<code>+</code>）表示，放在变量前头，对数值没有任何影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = +num;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>如果将一元减应用到非数值，则会执行与使用<code>Number()</code>转型函数一样的类型转换：布尔值<code>false</code>和<code>true</code>转换为0和1，字符串根据特殊规则进行解析，对象会调用它们的<code>valueOf()</code>和/或<code>toString()</code>方法以得到可以转换的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;  <span class="comment">// 值变成数值1</span></span><br><span class="line">s2 = +s2;  <span class="comment">// 值变成数值1.1</span></span><br><span class="line">s3 = +s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = +b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = +f;    <span class="comment">// 不变，还是1.1</span></span><br><span class="line">o = +o;    <span class="comment">// 值变成数值-1</span></span><br></pre></td></tr></table></figure><p>一元减由一个减号（<code>-</code>）表示，放在变量前头，主要用于把数值变成负值，如把1转换为-1。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// -25</span></span><br></pre></td></tr></table></figure><p>在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = -s1;  <span class="comment">// 值变成数值-1</span></span><br><span class="line">s2 = -s2;  <span class="comment">// 值变成数值-1.1</span></span><br><span class="line">s3 = -s3;  <span class="comment">// 值变成NaN</span></span><br><span class="line">b = -b;    <span class="comment">// 值变成数值0</span></span><br><span class="line">f = -f;    <span class="comment">// 变成-1.1</span></span><br><span class="line">o = -o;    <span class="comment">// 值变成数值1</span></span><br></pre></td></tr></table></figure><p>一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。</p><h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2　位操作符"></a>3.5.2　位操作符</h3><p>ECMAScript中的所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位。对开发者而言，就好像只有32位整数一样，因为64位整数存储格式是不可见的。但这个转换也导致了一个奇特的副作用，即特殊值<code>NaN</code>和<code>Infinity</code>在位操作中都会被当成0处理。</p><p>如果将位操作符应用到非数值，那么首先会自动使用<code>Number()</code>函数将该值转换为数值，然后再应用位操作。最终结果是数值。要注意的是，在处理有符号整数时，我们无法访问第31位。</p><p>在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = -<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// &quot;-10010&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>默认情况下，ECMAScript中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第32位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p><h4 id="3-5-2-1-按位非"><a href="#3-5-2-1-按位非" class="headerlink" title="3.5.2.1   按位非"></a><strong>3.5.2.1   按位非</strong></h4></blockquote><p>按位非操作符用波浪符（<code>~</code>）表示，它的作用是返回数值的一补数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;      <span class="comment">// 二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1;   <span class="comment">// 二进制11111111111111111111111111100110</span></span><br><span class="line"><span class="built_in">console</span>.log(num2);  <span class="comment">// -26</span></span><br></pre></td></tr></table></figure><p>由此可以看出，按位非的最终效果是对数值取反并减1，就像执行如下操作的结果一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = -num1 - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2);   <span class="comment">// &quot;-26&quot;</span></span><br></pre></td></tr></table></figure><p>尽管两者返回的结果一样，但位操作的速度快得多。因为位操作是在数值的底层表示上完成的。</p><h4 id="3-5-2-2-按位与"><a href="#3-5-2-2-按位与" class="headerlink" title="3.5.2.2   按位与"></a><strong>3.5.2.2   按位与</strong></h4><p>按位与操作符用和号（<code>&amp;</code>）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p><p>|第一个数值的位|第二个数值的位|结果|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|1|1|1|<br>|1|0|0|<br>|0|1|0|<br>|0|0|0|</p><p>下面看一个例子，我们对数值25和3求与操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>看下面的二进制计算过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure><p>如上所示，25和3的二进制表示中，只有第0位上的两个数都是1。于是结果数值的所有其他位都会以0填充，因此结果就是1。</p><h4 id="3-5-2-3-按位或"><a href="#3-5-2-3-按位或" class="headerlink" title="3.5.2.3   按位或"></a><strong>3.5.2.3   按位或</strong></h4><p>按位或操作符用管道符（<code>|</code>）表示，同样有两个操作数。按位或遵循如下真值表：</p><table><thead><tr><th align="left">第一个数值的位</th><th align="left">第二个数值的位</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>仍然用按位与的示例，如果对25和3执行按位或，代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>可见25和3的按位或操作的结果是27：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line"> OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure><p>在参与计算的两个数中，有4位都是1，因此它们直接对应到结果上。二进制码11011等于27。</p><h4 id="3-5-2-4-按位异或"><a href="#3-5-2-4-按位异或" class="headerlink" title="3.5.2.4   按位异或"></a><strong>3.5.2.4   按位异或</strong></h4><p>按位异或用脱字符（<code>^</code>）表示，同样有两个操作数。下面是按位异或的真值表：</p><table><thead><tr><th align="left">第一个数的位</th><th align="left">第二个数的位</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">1</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table><p>对数值25和3执行按位异或操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let result &#x3D; 25 ^ 3;</span><br><span class="line">console.log(result); &#x2F;&#x2F; 26</span><br></pre></td></tr></table></figure><p>可见，25和3的按位异或操作结果为26，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">---------------------------------------------</span><br><span class="line">XOR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure><h4 id="3-5-2-5-左移"><a href="#3-5-2-5-左移" class="headerlink" title="3.5.2.5   左移"></a><strong>3.5.2.5   左移</strong></h4><p>左移操作符用两个小于号（<code>&lt;&lt;</code>）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值2（二进制10）向左移5位，就会得到64（二进制1000000），如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;              <span class="comment">// 等于二进制10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>;  <span class="comment">// 等于二进制1000000，即十进制64</span></span><br></pre></td></tr></table></figure><p>注意在移位后，数值右端会空出5位。左移会以0填充这些空位，让结果是完整的32位数值（见图3-2）。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/Wo1bzsOAa2BZFYH.png"                      alt="b7qdJi277GnnBKhO__thumbnail.png"                ></p><p>左移会保留它所操作数值的符号。比如，如果-2左移5位，将得到-64，而不是正64。</p><h4 id="3-5-2-6-有符号右移"><a href="#3-5-2-6-有符号右移" class="headerlink" title="3.5.2.6   有符号右移"></a><strong>3.5.2.6   有符号右移</strong></h4><p>有符号右移由两个大于号（<code>&gt;&gt;</code>）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;             <span class="comment">// 等于二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;  <span class="comment">// 等于二进制10，即十进制2</span></span><br></pre></td></tr></table></figure><p>同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图3-3）。ECMAScript会用符号位的值来填充这些空位，以得到完整的数值。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/zdWytfUcQuvbgSJ.png"                      alt="lfyDtLTtly9xPjgW__thumbnail.png"                ></p><h4 id="3-5-2-7-无符号右移"><a href="#3-5-2-7-无符号右移" class="headerlink" title="3.5.2.7   无符号右移"></a><strong>3.5.2.7   无符号右移</strong></h4><p>无符号右移用3个大于号表示（<code>&gt;&gt;&gt;</code>），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同。</p><p>对于负数，有时候差异会非常大。右移会给空位补0，而不管符号位是什么。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = -<span class="number">64</span>;              <span class="comment">// 等于二进制11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;   <span class="comment">// 等于十进制134217726</span></span><br></pre></td></tr></table></figure><h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3　布尔操作符"></a>3.5.3　布尔操作符</h3><p>布尔操作符一共有3个：逻辑非、逻辑与和逻辑或。</p><h4 id="3-5-3-1-逻辑非"><a href="#3-5-3-1-逻辑非" class="headerlink" title="3.5.3.1   逻辑非"></a><strong>3.5.3.1   逻辑非</strong></h4><p>逻辑非操作符由一个叹号（<code>!</code>）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。</p><pre><code>1. 如果操作数是对象，则返回`false`。2. 如果操作数是空字符串，则返回`true`。3. 如果操作数是非空字符串，则返回`false`。4. 如果操作数是数值0，则返回`true`。5. 如果操作数是非0数值（包括`Infinity`），则返回`false`。6. 如果操作数是`null`，则返回`true`。7. 如果操作数是`NaN`，则返回`true`。8. 如果操作数是`undefined`，则返回`true`。</code></pre><p>以下示例验证了上述行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;blue&quot;</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">&quot;&quot;</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">12345</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（<code>!!</code>），相当于调用了转型函数<code>Boolean()</code>。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用<code>Boolean()</code>函数是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;blue&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">12345</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="3-5-3-2-逻辑与"><a href="#3-5-3-2-逻辑与" class="headerlink" title="3.5.3.2   逻辑与"></a><strong>3.5.3.2   逻辑与</strong></h4><p>逻辑与操作符由两个和号（<code>&amp;&amp;</code>）表示，应用到两个值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>逻辑与操作符遵循如下真值表：<br>|第一个操作数|第二个操作数|结果|<br>|:—-|:—-|:—-|<br>|true|true|true|<br>|true|false|false|<br>|false|true|false|<br>|false|false|false|</p><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。</p><pre><code>1. 如果第一个操作数是对象，则返回第二个操作数。2. 如果第二个操作数是对象，则只有第一个操作数求值为`true`才会返回该对象。3. 如果两个操作数都是对象，则返回第二个操作数。4. 如果有一个操作数是`null`，则返回`null`。5. 如果有一个操作数是`NaN`，则返回`NaN`。6. 如果有一个操作数是`undefined`，则返回`undefined`。</code></pre><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是<code>false</code>，那么无论第二个操作数是什么值，结果也不可能等于<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable); <span class="comment">// 这里会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 不会执行这一行</span></span><br></pre></td></tr></table></figure><p>假如变量<code>found</code>的值是<code>false</code>，那么就不会报错了：</p><h4 id="3-5-3-3-逻辑或"><a href="#3-5-3-3-逻辑或" class="headerlink" title="3.5.3.3   逻辑或"></a><strong>3.5.3.3   逻辑或</strong></h4><p>逻辑或操作符由两个管道符（<code>||</code>）表示，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="literal">true</span> || <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>逻辑或操作符遵循如下真值表：<br>|第一个操作数|第二个操作数|结果|<br>|:—-|:—-|:—-|<br>|true|true|true|<br>|true|false|true|<br>|false|true|true|<br>|false|false|false|</p><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。</p><pre><code>1. 如果第一个操作数是对象，则返回第一个操作数。2. 如果第一个操作数求值为`false`，则返回第二个操作数。3. 如果两个操作数都是对象，则返回第一个操作数。4. 如果两个操作数都是`null`，则返回`null`。5. 如果两个操作数都是`NaN`，则返回`NaN`。6. 如果两个操作数都是`undefined`，则返回`undefined`。</code></pre><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为<code>true</code>，第二个操作数就不会再被求值了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable); <span class="comment">// 不会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure><p>利用这个行为，可以避免给变量赋值<code>null</code>或<code>undefined</code>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = preferredObject || backupObject;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量<code>myObject</code>会被赋予两个值中的一个。其中，<code>preferredObject</code>变量包含首选的值，<code>backupObject</code>变量包含备用的值。如果<code>preferredObject</code>不是<code>null</code>，则它的值就会赋给<code>myObject</code>；如果<code>preferredObject</code>是<code>null</code>，则<code>backupObject</code>的值就会赋给<code>myObject</code>。这种模式在ECMAScript代码中经常用于变量赋值。</p><h3 id="3-5-4-乘性操作符"><a href="#3-5-4-乘性操作符" class="headerlink" title="3.5.4　乘性操作符"></a>3.5.4　乘性操作符</h3><p>ECMAScript定义了3个乘性操作符：乘法、除法和取模。这些操作符跟它们在Java、C语言及Perl中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用<code>Number()</code>转型函数转换为数值。这意味着空字符串会被当成0，而布尔值<code>true</code>会被当成1。</p><h4 id="3-5-4-1-乘法操作符"><a href="#3-5-4-1-乘法操作符" class="headerlink" title="3.5.4.1   乘法操作符"></a><strong>3.5.4.1   乘法操作符</strong></h4><p>乘法操作符由一个星号（<code>*</code>）表示，可以用于计算两个数值的乘积。其语法类似于C语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">34</span> * <span class="number">56</span>;</span><br></pre></td></tr></table></figure><p>乘法操作符在处理特殊值时也有一些特殊的行为。</p><ol><li>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果ECMAScript不能表示乘积，则返回<code>Infinity</code>或<code>-Infinity</code>。</li><li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li><li>如果是<code>Infinity</code>乘以0，则返回<code>NaN</code>。</li><li>如果是<code>Infinity</code>乘以非0的有限数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li><li>如果是<code>Infinity</code>乘以<code>Infinity</code>，则返回<code>Infinity</code>。</li><li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-2-除法操作符"><a href="#3-5-4-2-除法操作符" class="headerlink" title="3.5.4.2   除法操作符"></a><strong>3.5.4.2   除法操作符</strong></h4></li></ol><p>除法操作符由一个斜杠（<code>/</code>）表示，用于计算第一个操作数除以第二个操作数的商，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">66</span> / <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>除法操作符针对特殊值也有一些特殊的行为。</p><ol><li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回<code>Infinity</code>或<code>-Infinity</code>。</li><li>如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。</li><li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li><li>如果是0除以0，则返回<code>NaN</code>。</li><li>如果是非0的有限值除以0，则根据第一个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li><li>如果是<code>Infinity</code>除以任何数值，则根据第二个操作数的符号返回<code>Infinity</code>或<code>-Infinity</code>。</li><li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h4 id="3-5-4-3-取模操作符-reivew"><a href="#3-5-4-3-取模操作符-reivew" class="headerlink" title="3.5.4.3   取模操作符(reivew)"></a><strong>3.5.4.3   取模操作符(reivew)</strong></h4></li></ol><p>取模（余数）操作符由一个百分比符号（<code>%</code>）表示，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">26</span> % <span class="number">5</span>; <span class="comment">// 等于1</span></span><br></pre></td></tr></table></figure><p>取模操作符对特殊值也有一些特殊的行为。</p><ol><li>如果操作数是数值，则执行常规除法运算，返回余数。</li><li>如果被除数是无限值，除数是有限值，则返回<code>NaN</code>。</li><li>如果被除数是有限值，除数是0，则返回<code>NaN</code>。</li><li>如果是<code>Infinity</code>除以<code>Infinity</code>，则返回<code>NaN</code>。</li><li>如果被除数是有限值，除数是无限值，则返回被除数。</li><li>如果被除数是0，除数不是0，则返回0。</li><li>如果有不是数值的操作数，则先在后台用<code>Number()</code>将其转换为数值，再应用上述规则。<h3 id="3-5-5-指数操作符"><a href="#3-5-5-指数操作符" class="headerlink" title="3.5.5　指数操作符"></a>3.5.5　指数操作符</h3></li></ol><p>ECMAScript 7新增了指数操作符，<code>Math.pow()</code>现在有了自己的操作符<code>**</code>，结果是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>);         <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>指数操作符也有自己的指数赋值操作符<code>**=</code>，该操作符执行指数运算和结果的赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared **= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h3 id="3-5-6-加性操作符"><a href="#3-5-6-加性操作符" class="headerlink" title="3.5.6　加性操作符"></a>3.5.6　加性操作符</h3><p>加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。但在ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p><h4 id="3-5-6-1-加法操作符（review）"><a href="#3-5-6-1-加法操作符（review）" class="headerlink" title="3.5.6.1   加法操作符（review）"></a><strong>3.5.6.1   加法操作符（review）</strong></h4><p>加法操作符（<code>+</code>）用于求两个数的和，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：<br>    1. 如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>；<br>    2. 如果是<code>Infinity</code>加<code>Infinity</code>，则返回<code>Infinity</code>；<br>    3. 如果是<code>-Infinity</code>加<code>-Infinity</code>，则返回<code>-Infinity</code>；<br>    4. 如果是<code>Infinity</code>加<code>-Infinity</code>，则返回<code>NaN</code>；<br>    5. 如果是<code>+0</code>加<code>+0</code>，则返回<code>+0</code>；<br>    6. 如果是<code>-0</code>加<code>+0</code>，则返回<code>+0</code>；<br>    7. 如果是<code>-0</code>加<code>-0</code>，则返回<code>-0</code>。</p><p>不过，如果有一个操作数是字符串，则要应用如下规则：</p><pre><code>1. 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</code></pre><p>如果有任一操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法以获取字符串，然后再应用前面的关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则调用<code>String()</code>函数，分别获取<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> + <span class="number">5</span>;        <span class="comment">// 两个数值</span></span><br><span class="line"><span class="built_in">console</span>.log(result1);       <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;      <span class="comment">// 一个数值和一个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);       <span class="comment">// &quot;55&quot;</span></span><br></pre></td></tr></table></figure><p>ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(message);  <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br></pre></td></tr></table></figure><p>这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值，结果是一个字符串。第二次加法仍然是用一个字符串去加一个数值，同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + (num1 + num2);</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;The sum of 5 and 10 is 15&quot;</span></span><br></pre></td></tr></table></figure><p>在此，我们用括号把两个数值变量括了起来，意思是让解释器先执行两个数值的加法，然后再把结果追加给字符串。因此，最终得到的字符串变成了<code>&quot;The sum of 5 and 10 is 15&quot;</code>。</p><h4 id="3-5-6-2-减法操作符-review"><a href="#3-5-6-2-减法操作符-review" class="headerlink" title="3.5.6.2   减法操作符(review)"></a><strong>3.5.6.2   减法操作符(review)</strong></h4><p>减法操作符（<code>-</code>）也是使用很频繁的一种操作符，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。<br>    1. 如果两个操作数都是数值，则执行数学减法运算并返回结果。<br>    2. 如果有任一操作数是<code>NaN</code>，则返回<code>NaN</code>。<br>    3. 如果是<code>Infinity</code>减<code>Infinity</code>，则返回<code>NaN</code>。<br>    4. 如果是<code>-Infinity</code>减<code>-Infinity</code>，则返回<code>NaN</code>。<br>    5. 如果是<code>Infinity</code>减<code>-Infinity</code>，则返回<code>Infinity</code>。<br>    6. 如果是<code>-Infinity</code>减<code>Infinity</code>，则返回<code>-Infinity</code>。<br>    7. 如果是<code>+0</code>减<code>+0</code>，则返回<code>+0</code>。<br>    8. 如果是<code>+0</code>减<code>-0</code>，则返回<code>-0</code>。<br>    9. 如果是<code>-0</code>减<code>-0</code>，则返回<code>+0</code>。<br>    10. 如果有任一操作数是字符串、布尔值、<code>null</code>或<code>undefined</code>，则先在后台使用<code>Number()</code>将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。<br>    11. 如果有任一操作数是对象，则调用其<code>valueOf()</code>方法取得表示它的数值。如果该值是<code>NaN</code>，则减法计算的结果是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法，然后再将得到的字符串转换为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> - <span class="literal">true</span>; <span class="comment">// true被转换为1，所以结果是4</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> - <span class="number">1</span>;  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> - <span class="number">3</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;   <span class="comment">// &quot;&quot;被转换为0，所以结果是5</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;  <span class="comment">// &quot;2&quot;被转换为2，所以结果是3</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// null被转换为0，所以结果是5</span></span><br></pre></td></tr></table></figure><h3 id="3-5-7-关系操作符"><a href="#3-5-7-关系操作符" class="headerlink" title="3.5.7　关系操作符"></a>3.5.7　关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）和大于等于（<code>&gt;=</code>）。这几个操作符都返回布尔值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ul><li>如果操作数都是数值，则执行数值比较。</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li><li>如果有任一操作数是对象，则调用其<code>valueOf()</code>方法，取得结果后再根据前面的规则执行比较。如果没有<code>valueOf()</code>操作符，则调用<code>toString()</code>方法，取得结果后再根据前面的规则执行比较。</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li></ul><p>在使用关系操作符比较两个字符串时，很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span> &lt; <span class="string">&quot;alphabet&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式，然后再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;Brick&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alphabet&quot;</span>.toLowerCase(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>另一个奇怪的现象是在比较两个数值字符串的时候，比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符<code>&quot;2&quot;</code>的编码是50，而字符<code>&quot;3&quot;</code>的编码是51）。如果有一个操作数是数值，那么比较的结果就对了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;23&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>只要是数值和字符串比较，字符串就会先被转换为数值，然后进行数值比较。对于数值字符串而言，这样能保证结果正确。<br>如果字符串不能转换成数值呢？比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// 因为&quot;a&quot;会转换为NaN，所以结果是false</span></span><br></pre></td></tr></table></figure><p>因为字符<code>&quot;a&quot;</code>不能转换成任何有意义的数值，所以只能转换为<code>NaN</code>。这里有一个规则，即任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="3-5-8-相等操作符"><a href="#3-5-8-相等操作符" class="headerlink" title="3.5.8　相等操作符"></a>3.5.8　相等操作符</h3><p>判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是<strong>等于</strong>和<strong>不等于</strong>，它们在比较之前执行转换。第二组是<strong>全等</strong>和<strong>不全等</strong>，它们在比较之前不执行转换。</p><h4 id="3-5-8-1-等于和不等于"><a href="#3-5-8-1-等于和不等于" class="headerlink" title="3.5.8.1   等于和不等于"></a><strong>3.5.8.1   等于和不等于</strong></h4><p>ECMAScript中的等于操作符用两个等于号（<code>==</code>）表示，如果操作数相等，则会返回<code>true</code>。不等于操作符用叹号和等于号（<code>!=</code>）表示，如果两个操作数不相等，则会返回<code>true</code>。这两个操作符都会先进行类型转换（通常称为<strong>强制类型转换</strong>）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p><ol><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。</li><li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的<code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较。</li></ol><p>在进行比较时，这两个操作符会遵循如下规则。</p><ol><li><code>null</code>和<code>undefined</code>相等。</li><li><code>null</code>和<code>undefined</code>不能转换为其他类型的值再进行比较。</li><li>如果有任一操作数是<code>NaN</code>，则相等操作符返回<code>false</code>，不相等操作符返回<code>true</code>。记住：即使两个操作数都是<code>NaN</code>，相等操作符也返回<code>false</code>，因为按照规则，<code>NaN</code>不等于<code>NaN</code>。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code>true</code>。否则，两者不相等。</li></ol><p>下表总结了一些特殊情况及比较的结果。</p><table><thead><tr><th align="left">表达式</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">null == undefined</td><td align="left">true</td></tr><tr><td align="left">“NaN” == NaN</td><td align="left">false</td></tr><tr><td align="left">5 == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN != NaN</td><td align="left">true</td></tr><tr><td align="left">false == 0</td><td align="left">true</td></tr><tr><td align="left">true == 1</td><td align="left">true</td></tr><tr><td align="left">true == 2</td><td align="left">false</td></tr><tr><td align="left">undefined == 0</td><td align="left">false</td></tr><tr><td align="left">null == 0</td><td align="left">false</td></tr><tr><td align="left">“5” == 5</td><td align="left">true</td></tr></tbody></table><h4 id="3-5-8-2-全等和不全等"><a href="#3-5-8-2-全等和不全等" class="headerlink" title="3.5.8.2   全等和不全等"></a><strong>3.5.8.2   全等和不全等</strong></h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由3个等于号（<code>===</code>）表示，只有两个操作数在不转换的前提下相等才返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>);  <span class="comment">// true，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure><p>不全等操作符用一个叹号和两个等于号（<code>!==</code>）表示，只有两个操作数在不转换的前提下不相等才返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> != <span class="number">55</span>);  <span class="comment">// false，转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> !== <span class="number">55</span>); <span class="comment">// true，不相等，因为数据类型不同</span></span><br></pre></td></tr></table></figure><p>另外虽然<code>null == undefined</code>是<code>true</code>（因为这两个值类似），但<code>null === undefined</code>是<code>false</code>，因为它们不是相同的数据类型。</p><blockquote><p><strong>注意</strong>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p></blockquote><h3 id="3-5-9-条件操作符"><a href="#3-5-9-条件操作符" class="headerlink" title="3.5.9　条件操作符"></a>3.5.9　条件操作符</h3><p>条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = (num1 &gt; num2) ? num1 : num2;</span><br></pre></td></tr></table></figure><h3 id="3-5-10-赋值操作符"><a href="#3-5-10-赋值操作符" class="headerlink" title="3.5.10　赋值操作符"></a>3.5.10　赋值操作符</h3><p>简单赋值用等于号（<code>=</code>）表示，将右手边的值赋给左手边的变量，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>复合赋值使用乘性、加性或位操作符后跟等于号（<code>=</code>）表示。这些赋值操作符是类似如下常见赋值操作的简写形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num = num + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>以上代码的第二行可以通过复合赋值来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p><ul><li>乘后赋值（<code>*=</code>）</li><li>除后赋值（<code>/=</code>）</li><li>取模后赋值（<code>%=</code>）</li><li>加后赋值（<code>+=</code>）</li><li>减后赋值（<code>-=</code>）</li><li>左移后赋值（<code>&lt;&lt;=</code>）</li><li>右移后赋值（<code>&gt;&gt;=</code>）</li><li>无符号右移后赋值（<code>&gt;&gt;&gt;=</code>）</li></ul><p>这些操作符仅仅是简写语法，使用它们不会提升性能。</p><h3 id="3-5-11-逗号操作符"><a href="#3-5-11-逗号操作符" class="headerlink" title="3.5.11　逗号操作符"></a>3.5.11　逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num的值为0</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>num</code>将被赋值为0，因为0是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</p><h2 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6　语句"></a>3.6　语句</h2><p>ECMA-262描述了一些语句（也称为<strong>流控制语句</strong>），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p><h3 id="3-6-1if语句"><a href="#3-6-1if语句" class="headerlink" title="3.6.1if语句"></a>3.6.1<code>if</code>语句</h3><p><code>if</code>语句是使用最频繁的语句之一，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的最佳实践是使用语句块，即使只有一行代码要执行也是如此。这是因为语句块可以避免对什么条件下执行什么产生困惑。可以像这样连续使用多个<code>if</code>语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Greater than 25.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-2do-while语句"><a href="#3-6-2do-while语句" class="headerlink" title="3.6.2do-while语句"></a>3.6.2<code>do-while</code>语句</h3><p><code>do-while</code>语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。<code>do-while</code>的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>后测试循环经常用于这种情形：循环体内代码在退出前至少要执行一次。</p></blockquote><h3 id="3-6-3while语句"><a href="#3-6-3while语句" class="headerlink" title="3.6.3while语句"></a>3.6.3<code>while</code>语句</h3><p><code>while</code>语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code>循环体内的代码有可能不会执行。下面是<code>while</code>循环的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-4for语句"><a href="#3-6-4for语句" class="headerlink" title="3.6.4for语句"></a>3.6.4<code>for</code>语句</h3><p><code>for</code>语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for</code>循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用<code>let</code>声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。<br>初始化、条件表达式和循环后表达式都不是必需的。因此可以创建一个无穷循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无穷循环</span></span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只包含条件表达式，那么<code>for</code>循环实际上就变成了<code>while</code>循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; count; ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无法通过<code>while</code>循环实现的逻辑，同样也无法使用<code>for</code>循环实现。因此<code>for</code>循环只是将循环相关的代码封装在了一起而已。</p><h3 id="3-6-5for-in语句"><a href="#3-6-5for-in语句" class="headerlink" title="3.6.5for-in语句"></a>3.6.5<code>for-in</code>语句</h3><p><code>for-in</code>语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里控制语句中的<code>const</code>也不是必需的。但为确保这个局部变量不被修改，推荐使用<code>const</code>。<br>ECMAScript中对象的属性是无序的，因此<code>for-in</code>语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果<code>for-in</code>循环要迭代的变量是<code>null</code>或<code>undefined</code>，则不执行循环体。</p><h3 id="3-6-6for-of语句（review）"><a href="#3-6-6for-of语句（review）" class="headerlink" title="3.6.6for-of语句（review）"></a>3.6.6<code>for-of</code>语句（review）</h3><p><code>for-of</code>语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for-of</code>循环会按照可迭代对象的<code>next()</code>方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则<code>for-of</code>语句会抛出错误。</p><blockquote><p><strong>注意</strong>ES2018对<code>for-of</code>语句进行了扩展，增加了<code>for-await-of</code>循环，以支持生成期约（promise）的异步可迭代对象。。</p></blockquote><h3 id="3-6-7-标签语句"><a href="#3-6-7-标签语句" class="headerlink" title="3.6.7　标签语句"></a>3.6.7　标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start</code>是一个标签，可以在后面通过<code>break</code>或<code>continue</code>语句引用。标签语句的典型应用场景是嵌套循环。</p><h3 id="3-6-8break和continue语句"><a href="#3-6-8break和continue语句" class="headerlink" title="3.6.8break和continue语句"></a>3.6.8<code>break</code>和<code>continue</code>语句</h3><p><code>break</code>和<code>continue</code>语句为执行循环代码提供了更严格的控制手段。其中，<code>break</code>语句用于立即退出循环，强制执行循环后的下一条语句。而<code>continue</code>语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><p><code>break</code>与标签语句一起使用，返回代码中特定的位置。通常是在嵌套循环中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><p>添加标签不仅让<code>break</code>退出（使用变量<code>j</code>）的内部循环，也会退出（使用变量<code>i</code>）的外部循环。<code>continue</code>语句也可以使用标签，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure><p><code>continue</code>语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当<code>i</code>和<code>j</code>都等于5时，会执行<code>continue</code>，跳到外部循环继续执行。<br>组合使用标签语句和<code>break</code>、<code>continue</code>能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><h3 id="3-6-9with语句（review）"><a href="#3-6-9with语句（review）" class="headerlink" title="3.6.9with语句（review）"></a>3.6.9<code>with</code>语句（review）</h3><p><code>with</code>语句的用途是将代码作用域设置为特定的对象，主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利,其语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br></pre></td></tr></table></figure><p>上面代码中的每一行都用到了<code>location</code>对象。如果使用<code>with</code>语句，就可以少写一些代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">location</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>with</code>语句用于连接<code>location</code>对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索<code>location</code>对象，看它是否有一个同名的属性。如果有，则该变量会被求值为<code>location</code>对象的属性。<br>严格模式不允许使用<code>with</code>语句，否则会抛出错误。</p><blockquote><p><strong>警告</strong>由于<code>with</code>语句影响性能且难于调试其中的代码，通常不推荐使用<code>with</code>语句。</p></blockquote><h3 id="3-6-10switch语句"><a href="#3-6-10switch语句" class="headerlink" title="3.6.10switch语句"></a>3.6.10<code>switch</code>语句</h3><p><code>switch</code>语句是与<code>if</code>语句紧密相关的一种流控制语句，每个<code>case</code>（条件/分支）相当于：“如果表达式等于后面的值，则执行下面的语句。”<code>break</code>关键字会导致代码执行跳出<code>switch</code>语句。如果没有<code>break</code>，则代码会继续匹配下一个条件。<code>default</code>关键字用于在任何条件都没有满足时指定默认执行的语句（相当于<code>else</code>语句）。</p><p>为避免不必要的条件判断，最好给每个条件后面都加上<code>break</code>语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了<code>break</code>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">    <span class="comment">/*跳过*/</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;25 or 35&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>switch</code>语句是从其他语言借鉴过来的，但ECMAScript为它赋予了一些独有的特性。首先<code>switch</code>语句可以用于所有数据类型。其次，条件的值不需要是常量，也可以是变量或表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 0 and 10.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Between 10 and 20.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;More than 20.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong><code>switch</code>语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型</p></blockquote><h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7　函数"></a>3.7　函数</h2><p>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用<code>function</code>关键字声明，后跟一组参数，然后是函数体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是调用函数<code>sayHi()</code>的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHi(<span class="string">&quot;Nicholas&quot;</span>, <span class="string">&quot;how are you today?&quot;</span>);</span><br></pre></td></tr></table></figure><p>ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用<code>return</code>语句来返回函数的值，用法是后跟要返回的值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>return</code>语句之外没有任何特殊声明表明该函数有返回值。然后就可以这样调用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = sum(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>只要碰到<code>return</code>语句，函数会立即停止执行并退出。因此<code>return</code>语句后的代码不会被执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);  <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数里也可以有多个<code>return</code>语句，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">    <span class="keyword">return</span> num2 - num1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return</code>语句也可以不带返回值。这时候，函数会立即停止执行并返回<code>undefined</code>。这种用法最常用于提前终止函数执行，并不是为了返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。</p></blockquote><p>严格模式对函数也有一些限制：</p><ul><li>函数不能以<code>eval</code>或<code>arguments</code>作为名称；</li><li>函数的参数不能叫<code>eval</code>或<code>arguments</code>；</li><li>两个函数的参数不能叫同一个名称。</li></ul><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p><h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8　小结"></a>3.8　小结</h2><p>JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。</p><ul><li>ECMAScript中的基本数据类型包括<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbol</code>。</li><li>与其他语言不同，ECMAScript不区分整数和浮点值，只有<code>Number</code>一种数值数据类型。</li><li><code>Object</code>是一种复杂数据类型，它是这门语言中所有对象的基类。</li><li>严格模式为这门语言中某些容易出错的部分施加了限制。</li><li>ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。</li><li>这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如<code>if</code>语句、<code>for</code>语句和<code>switch</code>语句等。</li></ul><p>ECMAScript中的函数与其他语言中的函数不一样。</p><ul><li>不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。</li><li>不指定返回值的函数实际上会返回特殊值<code>undefined</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-语法&quot;&gt;&lt;a href=&quot;#3-1-语法&quot; class=&quot;headerlink&quot; title=&quot;3.1　语法&quot;&gt;&lt;/a&gt;3.1　语法&lt;/h2&gt;&lt;h3 id=&quot;3-1-1-区分大小写&quot;&gt;&lt;a href=&quot;#3-1-1-区分大小写&quot; class=&quot;header</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    <category term="03-语言基础" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/03-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>15-实体和编码</title>
    <link href="http://example.com/2021/01/23/note/HTTP/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2021/01/23/note/HTTP/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/</id>
    <published>2021-01-23T11:00:09.002Z</published>
    <updated>2021-03-08T02:56:33.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-1-报文是箱子，实体是货物"><a href="#15-1-报文是箱子，实体是货物" class="headerlink" title="15.1 报文是箱子，实体是货物"></a>15.1 报文是箱子，实体是货物</h2><p>报文实体由实体首部和实体主体组成的。首部字段以一个空白的CRLF行结束，随后就是实体主体的原始内容。任何其他描述性的信息都包含在实体首部中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/cnoa3xepd6bS4Nf.png"                      alt="YuTjZHTRjDigxdVP__thumbnail.png"                ></p><h2 id="15-2-Content-Length：实体的大小"><a href="#15-2-Content-Length：实体的大小" class="headerlink" title="15.2 Content-Length：实体的大小"></a>15.2 Content-Length：实体的大小</h2><p>Content-Length首部指示出报文中实体主体的字节大小，包含了所有内容编码的。Content-Length首部就是带有实体主体的报文必须使用的，除非使用了分块编码。使用Content-Length首部能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段。</p><h3 id="15-2-1-检测截尾"><a href="#15-2-1-检测截尾" class="headerlink" title="15.2.1 检测截尾"></a>15.2.1 检测截尾</h3><p>HTTP的早期版本采用关闭连接的办法来划定报文的结束。但客户端无法区分是正常的连接关闭，还是由于服务器崩溃而导致的连接关闭。</p><p>客户端需要通过Content-Length来检测报文截尾。尤其对缓存代理服务器来说，如果收到被截尾的报文却没有识别出截尾的话，它可能会存储不完整的内容并多次使用它来提供服务。</p><p>缓存代理服务器通常不会为没有显式Content-Length首部的HTTP主体做缓存，以此来减小缓存已截尾报文的风险。</p><h3 id="15-2-2-错误的Content-Length"><a href="#15-2-2-错误的Content-Length" class="headerlink" title="15.2.2 错误的Content-Length"></a>15.2.2 错误的Content-Length</h3><p>错误的Content-Length比缺少Content-Length还要糟糕。因此有些客户端、服务器以及代理中就包含特别的算法，用来检测和纠正与有缺陷服务器的交互过程。HTTP/1.1规定用户Agent代理应该在接收且检测到无效长度时通知用户。</p><h3 id="15-2-3-Content-Length与持久连接"><a href="#15-2-3-Content-Length与持久连接" class="headerlink" title="15.2.3 Content-Length与持久连接"></a>15.2.3 Content-Length与持久连接</h3><p>因为如果响应通过持久连接传送，客户端无法依赖连接关闭来判别报文的结束，因此客户端通过Content-Length首部知道报文在何处结束，下一 条报文从何处开始。</p><p>采用<strong>分块编码</strong>（chunked encoding），使用持久连接时可以没有Content-Length首部。在分块编码的情况下，数据是分为一系列的块来发送的，每块都有大小说明。</p><h3 id="15-2-4-内容编码"><a href="#15-2-4-内容编码" class="headerlink" title="15.2.4 内容编码"></a>15.2.4 内容编码</h3><p>HTTP允许对实体主体的内容进行编码，可以使之更安全或进行压缩以节省空间。如果主体进行了内容编码，Content-Length说明的就是编码后主体的字节长度，而不是原始主体的长度。</p><h3 id="15-2-5-确定实体主体长度的规则"><a href="#15-2-5-确定实体主体长度的规则" class="headerlink" title="15.2.5 确定实体主体长度的规则"></a>15.2.5 确定实体主体长度的规则</h3><p>下面列出的规则说明了在若干不同的情况下如何正确计算主体的长度和结束位置，规则按顺序应用，谁先匹配就用谁：</p><ol><li>如果特定的HTTP报文类型中不允许带有主体，就忽略Content-Length首部，它是对实际上没有发送出来的主体进行计算的。这种情况下，Content-Length首部是提示性的，并不说明实际的主体长度。</li><li>如果报文中有描述传输编码的Transfer-Encoding首部（不采用默认的HTTP“恒等”编码），那实体就应由一个称为“零字节块”（zero-byte chunk）的特殊模式结束，除非报文已经因连接关闭而结束。</li><li>如果报文中有Content-Length首部且报文类型允许有实体主体，而且没有非恒等的Transfer-Encoding首部字段，那么Content-Length的值就是主体的长度。如果收到的报文中Content-Length和Transfer-Encoding首部字段都有，就必须忽略Content-Length，因为传输编码会改变实体主体的表示和传输方式。从而可能就会改变传输的字节数。</li><li>如果报文使用了multipart/byteranges（多部分/字节范围）媒体类型，并且没有用Content-Length首部指出实体主体的长度，那么多部分报文中的每个部分都要说明自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型。</li><li>如果上面的规则都不匹配，实体就在连接关闭的时候结束。只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应。</li></ol><p>为了和使用HTTP/1.0的应用程序兼容，任何带有实体主体的HTTP/1.1请求都必须带有正确的Content-Length首部字段，除非知道服务器兼容HTTP/1.1。对于带有主体但没有Content-Length首部的请求，服务器就应当发送400 Bad Request响应或411 Length Required响应。.</p><h2 id="15-3-实体摘要"><a href="#15-3-实体摘要" class="headerlink" title="15.3 实体摘要"></a>15.3 实体摘要</h2><p>发送方可以在生成初始的主体时，生成一个数据的校验和，接收方就可以通过检查这个校验和来检测实体主体的数据是否被修改。</p><p>Content-MD5首部是发送对实体主体运行MD5算法的结果，只有产生响应的原始服务器可以计算并发送。中间代理和缓存不应当修改或添加这个首部，否则就会与验证端到端完整性的这个最终目的相冲突。</p><p>Content-MD5首部是在对内容做了所有需要的内容编码之后，还没有做传输编码前，计算出来的。为了验证报文的完整性，客户端必须先进行传输编码的解码，然后计算所得到的未进行传输编码的实体主体的MD5。</p><p>除了检查报文的完整性之外，MD5还可以当作散列表的关键字，用来快速定位文档并消除不必要的重复内容存储。</p><p>作为对HTTP的扩展，增加新的Want-Digest首部，它允许客户端说明期望响应中使用的摘要类型，并使用质量值来建议多种摘要算法并说明优先顺序。</p><h2 id="15-4-媒体类型和字符集"><a href="#15-4-媒体类型和字符集" class="headerlink" title="15.4 媒体类型和字符集"></a>15.4 媒体类型和字符集</h2><p>Content-Type首部字段说明实体主体的MIME类型。MIME类型是标准化的名字，用以说明运载实体的基本媒体类型。客户端应用程序使用MIME类型来解释和处理其内容。Content-Type的值是标准化的MIME类型，在互联网号码分配机构（Internet Assigned Numbers Authority，简称IANA）中注册。</p><p>MIME类型由一个主媒体类型后面跟一条斜线以及一个子类型组成，子类型用于进一步描述媒体类型。</p><p>Content-Type首部说明的是原始实体主体的媒体类型。实体经过内容编码的话，Content-Type首部说明的仍是编码之前的实体主体的类型。，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/jnyXQHRc4t2gT3U.png"                      alt="Hgvet3LTBs7pzFpx__thumbnail.png"                ></p><h3 id="15-4-1-文本的字符编码"><a href="#15-4-1-文本的字符编码" class="headerlink" title="15.4.1 文本的字符编码"></a>15.4.1 文本的字符编码</h3><p>Content-Type首部还支持可选的参数来进一步说明内容的类型。比如charset（字符集）参数，说明把实体中的比特转换为文本文件中的字符的方法：Content-Type：text/html；</p><h3 id="15-4-2-多部分媒体类型"><a href="#15-4-2-多部分媒体类型" class="headerlink" title="15.4.2 多部分媒体类型"></a>15.4.2 多部分媒体类型</h3><p>MIME中的multipart（多部分）电子邮件报文中包含多个报文，它们一起作为复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同的部分之间用分界字符串连接。</p><p>HTTP也支持多部分主体。通常只用在下列两种情形之一：</p><ol><li>多部分表格提交，HTTP使用<strong>Content-Type：multipart/form-data</strong>或<strong>Content-Type：multipart/mixed</strong>首部以及多部分主体来发送这种请求，e.g. Content-Type：multipart/form-data；boundary=[abc]，其中的boundary参数说明了分割主体中不同部分所用的字符串。</li><li>作为承载若干文档片段的范围响应。HTTP对范围请求的响应也可以是多部分的，这样的响应中有<strong>Content-Type：multipart/byteranges</strong>首部和带有不同范围的多部分主体。<h2 id="15-5-内容编码"><a href="#15-5-内容编码" class="headerlink" title="15.5 内容编码"></a>15.5 内容编码</h2></li></ol><p>HTTP应用程序有时在发送之前对内容进行编码，有助于减少传输实体的时间，还可以把内容搅乱或加密，以此来防止未经授权的第三方看到文档的内容。这种类型的编码是在发送方应用到内容之上的。</p><h3 id="15-5-1-内容编码过程"><a href="#15-5-1-内容编码过程" class="headerlink" title="15.5.1 内容编码过程"></a>15.5.1 内容编码过程</h3><p>内容编码的过程如下所述：</p><ol><li>网站服务器生成原始响应报文，其中有原始的Content-Type和Content-Length首部。</li><li>内容编码服务器（也可能就是原始的服务器或下行的代理）创建编码后的报文。编码后的报文有同样的Content-Type，但Content-Length可能不同，在编码后的报文中增加Content-Encoding首部，这样接收的应用程序就可以进行解码。</li><li>接收程序得到编码后的报文，进行解码，获得原始报文。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/ny5FQBflWuTLOAi.png"                      alt="wfXRqxnk1BEU33wW__thumbnail.png"                ></p><h3 id="15-5-2-内容编码类型"><a href="#15-5-2-内容编码类型" class="headerlink" title="15.5.2 内容编码类型"></a>15.5.2 内容编码类型</h3><p>HTTP定义了一些标准的内容编码类型，并允许用扩展编码的形式增添更多的编码。由互联网号码分配机构（IANA）对各种编码进行标准化，它给每个内容编码算法分配了唯一的代号。Content-Encoding首部就用这些标准化的代号来说明编码时使用的算法。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/z2TfyUgZSmcl75A.png"                      alt="Bd5Wji9r83iXfpN0__thumbnail.png"                ></p><h3 id="15-5-3-Accept-Encoding首部"><a href="#15-5-3-Accept-Encoding首部" class="headerlink" title="15.5.3 Accept-Encoding首部"></a>15.5.3 Accept-Encoding首部</h3><p>为了避免服务器使用客户端不支持的编码方式，客户端就把自己支持的内容编码方式列表放在请求的Accept-Encoding首部里发出去。如果HTTP请求中没有包含Accept-Encoding首部，服务器就可以假设客户端能够接受任何编码方式。</p><p>客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q值范围从0.0到1.0，0.0说明客户端不想接受所说明的编码，1.0则表明最希望使用的编码。*表示“任何其他方法”。</p><p>identity编码代号只能在Accept-Encoding首部中出现，客户端用它来说明相对于其他内容编码算法的优先级。</p><h2 id="15-6-传输编码和分块编码"><a href="#15-6-传输编码和分块编码" class="headerlink" title="15.6 传输编码和分块编码"></a>15.6 传输编码和分块编码</h2><p>传输编码也是作用在实体主体上的可逆变换，使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/qlKXONDHRMSLdmr.png"                      alt="KmJHDOGZldzZmjDu__thumbnail.png"                ></p><h3 id="15-6-1-可靠传输"><a href="#15-6-1-可靠传输" class="headerlink" title="15.6.1 可靠传输"></a>15.6.1 可靠传输</h3><p>在HTTP协议中，底层的传输设施已经标准化且容错性好，只有少数情况下，所传输的报文主体可能会引发问题：</p><ol><li><strong>未知的尺寸</strong>。如果不先生成内容，某些网关应用程序和内容编码器无法确定报文主体的最终大小，所以它们希望在知道大小前就开始传输数据。因为HTTP协议要求Content-Length首部必须在数据之前，所以使用传输编码来发送数据，并用特别的结束脚注表明数据结束。</li><li><strong>安全性</strong>。可以用传输编码来把报文内容扰乱，然后在共享的传输网络上发送。但由于像SSL这样的传输层安全体系，很少需要靠传输编码来实现安全性。<h3 id="15-6-2-Transfer-Encoding首部"><a href="#15-6-2-Transfer-Encoding首部" class="headerlink" title="15.6.2 Transfer-Encoding首部"></a>15.6.2 Transfer-Encoding首部</h3></li></ol><p>用来描述和控制传输编码的两个首部:</p><ol><li>Transfer-Encoding。告知接收方为了可靠地传输报文，已经对其进行了何种编码。</li><li>TE。用在请求首部中，告知服务器可以使用哪些传输编码扩展。</li></ol><p>HTTP规范只定义了一种传输编码，就是分块编码（chunked）。TE首部也可以使用Q值来说明传输编码的优先顺序，但禁止设为0.0。</p><h3 id="15-6-3-分块编码"><a href="#15-6-3-分块编码" class="headerlink" title="15.6.3 分块编码"></a>15.6.3 分块编码</h3><p>分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。</p><p>分块编码是一种传输编码，因此是报文的属性，而不是主体的属性。而多部分编码，是主体的属性，它和分块编码是完全独立的。</p><h4 id="15-6-3-1-分块与持久连接"><a href="#15-6-3-1-分块与持久连接" class="headerlink" title="15.6.3.1 分块与持久连接"></a>15.6.3.1 分块与持久连接</h4><p>若客户端和服务器之间不是持久连接，客户端就不需要知道主体的长度，而只需要读到服务器关闭主体连接为止。否则必须加上Content-Length首部发送。</p><p>但如果服务器动态创建内容，就可能在发送之前无法知道主体的长度，于是通过分块编码解决。服务器可以用大小为0的块作为主体结束的信号，来继续保持连接，为下一个响应做准备。</p><p>客户端也可以发送分块的数据给服务器。因为客户端事先不知道服务器是否接受分块编码（因为客户端才会发送TE首部），所以客户端必须做好服务器用411 Length Required响应来拒绝分块请求的准备。</p><p>分块编码报文的基本结构：它由起始的HTTP响应首部块开始，随后是一系列分块。每个分块包含一个长度值和该分块的数据。长度值是十六进制形式并将CRLF与数据分隔开。分块中数据的大小以字节计算，不包括长度值与数据之间的CRLF序列以及分块结尾的CRLF序列。最后一个块长度值为0，表示“主体结束”。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/yqf1AQakN5l3EWL.png"                      alt="QefkJBLxwkzvePyF__thumbnail.png"                ></p><h4 id="15-6-3-2-分块报文的拖挂"><a href="#15-6-3-2-分块报文的拖挂" class="headerlink" title="15.6.3.2 分块报文的拖挂"></a>15.6.3.2 分块报文的拖挂</h4><p>只有客户端的TE首部中说明可以接受拖挂，才在分块的报文最后加上。产生原始响应的服务器也可以在分块的报文最后加上拖挂。</p><p>拖挂的内容是可选的元数据，客户端不一定需要理解和使用（甚至可以忽略并丢弃拖挂中的内容）。拖挂中可以包含附带的首部字段，它们的值在报文开始的时候可能是无法确定的。比如Content-MD5 ，在文档生成之前很难算出它的MD5。</p><p>报文首部中包含一个Trailer首部，列出了跟在分块报文之后的首部列表，除了Transfer-Encoding、Trailer 以及Content-Length首部之外，其他HTTP首部都可以作为拖挂发送，这些首部紧接在最后一个分块之后。</p><h3 id="15-6-4-内容编码与传输编码的结合"><a href="#15-6-4-内容编码与传输编码的结合" class="headerlink" title="15.6.4 内容编码与传输编码的结合"></a>15.6.4 内容编码与传输编码的结合</h3><p>内容编码与传输编码可以同时使用。接收方“重构”主体的过程和发送方相反。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/t1bpNjzZSgG4XVv.png"                      alt="R2V1NNz6yChk86Tq__thumbnail.png"                ></p><h3 id="15-6-5-传输编码的规则"><a href="#15-6-5-传输编码的规则" class="headerlink" title="15.6.5 传输编码的规则"></a>15.6.5 传输编码的规则</h3><p>对报文主体使用传输编码时，必须遵守以下规则，使得接收方能够确定报文的传输长度：</p><ol><li>传输编码集合中必须包括“分块”，唯一例外是使用关闭连接来结束报文。</li><li>当使用分块传输编码时，它必须是最后一个作用到报文主体之上的。</li><li>分块传输编码不能多次作用到一个报文主体上。</li></ol><p>实现传输编码的服务器必须意不把经传输编码后的报文发送给非HTTP/1.1的应用程序。否则如果服务器收到无法理解的经过传输编码的报文，用501 Unimplemented状态码来回复。</p><h2 id="15-7-随时间变化的实例"><a href="#15-7-随时间变化的实例" class="headerlink" title="15.7 随时间变化的实例"></a>15.7 随时间变化的实例</h2><p>网站对象并不是静态的。同样的URL会随着时间变化而指向对象的不同版，也就是实例。</p><p>HTTP协议规定了称为<strong>实例操控</strong>（instance manipulations）的一系列请求和响应操作，用以操控对象的实例。两个主要的实例操控方法是范围请求和差异编码。这两种方法都要求客户端能够标识它所拥有（如果有的话）的资源的特定副本，并在一定的条件下请求新的实例。</p><h2 id="15-8-验证码和新鲜度"><a href="#15-8-验证码和新鲜度" class="headerlink" title="15.8 验证码和新鲜度"></a>15.8 验证码和新鲜度</h2><p>当文档在客户端“过期”之后（客户端不认为该副本有效），客户端须从服务器请求一份新副本。如果该文档在服务器上并未改变，客户端也就不需要再接收，继续使用缓存的副本即可。</p><p>这种特殊的请求，称为<strong>有条件的请求</strong>（conditional request），要求客户端使用验证码</p><p>（validator）来告知服务器它当前拥有的版本号，并仅当它当前副本无效才要求发送新的副本。</p><h3 id="15-8-1-新鲜度"><a href="#15-8-1-新鲜度" class="headerlink" title="15.8.1 新鲜度"></a>15.8.1 新鲜度</h3><p>服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。服务器可以用Expires（过期）和Cache-Control（缓存控制）来提供这种信息。</p><p>同时服务器和客户端不仅都可以用Cache-Control来说明新鲜度，并且除了使用期或过期时间之外，还有很多指令可用。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/ysK29bnJzuWZOcB.png"                      alt="m7VrGBnCBAIpGjwd__thumbnail.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/zUOXlkoVYQ3txPF.png"                      alt="27woIO882zhDrUbJ__thumbnail.png"                ></p><h3 id="15-8-2-有条件的请求与验证码"><a href="#15-8-2-有条件的请求与验证码" class="headerlink" title="15.8.2 有条件的请求与验证码"></a>15.8.2 有条件的请求与验证码</h3><p>当原始服务器上的文档与缓存中已过期的副本相同，而缓存服务器还是要从原始服务器上取文档的话，那缓存服务器就是在浪费网络带宽，给缓存服务器和原始服务器增加不必要的负载。</p><p>解决方案：仅当资源改变时才请求副本，这种特殊请求称为有条件的请求，仅当某个特定条件为真时才执行，如果条件不满足，服务器就发回一个HTTP错误码。</p><p>每个有条件的请求都通过特定的验证码来发挥作用。验证码是文档实例的特殊属性，用它来测试条件是否为真。可以把验证码看作文件的序列号、版本号，或者最后发生改变的日期时间。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/2kSovtqjD1YQaNu.png"                      alt="ZOLwYk7M1G3NhugX__thumbnail.png"                ></p><p>HTTP把验证码分为两类：<strong>弱验证码</strong>（weak validators）和<strong>强验证码</strong>（strong validators）。</p><p>弱验证码不一定能唯一标识资源的一个实例，而强验证码可以。</p><p>弱验证码：</p><ol><li>字节计数验证码，可能资源的内容改变了，而大小还保持不变，资源内容的加密校验和就是强验证码，文档改变时总是会变。</li><li>最后修改时间，因为它的描述精度最大就是1秒。资源可能在1秒内可以改变很多次。</li></ol><p>强验证码：ETag首部被当作强验证码，因为每当资源内容改变时，服务器都可以在ETag首部放置不同的值。ETag首部很灵活，它可以带上任意的文本值，这样就可以设计出各种各样的客户端和服务器验证策略。版本号和摘要校验是很好的ETag首部候选，但不能带有任意的文本。</p><p>有时候，不想在缓存服务器再验证时产生很大的传输流量，就需要采用不那么精确的实体标记验证方法。服务器可以在标记前加上”W/“前缀来广播一个“弱”实体标记。对于弱实体标记来说，只有当关联的实体在语义上发生了重大改变时，标记才变化。而强实体标记只要内容变化，标记都一定会改变。</p><h2 id="15-9-范围请求"><a href="#15-9-范围请求" class="headerlink" title="15.9 范围请求"></a>15.9 范围请求</h2><p>范围请求允许客户端实际上只请求文档的一部分。比如HTTP客户端可以通过请求曾获取失败的实体的一个范围，来恢复下载该实体。前提是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象没有改变过。</p><p>可以使用Range：bytes=4000-这种形式的范围请求，因为请求方可能不知道文档的大小。还可以用Range首部来请求多个范围（可以按任意顺序给出，也可以相互重叠）。因为客户端可以同时连接多个服务器下载同一个文档的不同部分。</p><p>对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有一个多部分主体及Content-Type：multipart/byteranges 首部。</p><p>不是所有服务器都接受范围请求，服务器可以通过在响应中包含Accept-Ranges首部的形式向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，规范中只定义了bytes 记号，但具体实现可以用服务器和客户端自己认定的单位来衡量或切分实体。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/A2MzCgNQdYvInuW.png"                      alt="W7dJGGZkH5D2R8X5__thumbnail.png"                ></p><p>Range首部在流行的<strong>点对点</strong>（Peer-to-Peer，P2P）文件共享客户端软件中得到广泛应用，它们从不同的对等实体同时下载多媒体文件的不同部分。</p><p>范围请求属于实例操控，因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是客户端的范围请求仅当客户端和服务器拥有文档的同一个版本时才有意义。</p><h2 id="15-10-差异编码"><a href="#15-10-差异编码" class="headerlink" title="15.10 差异编码"></a>15.10 差异编码</h2><p>差异编码通过交换对象改变的部分而不是完整的对象来优化传输性能。差异编码也属于实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。</p><p>客户端必须告诉服务器现有资源的版本，是否接受资源最新版的差异（delta），知道将差异应用于现有版本的哪些算法。</p><p>服务器必须检查客户端是否有这个资源现有版本，通过算法计算客户端资源现有版本与新版之间的差异，然后发送给客户端，告知客户端所发送的是差异，并说明新资源的（ETag），因为客户端将差异应用于其老版本之后就会得到这个版本。</p><p>如果客户端想告诉服务器接受资源的差异，就发送A-IM（Accept-Instance-Manipulation）首部，而不用发送完整的资源。在A-IM首部中，客户端说明知道哪些算法可以把差异应用于老版本而得到最新版本。</p><p>服务端发送的是一个特殊的响应代码一226 IM Used，告知客户端它正在发送的是所请求对象的实例操控，而不是完整的对象。IM（Instance-Manipulation）首部，说明用于计算差异的算法，还有新的ETag首部，以及Delta-Base首部，说明用于计算差异的基线文档的ETag。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/a6SjMEOpBYmCJHl.png"                      alt="1zeEzzzA7jllslxR__thumbnail.png"                ></p><p>客户端用A-IM首部说明可以接受的一些实例操控的类型。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/wRvzhJaXt6FPfme.png"                      alt="l9MCr1VSHCxu3wQi__thumbnail.png"                ></p><p>服务器侧的<strong>差异生成器</strong>根据基线文档和该文档的最新实例，并用客户端在A-IM首部中指明的算法计算它们之间的差异。客户端侧的<strong>差异应用器</strong>得到差异，将其应用于基线文档，得到文档的最新实例。</p><p>在返回给客户端之前，文档可以经过多种实例操控，这样可以获得最大程度的压缩。例如，用vcdiff算法产生的差异后可以再用gzip算法压缩。</p><p>差异编码可以减少传输次数，但支持差异编码的服务器必须保存资源的所有不同版本，才能计算新版本与所请求的客户端持有的现有版本之间的差异。这样服务器必须增加磁盘空间来保存文档的各种旧的实例，可能反而得不偿失。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/wtf3A2NQOVrXn8U.png"                      alt="Ttoo45eBe0QpTIHZ__thumbnail.png"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;15-1-报文是箱子，实体是货物&quot;&gt;&lt;a href=&quot;#15-1-报文是箱子，实体是货物&quot; class=&quot;headerlink&quot; title=&quot;15.1 报文是箱子，实体是货物&quot;&gt;&lt;/a&gt;15.1 报文是箱子，实体是货物&lt;/h2&gt;&lt;p&gt;报文实体由实体首部和实体主体</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="15-实体和编码" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/15-%E5%AE%9E%E4%BD%93%E5%92%8C%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>08-集成点：网关、隧道及中继</title>
    <link href="http://example.com/2021/01/23/note/HTTP/08-%E9%9B%86%E6%88%90%E7%82%B9%EF%BC%9A%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93%E5%8F%8A%E4%B8%AD%E7%BB%A7/"/>
    <id>http://example.com/2021/01/23/note/HTTP/08-%E9%9B%86%E6%88%90%E7%82%B9%EF%BC%9A%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93%E5%8F%8A%E4%B8%AD%E7%BB%A7/</id>
    <published>2021-01-23T10:59:59.370Z</published>
    <updated>2021-03-08T01:52:42.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-1-网关"><a href="#8-1-网关" class="headerlink" title="8.1 网关"></a>8.1 网关</h2><p>HTTP扩展和接口的发展是由用户需求驱动的。单个应用程序无法处理复杂资源的需求。网关（gateway）抽象出一种能够到达资源的方法，网关是资源和应用程序之间的粘合剂。应用程序可以（通过HTTP或其他已定义的接口）请求网关来处理某条请求，网关可以提供响应。</p><p>常见网关类型：服务器协议转换器、服务器端安全网关、客户端安全网关、应用程序服务器。</p><h2 id="8-2-协议网关"><a href="#8-2-协议网关" class="headerlink" title="8.2 协议网关"></a>8.2 协议网关</h2><p><strong>客户端和服务器端网关</strong>：Web网关在一侧使用HTTP协议，在另一侧使用另一种协议。用一个斜杠来分隔客户端和服务器端协议，并以此对网关进行描述：&lt;客户端协议&gt;/&lt;服务器端协议&gt;</p><p>将HTTP流量导向网关时所使用的方式与将流量导向代理的方式相同。最常见的方式是，显式地配置浏览器使用网关，对流量进行透明的拦截，或者将网关配置为替代者（反向代理）。</p><h3 id="8-2-1-HTTP-：服务器端Web网关"><a href="#8-2-1-HTTP-：服务器端Web网关" class="headerlink" title="8.2.1 HTTP/*：服务器端Web网关"></a>8.2.1 HTTP/*：服务器端Web网关</h3><p>请求流入原始服务器时，服务器端Web网关会将客户端HTTP请求转换为其他协议。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/dR1Lzwym7V2TJQj.png"                      alt="h5rMSRFnKAI0fo2a.png"                ></p><h3 id="8-2-2-HTTP-HTTPS：服务器端安全网关"><a href="#8-2-2-HTTP-HTTPS：服务器端安全网关" class="headerlink" title="8.2.2 HTTP/HTTPS：服务器端安全网关"></a>8.2.2 HTTP/HTTPS：服务器端安全网关</h3><p>可以通过网关对所有的输入Web请求加密，以提供额外的隐私和安全性保护。客户端可以用普通的HTTP浏览Web内容，但网关会自动加密用户的对话。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/7xU9GV2eOCZDTS8.png"                      alt="XsHGngySl0b7vnU1__thumbnail.png"                ></p><h3 id="8-2-3-HTTPS-HTTP客户端安全加速器网关"><a href="#8-2-3-HTTPS-HTTP客户端安全加速器网关" class="headerlink" title="8.2.3 HTTPS/HTTP客户端安全加速器网关"></a>8.2.3 HTTPS/HTTP客户端安全加速器网关</h3><p>HTTPS/HTTP网关位于Web服务器之前，通常作为不可见的拦截网关或反向代理使用。它们接收安全的HTTPS流量，对安全流量进行解密，并向Web服务器发送普通的HTTP请求。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/eJQEum4ya71WjHX.png"                      alt="wt2ibTUjzYWa44Kf__thumbnail.png"                ></p><h2 id="8-3-资源网关"><a href="#8-3-资源网关" class="headerlink" title="8.3 资源网关"></a>8.3 资源网关</h2><p>最常见的网关是<strong>应用程序服务器</strong>，它会将目标服务器与网关结合在一个服务器中实现，它是服务器端网关，与服务器端的应用程序相连，并与客户端通过HTTP进行通信。</p><p>客户端通过HTTP连接到应用程序服务器，应用程序服务器将请求通过网关<strong>应用程序编程接口</strong>（Application Programming Interface，API）发送给运行在服务器上的应用程序，然后它向服务器返回响应或响应数据，服务器将其转发给客户端。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/c7Zw3JOpstbk8Hx.png"                      alt="SW60nADbd4fHQVhN__thumbnail.png"                ></p><h3 id="8-3-1-CGI"><a href="#8-3-1-CGI" class="headerlink" title="8.3.1 CGI"></a>8.3.1 CGI</h3><p>第一个流行的应用程序网关API就是<strong>通用网关接口</strong>（Common Gateway Interface，CGI）。CGI是一个标准接口集，Web服务器可以用它来装载程序以响应对特定URL的HTTP请求，并收集程序的输出数据，将其放在HTTP响应中回送。</p><p>CGI的处理对用户来说是不可见的，但可见的是URL中出现字符cgi和可能出现的“？”。</p><p>CGI广泛用于动态HTML、信用卡处理、数据库查询等。CGI应用程序是独立于服务器的，所以几乎可以用任意语言来实现。它能很好地保护服务器，防止糟糕的扩展对服务器造成破坏。</p><p>但是这种分离会造成性能的耗费。为每条CGI请求引发一个新进程的开销很高，会限制使用CGI的服务器的性能，并且会加重服务端机器资源的负担。</p><p>一种新型CGI（快速CGI）解决了这个问题。这个接口模拟了CGI，但它是作为持久守护进程运行的，消除了为每个请求建立或拆除新进程所带来的性能损耗。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/XAQ51W2SCxuTVJl.png"                      alt="lMjXhzVkWBBSUTH4__original.png"                ></p><h3 id="8-3-2-服务器扩展API"><a href="#8-3-2-服务器扩展API" class="headerlink" title="8.3.2 服务器扩展API"></a>8.3.2 服务器扩展API</h3><p>多数服务器都会为开发者提供一个或多个扩展API，这些扩展通常都会绑定在服务器自身的结构上，为Web开发者提供了强大的接口，以便将自己的模块与HTTP服务器直接相连，它允许程序员将自己的代码嫁接到服务器上，或者用自己的代码将服务器的一个组件完整地替换出来。</p><h2 id="8-4-应用程序接口和Web服务"><a href="#8-4-应用程序接口和Web服务" class="headerlink" title="8.4 应用程序接口和Web服务"></a>8.4 应用程序接口和Web服务</h2><p>HTTP可以作为连接应用程序的基础软件来使用，在将应用程序连接起来的过程中，通过web服务标准解决两个应用程序之间进行协议接口的协商，以便应用程序可以进行数据的交换。</p><p>Web服务是构建在标准的Web技术（比如HTTP）之上的。Web服务可以用XML通过SOAP来交换信息。XML提供了一种创建数据对象的定制信息，并对其进行解释的方法<strong>SOAP</strong>（Simple Object Access Protocol，简单对象访问协议）是向HTTP报文中添加XML信息的标准方式。</p><h2 id="8-5-隧道"><a href="#8-5-隧道" class="headerlink" title="8.5 隧道"></a>8.5 隧道</h2><p>通过<strong>Web 隧道</strong>（Web tunnel）可以通过HTTP应用程序访问使用非HTTP协议的应用程序。使用Web隧道最常见的原因就是要在HTTP连接中嵌入非HTTP流量，这样这类流量就可以穿过只允许Web流量通过的防火墙了。</p><h3 id="8-5-1-用CONNECT建立HTTP隧道"><a href="#8-5-1-用CONNECT建立HTTP隧道" class="headerlink" title="8.5.1 用CONNECT建立HTTP隧道"></a>8.5.1 用CONNECT建立HTTP隧道</h3><p>Web隧道是用HTTP的CONNECT方法建立起来的。CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/a9AcYRv3lokKyni.png"                      alt="eW9jkF1kxuU5siZD__thumbnail.png"                ></p><ol><li><strong>CONNECT请求</strong></li></ol><p>除了起始行之外，CONNECT的语法与其他HTTP方法类似。一个后面跟着冒号和端口号的主机名取代了请求URI。主机和端口都必须指定。</p><ol start="2"><li><strong>CONNECT响应</strong></li></ol><p>发送请求之后，客户端会等待来自网关的响应。响应码200表示成功。通常响应中的原因短语通常被设置为“Conection Established”，这个响应并不需要包含Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。</p><h3 id="8-5-2-数据隧道、定时及连接管理"><a href="#8-5-2-数据隧道、定时及连接管理" class="headerlink" title="8.5.2 数据隧道、定时及连接管理"></a>8.5.2 数据隧道、定时及连接管理</h3><p>管道化数据对网关是不透明的，所以网关不能改变分组的顺序和分组流。一旦隧道建立起来了，数据就可以在任意时间流向任意方向了。</p><p>客户端可以在发送了CONNECT请求之后，接收响应之前，发送隧道数据，这样可以更快地将数据发送给服务器。但网关必须能够正确处理跟在请求之后的数据，尤其是网关不能假设网络I/O请求只会返回首部数据，网关必须确保在连接准备就绪时，将与首部一同读进来的数据发送给服务器。如果客户端发现回送的响应是认证请求，或其他非200但不致命的错误状态，就必须做好重发请求数据的准备。</p><p>如果隧道的任意一个端点断开了连接，那个端点发出的所有未传输数据都会被传送给另一个端点，之后到另一个端点的连接也会被代理终止。如果还有数据要传输给关闭连接的端点，数据会被丢弃。</p><h3 id="8-5-3-SSL隧道"><a href="#8-5-3-SSL隧道" class="headerlink" title="8.5.3 SSL隧道"></a>8.5.3 SSL隧道</h3><p>最初Web隧道是为了通过防火墙来传输加密的SSL流量。将所有流量通过分组过滤路由器和代理服务器以隧道方式传输，以提升安全性。但有些协议如加密SSL，其信息是加密的，无法通过传统的代理服务器转发。</p><p>HTTP中添加一项隧道特性，可以将原始的加密数据放在HTTP报文中，通过普通的HTTP信道传送。但是，这项特性可能会被滥用，使得恶意协议通过HTTP隧道流入某个组织内部。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/LG2Qj3xtDazou1H.png"                      alt="SdlL3tBsyFZEL7Vt__thumbnail.png"                ></p><h3 id="8-5-4SSL隧道与HTTP-HTTPS网关的对比"><a href="#8-5-4SSL隧道与HTTP-HTTPS网关的对比" class="headerlink" title="8.5.4SSL隧道与HTTP/HTTPS网关的对比"></a>8.5.4SSL隧道与HTTP/HTTPS网关的对比</h3><p>HTTPS协议（SSL上的HTTP）进行网关的操作：由网关（而不是客户端）初始化与远端HTTPS服务器的SSL会话，然后代表客户端执行HTTPS事务。响应会由代理接收并解密，然后通过（不安全的）HTTP传送给客户端。这种方式有几个缺点：</p><ol><li>客户端到网关之间的连接是普通的非安全HTTP；</li><li>虽然代理是已认证主体，但客户端无法对远端服务器执行SSL客户端认证；</li><li>网关要支持完整的SSL实现。</li></ol><p>对于SSL隧道机制来说，无需在代理中实现SSL。SSL 会话是建立在产生请求的客户端和目的（安全的）Web服务器之间的，中间的代理服务器只是将加密数据经过隧道传输，并不会在安全事务中扮演其他的角色。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/mXFkvVxJdzy9qY5.png"                      alt="cITItirpNAmBAC8F__thumbnail.png"                ></p><h3 id="8-5-5-隧道认证"><a href="#8-5-5-隧道认证" class="headerlink" title="8.5.5 隧道认证"></a>8.5.5 隧道认证</h3><p>在适当的情况下，可以将HTTP的其他特性与隧道配合使用。比如将代理的认证支持与隧道配合使用，对客户端使用隧道的权利进行认证。</p><h3 id="8-5-6-隧道的安全性考虑"><a href="#8-5-6-隧道的安全性考虑" class="headerlink" title="8.5.6 隧道的安全性考虑"></a>8.5.6 隧道的安全性考虑</h3><p>隧道网关无法验证目前使用的协议是否是它原本打算经过隧道传输的协议。因此一些用户可能会通过本打算用于SSL的隧道，越过公司防火墙传递因特网游戏流量，甚至恶意用户可能会用隧道打开Telnet会话，或用隧道绕过公司的E-mail扫描器来发送E-mail。</p><p>为了降低对隧道的滥用，网关应该只为特定的知名端口，如HTTPS的端口443，打开隧道。</p><h2 id="8-6-中继"><a href="#8-6-中继" class="headerlink" title="8.6 中继"></a>8.6 中继</h2><p><strong>HTTP中继</strong>（relay）是没有完全遵循HTTP规范的简单HTTP代理，它负责处理HTTP中建立连接的部分，然后对字节进行盲转发。</p><p>盲中继不执行任何首部和方法逻辑，有时是很有用的，有时会提供简单的过滤、诊断或内容转换功能。但这种方式可能潜在严重的互操作问题。</p><p>某些简单盲中继实现中存在的问题是，由于它们无法正确处理Connection首部，所以有潜在的挂起keep-alive连接的可能。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/08/ENAhCpFIZGrD645.png"                      alt="IULgh1VsZyxKgPpy__thumbnail.png"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;8-1-网关&quot;&gt;&lt;a href=&quot;#8-1-网关&quot; class=&quot;headerlink&quot; title=&quot;8.1 网关&quot;&gt;&lt;/a&gt;8.1 网关&lt;/h2&gt;&lt;p&gt;HTTP扩展和接口的发展是由用户需求驱动的。单个应用程序无法处理复杂资源的需求。网关（gateway）抽象出</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP权威指南" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    
    <category term="08-集成点：网关、隧道及中继" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/08-%E9%9B%86%E6%88%90%E7%82%B9%EF%BC%9A%E7%BD%91%E5%85%B3%E3%80%81%E9%9A%A7%E9%81%93%E5%8F%8A%E4%B8%AD%E7%BB%A7/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
