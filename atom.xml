<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>别着急，慢慢来</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-23T05:00:51.695Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>胡倚豪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04-网络层：数据平面</title>
    <link href="http://example.com/2021/06/15/note/Computer%20Networking/04-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/"/>
    <id>http://example.com/2021/06/15/note/Computer%20Networking/04-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</id>
    <published>2021-06-15T10:13:04.783Z</published>
    <updated>2021-06-23T05:00:51.695Z</updated>
    
    <content type="html"><![CDATA[<p>网络层能够被分解为两个相互作用的部分:</p><ul><li><p>网络层的数据平面功能，即网络层中每台路由器的功能，决定到路由器一条输入链路的数据报如何转发到该路由器的一条输出链路。</p></li><li><p>网络层的控制平面功能，即网络范围的逻辑，控制数据报沿着路径中路由器之间的路由方式。</p></li></ul><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1  网络层概述"></a>4.1  网络层概述</h2><h3 id="4-1-1-转发和路由选择：数据平面和控制平面"><a href="#4-1-1-转发和路由选择：数据平面和控制平面" class="headerlink" title="4.1.1   转发和路由选择：数据平面和控制平面"></a>4.1.1   转发和路由选择：数据平面和控制平面</h3><p>网络层两种重要的功能：</p><ul><li><p>转发。在数据平面中用硬件来实现的唯一功能，当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。</p></li><li><p>路由选择。在控制平面中用软件来实现。当分组从发送方流向接收方时，决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法。</p></li></ul><p>每台路由器中有一个转发表。路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引，这些值对应存储在转发表项中的值，指出该分组将被转发的路由器的输出链路接口。</p><ol><li>控制平面：传统方法<br>运行在每台路由器中的路由选择算法决定了插入该路由器转发表的内容，路由选择算法之间通信，以计算出它的转发表的值。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/jzcKxepV7Q1lX6w.png"                      alt="image-20210530160723243"                ></p><ol start="2"><li>控制平面：软件定义网络（<code>SDN</code>）方法<br>每台路由器都有一个路由选择组件相互通信。远程控制器计算和分发转发表以供每台路由器所使用。路由器和远程控制器通过交换包含转发表和其他路由选择信息的报文通信。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/MZp75LIFhoGWET3.png"                      alt="image-20210530163734572"                ></p><h2 id="4-2-路由器工作原理"><a href="#4-2-路由器工作原理" class="headerlink" title="4.2   路由器工作原理"></a>4.2   路由器工作原理</h2><p>一台路由器的4个组件：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/QXAsovZCjwxSTMd.png"                      alt="image-20210530165651459"                ></p><ul><li>输入端口。输入端口最左侧和输出端口最右侧的方框执行终结入物理链路的物理层功能。输入与输出端口中间的方框，与位于入链路远端的数据链路层交互来执行数据链路层功能。在输入端口最右侧的方框中，通过查询转发表决定路由器的输出端口，到达的分组通过交换结构转发到输出端口。</li><li>交换结构。交换结构将路由器的输入端口连接到它的输出端口。</li><li>输出端口。输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。当一条链路是双向的时，输出端口通常与该链路的输入端口成对出现在同一线路卡上。</li><li>路由选择处理器。在传统的路由器中，执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在<code>SDN</code>路由器中，负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。路由选择处理器还执行网络管理功能。</li></ul><h3 id="4-2-1-输入端口处理和基于目的地转发"><a href="#4-2-1-输入端口处理和基于目的地转发" class="headerlink" title="4.2.1   输入端口处理和基于目的地转发"></a>4.2.1   输入端口处理和基于目的地转发</h3><p>输入端口处理：</p><ol><li><p>物理层和链路层处理；</p></li><li><p>检查分组的版本号、检验和以及寿命字段，并且重写后两个字段；</p></li><li><p>更新用于网络管理的计数器（如接收到的<code>IP</code>数据报的数目）</p></li><li><p>根据转发表查找转发。</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/GuE1hOiXeF9zRTt.png"                      alt="image-20210530175102784"                ></p><p>在32比特<code>IP</code>地址的情况下，针对每个目的地址有一个表项是不可行，而是路由器用分组目的地址的前缀与表中的表项进行匹配，如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发分组。当有多个匹配时，该路由器使用最长前缀匹配规则，并向相关联的链路接口转发分组。表查找是简单的，但这种查找必须在纳秒级执行。因此，不仅必须要用硬件执行查找，而且需要对大型转发表使用快速查找算法。</p><table><thead><tr><th align="center">前缀匹配</th><th align="center">链路接口</th></tr></thead><tbody><tr><td align="center">1001000 00010111 00010</td><td align="center">0</td></tr><tr><td align="center">11001000 00010111 000110000</td><td align="center">1</td></tr><tr><td align="center">11001000 00010111 00011</td><td align="center">2</td></tr><tr><td align="center">其他</td><td align="center">3</td></tr></tbody></table><p>一旦通过查找确定了某分组的输出端口，则该分组就能够发送进入交换结构。但如果来自其他输入端口的分组当前正在使用该交换结构，必须要在输入端口处排队，并等待稍后被及时调度以通过交换结构。</p><h3 id="4-2-2-交换"><a href="#4-2-2-交换" class="headerlink" title="4.2.2   交换"></a>4.2.2   交换</h3><p>交换结构位于一台路由器的核心部位，分组从一个输入端口交换（即转发）到一个输出端口中。交换可以用许多方式完成。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/vAwWIJcRXuFLjT3.png"                      alt="image-20210530201524035"                ></p><ul><li><p>经内存交换。输入端口与输出端口之间的交换是在CPU（路由选择处理器）的直接控制下完成的。一个分组到达一个输入端口时，该端口会先通过中断方式向路由选择处理器发出信号，于是该分组从输入端口处被复制到处理器内存中。路由选择处理器则从其首部中提取目的地址，在转发表中找出适当的输出端口，并将该分组复制到输出端口的缓存中。在这种情况下，不能同时转发两个分组，即使它们有不同的目的端口，因为经过共享系统总线一次仅能执行一个内存读/写。</p></li><li><p>经总线交换。输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。让输入端口为分组的首部预先计划一个交换机内部标签，分组能由所有输出端口收到，但只有与该标签匹配的端口才能保存该分组，然后标签在输出端口被去除。因为其仅用于交换机内部来跨越总线，如果多个分组同时到达路由器，因为一次只有一个分组能够跨越总线，除了一个分组外所有其他分组必须等待，故路由器的交换带宽受总线速率的限制。</p></li><li><p>经互联网络交换。纵横式交换机就是一种由<code>2N</code>条总线组成的互联网络，它连接N个输入端口与N个输出端口，交叉点通过交换结构控制器（其逻辑是交换结构自身的一部分）能够开启和闭合。因此纵横式网络能够并行转发多个分组。纵横式交换机是非阻塞的，但如果来自两个不同输入端口的两个分组其目的地为相同的输出端口，则一个分组还是必须在输入端等待，因为在某个时刻经给定总线仅能够发送一个分组。</p></li></ul><h3 id="4-2-3-输出端口处理"><a href="#4-2-3-输出端口处理" class="headerlink" title="4.2.3   输出端口处理"></a>4.2.3   输出端口处理</h3><p>输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上，包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/Jj3EbPXG4ftpLT8.png"                      alt="image-20210530203625367"                ></p><h3 id="4-2-4-何处出现排队"><a href="#4-2-4-何处出现排队" class="headerlink" title="4.2.4   何处出现排队"></a>4.2.4   何处出现排队</h3><p>排队的位置和程度将取决于流量负载、交换结构的相对速率和线路速率。随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现丢包。</p><h4 id="4-2-4-1-输入排队"><a href="#4-2-4-1-输入排队" class="headerlink" title="4.2.4.1   输入排队"></a>4.2.4.1   输入排队</h4><p>如果交换结构相对于输入线路速度不能快得使所有到达分组无时延地通过它传送，在输入端口将出现分组排队，因为到达的分组必须加入输入端口队列中，以等待通过交换结构传送到输出端口。</p><p>输入排队交换机中的线路前部（<code>HOL</code>）阻塞：即在一个输入队列中排队的分组必须等待通过交换结构发送（即使输出端口是空闲的），因为它被位于线路前部的另一个分组所阻塞。由于<code>HOL</code>阻塞，只要输入链路上的分组到达速率通常达到其容量的58%，输入队列长度就将无限制地增大。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/7VmygZIaSBXYPjR.png"                      alt="image-20210530204312111"                ></p><h4 id="4-2-4-2-输出排队"><a href="#4-2-4-2-输出排队" class="headerlink" title="4.2.4.2   输出排队"></a>4.2.4.2   输出排队</h4><p>假定输入与输出线路速度是相同的，均为R<sub>line</sub>（单位为每秒分组数），并且有N个输入端口和N个输出端口。假设所有分组具有相同的固定长度，分组以同步的方式到达输入端口。定义交换结构传送速率R<sub>switch</sub>为从输入端口到输出端口能够移动分组的速率。</p><p>如果R<sub>switch</sub>比R<sub>line</sub>快N倍，并且到达N个输入端口的每个端口的分组，其目的地是相同的输出端口。在这种情况下，能够在输出端口形成排队。输出端口的<strong>分组调度</strong>在这些排队分组中选择一个分组来传输。</p><p>如果通过路由器缓存来吸收流量负载的波动，用于缓存长度的方法是，缓存数量（B）应当等于平均往返时延（<code>RTT</code>）乘以链路的容量（C）。这个结果是基于相对少量的TCP流的排队动态性分析得到的。当有大量的TCP流（N条）流过一条链路时，缓存所需要的数量是<code>B=RTT*C/N</code>，对于通常有大量流经过的大型主干路由器链路，N的值可能非常大，所需的缓存长度的减小相当明显。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/JxMiDgATtvF6UHL.png"                      alt="image-20210530212818102"                ></p><h3 id="4-2-5-分组调度"><a href="#4-2-5-分组调度" class="headerlink" title="4.2.5   分组调度"></a>4.2.5   分组调度</h3><h4 id="4-2-5-1-先进先出"><a href="#4-2-5-1-先进先出" class="headerlink" title="4.2.5.1   先进先出"></a>4.2.5.1   先进先出</h4><p>FIFO调度规则按照分组到达输出链路队列的相同次序来选择分组在链路上传输。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/d8XfOmQwTCNlLSJ.png"                      alt="image-20210530222248203"                ></p><h4 id="4-2-5-2-优先权排队"><a href="#4-2-5-2-优先权排队" class="headerlink" title="4.2.5.2   优先权排队"></a>4.2.5.2   优先权排队</h4><p>到达输出链路的分组被分类放入输出队列中的优先权类。在实践中，可以配置一个队列，这样携带网络管理信息的分组（例如由源或目的<code>TCP/UDP</code>端口号所标识）获得超过用户流量的优先权；此外，基于<code>IP</code>的实时话音分组可能获得超过非实时流量（如<code>SMTP</code>或<code>IMAP</code>电子邮件分组）的优先权。每个优先权类通常都有自己的队列。当选择一个分组传输时，优先权排队规则将从队列为非空（也就是有分组等待传输）的最高优先权类中传输一个分组。在同一优先权类的分组之间的选通常以FIFO方式完成。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/vC6oiAL8jKUwkrD.png"                      alt="image-20210530222444141"                ></p><h4 id="4-2-5-3-循环和加权公平排队"><a href="#4-2-5-3-循环和加权公平排队" class="headerlink" title="4.2.5.3   循环和加权公平排队"></a>4.2.5.3   循环和加权公平排队</h4><p>在循环排队规则下，分组像使用优先权排队那样被分类，但不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。当寻找给定类的分组没有找到时，保持工作的循环规则将立即检查循环序列中的下一个类。</p><p>加权公平排队（<code>WFQ</code>）规则：到达的分组被分类并在合适的每个类的等待区域排队。与使用循环调度一样，<code>WFQ</code>调度器也以循环的方式为各个类提供服务，在发现一个空的类队列时，它立即移向服务序列中的下一个类。</p><p><code>WFQ</code>和循环排队的不同之处在于，每个类在任何时间间隔内可能收到不同数量的服务。每个类i被分配一个权w<sub>i</sub>，在类i有分组要发送的任何时间间隔中，第i类将确保接收到的服务部分等于w<sub>i</sub>/（Σw<sub>j</sub>），分母中的和是计算所有有分组排队等待传输的类别得到的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/30/vVijo7REu46pAyL.png"                      alt="image-20210530214714532"                ></p><h2 id="4-3-网际协议：IPv4、寻址、IPv6及其他"><a href="#4-3-网际协议：IPv4、寻址、IPv6及其他" class="headerlink" title="4.3   网际协议：IPv4、寻址、IPv6及其他"></a>4.3   网际协议：<code>IPv4</code>、寻址、<code>IPv6</code>及其他</h2><h3 id="4-3-1-IPv4数据报格式"><a href="#4-3-1-IPv4数据报格式" class="headerlink" title="4.3.1   IPv4数据报格式"></a>4.3.1   <code>IPv4</code>数据报格式</h3><p>网络层分组被称为数据报，<code>IPv4</code>数据报格式如下图所示。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/31/Idq7yVKabv3WCpD.png"                      alt="image-20210531163929050"                ></p><p><code>IPv4</code>数据报中的关键字段如下：</p><ul><li>版本（号）。这4比特规定了数据报的<code>IP</code>协议版本。通过查看版本号，路由器能够确定如何解释<code>IP</code>数据报的剩余部分。不同的<code>IP</code>版本使用不同的数据报格式。</li><li>首部长度。因为一个<code>IPv4</code>数据报可包含一些可变数量的选项，故需要用这4比特来确定<code>IP</code>数据报中载荷实际开始的地方。大多数<code>IP</code>数据报不包含选项，所以一般<code>IP</code>数据报具有20字节的首部。</li><li>服务类型（<code>TOS</code>）。以便使不同类型的<code>IP</code>数据报能相互区别开来。例如，将实时数据报与非实时流量区分开。</li><li>数据报长度。这是<code>IP</code>数据报的总长度（首部加上数据），以字节计。该长度使得<code>IP</code>数据报能容纳最大长度以太网帧的载荷字段。</li><li>标识、标志、片偏移。这三个字段与<code>IP</code>分片有关，<code>IPv6</code>不允许在路由器上对分组分片。</li><li>寿命（<code>TTL</code>）。用来确保数据报不会永远在网络中循环。每当一台路由器处理数据报时，该字段的值减1，当减为0，则该数据报必须丢弃。</li><li>协议。指示了<code>IP</code>数据报的数据部分应交给哪个特定的运输层协议，通常仅当一个<code>IP</code>数据报到达其最终目的地时才会有用。例如，值为6表明数据部分要交给<code>TCP</code>，值为17表明数据要交给<code>UDP</code>。</li><li>首部检验和。用于帮助路由器检测收到的<code>IP</code>数据报中的比特错误。一般会丢弃检测出错误的数据报。在每台路由器上必须重新计算检验和并再次存放到原处，因为TTL字段以及可能的选项字段会改变。传输层和网络层重复检测原因：<code>IP</code>层只对<code>IP</code>首部计算了检验和，而<code>TCP/UDP</code>检验和是对整个报文段进行，另一方面<code>TCP/UDP</code>与<code>IP</code>不一定属于同一个协议栈。</li><li>源和目的<code>IP</code>地址。当某源生成一个数据报时，插入它的<code>IP</code>地址，并通过<code>DNS</code>查找再插入目的<code>IP</code>地址。</li><li>选项。允许<code>IP</code>首部被扩展，在<code>IPv6</code>首部中已去掉了<code>IP</code>选项。</li><li>数据（有效载荷）。在大多数情况下，包含要交付给目的地的运输层报文段（<code>TCP或UDP</code>），也可承载其他类型的数据，如<code>ICMP</code>报文。</li></ul><h3 id="4-3-2-IPv4数据报分片"><a href="#4-3-2-IPv4数据报分片" class="headerlink" title="4.3.2   IPv4数据报分片"></a>4.3.2   <code>IPv4</code>数据报分片</h3><p>一个链路层帧能承载的最大数据量叫作最大传送单元（<code>MTU</code>）。<code>MTU</code>限制着<code>IP</code>数据报的长度，每种链路层协议可能具有不同的<code>MTU</code>。当<code>MTU</code>比该<code>IP</code>数据报的长度要小时，解决方法是将<code>IP</code>数据报中的数据分片成两个或更多个较小的<code>IP</code>数据报(<strong>片</strong>)，用单独的链路层帧封装这些较小的<code>IP</code>数据报，然后通过输出链路发送这些帧。</p><p>在端系统中重新组装数据报，而不是在路由器，因为会影响路由器的性能。<code>IPv4</code>将标识、标志和片偏移字段放在<code>IP</code>数据报首部中。</p><ul><li>发送主机在为数据报设置源和目的地址的同时贴上标识号，发送的每个数据报的标识号加1。当目的主机收到一系列数据报时，检查数据报的标识号是否相同从而确定哪些数据报是同一数据报的片。</li><li>由于<code>IP</code>是一种不可靠的服务，最后一个片的标志比特被设为0，而其他片的标志比特被设为1，让目的主机确定是否收到初始数据报的最后一个片。</li><li>使用偏移字段指定该片在初始<code>IP</code>数据报的位置，让目的主机确定是否丢失了一个片且能按正确的顺序重新组装片。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/31/vqZXIMJg6LC1ylw.png"                      alt="image-20210531170820139"                ></p><h3 id="4-3-3-IPv4编址"><a href="#4-3-3-IPv4编址" class="headerlink" title="4.3.3   IPv4编址"></a>4.3.3   <code>IPv4</code>编址</h3><p>主机与路由器连入网络的方法：一台主机通常只有一条链路连接到网络。主机/路由器与物理链路之间的边界叫作接口，路由器必须拥有多条链路与它连接。因为每台主机与路由器都能发送和接收<code>IP</code>数据报，所以每台主机和路由器接口拥有自己全球唯一的<code>IP</code>地址（在NAT后面的接口除外）。因此，一个<code>IP</code>地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。地址不能随意地自由选择，一个接口的<code>IP</code>地址的一部分需要由其连接的子网来决定。</p><p>每个<code>IP</code>地址长度为32比特，按点分十进制记法书写，即地址中的每个字节用它的十进制形式书写，例如地址193.32.216.9的二进制记法是：11000001 00100000 11011000 00001001。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/31/uX3zNJHEhFMmDVg.png"                      alt="image-20210531200408798"                ></p><p>互联这3个主机接口与1个路由器接口的网络形成一个子网。<code>IP</code>编址为这个子网分配一个地址223.1.1.0/24，其中的<code>/24</code>记法，称为子网掩码，指示最左侧24比特定义了子网地址。任何其他要连到223.1.1.0/24网络的主机都要求其地址具有<code>223.1.1.xxx</code>形式。</p><p>一个子网的<code>IP</code>定义并不局限于连接多台主机到一个路由器接口的以太网段。对于一个路由器和主机的通用互联系统，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点，这些隔离的网络中的每一个都叫作一个子网。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/31/GiJ1wOPA5t6Yobz.png"                      alt="image-20210531204945902"                ></p><p>互联网的地址分配策略被称为无类别域间路由选择（<code>CIDR</code>），当使用子网寻址时，<code>IP</code>地址被划分为两部分<code>a.b.c.d/x</code>，其中<code>x</code>指示了地址的第一部分中的比特数，这构成了<code>IP</code>地址的网络部分，被称为该地址的前缀。一个组织通常被分配具有相同前缀的一段地址，该组织内部的设备的<code>IP</code>地址将共享共同的前缀。一个地址的剩余<code>32-x</code>比特可认为是用于区分该组织内部设备的，当该组织内部的路由器转发分组时，才会考虑这些比特。这些较低阶比特可能（或可能不）具有另外的子网结构。例如，某<code>CIDR</code>化的地址<code>a.b.c.d/21</code>的前21比特定义了该组织的网络前缀，该组织的内部结构可以使用最右边的11比特在该组织中划分子网，例如，<code>a.b.c.d/24</code>可能表示该组织内的特定子网。</p><p>在<code>CIDR</code>被采用之前，<code>IP</code>地址的网络部分被限制为长度为8、16或24比特，它们的子网地址的子网分别被称为A、B、C类网络，这是一种称为分类编址的编址方案。但对于一个组织来说，不同类的子网可能出现不够分配或者剩余太多导致浪费的情况。</p><p><code>IP</code>广播地址255.255.255.255，当一台主机发出一个目的地址为255.255.255.255 数据报时，该报文会交付给同一个网络中的所有主机，路由器也可能会向邻近的子网转发该报文。</p><h4 id="4-3-3-1-获取组织地址块"><a href="#4-3-3-1-获取组织地址块" class="headerlink" title="4.3.3.1   获取组织地址块"></a>4.3.3.1   获取组织地址块</h4><p>可以从一个<code>ISP</code>获取一组地址。例如，该<code>ISP</code>已被分配了地址块200.23.16.0/20，可以依次将该地址块分成8个长度相等的连续地址块，为本<code>ISP</code>支持的最多达8个组织中的一个分配这些地址块中的一块，如下所示。</p><p><code>ISP</code>的地址块   200.23.16.0/20       <u>11001000 00010111 0001</u>0000 00000000</p><p>组织0                200.23.16.0/23       <u>11001000 00010111 0001000</u>0 00000000</p><p>组织1                200.23.18.0/23       <u>11001000 00010111 0001001</u>0 00000000</p><p>组织2                200.23.20.0/23       <u>11001000 00010111 0001010</u>0 00000000<br>…<br>组织7                200.23.30.0/23       <u>11001000 00010111 0001111</u>0 000000000</p><p>通常由因特网名字和编号分配机构（<code>ICANN</code>）管理<code>IP</code>地址空间并向各<code>ISP</code>和其他组织分配地址块，并且还管理<code>DNS</code>根服务器、分配域名与解决域名纷争。</p><h4 id="4-3-3-2-获取主机地址：动态主机配置协议"><a href="#4-3-3-2-获取主机地址：动态主机配置协议" class="headerlink" title="4.3.3.2   获取主机地址：动态主机配置协议"></a>4.3.3.2   获取主机地址：动态主机配置协议</h4><p>某组织一旦获得一块地址，就可为本组织内的主机与路由器接口逐个分配<code>IP</code>地址。通常通过网络管理工具进行手工配置<code>IP</code>地址，但更多的是使用动态主机配置协议（<code>DHCP</code>）来完成。</p><p><code>DHCP</code>允许主机自动获取（被分配）一个<code>IP</code>地址，网络管理员能够配置<code>DHCP</code>，以使某给定主机每次与网络连接时能得到一个相同的<code>IP</code>地址，或者某主机将被分配一个临时的<code>IP</code>地址，每次与网络连接时该地址可能不同。<code>DHCP</code>还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（默认网关）与它的本地<code>DNS</code>服务器的地址。</p><p><code>DHCP</code>是一个客户-服务器协议。客户通常是新到达的主机，它要获得包括自身使用的<code>IP</code>地址在内的网络配置信息。在简单场合下，每个子网将具有一台<code>DHCP</code>服务器，或者需要一个<code>DHCP</code>中继代理（通常是一台路由器），这个代理知道用于该网络的<code>DHCP</code>服务器的地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/ewsgr6NcSJY7IWx.png"                      alt="image-20210601142329609"                ></p><p>对于一台新到达的主机而言，<code>DHCP</code>协议是一个4个步骤的过程：</p><ol><li><p><code>DHCP</code>服务器发现。一台新到达的主机通过使用<code>DHCP</code>发现报文找到一个要与其交互的<code>DHCP</code>服务器。客户在<code>UDP</code>分组中向端口67发送该发现报文，<code>UDP</code>分组封装在一个<code>IP</code>数据报中，使用广播目的地址255.25.255.255且使用源<code>IP</code>地址0.0.0.0。将<code>IP</code>数据报传递给链路层，链路层将帧广播到所有与该子网连接的节点。</p></li><li><p><code>DHCP</code>服务器提供。<code>DHCP</code>服务器收到一个<code>DHCP</code>发现报文时，用<code>DHCP</code>提供报文做出响应，该报文仍然使用<code>IP</code>广播地址255.255.255.255向该子网的所有节点广播。<code>DHCP</code>提供报文包含有收到的发现报文的事务ID、向客户推荐的<code>IP</code>地址、网络掩码以及<code>IP</code>地址租用期，即<code>IP</code>地址有效的时间量。服务器租用期通常设置为几小时或几天。</p></li><li><p><code>DHCP</code>请求。新到达的客户从一个或多个服务器提供中选择一个，因为在子网中可能存在几个<code>DHCP</code>服务器，并向选中的服务器用<code>DHCP</code>请求报文进行响应，回显配置的参数。</p></li><li><p><code>DHCP</code> <code>ACK</code>，服务器用<code>DHCP ACK</code>报文对<code>DHCP</code>请求报文进行响应，证实所要求的参数，客户收到<code>DHCP ACK</code>后，交互便完成了，该客户能够在租用期内使用<code>DHCP</code>分配的<code>IP</code>地址。</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/845azqFHWxjSoXZ.png"                      alt="image-20210601143057709"                ></p><h3 id="4-3-4-网络地址转换"><a href="#4-3-4-网络地址转换" class="headerlink" title="4.3.4   网络地址转换"></a>4.3.4   网络地址转换</h3><p>当子网<code>IP</code>地址不够使用需要再分配一块较大的地址，但<code>ISP</code>已经分配过一块连续地址时，通常使用网络地址转换（<code>NAT</code>）解决。</p><p>下图所有4个接口都具有相同的网络地址，这些地址用于家庭网络等专用网络或具有专用地址的地域，其地址仅对该网络中的设备有意义的网络，转发到家庭网络之外的分组不能使用这些地址作为源地址或目的地址。<code>NAT</code>使能路由器对外界隐藏了专用网络的细节，所有离开<code>NAT</code>路由器的报文都拥有一个源<code>IP</code>地址，且所有进入专用网络的报文都拥有同一个目的<code>IP</code>地址。NAT路由器上的NAT转换表，用于重写首部<code>IP</code>地址和端口号。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/B42lsTrHRn3WOLx.png"                      alt="image-20210601144713039"                ></p><h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5   IPv6"></a>4.3.5   <code>IPv6</code></h3><h4 id="4-3-5-1-IPv6数据报格式"><a href="#4-3-5-1-IPv6数据报格式" class="headerlink" title="4.3.5.1   IPv6数据报格式"></a>4.3.5.1   <code>IPv6</code>数据报格式</h4><p><code>IPv6</code>数据报的格式如图所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/vaPZckVNQ45pmJC.png"                      alt="image-20210601154805112"                ></p><ul><li>版本。用于标识<code>IP</code>版本号。<code>IPv6</code>将该字段值设为6，但设置为4并不能创建一个合法的<code>IPv4</code>数据报。</li><li>流量类型。与<code>IPv4</code>的<code>TOS</code>字段的含义相似。</li><li>流标签。用于标识一条数据报的流，是发送方要求进行特殊处理的流，对一条流中的某些数据报给出优先权。</li><li>有效载荷长度。一个无符号整数，给出<code>IPv6</code>数据报中跟在定长的40字节数据报首部后面的字节数量。</li><li>下一个首部。与<code>IPv4</code>首部中协议字段相同。</li><li>跳限制。转发数据报的每台路由器将对该字段的内容减1。如果跳限制计数达到0，则该数据报将被丢弃。</li><li>源地址和目的地址。128比特地址不会用尽。除了单播与多播地址以外还有任播地址，这种地址可以使数据报交付给一组主机中的任意一个。</li><li>数据。数据报到达目的地时，从<code>IP</code>数据报中移出，并交给在下一个首部字段中指定的协议处理。</li></ul><p>在<code>IPv4</code>数据报中出现的几个字段在<code>IPv6</code>数据报中已不复存在：</p><ul><li><p>分片与重新组装，这加快了网络中的<code>IP</code>转发速度。如果路由器收到的<code>IPv6</code>数据报太大不能转发到出链路上，只需丢掉该数据报，并向发送方发回<code>ICMP</code>差错报文，发送方再使用较小长度的<code>IP</code>数据报重发数据。</p></li><li><p>首部检验和。</p></li><li><p>选项。但它可能出现在<code>IPv6</code>首部中下一个首部。</p></li></ul><h4 id="4-3-5-2-从IPv4到IPv6的迁移"><a href="#4-3-5-2-从IPv4到IPv6的迁移" class="headerlink" title="4.3.5.2   从IPv4到IPv6的迁移"></a>4.3.5.2   从<code>IPv4</code>到<code>IPv6</code>的迁移</h4><p>虽然<code>IPv6</code>使能系统可做成向后兼容，即能发送、路由和接收<code>IPv4</code>数据报，但已部署的具有<code>IPv4</code>能力的系统却不能够处理<code>IPv6</code>数据报。</p><p>在实践中广泛采用的方法是建隧道。基本思想如下：假定两个<code>IPv6</code>节点使用<code>IPv6</code>数据报进行交互，两台中间<code>IPv4</code>路由器的集合称为一个隧道。在隧道发送端的<code>IPv6</code>节点B可将整个<code>IPv6</code>数据报放到一个<code>IPv4</code>数据报的数据字段中，并将该<code>IPv4</code>数据报的地址设为指向隧道接收端的<code>IPv6</code>节点E，隧道中的中间<code>IPv4</code>路由器在它们之间为该数据报提供路由，就像对待<code>IPv4</code>数据报一样。隧道接收端的<code>IPv6</code>节点最终收到该<code>IPv4</code>数据报（它是该<code>IPv4</code>数据报的目的地），并通过观察在<code>IPv4</code>数据报中的协议号字段是41，从而确定该<code>IPv4</code>数据报含有一个<code>IPv6</code>数据报并取出，然后再为该<code>IPv6</code>数据报提供路由。    </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/P87aohrsYiACD3M.png"                      alt="image-20210601161524579"                ></p><h2 id="4-4-通用转发和SDN"><a href="#4-4-通用转发和SDN" class="headerlink" title="4.4  通用转发和SDN"></a>4.4  通用转发和<code>SDN</code></h2><p>路由器的转发决定传统上仅仅基于分组的目的地址。目的地转发的特征总结为两个步骤：查找目的<code>IP</code>地址（“匹配”），将分组发送到有特定输出端口的交换结构（“动作”）。</p><p>然而随着中间盒的剧增，出现一种能提供多种网络层功能以及某些链路层功能的通用“匹配加动作”范式：对协议栈的多个首部字段进行“匹配”，这些首部字段是与不同层次的不同协议相关联的。“动作”包括：</p><ul><li>将分组转发到一个或多个输出端口，就像在基于目的地转发中一样；</li><li>跨越多个通向服务的离开接口进行负载均衡分组，就像在负载均衡中一样；</li><li>重写首部值，就像在NAT中一样；</li><li>有意识地阻挡/丢弃某个分组，就像在防火墙中一样；</li><li>为进一步处理和动作而向某个特定的服务器发送一个分组，就像在深度分组检测（<code>DPI</code>）一样。</li></ul><p>因为在通用转发中，能够使用网络层和/或链路层源和目的地址做出转发决定，所以转发设备用通用的描述称为分组交换机，而不仅仅是路由器或交换机。位于每台分组交换机中的一张匹配加动作表，虽然在各台分组交换机中的控制组件可以相互作用，但实践中是远程控制器计算、安装和更新这些表。对通用转发将主要考虑<code>OpenFlow 1.0</code>，该标准引入了关键的<code>SDN</code>抽象和功能。匹配加动作转发表在<code>OpenFlow</code>中称为流表（flow table），它的每个表项包括：</p><ul><li>首部字段值的集合，入分组将与之匹配。匹配不上流表项的分组将被丢弃或发送到远程控制器做更多处理。在实践中，为了性能或成本原因，一个流表可以由多个流表实现。</li><li>计数器集合。当分组与流表项匹配时更新计数器，可以包括已经与该表项匹配的分组数量，以及自从该表项上次更新以来的时间。</li><li>当分组匹配流表项时所采取的动作集合。包括将分组转发到给定的输出端口，丢弃该分组、复制该分组和将它们发送到多个输出端口，和/或重写所选的首部字段。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/ukeXwxVn7SGiHZ6.png"                      alt="image-20210601164513374"                ></p><h3 id="4-4-1-匹配"><a href="#4-4-1-匹配" class="headerlink" title="4.4.1   匹配"></a>4.4.1   匹配</h3><p><code>Openflow</code>的匹配抽象允许对来自三个层次的协议首部所选择的字段进行匹配。入端口是指分组交换机上接收分组的输入端口，入端口ID能被<code>OpenFlow 1.0</code>中的匹配加动作规则所匹配。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/01/JaIsBOQNvHhGRSK.png"                      alt="image-20210601185825435"                >流表项也可以有通配符。例如，在一个流表中<code>IP</code>地址128.119.*.*。每个流表项也具有相应的优先权，如果一个分组匹配多个流表项，选定的匹配和对应的动作将是其中有最高优先权的那个。</p><h3 id="4-4-2-动作"><a href="#4-4-2-动作" class="headerlink" title="4.4.2   动作"></a>4.4.2   动作</h3><p>每个流表项都有零个或多个动作列表，这些动作决定了应用于与流表项匹配的分组的处理。如果有多个动作，它们以在表中规定的次序执行。其中最为重要的动作可能是：</p><ul><li>转发。入分组可以转发到一个特定的物理输出端口，广播到所有端口（分组到达的端口除外），或对所选的端口集合进行多播。该分组可能被封装并发送到用于该设备的远程控制器。该控制器则可能对该分组采取某些动作，包括安装新的流表项，以及可能将该分组返回给该设备以在更新的流表规则集合下进行转发。</li><li>丢弃。没有动作的流表项表明某个匹配的分组应当被丢弃。</li><li>修改字段。在分组被转发到所选的输出端口之前，分组首部10个字段（除<code>IP</code>协议字段)中的值都可以重写。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络层能够被分解为两个相互作用的部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网络层的数据平面功能，即网络层中每台路由器的功能，决定到路由器一条输入链路的数据报如何转发到该路由器的一条输出链路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络层的控制平面功能，即网络范围的逻辑，控制数据报</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络：自顶向下方法" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>06-链路层和局域网</title>
    <link href="http://example.com/2021/06/07/note/Computer%20Networking/06-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <id>http://example.com/2021/06/07/note/Computer%20Networking/06-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</id>
    <published>2021-06-07T10:47:32.587Z</published>
    <updated>2021-06-25T13:00:23.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-链路层概述"><a href="#6-1-链路层概述" class="headerlink" title="6.1   链路层概述"></a>6.1   链路层概述</h2><p>运行链路层协议协议的任何设备均称为节点（node），包括主机、路由器、交换机和<code>WiFi</code>接入点。沿着通信路径连接相邻节点的通信信道称为链路（link）。</p><h3 id="6-1-1-链路层提供的服务"><a href="#6-1-1-链路层提供的服务" class="headerlink" title="6.1.1   链路层提供的服务"></a>6.1.1   链路层提供的服务</h3><p>链路层的基本服务是将数据报通过单一通信链路从一个节点移动到相邻节点，可能提供的服务包括：</p><ul><li><p>成帧（framing）。将网络层数据报用链路层帧封装起来，帧的结构由链路层协议规定。</p></li><li><p>链路接入。媒体访问控制（<code>MAC</code>）协议规定了帧在链路上传输的规则。</p></li><li><p>可靠交付。链路层的可靠交付服务通常也是通过确认和重传取得的，通常用于易于产生高差错率的链路，例如无线链路，其目的是本地（也就是在差错发生的链路上）上纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而对于低比特差错的链路，包括光纤、同轴电缆和许多双绞铜线链路，可能不提供可靠交付服务。</p></li><li><p>差错检测和纠正。帧中的比特差错是由信号衰减和电磁噪声导致的。通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查。</p></li></ul><h3 id="6-1-2-链路层在何处实现"><a href="#6-1-2-链路层在何处实现" class="headerlink" title="6.1.2   链路层在何处实现"></a>6.1.2   链路层在何处实现</h3><p>链路层的主体部分是在网络适配器中实现的，网络适配器有时也称为网络接口卡（<code>NIC</code>）。位于网络适配器核心的是链路层控制器，通常是一个实现了许多链路层服务的专用芯片，现在越来越多的网络适配器被综合进主机的主板。</p><p>在发送端，控制器取得了由协议栈较高层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报，然后遵循链路接入协议将该帧传进通信链路中。在接收端，控制器接收了整个帧，抽取出网络层数据报。如果链路层执行差错检测，则需要发送控制器在该帧的首部设置差错检测比特，由接收控制器执行差错检测。</p><p>大部分链路层是在硬件中实现的，但部分链路层是在运行于主机CPU上的软件中实现的。链路层的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。在接收端，链路层软件响应控制器中断、处理差错条件和将数据报向上传递给网络层，所以链路层是硬件和软件的结合体，即此处是协议栈中软件与硬件交接的地方。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/F5hETSdXUwVfk6G.png"                      alt="image-20210607185627115"                ></p><h2 id="6-2-差错检测和纠正技术"><a href="#6-2-差错检测和纠正技术" class="headerlink" title="6.2   差错检测和纠正技术"></a>6.2   差错检测和纠正技术</h2><p>比特级差错检测和纠正：即对从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行检测和纠正。</p><p>在发送节点，为了保护比特免受差错，使用差错检测和纠正比特（<code>EDC</code>）来增强数据<code>D</code>，通常要保护的数据包括数据报和链路帧首部中的链路级的寻址信息、序号和其他字段。链路级帧中的<code>D</code>和<code>EDC</code>都被发送到接收节点。接收方收到<code>D&#39;</code>和<code>EDC&#39;</code>，确定<code>D&#39;</code>是否和初始的D相同。差错检测和纠正技术可能会使接收方有时检测不出比特差错，从而接收方向网路层交付一个损伤的数据报。</p><p>在传输数据中检测差错的3种技术：</p><ul><li>奇偶校验，用来描述差错检测和纠正背后隐含的基本思想。</li><li>检验和方法，通常应用于运输层。</li><li>循环冗余检测，通常应用在适配器中的链路层。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/jqiwXQnHDW75Stf.png"                      alt="image-20210607185828688"                ></p><h3 id="6-2-1-奇偶校验"><a href="#6-2-1-奇偶校验" class="headerlink" title="6.2.1   奇偶校验"></a>6.2.1   奇偶校验</h3><p>差错检测最简单的方式就是用单个奇偶校验位。发送方只需包含一个附加的比特，选择它的值，使得这d + 1中1的总数是偶数，对于奇校验方案则相反。如果在采用偶校验方案中发现了奇数个值为1的比特，接收方就知道出现了奇数个比特差错。</p><p>但是如果出现了偶数个比特差错，这将导致一个未检出的差错。在突发差错的情况下，使用单比特奇偶校验保护的一帧中未检测出差错的概率只能够达到50%。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/jH1spXt4mvbgZ9U.png"                      alt="image-20210607185933479"                ></p><p>因此出现了单比特奇偶校验方案的二维一般化方案。这里D中的d个比特被划分为i行j列。对每行和每列计算奇偶值，产生的i+j+1奇偶比特构成了链路层帧的差错检测比特。假设在初始d比特信息中出现了单个比特差错，包含比特值改变的列和行的校验值都将会出现差错，因此接收方不仅可以检测还可以利用存在奇偶校验差错的列和行的索引来识别发生差错的比特并纠正它。二维奇偶校验能够检测但不能纠正一个分组中两个比特差错的任何组合。</p><p>接收方检测和纠正差错的能力被称为前向纠错（<code>FEC</code>），<code>FEC</code>可以减少所需的发送方重发的次数，这对于实时网络应用或者具有长传播时延的链路很重要，通常用于音频存储和回放设备中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/F98J647hUBLDerS.png"                      alt="image-20210607190101258"                ></p><h3 id="6-2-2-检验和方法"><a href="#6-2-2-检验和方法" class="headerlink" title="6.2.2   检验和方法"></a>6.2.2   检验和方法</h3><p>在检验和技术中，d比特数据被作为一个k比特整数的序列处理。比如一个简单检验和方法就是将数据作为16比特的整数对待并求和，这个和的反码形成了携带在报文段首部的互联网检验和，接收方通过对接收的数据（包括检验和）的和取反码，并且检测其结果是否为全1比特来检测检验和。</p><p>在<code>TCP</code>和<code>UDP</code>协议中，对首部和数据字段都计算检验和，而<code>XTP</code>对首部和整个分组分别计算一个检验和。因为运输层差错检测用软件实现，需要检验和这样的简单快速的差错检测方案。而链路层的差错检测在适配器中用专用的硬件能更快实现，所以它一般采用更复杂的<code>CRC</code>操作。</p><h3 id="6-2-3-循环冗余检测"><a href="#6-2-3-循环冗余检测" class="headerlink" title="6.2.3   循环冗余检测"></a>6.2.3   循环冗余检测</h3><p>循环冗余检测（<code>CRC</code>）编码，也称为多项式编码，关键思想：发送方和接收方首先协商一个r+1比特模式，称为生成多项式G，要求G的最高有效位的比特是1，对于一个给定的数据段D，发送方要选择r个比特R附加到D上，使得d+r比特模式用模2算术恰好能被G整除。接收方用G去除接收到的d+r比特。如果余数为零，接收方认为数据正确而被接收，否则知道出现了差错。</p><p>所有<code>CRC</code>计算采用模2算术来做，在加法中不进位，在减法中不借位，等价于操作数的按位异或（XOR），乘以2<sup>r</sup>就是以一种比特模式左移r个位置，当给定D和R，D·2<sup>r </sup>  XOR  R产生d+r比特模式。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/axrbSgiftIeKvZQ.png"                      alt="image-20210607210354754"                ></p><p>求R公式：首先要满足R，使得G能够除以D·2<sup>r</sup>  XOR R没有余数需要满足下面这个等式：<br>$$<br>D·2^r\quad XOR \quad R= nG<br>$$<br>在对上述等式的两边都用R异或，并将R单独放到等式一边，可以清晰得出求R计算过程：<br>$$<br>R=remainder\frac{D·2^r}{G}<br>$$<br>下图为当D=101110，d=6，G=1001，r=3的情况下的计算得到R为011，因此传输的9个比特是101110011。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/UQEwLe4hTCI6Kod.png"                      alt="image-20210607223647423"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/gk4GDwURyEPdaCV.png"                      alt="image-20210607220949982"                ></p><p>国际标准已经定义了8、12、16和32比特生成多项式G。<code>CRC-32</code>32比特的标准被多种链路级IEEE协议采用，使用的一个生成多项式是：G<sub>CRC-32</sub>=10000010011000001001110110110 11。每个<code>CRC</code>标准都能检测小于r+1比特的突发差错，包括奇数个比特差错，长度大于r+1比特的突发差错以概率1-0.5<sup>r</sup>被检测到。    </p><h2 id="6-3-多路访问链路和协议"><a href="#6-3-多路访问链路和协议" class="headerlink" title="6.3   多路访问链路和协议"></a>6.3   多路访问链路和协议</h2><p>有两种类型的网络链路：点对点链路和广播链路。点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成。如点对点协议（<code>PPP</code>）和高级数据链路控制（<code>HDLC</code>）就是为点对点链路设计的。广播链路能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上，以太网和无线局域网是广播链路层技术的例子。</p><p>由于广播信道所有的节点都能够传输帧，所有节点同时接到多个帧，如果传输的帧在所有的接收方处碰撞了，就没有一个接收节点能够有效地获得任何传输的帧，在碰撞时间间隔中的广播信道被浪费了，因此需要多路访问协议，规范节点在共享的广播信道上的传输行为。多路访问协议划分为3种类型：信道划分协议、随机接入协议、轮流协议。</p><h3 id="6-3-1-信道划分协议"><a href="#6-3-1-信道划分协议" class="headerlink" title="6.3.1 信道划分协议"></a>6.3.1 信道划分协议</h3><p>时分多路复用（<code>TDM</code>）和频分多路复用（<code>FDM</code>）是两种能够用于在所有共享信道节点之间划分广播信道带宽的技术。</p><p><code>TDM</code>将时间划分为时间帧，并进一步划分每个时间帧为N个时隙（slot），然后把每个时隙分配给N个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的<code>TDM</code>帧中指派给它的时隙内传输分组比特。通常，选择的时隙长度应使一个时隙内能够传输单个分组。<code>TDM</code>消除了碰撞而且公平。但有两个主要缺陷。首先，节点被限制于R/N bps的平均速率。其次，节点必须总是等待它在传输序列中的轮次，即使它是唯一要发送帧的节点。<code>FDM</code>将信道划分为不同的频段，也有<code>TDM</code>同样的优点和缺点。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/08/PFIY2jSznytoJUf.png"                      alt="image-20210608141944537"                ></p><p>第三种信道划分协议是码分多址（<code>CDMA</code>）。<code>TDM</code>和<code>FDM</code>分别为节点分配时隙和频率，而<code>CDMA</code>对每个节点分配一种不同的编码，然后每个节点用它唯一的编码来对它发送的数据进行编码。这样不同的节点就能够同时传输，接收方能正确接收发送方编码的数据比特，而不在乎其他节点的干扰传输，目前广泛地用于蜂窝电话中。</p><h3 id="6-3-2-随机接入协议"><a href="#6-3-2-随机接入协议" class="headerlink" title="6.3.2   随机接入协议"></a>6.3.2   随机接入协议</h3><p>在随机接入协议中，一个传输节点能以信道的全部速率进行发送。当有碰撞时，涉及碰撞的每个节点独立的选择一个随机时延重发它的帧，直到该帧无碰撞地通过为止。最常用的随机接入协议， <code>ALOHA</code>协议和载波侦听多路访问（<code>CSMA</code>）协议。以太网就是部署的<code>CSMA</code>协议。</p><h4 id="6-3-2-1-时隙ALOHA"><a href="#6-3-2-1-时隙ALOHA" class="headerlink" title="6.3.2.1   时隙ALOHA"></a>6.3.2.1   时隙<code>ALOHA</code></h4><p>在每个节点中，时隙 <code>ALOHA</code>的操作：</p><ul><li>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</li><li>如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧。</li><li>如果有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点以概率P在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</li></ul><p>时隙 <code>ALOHA</code>与信道划分不同，当某节点是唯一活跃的节点时，允许该节点以R连续传输，同样也是高度分散的，因为每个节点检测碰撞并独立地决定什么时候重传。然而时隙 <code>ALOHA</code>需要在节点中对时隙同步，不分时隙的<code>ALOHA</code>版本以及<code>CSMA</code>协议，则不需要这种同步。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/08/aZNPqf86TSoKlpQ.png"                      alt="image-20210608142329576"                ></p><h4 id="6-3-2-2-ALOHA"><a href="#6-3-2-2-ALOHA" class="headerlink" title="6.3.2.2   ALOHA"></a>6.3.2.2   <code>ALOHA</code></h4><p>在纯<code>ALOHA</code>中，当一帧首次到达，节点立刻将该帧完整地传输进广播信道，如果一个传输的帧经历了碰撞，节点将立即以概率p重传该帧，否则节点等待一个帧传输时间再以概率p传输该帧，直到无碰撞传输成功。纯 <code>ALOHA</code>协议的最大效率是时隙 <code>ALOHA</code>的一半，但不需要在节点中对时隙同步。</p><h4 id="6-3-2-3-载波侦听多路访问（CSMA）和-具有碰撞检测的载波侦听多路访问（CSMA-CD）"><a href="#6-3-2-3-载波侦听多路访问（CSMA）和-具有碰撞检测的载波侦听多路访问（CSMA-CD）" class="headerlink" title="6.3.2.3   载波侦听多路访问（CSMA）和 具有碰撞检测的载波侦听多路访问（CSMA/CD）"></a>6.3.2.3   载波侦听多路访问（<code>CSMA</code>）和 具有碰撞检测的载波侦听多路访问（<code>CSMA/CD</code>）</h4><p>在时隙和纯<code>ALOHA</code>中，节点传输的决定独立于其他节点的活动，不关心在它开始传输时是否有其他节点碰巧在传输，而且即使有另一个节点开始干扰它的传输也不会停止传输。载波侦听多路访问（<code>CSMA</code>）和具有碰撞检测的<code>CSMA</code>（<code>CSMA/CD</code>）协议有以下两个规则：</p><ul><li><p>载波侦听，节点在传输前先侦听信道，如果来自另个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有其他节点传输侦了，才开始本节点的传输。</p></li><li><p>碰撞检测，节点在传输时持续侦听信道，如果检测到另一个节点正在传输干扰帧，就停止传输，随机等待一段时间再侦听信道是否空闲。</p></li></ul><p>如下图左所示，在时刻t<sub>0</sub>，节点B侦听到信道是空闲的，因此节点B开始沿着广播媒体在两个方向上传播它的比特。B的比特随着时间的增加向下传播，但节点D在时刻t<sub>1</sub>也有帧要发送，但B传输的比特还没有到达D，因此D在t<sub>1</sub>侦听到信道空闲，因此一个短暂的时间之后，B的传输开始在D干扰D的传输。广播信道的端到端信道传播时延越长，载波侦听节点不能侦听到另一个节点已经开始传输的可能就越大，因此即便所有的节点都进行载波侦听，还是可能会发生碰撞。</p><p>如下图有所示，当某节点执行碰撞检测时，一旦它检测到碰撞将立即停止传输。显然，在多路访问协议中加入碰撞检测，不传输一个无用的、损坏的帧有助于改善协议的性能。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/08/nc5K4zfHp9Ml12L.png"                      alt="image-20210608142621305"                ></p><p>在节点中的适配器与广播信道相连的运行过程：</p><ol><li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中。</li><li>如果适配器侦听到无信号能量从信道进入适配器（即信道空闲），开始传输帧。否则将等待直到侦听到没有信号能量时才开始传输帧。</li><li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。否则中止传输。</li><li>中止传输后，适配器等待一个随机时间量，然后返回步骤2。</li></ol><p>等待时间量的要求：</p><ul><li>必须随机。如果两个节点同时传输帧，等待时间量也是固定的，将持续碰撞下去。</li><li>随机回退时间的间隔。如果时间间隔大而碰撞节点数量小，节点很可能等待较长的时间。如果时间间隔小而碰撞节点数量大，很可能选择的随机值将几乎相同，传输节点将再次碰撞。</li></ul><p>通过二进制指数后退算法，使得当碰撞节点数量较少时，时间间隔较短；当碰撞节点数量较大时，时间间隔较长。当传输一个帧时，在该帧经历了一连串的n次碰撞后，节点随机地从{0，1，2，…，2<sup>n</sup>-1}中选择一个K值。因此一个帧经历的碰撞越多，K选择的间隔越大。</p><p>传播时延（信号从一个节点传播到另一个节点所花费的时间）越小，传输一个最大长度的以太网帧的时间越大<code>CSMA/CD</code>效率越高。</p><h3 id="6-3-3-轮流协议"><a href="#6-3-3-轮流协议" class="headerlink" title="6.3.3   轮流协议"></a>6.3.3   轮流协议</h3><p>轮流协议有两种比较重要的协议：</p><ul><li><p>轮询协议。要求指定一个节点为主节点，主节点以循环的方式轮询每个节点，告知其能够传输的帧的最多数量。主节点能够通过观察在信道上是否缺乏信号，来决定一个节点何时完成了帧的发送。从而避免了随机接入协议的碰撞和空时隙，使得轮询效率更高。缺点在于，引入了轮询时延，即便只有一个节点是活跃的，主节点也必须依次轮询每一个节点；其次如果主节点有故障，整个信道都变得不可操作。蓝牙协议就是轮询协议的例子。</p></li><li><p>令牌传递协议。一个称为令牌的特殊帧在节点之间以某种固定的次序进行交换。当一个节点收到令牌时，如果它有一些帧要发送时，基于发送最大数目的帧数，否则立即向下一个节点转发该令牌。令牌传递是分散的，并有很高的效率。但缺点在于，一个节点的故障可能会使整个信道崩溃，或者如果一个节点没有释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p></li></ul><h3 id="6-3-4-DOCSIS：用于电缆互联网接入的链路层协议"><a href="#6-3-4-DOCSIS：用于电缆互联网接入的链路层协议" class="headerlink" title="6.3.4   DOCSIS：用于电缆互联网接入的链路层协议"></a>6.3.4   <code>DOCSIS</code>：用于电缆互联网接入的链路层协议</h3><p>在电缆接入网中应用了多种多路访问协议（<code>FDM</code>、<code>TDM</code>、随机接入和集中分配时隙）。一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个电缆调制解调器端接系统（<code>CMTS</code>）连接。数据经电缆服务接口规范（<code>DOCSIS</code>）定义了电缆数据网络体系结构及其协议。<code>DOCSIS</code>使用<code>FDM</code>将下行（<code>CMTS</code>到调制解调器）和上行（调制解调器到<code>CMTS</code>）网络段划分为多个频率信道，每个上行和下行信道均为广播信道。<code>CMTS</code>在下行信道中传输的帧被所有在信道上做接收的电缆调制解调器接收到，因为仅有单一的<code>CMTS</code>在下行信道上传输，不存在多路访问问题。但在上行方向，因为多个电缆调制解调器共享到<code>CMTS</code>的相同上行信道（频率），因此能够潜在地出现碰撞。</p><p>每条上行信道被划分为时间间隔(类似<code>TDM</code>)，每个时间间隔包含一个微时隙序列，电缆调制解调器可在该微时隙中向<code>CMTS</code>传输。<code>CMTS</code>在下行信道上通过发送<code>MAP</code>报文的控制报文，指定电缆调制解调器能够在微时隙中传输由控制报文指定的时间间隔。由于微时隙被明确分配给电缆调制解调器，故<code>CMTS</code>能够确保在微时隙中没有碰撞传输。</p><p>通过在一组特殊的微时隙间隔内向<code>CMTS</code>发送微时隙请求帧，从而知道哪个电缆调制解调器有数据要发送。这些微时隙请求帧以随机接入方式传输，故可能相互碰撞，但电缆调制解调器既不能侦听上行信道是否忙，也不能检测碰撞，如果该电缆调制解调器如果没有在下一个下行控制报文中收到对请求分配的响应的话，就推断出它的微时隙请求帧经历了一次碰撞，再使用二进制指数回退将其微时隙请求帧延缓到以后的时隙重新发送。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/08/t4Zuw8yhpkgFr2d.png"                      alt="image-20210608142916258"                ></p><h2 id="6-4-交换局域网"><a href="#6-4-交换局域网" class="headerlink" title="6.4   交换局域网"></a>6.4   交换局域网</h2><h3 id="6-4-1-链路层寻址和ARP"><a href="#6-4-1-链路层寻址和ARP" class="headerlink" title="6.4.1   链路层寻址和ARP"></a>6.4.1   链路层寻址和<code>ARP</code></h3><h4 id="6-4-1-1-MAC地址"><a href="#6-4-1-1-MAC地址" class="headerlink" title="6.4.1.1   MAC地址"></a>6.4.1.1   <code>MAC</code>地址</h4><p>主机或路由器的每个适配器即网络接口具有链路层地址，然而链路层交换机并不具有与它们的接口相关联的链路层地址，因为链路层交换机的任务是在主机与路由器之间承载数据报，主机或路由器不必明确地将帧寻址到其间的交换机。链路层地址有各种不同的称呼：LAN地址、物理地址或<code>MAC</code>地址。对于大多数局域网（包括以太网和802.11无线局域网）而言，<code>MAC</code>地址长度为6字节，通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。</p><p>适配器具有唯一的<code>MAC</code>地址，由IEEE管理<code>MAC</code>地址空间，分配方式是：固定一个<code>MAC</code>地址的前24比特，让公司自己为每个适配器生成后24比特的唯一组合。适配器的<code>MAC</code>地址具有扁平结构，不论适配器地理位置在哪里都不会变化，而<code>IP</code>地址具有层次结构，当主机或路由器地理位置改变，<code>IP</code>地址也需要改变，即改变它所连接到的网络。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/cHwfvsCSjNVlqJQ.png"                      alt="image-20210609153347468"                ></p><p>当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的<code>MAC</code>地址插入到该帧中，并将该帧广播到局域网上，当适配器接收到一个帧时，将检查该帧中的目的<code>MAC</code>地址是否与它自己的<code>MAC</code>地址匹配。如果匹配，该适配器提取出封装的数据报，并将该数据报沿协议栈向上传递，否则该适配器丢弃该帧。但有时某发送适配器要让局域网上所有其他适配器来接收并处理它发送的帧，发送适配器在该帧的目的地址字段中插入一个特殊的<code>MAC</code>广播地址。对于以太网和802.11来说，广播地址是FF-FF-FF-FF-FF-FF。</p><p>主机和路由器接口除了网络层地址之外还有<code>MAC</code>地址，原因如下：</p><ul><li>局域网是为任意网络层协议而设计的，不只是用于<code>IP</code>和互联网。如果适配器被指派<code>IP</code>地址，则适配器将不能够方便地支持其他网络层协议，并且在每次适配器移动或断电时要重新配置。</li><li>如果适配器中不使用任何地址，让每个适配器将它收到的每帧数据沿协议栈向上传递，由网络层核对网络地址层是否匹配，这样主机将被局域网上发送的每个帧中断，包括被目的地是在相同广播局域网上的其他节点的帧中断。</li></ul><h4 id="6-4-1-2-地址解析协议"><a href="#6-4-1-2-地址解析协议" class="headerlink" title="6.4.1.2   地址解析协议"></a>6.4.1.2   地址解析协议</h4><p>地址解析协议（<code>ARP</code>）用于网络层地址和链路层地址之间的转换。<code>ARP</code>将一个<code>IP</code>地址解析为一个<code>MAC</code>地址，和<code>DNS</code>类似，区别是<code>ARP</code>只为在同一个子网上的主机和路由器接口解析P地址。</p><p>每台主机或路由器在其内存中具有一个<code>ARP</code>表，包含了<code>IP</code>地址到<code>MAC</code>地址的映射关系和一个寿命（TTL）值，它指示了从表中删除每个映射的时间，通常是20分钟。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/8kf37RtQgGOlysJ.png"                      alt="image-20210609155118402"                ></p><p>当源主机<code>ARP</code>表中没有该目的主机的表项时，发送方用<code>MAC</code>广播地址发送一个<code>ARP</code>分组，包括发送和接收方<code>IP</code>地址及发送方<code>MAC</code>地址，<code>ARP</code>查询分组和响应分组都具有相同的格式。子网上所有其他主机和路由器都能收到<code>ARP</code>查询分组，然后检查它的<code>IP</code>地址是否与<code>ARP</code>分组中的目的<code>IP</code>地址相匹配，与之匹配的一个给查询主机发送回一个带有所希望映射的响应<code>ARP</code>分组，然后查询主机能够更新它的<code>ARP</code>表。</p><p><code>ARP</code>是即插即用的，一个<code>ARP</code>表是自动建立的，不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除掉。</p><h4 id="6-4-1-3-发送数据报到子网以外"><a href="#6-4-1-3-发送数据报到子网以外" class="headerlink" title="6.4.1.3   发送数据报到子网以外"></a>6.4.1.3   发送数据报到子网以外</h4><p>当子网中的某主机要向子网之外的主机发送网络层数据报，每台主机和路由器的每个接口都有一个<code>IP</code>地址和一个适配器和<code>ARP</code>模块。假设主机1111.11.11要向主机222.22.22.222发送一个<code>IP</code>数据报，发送主机向它的适配器指示目的<code>MAC</code>地址，即路由器接口111.111.11.10的适配器地址，再通过查询路由器中的转发表把这个数据报封装到一个新的帧中，并且将帧发送进子网2中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/TcpA38slQifJtUq.png"                      alt="image-20210609160917341"                ></p><h3 id="6-4-2-以太网"><a href="#6-4-2-以太网" class="headerlink" title="6.4.2   以太网"></a>6.4.2   以太网</h3><h4 id="6-4-2-1-以太网帧结构"><a href="#6-4-2-1-以太网帧结构" class="headerlink" title="6.4.2.1   以太网帧结构"></a>6.4.2.1   以太网帧结构</h4><p>以太网帧结构的6个字段：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/RyzgBQtGjVwcZPW.png"                      alt="image-20210609163255227"                ></p><ul><li><strong>前同步码</strong>（8字节）。该前同步码的前7字节的值都是10101010，用于将接收适配器的时钟和发送方的时钟同步。因为发送适配器根据以太局域网类型的不同，传输帧的速率也不同，接收适配器通过锁定前同步码的前7字节的比特，就能够锁定发送适配器的时钟。最后一个字节是10101011，其中最后两个连续的1用于提醒接受适配器接下来的内容。</li><li><strong>目的地址</strong>（6字节）。目的适配器的<code>MAC</code>地址，当接收适配器收到一个以太网帧，帧的目的地址于自身相同或者是<code>MAC</code>广播地址，就将该帧的数据字段的内容传递给网络层，否则丢弃。</li><li><strong>源地址</strong>（6字节）。传输该帧到局域网上的适配器的<code>MAC</code>地址，</li><li><strong>类型字段</strong>（2字节）。类型字段允许以太网复用多种网络层协议。当以太网帧到达适配器，适配器根据类型字段的内容传递给对应网络层协议。</li><li><strong>数据字段</strong>（46-1500字节）。这个字段承载<code>IP</code>数据报。以太网的最大传输单元（<code>MTU</code>）是1500字节。这意味着如果<code>IP</code>数据报超过了1500字节，则主机必须将该数据报分片。如果小于46字节，数据报必须被填充到46字节，网络层使用<code>IP</code>数据报首部中的长度字段来去除填充部分。</li><li>**<code>CRC</code>**（4字节）。使得接收适配器检测帧中是否引入了差错。</li></ul><p>所有的以太网技术都向网络层提供无连接服务，发送适配器和接受适配器不会提前握手，也不提供可靠服务。接收适配器对帧进行<code>CRC</code>校验时既不发送确认帧，也不发送否定确认帧，而是直接丢弃该帧。如果由于丢弃了以太网帧而存在间隙，如果上层协议使用的是<code>UDP</code>，的确会看到数据中的间隙，如果使用的是TCP，接收主机的TCP将不会确认包含在丢弃帧中的数据，从而引起发送主机的TCP重传。对于以太网来说，并不知道是一个帧是全新的还是重传的。</p><h3 id="6-4-3-链路层交换机"><a href="#6-4-3-链路层交换机" class="headerlink" title="6.4.3   链路层交换机"></a>6.4.3   链路层交换机</h3><p>交换机的任务是接收入链路层帧并将它们转发到出链路，交换机自身对子网中的主机和路由器是透明的，某主机/路由器向另一个主机/路由器寻址一个帧而不是向交换机寻址该帧。</p><h4 id="6-4-3-1-交换机转发和过滤"><a href="#6-4-3-1-交换机转发和过滤" class="headerlink" title="6.4.3.1   交换机转发和过滤"></a>6.4.3.1   交换机转发和过滤</h4><p>交换机有两个功能过滤和转发，过滤是决定一个帧应该转发到某个接口还是应当将其丢弃。转发是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口。交换机的过滤和转发借助于交换机表完成，包含某局域网上某些主机和路由器的但不必是全部。交换机表中的一个表项包含：</p><ul><li>一个<code>MAC</code>地址；</li><li>通向该<code>MAC</code>地址的交换机接口；</li><li>表项放置在表中的时间。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/vkfC4gObxPVu9z3.png"                      alt="image-20210609170637194"                ></p><p>交换机表是自动、动态和自治地建立的，是自学习的，当目的<code>MAC</code>地址从接口X到达，交换机索引它的表，有3种可能的情况：</p><ul><li>没有目的<code>MAC</code>地址的表项。交换机向除接口x外的所有接口前面的输出缓存转发该帧的副本。</li><li>有一个表项将目的<code>MAC</code>地址与接口X联系。该帧是从包括目的<code>MAC</code>地址适配器的局域网网段到来的。无须将该帧转发到任何其他接口，丢弃该帧即可。</li><li>有一个表项目的<code>MAC</code>地址与接口Y但不是X联系。该帧需要被转发到与接口Y相连的局域网网段，将该帧放到接口Y前面的输出缓存完成转发功能。</li></ul><h4 id="6-4-3-2-链路层交换机的性质"><a href="#6-4-3-2-链路层交换机的性质" class="headerlink" title="6.4.3.2   链路层交换机的性质"></a>6.4.3.2   链路层交换机的性质</h4><p>交换机不同于如总线或基于集线器的星形拓扑那样的广播链路，优点如下：</p><ul><li>消除碰撞。交换机缓存帧并且不会在网段上同时传输多于一个帧，没有因碰撞而浪费的带宽。</li><li>异质的链路。交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。</li><li>安全性。与如802.11局域网或基于集线器的以太局域网的广播链路环境形成对比，在交换局域网的环境中，当一台主机与某交换机相连时，它通常仅接收到明确发送给它的帧，因此其他主机无法通过运行嗅探器嗅探不是明确寻址到它的帧，广播帧除外，因此也出现一个对抗交换机的攻击称为交换机毒化，它向交换机发送大量的具有不同伪造源<code>MAC</code>地址的分组，因为交换机表中未出现包含该地址的表项，从而广播大多数帧，从而被嗅探器俘获到。</li><li>易于管理。如果一个适配器工作异常并持续发送以太网帧，交换机能够检测到该问题，并在内部断开异常适配器。交换机也收集带宽使用的统计数据、碰撞率和流量类型，并使这些信息为网络管理者使用，用于调试和解决问题。</li></ul><h4 id="6-4-3-3-交换机和路由器比较"><a href="#6-4-3-3-交换机和路由器比较" class="headerlink" title="6.4.3.3    交换机和路由器比较"></a>6.4.3.3    交换机和路由器比较</h4><p>路由器是使用网络层地址的存储转发分组交换机。交换机是使用<code>MAC</code>地址的存储转发分组交换机，使用“匹配加动作”的现代交换机能够转发基于目的<code>MAC</code>地址的帧，也能转发基于目的<code>IP</code>地址的数据报。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/EmY3vFD6hZsP7WN.png"                      alt="image-20210609170731557"                ></p><p>交换机和路由器比较：</p><ul><li>交换机是即插即用的，具有相对高的分组过滤和转发速率。而路由器不是，即路由器和连接到它们的主机都需要配置<code>IP</code>地址，而且路由器对每个分组的处理时间更长，因为它们必须处理高达第三层的字段。</li><li>交换机为了防止广播帧的循环，交换网络的活跃拓扑限制为一棵生成树。而路由器寻址是分层次的，即使当网络中存在冗余路径时，分组通常也不会通过路由器循环，除非路由器表被误配置，所以分组就不会被限制到一棵生成树上，因此它们允许以丰富的拓扑结构构建互联网，可以使用源和目的地之间的最佳路径。</li><li>大型交换网络中，要求在主机和路由器中有较大的<code>ARP</code>表，这将生成大量的<code>ARP</code>流量和处理量，而交换机对于广播风暴并不提供任何保护措施，如果某主机出了故障传输大量以太网广播帧流，交换机还是转发所有帧，使得整个以太网的崩溃。而路由器对第二层的广播风暴提供了防火墙保护。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/eAqDVujixBYaZfI.png"                      alt="image-20210609170752563"                ></p><p>通常，由几百台主机组成的小网络通常有几个局域网网段，交换机就足够了，因为它们不要求<code>IP</code>地址的任何配置就能使流量局部化并增加总计吞吐量。但在由几千台主机组成的更大网络中，通常在网络中除了交换机之外还包括路由器，路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用最佳路径路由。</p><h3 id="6-4-4-虚拟局域网"><a href="#6-4-4-虚拟局域网" class="headerlink" title="6.4.4   虚拟局域网"></a>6.4.4   虚拟局域网</h3><p>现代机构的局域网常常是配置为等级结构的，通常有3个缺点：</p><ul><li>缺乏流量隔离。尽管等级结构把组流量局域化到一个单一交换机中，但广播流量仍可跨越整个机构网络。更重要的是，出于安全/隐私的目的也可能希望限制局域网广播流量。</li><li>交换机的无效使用。如果一个机构有多个组，则将要求多个第一级交换机，但当每个组都较小，单台的交换机也足以容纳。</li><li>管理用户。如果一个主机在不同组间移动，必须改变物理布线，以将该主机连接到不同的交换机上。</li></ul><p>以上问题可以通过支持虚拟局域网（ <code>VLAN</code>）的交换机来处理。支持<code>VLAN</code>的交换机允许经一个单一的物理局域网定义多个虚拟局域网。在一个<code>VLAN</code>内的主机彼此通信，<code>VLAN</code>交换机的端口（接口）可划分为不同的组，每个组构成一个<code>VLAN</code>，在每个<code>VLAN</code>中的端口形成一个广播域。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="C:\Users\HuOneNumber\AppData\Roaming\Typora\typora-user-images\image-20210609170820531.png"                      alt="image-20210609170820531"                ></p><p>同一交换机下，不同<code>VLAN</code>之间的流量的通信：将<code>VLAN</code>交换机的一个端口与一台外部的路由器相连，并且将该端口同时配置为要互相通信<code>VLAN</code>。在此情况下，不同的组共享相同的物理交换机，但逻辑配置看起来不同的组经路由器连接的分离交换机。</p><p>不同交换机下，同一<code>VLAN</code>之间的通信：</p><ul><li><p>在隔离的每台交换机上将属于同一<code>VLAN</code>的端口彼此互联起来，然而这种解决方案不具有扩展性，因为在每台交换机上N个<code>VLAN</code>将要求N个端口直接互联这两台交换机。</p></li><li><p><code>VLAN</code>干线连接。每台交换机上的一个特殊端口被配置为干线端口，以互联这两台<code>VLAN</code>交换机。该干线端口属于所有<code>VLAN</code>，发送到任何<code>VLAN</code>的帧经过干线链路转发到其他交换机。IEEE定义了一种扩展的以太网帧格式<code>802.1Q</code>，用于跨越<code>VLAN</code>干线的帧。<code>802.1Q</code>帧由标准以太网帧加4字节<code>VLAN</code>标签组成，<code>VLAN</code>标签由一个标签协议标识符（<code>TPID</code>）字段、一个标签控制信息字段（包含一个<code>VLAN</code>标识符字段）和一个优先权字段（类似于<code>IP</code>数据报<code>TOS</code>字段）组成。<code>VLAN</code>标签由在<code>VLAN</code>干线发送侧的交换机加进帧中，解析后并由在<code>VLAN</code>干线接收侧的交换机删除。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/mE2e4ds61Wp5PU3.png"                      alt="image-20210609203917082"                ></p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/yfw6vVNImastFpT.png"                      alt="image-20210609171036853"                ></p><h2 id="6-5-链路虚拟化：网络作为链路层"><a href="#6-5-链路虚拟化：网络作为链路层" class="headerlink" title="6.5   链路虚拟化：网络作为链路层"></a>6.5   链路虚拟化：网络作为链路层</h2><p>多协议标签交换（<code>MPLS</code>）网络，是一种分组交换的虚电路网络。它们有自己的分组格式和转发行为。其目标是：基于固定长度标签和虚电路的技术，在不放弃基于目的地<code>IP</code>数据报转发的基础设施的前提下，当可以时通过选择性地标识数据报并允许路由器基于固定长度的标签而不是目的地<code>IP</code>地址转发数据报来增强其功能。</p><p>下图显示了在<code>MPLS</code>使能的路由器之间传输的一个链路层帧，该帧具有一个小的<code>MPLS</code>首部，增加到第二层首部和第三层首部之间。包括在<code>MPLS</code>首部中的字段是：标签；预留的实验字段；S字段，用于指示一系列“成栈”的<code>MPLS</code>首部的结束；寿命字段。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="C:\Users\HuOneNumber\AppData\Roaming\Typora\typora-user-images\image-20210609215604563.png"                      alt="image-20210609215604563"                ></p><p>一个<code>MPLS</code>加强的帧仅能在两个均为<code>MPLS</code>使能的路由器（标签交换路由器）之间发送，它通过在其转发表中查找<code>MPLS</code>标签，然后立即将数据报传递给适当的输出接口来转发<code>MPLS</code>帧，不需要提取目的<code>IP</code>地址和在转发表中执行最长前缀匹配的查找。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/u8DZULyg9jvMGXP.png"                      alt="image-20210609220114444"                ></p><p><code>MPLS</code>的优点不仅在于交换速度的潜在增加，还在于<code>MPLS</code>使能的新的流量管理能力。如前面所述，<code>R4</code>到A具有两条<code>MPLS</code>路径。如果转发在<code>IP</code>层基于<code>IP</code>地址执行，<code>IP</code>路由选择协议将只指定到A的单一最小费用的路径，所以<code>MPLS</code>提供了沿着多条路由转发分组的能力。网络运行者能够超越普通的<code>IP</code>路由选择，迫使某些流量沿着一条路径朝着某给定的目的地引导，并且朝着相同目的地的其他流量沿着另一条路径流动，还能用于执行<code>MPLS</code>转发路径的快速恢复，例如，经过一条预计算的无故障路径重路由流量来对链路故障做出反应。<code>MPLS</code>已被用于实现虚拟专用网（<code>VPN</code>）。</p><h2 id="6-6-Web页面请求的历程"><a href="#6-6-Web页面请求的历程" class="headerlink" title="6.6   Web页面请求的历程"></a>6.6   Web页面请求的历程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/09/HJrn93RM1ybwae2.png"                      alt="image-20210609222828355"                ></p><h3 id="6-6-1-准备：DHCP、UDP、IP和以太网"><a href="#6-6-1-准备：DHCP、UDP、IP和以太网" class="headerlink" title="6.6.1   准备：DHCP、UDP、IP和以太网"></a>6.6.1   准备：<code>DHCP</code>、<code>UDP</code>、<code>IP</code>和以太网</h3><p>将个人电脑用一根以太网电缆连接到学校的以太网交换机，交换机与学校的路由器相连，学校的这台路由器与一个<code>ISP</code>连接，本例中<code>ISP</code>为 <code>Comcast.net</code>，并为学校提供了<code>DNS</code>服务；假设<code>DHCP</code>服务器运行在路由器中。</p><p>当首先将其个人电脑与网络连接时，个人电脑所采取的一个网络相关的动作是运行<code>DHCP</code>协议，以从本地<code>DHCP</code>服务器获得一个<code>IP</code>地址以及其他信息。</p><ol><li>个人电脑上的操作系统生成一个<code>DHCP</code>请求报文，并将这个报文放入具有目的端口67（<code>DHCP</code>服务器）和源端口68（<code>DHCP</code>客户）的<code>UDP</code>报文段，该<code>UDP</code>报文段则被放置在一个具有广播<code>IP</code>目的地址255.255.255.255和源<code>IP</code>地址0.0.0.0的<code>IP</code>数据报中。</li><li>包含<code>DHCP</code>请求报文的<code>IP</code>数据报则被放置在以太网帧中，目的MAC地址<code>FF:FF:FF:FF:FF:FF</code>，使该帧将广播到与交换机连接的所有设备，该帧的源MAC地址是个人电脑MAC地址<code>00:16:D3:23:68:8A</code></li><li>个人电脑发送到以太网交换机的包含<code>DHCP</code>请求的广播以太网帧是第一个，因此交换机在所有的出端口广播入帧，包括连接到路由器的端口。</li><li>路由器接口接收到该广播以太网帧，该帧中包含<code>DHCP</code>请求并从该以太网帧中抽取出<code>IP</code>数据报。该数据报的广播<code>IP</code>目的地址指示了这个<code>IP</code>数据报应当由在该节点的高层协议处理，因此该数据报的载荷一个<code>UDP</code>报文段被分解向上到达<code>UDP</code>，<code>DHCP</code>请求报文从此<code>UDP</code>报文段中抽取出来。此时<code>DHCP</code>服务器有了<code>DHCP</code>请求报文。</li><li>假设运行在路由器中的<code>DHCP</code>服务器能够以<code>CIDR</code>块68.85.2.0/24分配<code>IP</code>地址68.85.2.101给个人电脑，<code>DHCP</code>服务器生成包含这个<code>IP</code>地址以及<code>DNS</code>服务器的<code>IP</code>地址68.87.71.226、默认网关路由器的<code>IP</code>地址68.85.2.1和子网块68.85.2.0/24（等价于子网掩码）的一个<code>DHCP</code> <code>ACK</code>报文。该<code>DHCP</code>报文被放入一个<code>UDP</code>报文段中，<code>UDP</code>报文段被放入一个<code>IP</code>数据报中，<code>IP</code>数据报再被放入一个以太网帧中。这个以太网帧的源MAC地址是路由器连到归属网络时接口的MAC地址<code>00:22:6B:45:1F:1B</code>，目的MAC地址是个人电脑的MAC地址<code>00:16:D3:23:68:8A</code>。</li><li>包含<code>DHCP</code> <code>ACK</code>的以太网帧由路由器发送给交换机。因为交换机是自学习的，并且先前从个人电脑收到过<code>DHCP</code>请求的以太网帧，所以该交换机知道寻址到<code>00:16:D3:23:68:8A</code>的帧仅从通向个人电脑的输出端口转发。</li><li>个人电脑接收到包含<code>DHCP</code> <code>ACK</code>的以太网帧，从该以太网帧中依次抽取<code>IP</code>数据报、<code>UDP</code>报文段、<code>DHCP</code> <code>ACK</code>报文。个人电脑的<code>DHCP</code>客户则记录下<code>IP</code>地址和它的<code>DNS</code>服务器的<code>IP</code>地址，并在其<code>IP</code>转发表中安装默认网关的地址，个人电脑此后将向该默认网关发送目的地址为其子网68.85.2.0/24以外的所有数据报。</li></ol><h3 id="6-6-2-仍在准备：DNS和ARP"><a href="#6-6-2-仍在准备：DNS和ARP" class="headerlink" title="6.6.2   仍在准备：DNS和ARP"></a>6.6.2   仍在准备：<code>DNS</code>和<code>ARP</code></h3><p>当将<a class="link"   href="http://www.baidu.com的url键入其web浏览器时,web浏览器通过生成一个tcp套接字开始了该过程,套接字用于向www.baidu.com发送http请求.为了生成该套接字,个人电脑将需要知道www.baidu.com的`ip`地址./" >www.baidu.com的URL键入其Web浏览器时，Web浏览器通过生成一个TCP套接字开始了该过程，套接字用于向www.baidu.com发送HTTP请求。为了生成该套接字，个人电脑将需要知道www.baidu.com的`IP`地址。<i class="fas fa-external-link-alt"></i></a></p><ol start="8"><li>个人电脑上的操作系统因此生成一个<code>DNS</code>查询报文，将字符串<a class="link"   href="http://www.baidu.com放入`dns`报文的问题段中.该`dns`报文则放置在一个具有53号(`dns`服务器)目的端口的`udp`报文段中.该`udp`报文段则被放人具有`ip`目的地址68.87.71.226和源`ip`地址68.85.2.101的`ip`数据报中./" >www.baidu.com放入`DNS`报文的问题段中。该`DNS`报文则放置在一个具有53号（`DNS`服务器）目的端口的`UDP`报文段中。该`UDP`报文段则被放人具有`IP`目的地址68.87.71.226和源`IP`地址68.85.2.101的`IP`数据报中。<i class="fas fa-external-link-alt"></i></a></li><li>个人电脑则将包含<code>DNS</code>请求报文的数据报放入一个以太网帧中。该帧将发送到学校网络中的网关路由器。然而即使个人电脑经过上述第5步中的<code>DHCP</code> <code>ACK</code>报文知道了学校网关路由器的<code>IP</code>地址，但仍不知道该网关路由器的MAC地址。为了获得该网关路由器的MAC地址，个人电脑将需要使用<code>ARP</code>协议。</li><li>个人电脑生成一个具有目的<code>IP</code>地址68.85.2.1（默认网关）的<code>ARP</code>查询报文，将该<code>ARP</code>报文放置在一个具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器。</li><li>网关路由器在通往学校网络的接口上接收到包含该<code>ARP</code>查询报文的帧，发现在<code>ARP</code>报文中目标<code>IP</code>地址68.85.2.1匹配其接口的<code>IP</code>地址，因此准备一个<code>ARP</code>回答，指示它的MAC地址<code>00:22:6B:45:1F:1B</code>对应<code>IP</code>地址68.85.2.1，将<code>ARP</code>回答放在一个以太网帧中，其目的地址为<code>00:16:D3:23:68:8A</code>（个人电脑），并向交换机发送该帧，再由交换机将帧交付给个人电脑。</li><li>个人电脑接收包含<code>ARP</code>回答报文的帧，并从中抽取网关路由器的MAC地址<code>00:22:6B:45:1F:1B</code>。</li><li>个人电脑现在才能够使包含<code>DNS</code>查询的以太网帧寻址到网关路由器的MAC地址。注意到在该帧中的<code>IP</code>数据报具有<code>IP</code>目的地址68.87.71.226（<code>DNS</code>服务器），而该帧的目的地址<code>00:22:6B:45:1F:1B</code>（网关路由器），个人电脑向交换机发送该帧交换机将该帧交付给网关路由器。</li></ol><h3 id="6-6-3-仍在准备：域内路由选择到DNS服务器"><a href="#6-6-3-仍在准备：域内路由选择到DNS服务器" class="headerlink" title="6.6.3   仍在准备：域内路由选择到DNS服务器"></a>6.6.3   仍在准备：域内路由选择到<code>DNS</code>服务器</h3><ol start="14"><li>网关路由器接收该帧并抽取包含<code>DNS</code>查询的<code>IP</code>数据报。路由器查找该数据报的目的地址68.87.71.226，并根据其转发表决定该数据报应当发送到图6-32的<code>Comcast</code>网络中最左边的路由器。<code>IP</code>数据报放置在链路层帧中，该链路适合将学校路由器连接到最左边<code>Comcast</code>路由器，并且该帧经这条链路发送。</li><li>在<code>Comcast</code>网络中最左边的路由器接收到该帧，抽取<code>IP</code>数据报，检查该数据报的目的地址68.87.71.226，并根据其转发表确定出接口，经过该接口朝着<code>DNS</code>服务器转发数据报，而转发表已根据<code>Comcast</code>的域内协议（如<code>OSPF</code>或<code>IS-1S</code>）以及互联网的域间协议<code>BGP</code>所填写。</li><li>最终包含<code>DNS</code>查询的<code>IP</code>数据报到达了<code>DNS</code>服务器。<code>DNS</code>服务器抽取出<code>DNS</code>查询报文，在它的<code>DNS</code>数据库中查找名字<a class="link"   href="http://www.baidu.com对应的`ip`地址119.75.217.109的`dns`源记录.该`dns`服务器形成了一个包含这种主机名到`ip`地址映射的`dns`回答报文,将该`dns`回答报文放入`udp`报文段中,该报文段放入寻址到68.85.2.101(个人电脑)的`ip`数据报中.该数据报将通过`comcast`网络反向转发到学校的路由器,并从这里经过以太网交换机到个人电脑./" >www.baidu.com对应的`IP`地址119.75.217.109的`DNS`源记录。该`DNS`服务器形成了一个包含这种主机名到`IP`地址映射的`DNS`回答报文，将该`DNS`回答报文放入`UDP`报文段中，该报文段放入寻址到68.85.2.101（个人电脑）的`IP`数据报中。该数据报将通过`Comcast`网络反向转发到学校的路由器，并从这里经过以太网交换机到个人电脑。<i class="fas fa-external-link-alt"></i></a></li><li>个人电脑从<code>DNS</code>报文抽取出服务器<a class="link"   href="http://www.baidu.com的`ip`地址./" >www.baidu.com的`IP`地址。<i class="fas fa-external-link-alt"></i></a></li></ol><h3 id="6-6-4-Web户-服务器交互：TCP和HTTP"><a href="#6-6-4-Web户-服务器交互：TCP和HTTP" class="headerlink" title="6.6.4    Web户-服务器交互：TCP和HTTP"></a>6.6.4    Web户-服务器交互：TCP和HTTP</h3><ol start="18"><li>个人电脑有了<a class="link"   href="http://www.baidu.com的`ip`地址,它能够生成tcp套接字,该套接字将用于向www.baidu.com发送http/" >www.baidu.com的`IP`地址，它能够生成TCP套接字，该套接字将用于向www.baidu.com发送HTTP<i class="fas fa-external-link-alt"></i></a> GET报文。当生成TCP套接字时，在个人电脑中的TCP必须首先与<a class="link"   href="http://www.baidu.com中的tcp执行三次握手,个人电脑因此首先生成一个具有目的端口80(针对http的)的tcp/" >www.baidu.com中的TCP执行三次握手，个人电脑因此首先生成一个具有目的端口80（针对HTTP的）的TCP<i class="fas fa-external-link-alt"></i></a> SYN报文段，将该TCP报文段放置在具有目的<code>IP</code>地址64 233.169.105（<a href="http://www.baidu.com）的`IP`数据报中，将该数据报放置在MAC地址为`00:22:6B:45:1F:1B`网关路由器的帧中，并向交换机发送该帧。">www.baidu.com）的`IP`数据报中，将该数据报放置在MAC地址为`00:22:6B:45:1F:1B`网关路由器的帧中，并向交换机发送该帧。</a></li><li>在学校网络、<code>Comcast</code>网络和百度网络中的路由器朝着<a class="link"   href="http://www.baidu.com转发包含tcp/" >www.baidu.com转发包含TCP<i class="fas fa-external-link-alt"></i></a> SYN的数据报，使用每台路由器中的转发表，如前面步骤14-16那样。分组经<code>Comcast</code>和百度网络之间域间链路转发的路由器转发表项，是由<code>BGP</code>协议决定的。</li><li>最终，包含TCP SYN的数据报到达<a class="link"   href="http://www.baidu.com.从数据报抽取出tcp/" >www.baidu.com。从数据报抽取出TCP<i class="fas fa-external-link-alt"></i></a> SYN报文并分解到与端口80相联系的套接字。对于百度HTTP服务器和个人电脑之间的TCP连接生成一个连接套接字。产生一个TCP <code>SYN ACK</code>报文段，将其放入向个人电脑寻址的一个数据报中，最后放入链路层帧中，该链路适合将<a class="link"   href="http://www.baidu.com连接到其第一跳路由器./" >www.baidu.com连接到其第一跳路由器。<i class="fas fa-external-link-alt"></i></a></li><li>包含TCP <code>SYN ACK</code>报文段的数据报通过百度、<code>Comcast</code>和学校网络，最终到达个人电脑的以太网卡。数据报在操作系统中分解TCP套接字，从而进入连接状态。</li><li>借助于个人电脑上的套接字，浏览器生成包含要获取的URL的HTTP GET报文，HTTP GET报文则写人套接字，其中GET报文成为一个TCP报文段的载荷。该TCP报文段放置进一个数据报中，并交付到<a class="link"   href="http://www.baidu.com,如前面步骤18-20所述./" >www.baidu.com，如前面步骤18-20所述。<i class="fas fa-external-link-alt"></i></a></li><li>在<a class="link"   href="http://www.baidu.com的http服务器从tcp套接字读取http/" >www.baidu.com的HTTP服务器从TCP套接字读取HTTP<i class="fas fa-external-link-alt"></i></a> GET报文，生成一个HTTP响应报文，将请求的Web页内容放入HTTP响应体中，并将报文发送进TCP套接字中。</li><li>包含HTTP回答报文的数据报通过百度、<code>Comcast</code>和学校网络转发，到达个人电脑。Web浏览器程序从套接字读取HTTP响应，从HTTP响应体中抽取Web网页的<code>html</code>，并最终显示了Web网页。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;6-1-链路层概述&quot;&gt;&lt;a href=&quot;#6-1-链路层概述&quot; class=&quot;headerlink&quot; title=&quot;6.1   链路层概述&quot;&gt;&lt;/a&gt;6.1   链路层概述&lt;/h2&gt;&lt;p&gt;运行链路层协议协议的任何设备均称为节点（node），包括主机、路由器、交换机</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络：自顶向下方法" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>05-网络层：控制平面</title>
    <link href="http://example.com/2021/06/02/note/Computer%20Networking/05-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"/>
    <id>http://example.com/2021/06/02/note/Computer%20Networking/05-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</id>
    <published>2021-06-02T07:59:36.942Z</published>
    <updated>2021-06-24T12:59:27.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1   概述"></a>5.1   概述</h2><p>转发表（在基于目的地转发的场景中）和流表（在通用转发的场景中）是链接网络层的数据平面和控制平面的首要元素。完成这些工作有两种可能的方法。</p><ul><li>每路由器控制。在每台路由器中运行路由选择算法和一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。<code>OSPF</code>和<code>BGP</code>协议都是基于这种每路由器的方法进行控制的。</li><li>逻辑集中式控制。逻辑集中式控制器计算并分发转发表以供每台路由器使用况通用的“匹配加动作”抽象允许执行传统的<code>IP</code>转发以及其他功能（负载共享、防火墙功能和NAT）。该控制器与每台路由器中的控制代理（CA）进行交互，以配置和管理该路由器的转发表。CA任务是与控制器通信并且按控制器命令行事。CA既不能直接相互交互，也不能主动参与计算转发表。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/1EQDLIuB9RkZwmM.png"                      alt="image-20210606123132583"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/a3gtTFlw4GSo72b.png"                      alt="image-20210606123106079"                ></p><h2 id="5-2-路由选择算法"><a href="#5-2-路由选择算法" class="headerlink" title="5.2   路由选择算法"></a>5.2   路由选择算法</h2><p>路由选择算法，目的是从发送方到接收方的过程中确定一条通过路由器网络的最低开销的路径，但实践中还要关注诸如策略之类的问题。可以用图来形式化描述路由选择问题，图中的节点表示路由器，一条边还有一个值表示它的开销，通常反映出对应链路的物理长度、链路速度，或金钱上的开销。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/UFd2a39pWekHh8q.png"                      alt="image-20210606124223253"                ></p><p>路由选择算法的第一种分类方式：</p><ul><li>集中式路由选择算法。用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，要具有关于连通性和链路开销方面的完整信息。例如链路状态（<code>LS</code>）算法。</li><li>分散式路由选择算法。路由器以迭代、分布式的方式计算出最低开销路径。每个节点仅有与其直接相连链路的开销知识即可开始工作，然后通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。例如距离向量（<code>DV</code>）算法。</li></ul><p>第二种分类方式：</p><ul><li>静态路由选择算法。路由随时间的变化非常缓慢，通常是人工进行调整。</li><li>动态路由选择算法。随着网络流量负载或拓扑发生变化而改变路由选择路径。</li></ul><p>第三种分类方式：</p><ul><li><p>负载敏感算法。链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。</p></li><li><p>负载迟钝的算法。链路的开销不明确地反映其当前或最近的拥塞水平。例如<code>RIP</code>、<code> OSPF</code>、<code>BGP</code>。</p></li></ul><h2 id="5-3-因特网中自治系统内部的路由选择：OSPF"><a href="#5-3-因特网中自治系统内部的路由选择：OSPF" class="headerlink" title="5.3   因特网中自治系统内部的路由选择：OSPF"></a>5.3   因特网中自治系统内部的路由选择：<code>OSPF</code></h2><p>在实践中，不能将网络只看作一个路由器的集合，所有的路由器都执行相同的路由选择算法，有以下两个原因：</p><ul><li>规模。随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。</li><li>管理自治。每个<code>ISP</code>都有它自已的路由器网络，<code>ISP</code>通常希望按自己的意愿运行路由器，或对外部隐藏其网络的内部组织面貌。</li></ul><p>通过路由器组织进自治系统（AS）解决，通常在一个<code>ISP</code>中的路由器以及互联它们的链路构成一个AS，或者<code>ISP</code>将它们的网络划分为多个AS。一个自治系统由<code>ICANN</code>区域注册机构所分配的全局唯一的AS号（<code>ASN</code>）所标识。在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。</p><p>在一个自治系统内运行的路由选择算法叫作自治系统内部路由选择协议，比如开放最短路优先（<code>OSPF</code>）路由选择及IS-IS。<code>OSPF</code>是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。使用<code>OSPF</code>，一台路由器构建了一幅关于整个自治系统的完整拓扑图，于是每台路由器在本地运行<code>Dijikstra</code>的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。各条链路开销是由网络管理员配置的，可以选择将所有链路开销设为1，从而实现最少跳数路由选择；或者选择将链路权值按与链路容量成反比来设置，从而不鼓励流量使用低带宽链路。</p><p>使用<code>OSPF</code>时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息，即使未发生变化，也要周期性地广播链路状态。<code>OSPF</code>通告包含在<code>OSPF</code>报文中，并直接由<code>IP</code>承载，因此<code>OSPF</code>协议必须自己实现诸如可靠报文传输、链路状态广播等功能。<code>OSPF</code>协议还要检查链路是否正在运行，并允许<code>OSPF</code>路由器获得相邻路由器的网络范围链路状态的数据库。<code>OSPF</code>的优点包括下列几方面:</p><ul><li>安全。能够鉴别<code>OSPF</code>路由器之间的交换，防止恶意入侵者将不正确的信息注入路由器表内。能够配置简单的明文口令鉴别和<code>MD5</code>的鉴别。</li><li>多条相同开销的路径。当到达某目的地的多条路径具有相同的开销时，<code>OSPF</code>允许使用多条路径。</li><li>支持单播与多播路由选择。多播<code>OSPF</code>（<code>MOSPF</code>）使用现有的<code>OSPF</code>链路数据库，并为现有的<code>OSPF</code>链路状态广播机制增加了一种新型的链路状态通告。</li><li>支持在单个<code>AS</code>中的层次结构。一个<code>OSPF</code>自治系统能够层次化地配置多个区域，运行各自的<code>OSPF</code>链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。在每个区域内，区域边界路由器负责为流向该区域以外的分组提供路由选择。最后，在<code>AS</code>中只有一个<code>OSPF</code>区域配置成主干区域。主干区域的主要作用是为该<code>AS</code>中其他区域之间的流量提供路由选择。主干区域包含本<code>AS</code>中的所有区域边界路由器，可能还包含一些非边界路由器。在<code>AS</code>中的区域间的路由选择要求分组先路由到一个区域边界路由器（区域内路由选择），然后通过主干路由到位于目的区域的区域边界路由器，进而再路由到最终目的地。</li></ul><h2 id="5-4-ISP之间的路由选择：BGP"><a href="#5-4-ISP之间的路由选择：BGP" class="headerlink" title="5.4   ISP之间的路由选择：BGP"></a>5.4   <code>ISP</code>之间的路由选择：<code>BGP</code></h2><p>自治系统间路由选择协议用于分组跨越多个<code>AS</code>进行路由，因此涉及多个<code>AS</code>之间的协调，所以<code>AS</code>通信必须运行相同的<code>AS</code>间路由选择协议，也就是边界网关协议（<code>BGP</code>），一种分布式和异步的协议。</p><h3 id="5-4-1-BGP的作用"><a href="#5-4-1-BGP的作用" class="headerlink" title="5.4.1   BGP的作用"></a>5.4.1   <code>BGP</code>的作用</h3><p>考虑一个<code>AS</code>和在该<code>AS</code>中的任意一个路由器。在<code>BGP</code>中，分组并不是路由到一个特定的目的地址，而是是路由到<code>CIDR</code>化的前缀，其中每个前缀表示一个子网或一个子网的集合，因此一台路由器的转发表将具有形式为（x，I）的表项，其中x是一个前缀，I是该路由器的接口号。</p><p>作为一种<code>AS</code>间的路由选择协议，<code>BGP</code>为每台路由器提供了一种完成以下任务的手段：</p><ul><li>从邻居<code>AS</code>获得前缀的可达性信息。<code>BGP</code>允许每个子网向因特网的其余部分通告它的存在，确保所有<code>AS</code>知道该子网。</li><li>确定到该前缓的最佳路由。一台路由器可能知道两条或更多条到特定前缀的不同路由，路由器将在本地运行一个<code>BGP</code>路由选择过程，基于策略以及可达性信息来确定。</li></ul><h3 id="5-4-2-通告BGР路由信息"><a href="#5-4-2-通告BGР路由信息" class="headerlink" title="5.4.2   通告BGР路由信息"></a>5.4.2   通告<code>BGР</code>路由信息</h3><p>下图网络具有3个自治系统：<code>AS1</code>、<code>AS2</code>和<code>AS3</code>。<code>AS3</code>包括一个具有前缀x的子网。对于每个<code>AS</code>，每台路由器要么是一台位于<code>AS</code>边缘并直连其他<code>AS</code>中的网关路由器，要么是一台仅连接自己<code>AS</code>中的主机和路由器的内部路由器。在<code>BGP</code>中，路由器通过使用179端口的半永久TCP连接交换路由选择信息。每条直接连接以及所有通过该连接发送的<code>BGP</code>报文，称为<code>BGP</code>连接，其中两个AS的<code>BGP</code>连接称为外部<code>BGP</code>（<code>eBGP</code>）连接，而在相同AS中的两台路由器之间的<code>BGP</code>会话称为内部<code>BGP</code>（<code>iBGP</code>）连接。</p><p>考虑向<code>ASI</code>和<code>AS2</code>中的所有路由器通告前缀x的可达性信息过程，<code>3a</code>先向<code>2c</code>发送<code>eBGP</code>报文<code>AS3 X</code>，<code>2c</code>然后向<code>AS2</code>中的所有路由器发送<code>iBGP</code>报文<code>AS3 X</code>，接下来<code>2a</code>向<code>1c</code>发送<code>eBGP</code>报文<code>AS2 AS3 X</code>，最后<code>1c</code>向<code>AS1</code>中的所有路由器发送<code>iBGP</code>报文<code>AS2 AS3 x</code>。这样<code>AS</code>I和<code>AS2</code>中的每个路由器都知道了x的存在并且也知道了通往x的<code>AS</code>路径。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/LXNymAhdk1SeTgs.png"                      alt="image-20210606163903898"                ></p><h3 id="5-4-3-确定最好的路由"><a href="#5-4-3-确定最好的路由" class="headerlink" title="5.4.3   确定最好的路由"></a>5.4.3   确定最好的路由</h3><p>路由器常常接收到很多不同的可能路径的可达性信息。例如下图，从<code>AS1</code>到x有两条路径：<code>AS2 AS3 X</code>以及<code>AS3 X</code>。<br>当路由器通过<code>BGP</code>连接通告前缀时，会在前缀中包括一些<code>BGP</code>属性。前缀及其属性称为路由（route），属性有<code>AS-PATH</code>和<code>NEXT-HOP</code>：<code>AS-PATH</code>属性包含通告已经通过的AS列表，当一个前缀通过某AS时，该AS将其<code>ASN</code>加入<code>AS-PATH</code>中的现有列表，<code>AS-PATH</code>属性还用于来检测和防止通告环路，如果路由器在路径列表中发现有它的AS，将拒绝该通告。<code>NEXT-HOP</code>是<code>AS-PATH</code>起始的路由器接口的<code>IP</code>地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/dIJTmSklGpcByPj.png"                      alt="image-20210606163924302"                ></p><p>热土豆路由选择依据的思想是：减小在自己AS中的开销，但不管在其AS之外的端到端开销的其他部分。对同一AS中的两台路由器，可能对相同的前缀选择两条不同的AS路径。例如，路由器<code>1b</code>到达x将通过<code>AS2</code>发送分组。而路由器<code>1d</code>将绕过<code>AS2</code>并直接向<code>AS3</code>发送分组到达x。</p><p>考虑路由器<code>1b</code>到达前缀x的两条<code>BGP</code>路由。路由器<code>1b</code>将查阅它的AS内部路由选择信息，以找到最低开销路径的<code>NEXT-HOP</code>路由器，因此将选择路由器<code>2a</code>。路由器<code>1b</code>则将查阅它的转发表，并且找到通往路由器<code>2a</code>的位于最低开销路径上的接口I。<code>1b</code>则把（x，I）加到它的转发表中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/dlKNDGaytshuIn1.png"                      alt="image-20210606210529404"                ></p><p>在实践中，<code>BGP</code>使用了一种比热土豆路由选择更为复杂但却结合了其特点的算法。对于任何给定的目的地前缀，进入<code>BGP</code>的路由选择算法的输入是到某前缀的所有路由的集合。如果仅有一条这样的路由，<code>BGP</code>则选择该路由。如果到相同的前缀有两条或多条路由，则顺序地调用下列消除规则直到余下一条路由：</p><ol><li>路由被指派一个本地偏好值作为其属性之一，这是一种策略决定。一条路由的本地偏好可能由该路由器设置或可能由在相同AS中的另一台路由器学习到。</li><li>从余下的路由中，选择具有最短<code>AS-PATH</code>的路由。如果该规则是路由选择的唯一规则，则<code>BGP</code>将使用距离向量算法决定路径，其中距离测度使用AS跳的跳数而不是路由器跳的跳数。</li><li>从余下的路由中，使用热土豆路由选择，即选择具有最靠近<code>NEXT-HOP</code>路由器的路由。</li><li>如果仍留下多条路由，该路由器使用<code>BGP</code>标识符来选择路由，</li></ol><h3 id="5-4-4-IP任播"><a href="#5-4-4-IP任播" class="headerlink" title="5.4.4   IP任播"></a>5.4.4   <code>IP</code>任播</h3><p><code>IP</code>任播的动机：</p><ol><li>在许多分散的不同地理位置，替换不同服务器上的相同内容；</li><li>让用户从最靠近的服务器访问内容。</li></ol><p><code>BGP</code>常被用于实现<code>IP</code>任播服务，在<code>IP</code>任播配置阶段，<code>CDN</code>公司为多台服务器指派相同的<code>IP</code>地址，并且使用<code>BGP</code>从这些服务器的每台来通告该<code>IP</code>地址。当某台<code>BGP</code>路由器收到对于该<code>IP</code>地址的多个路由通告，它将这些通告处理为对相同的物理位置提供不同的路径。当配置其路由选择表时，每台路由器将本地化地使用<code>BGP</code>路由选择算法来挑选到该<code>IP</code>地址的“最好的”路由。</p><p>实践中<code>CDN</code>通常选择不使用<code>IP</code>任播，因为<code>BGP</code>路由选择变化能够导致相同的TCP连接的不同分组到达Web服务器的不同实例。但<code>IP</code>任播被<code>DNS</code>系统广泛用于将<code>DNS</code>请求指向最近的根<code>DNS</code>服务器。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/i9zyWpHkLKBhIcP.png"                      alt="image-20210606211933530"                ></p><h3 id="5-4-5-路由选择策略"><a href="#5-4-5-路由选择策略" class="headerlink" title="5.4.5   路由选择策略"></a>5.4.5   路由选择策略</h3><p>当某路由器选择到目的地的一条路由时，AS路由选择策略所确定的本地偏好值能够胜过所有其他考虑。下图显示了6个互联的自治系统：A、B，C、W，X和Y。W和Y显然是接入<code>ISP</code>，X是一个多宿接入<code>ISP</code>，而A、B和C是主干提供商网络。我们还要假设A，B和C直接向彼此发送流量，并向它们的客户网络提供全部的<code>BGP</code>信息。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/06/45BT3pCsqyDrLN1.png"                      alt="image-20210606213914697"                ></p><p>商业运行的<code>ISP</code>们都遵从的一个经验法则是：任何穿越某<code>ISP</code>主干网的流量必须是其源或目的位于该<code>ISP</code>的某个客户网络中，否则这些流量将会免费搭车通过该<code>ISP</code>的网络，除非<code>ISP</code>双方协商了对等协定，但经常是对外保密的。例如，X如果向其邻居B和C通告它有一条路径（<code>XCY</code>）能到达网络Y，这样B就可能经由x转发目的为Y（或C）的流量。接入<code>ISP</code>要保证自身是所有进入/离开流量的源/目的地，可以通过控制<code>BGP</code>路由的通告方式容易地实现。</p><p>对于提供商网络，比如自治系统B。假定B已经从A处知道一条到W的路径<code>AW</code>，显然B也想向它的客户通告路径<code>BAW</code>，这样知道它能够通过B路由到w。但是B如果将路径<code>BAW</code>通告给C，则C可以经由<code>BAW</code>将流量引导到W，而B也许并不想承担A与C之间传送流量的负担。</p><h2 id="5-5-SDN控制平面"><a href="#5-5-SDN控制平面" class="headerlink" title="5.5   SDN控制平面"></a>5.5   <code>SDN</code>控制平面</h2><p><code>SDN</code>体系结构具有4个关键特征：</p><ul><li>基于流的转发。<code>SDN</code>控制的交换机的分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段值进行。<code>SDN</code>控制平面的工作是计算、管理和安装所有网络交换机中的流表项，分组转发规则被规定在交换机的流表中。</li><li>数据平面与控制平面分离。数据平面由网络交换机组成，该设备在它们的流表中执行“匹配加动作”的规则。控制平面由服务器以及决定和管理交换机流表的软件组成。</li><li>网络控制功能：位于数据平面交换机外部。<code>SDN</code>控制平面由软件实现并在服务器上执行，该服务器与网络交换机分离。控制平面自身由<code>SDN</code>控制器或网络操作系统，以及若干网络控制应用程序组成。控制器维护网络状态信息（例如，远程链路、交换机和主机的状态）并为网络控制应用程序提供这些信息，并且为应用程序提供方法监视、编程和控制下面的网络设备。</li><li>可编程的网络。通过运行在控制平面中的网络控制应用程序，该网络是可编程的。这些应用程序使用由<code>SDN</code>控制器提供的<code>API</code>来定义和控制网络设备中的数据平面。例如路由选择网络控制应用程序通过由<code>SDN</code>控制器维护的节点状态和链路状态信息可以决定源和目的地之间的端到端路径。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/29xiAvpIjlK7mzU.png"                      alt="image-20210607135342797"                ></p><h3 id="5-5-1-SDN控制平面：SDN控制器和SDN网络控制应用程序"><a href="#5-5-1-SDN控制平面：SDN控制器和SDN网络控制应用程序" class="headerlink" title="5.5.1   SDN控制平面：SDN控制器和SDN网络控制应用程序"></a>5.5.1   <code>SDN</code>控制平面：<code>SDN</code>控制器和<code>SDN</code>网络控制应用程序</h3><p><code>SDN</code>控制平面大体划分为<code>SDN</code>控制器和<code>SDN</code>网络控制应用程序。控制器的功能可大体组织为3个层次:</p><ul><li>通信层。<code>SDN</code>控制器和受控网络设备之间的通信跨越了一个接口，被称为控制器的“南向”接口，其中<code>OpenFlow</code>是一种提供这种通信功能的特定协议。</li><li>网络范围状态管理层。由<code>SDN</code>控制平面所做出的最终控制决定需要控制器具有有关网络的主机、链路、交换机和其他<code>SDN</code>控制设备的最新状态信息。</li><li>对于网络控制应用程序层的接口。控制器通过它的“北向”接口与网络控制应用程序交互。该<code>API</code>允许网络控制应用程序在状态管理层之间读/写网络状态和流表。当状态改变事件出现时，应用程序能够注册进行通告。</li></ul><p><code>SDN</code>控制器被认为是逻辑上集中但物理上分布的，即该控制器可以被外部视为一个单一、整体的服务，在实践中这些服务和用于保持状态信息的数据库一般通过分布式服务器集合实现。在服务器集合实现控制器功能时，必须考虑控制器的内部操作（例如维护事件的逻辑时间顺序、一致性、意见一致等）的语义。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/A2thJxTMlv5j8Ue.png"                      alt="image-20210607141000641"                ></p><h3 id="5-5-2-OpenFlow协议"><a href="#5-5-2-OpenFlow协议" class="headerlink" title="5.5.2   OpenFlow协议"></a>5.5.2   <code>OpenFlow</code>协议</h3><p><code>OpenFlow</code>协议运行在<code>SDN</code>控制器和<code>SDN</code>控制的交换机或其他实现<code>OpenFlow</code> <code>API</code>的设备之间。<code>OpenFlow</code>协议运行在TCP之上，使用6653的默认端口号。从控制器到受控交换机流动的重要报文有：</p><ul><li>配置。该报文允许控制器查询并设置交换机的配置参数。</li><li>修改状态。该报文由控制器所使用，以增加/删除或修改交换机流表中的表项，并且设置交换机端口特性。</li><li>读状态。该报文被控制器用于从交换机的流表和端口收集统计数据和计数器值。</li><li>发送分组。该报文被控制器用于在受控交换机从特定的端口发送出一个特定的报文。</li></ul><p>从受控交换机到控制器流动的重要报文有：</p><ul><li>流删除。该报文通知控制器已删除一个流表项，例如由于超时，或作为收到“修改状态”报文的结果。</li><li>端口状态。交换机用该报文向控制器通知端口状态的变化。</li><li>分组入。一个分组到达交换机端口，并且不能与任何流表项匹配，那么这个分组将被发送给控制器进行额外处理。匹配的分组也被发送给控制器，作为匹配时所采取的一个动作。分组入报文被用于将分组发送给控制器。</li></ul><h2 id="5-6-ICMP：因特网控制报文协议"><a href="#5-6-ICMP：因特网控制报文协议" class="headerlink" title="5.6   ICMP：因特网控制报文协议"></a>5.6   <code>ICMP</code>：因特网控制报文协议</h2><p>因特网控制报文协议（<code>ICMP</code>），被主机和路由器用来彼此沟通网络层的信息，最典型的用途是差错报告。例如，<code>IP</code>路由器不能找到一条通往HTTP请求中所指定的主机的路径，该路由器就会向你的主机生成并发出一个<code>ICMP</code>报文以指示该错误。</p><p><code>ICMP</code>通常被认为是<code>IP</code>的一部分，但从体系结构上讲<code>ICMP</code>报文是承载在<code>IP</code>分组中的，上层协议编码为1。<code>ICMP</code>报文有一个类型字段和一个编码字段，并且包含引起该<code>ICMP</code>报文首次生成的<code>IP</code>数据报的首部和前8个字节，以便发送方能确定引发该差错的数据报。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/dU6VjZTaelJ8tbE.png"                      alt="image-20210607161130074"                ></p><h2 id="5-7-网络管理和SNMP"><a href="#5-7-网络管理和SNMP" class="headerlink" title="5.7   网络管理和SNMP"></a>5.7   网络管理和<code>SNMP</code></h2><p>网络是由许多复杂、交互的硬件和软件部件组成的，需要网络管理工具和方法来监视、管理和控制该网络保持运行良好，比如<code>SDN</code>环境中逻辑上集中的控制器就能够有助于这种过程。</p><p>网络管理的定义:包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求。</p><h3 id="5-7-1-网络管理框架"><a href="#5-7-1-网络管理框架" class="headerlink" title="5.7.1   网络管理框架"></a>5.7.1   网络管理框架</h3><ul><li><strong>管理服务器</strong>（managing server）是一个应用程序，通常有人的参与，并运行在网络运营中心（<code>NOC</code>）的集中式网络管理工作站上，它控制网络管理信息的收集、处理、分析和/或显示。</li><li><strong>被管设备</strong>是网络装备的一部分包括它的软件，被管设备可以是一台主机、路由器、交换机、中间盒、调制解调器、或其他联网的设备。一个被管设备中，有多个被管对象，这些被管对象可能是被管设备中硬件的实际部分（例如网络接口卡）和用于这些硬件及软件组件的配置参数（例如<code>OSPF</code>）。</li><li><strong>管理信息库</strong>（<code>MIB</code>）中存储被管设备中的每个被管对象的关联信息，这些信息的值可供管理服务器所用并且设置。一个<code>MIB</code>对象可以是：一个计数器，诸如由于<code>IP</code>数据报首部差错而由路由器丢弃的数量；诸如一个特定设备功能是否正确的状态信息。<code>MIB</code>对象由称为<code>SMI</code>的数据描述语言所定义，从而确保网络管理数据的语法和语义是定义良好的和无二义性的。相关的<code>MIB</code>对象被收集在<code>MIB</code>模块中。</li><li><strong>网络管理代理</strong>驻留在每个被管设备中，它是运行在被管设备中的一个进程，该进程与管理服务器通信，在管理服务器的命令和控制下在被管设备中采取本地动作。</li><li><strong>网络管理协议</strong>。该协议运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些设备上采取行动。代理能够使用网络管理协议向管理服务器通知异常事件。网络管理协议自己不能管理网络，它为网络管理员提供了一种能力，使他们能够管理网络。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/Fcb7YifmPw8yx5M.png"                      alt="image-20210607161725764"                ></p><h3 id="5-7-2-简单网络管理协议"><a href="#5-7-2-简单网络管理协议" class="headerlink" title="5.7.2   简单网络管理协议"></a>5.7.2   简单网络管理协议</h3><p>简单网络管理协议版本2（<code>SNMPv2</code>）是一个应用层协议，用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。<code>SNMP</code>最常使用的是请求响应模式，其中<code>SNMP</code>管理服务器向<code>SNMP</code>代理发送一个请求，代理接收到该请求后，执行某些动作，然后对该请求发送一个回答。请求通常用于查询或修改与某被管设备关联的<code>MIB</code>对象值。<code>SNMP</code>第二个常被使用的是代理向管理服务器发送的一种非请求报文，该报文称为陷阱报文（trap message），用于通知管理服务器一个异常情况（例如一个链路接口启动或关闭）已经导致了<code>MIB</code>对象值的改变。</p><p>下表显示了<code>SNMP</code>2定义的7种类型的报文，这些报文一般称为协议数据单元（<code>PDU</code>）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/UDuOYx5sZFHaMtE.png"                      alt="image-20210607162855724"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/07/BsHZznPKkN8UweI.png"                      alt="image-20210607162912232"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;5-1-概述&quot;&gt;&lt;a href=&quot;#5-1-概述&quot; class=&quot;headerlink&quot; title=&quot;5.1   概述&quot;&gt;&lt;/a&gt;5.1   概述&lt;/h2&gt;&lt;p&gt;转发表（在基于目的地转发的场景中）和流表（在通用转发的场景中）是链接网络层的数据平面和控制平面的首要</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络：自顶向下方法" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>03-运输层</title>
    <link href="http://example.com/2021/05/19/note/Computer%20Networking/03-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/05/19/note/Computer%20Networking/03-%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-05-19T05:58:41.417Z</published>
    <updated>2021-06-24T13:35:52.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1   概述和运输层服务"></a>3.1   概述和运输层服务</h2><h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1   运输层和网络层的关系"></a>3.1.1   运输层和网络层的关系</h3><p>网络层提供了主机之间的逻辑通信，而运输层提供了主机上进程之间的逻辑通信。运输层协议只工作在端系统中，将来自应用进程的报文移动到网络层，路由器不处理也不识别运输层加在应用层报文的任何信息。</p><p>运输协议能够提供的服务常常受制于网络层协议的服务模型。然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。例如网络层协议会使分组丢失、篡改和冗余，运输协议也能为应用程序提供可靠的数据传输服务；即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取。</p><h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2   因特网运输层概述"></a>3.1.2   因特网运输层概述</h3><p>两种运输层协议：<code>UDP</code>（用户数据报协议）、<code>TCP</code>（传输控制协议），运输层分组称为报文段，网络层分组称为数据报。<code>UDP</code>和<code>TCP</code>将两个端系统间<code>IP</code>的交付服务扩展为运行在端系统上的两个进程之间的交付服务，通过在其报文段首部中包含差错检查字段而提供完整性检查，进程到进程的数据交付和差错检查是<code>UDP</code>所能提供的仅有的两种服务。而<code>TCP</code>还提供可靠数据传输服务和拥塞控制。</p><h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2   多路复用与多路分解"></a>3.2   多路复用与多路分解</h2><p>将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>与<strong>多路分解</strong>。</p><p>多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（将在以后用于分解）从而生成报文段，然后将报文段传递到网络层。</p><p>多路分解：在接收端运输层检查报文段中的目的端口号，并将其定向到相应的套接字。</p><h3 id="3-2-1-无连接的多路复用与多路分解"><a href="#3-2-1-无连接的多路复用与多路分解" class="headerlink" title="3.2.1   无连接的多路复用与多路分解"></a>3.2.1   无连接的多路复用与多路分解</h3><p>一个<code>UDP</code>套接字是由一个二元组全面标识的，包含目的<code>IP</code>地址和目的端口号。因此，如果两个<code>UDP</code>报文段有不同的源<code>IP</code>地址，但目的<code>IP</code>地址和目的端口号相同，那么都将通过相同的目的套接字被定向到相同的目的进程。</p><p><code>UDP</code>报文段中，源端口号用作“返回地址”的一部分，当需要回发一个报文段时，从接收到的报文段中提取出源端口号做为目的端口号，向客户发送一个新的报文段。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/20/bI2CePuMoJqOFUB.png"                      alt="image-20210520193456944"                ></p><h3 id="3-2-2-面向连接的多路复用与多路分解"><a href="#3-2-2-面向连接的多路复用与多路分解" class="headerlink" title="3.2.2   面向连接的多路复用与多路分解"></a>3.2.2   面向连接的多路复用与多路分解</h3><p><code>TCP</code>套接字是由一个四元组（源<code>IP</code>地址，源端口号，目的<code>IP</code>地址，目的端口号）来标识的。4个值全部用来将报文段定向（分解）到相应的套接字，因此两个具有不同源<code>IP</code>地址或源端口号的到达<code>TCP</code>报文段将被定向到两个不同的套接字，除非<code>TCP</code>报文段携带了初始创建连接的请求。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/20/Y8LvoxwmP7FZ2z6.png"                      alt="image-20210520194159439"                ></p><h3 id="3-2-3-Web服务器与TCP"><a href="#3-2-3-Web服务器与TCP" class="headerlink" title="3.2.3   Web服务器与TCP"></a>3.2.3   Web服务器与<code>TCP</code></h3><p>如果客户与服务器使用持续HTTP，则在整条连接持续期间，经由同一个服务器套接字交换HTTP报文。如果使用非持续HTTP，则对每一对请求/响应都创建一个新的<code>TCP</code>连接并在随后关闭。</p><p>然而连接套接字与进程之间不一定是一一对应的关系。当今的高性能Web服务器通常只使用一个进程，但为每个新的客户连接创建一个具有新连接套接字的新线程，对于这样一台服务器，可能有不同标识的连接套接字连接到相同的进程。</p><h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3   无连接运输：UDP"></a>3.3   无连接运输：<code>UDP</code></h2><p><code>UDP</code>从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。使用<code>UDP</code>时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手，因此，<code>UDP</code>被称为是无连接的。</p><p>有许多应用更适合用<code>UDP</code>，原因主要以下几点：</p><ol><li>关于发送什么数据以及何时发送的应用层控制更为精细。<code>TCP</code>有拥塞控制机制，甚至重新发送数据报文段。对于实时应用要求最快的发送速率，且能容忍数据丢失，更适合<code>UDP</code>。</li><li>无须连接建立。<code>TCP</code>在开始数据传输之前要经过三次握手。<code>UDP</code>却不需要任何准备即可进行数据传输。</li><li>无连接状态。<code>TCP</code>需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。因此，某些专门用于某种特定应用的服务器当应用程序运行在<code>UDP</code>之上而不是运行在<code>TCP</code>上时，一般都能支持更多的活跃客户。</li><li>分组首部开销小。每个<code>TCP</code>报文段都有20字节的首部开销，而<code>UDP</code>仅有8字节。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/20/vifogKD7BrPT3Lc.png"                      alt="image-20210520200245969"                ></p><p>使用<code>UDP</code>的应用也是可能实现可靠数据传输的，通过在应用程序自身中建立可靠性机制（例如确认与重传机制)来完成。谷歌的Chrome浏览器中所使用的<code>QUIC协议</code>，在<code>UDP</code>之上的应用层协议中实现了可靠性。</p><h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1   UDP报文段结构"></a>3.3.1   <code>UDP</code>报文段结构</h3><p><code>UDP</code>首部只有4个字段，每个字段由两个字节组成。通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能）。长度字段指示了在<code>UDP</code>报文段中的字节数（首部加数据）。检验和来用于接收方检查在该报文段中是否出现了差错。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/20/HcnaMz1fEB7FbD4.png"                      alt="image-20210520202132984"                ></p><h3 id="3-3-2-UDP检验和"><a href="#3-3-2-UDP检验和" class="headerlink" title="3.3.2   UDP检验和"></a>3.3.2   <code>UDP</code>检验和</h3><p>检验和用于确定当<code>UDP</code>报文段从源到达目的地移动时，其中的比特是否发生了改变。发送方的<code>UDP</code>对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在<code>UDP</code>报文段中的检验和字段。举例来说，假定我们有下面3个16比特的字：<br>$$<br>0110011001100000\<br>0101010101010101\<br>1000111100001100\<br>这些16比特字的前两个之和是：\<br>0110011001100000\<br>\underline{0101010101010101}\<br>1011101110110101\<br>再将上面的和与第三个字相加，其中有溢出被回卷，得出：\<br>1011101110110101\<br>\underline{1000111100001100}\<br>0100101011000010\<br>再进行反码运算得到校验和：1011010100111101\<br>$$<br>接收方检查时，将全部的4个16比特字（包括检验和）加在一起，如果该分组中没有引入差错，则在接收方处该和将是11111111111，如果有0，那么该分组中已经出现了差错。</p><p><code>UDP</code>之所以提供了检验和，因为不能保证源和目的之间的所有链路都提供差错检测（即便许多链路层协议也提供)，其次即使报文段经链路正确地传输，但当报文段存储在某台路由器的内存中时，也可能引入比特差错。虽然<code>UDP</code>提供差错检测，但无法恢复，可能会丢弃受损的报文段或交给应用程序并给出警告。</p><h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4   可靠数据传输原理"></a>3.4   可靠数据传输原理</h2><p>下图说明可靠数据传输的框架。为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏或丢失，而且所有数据都是按照其发送顺序进行交付。实现这种服务抽象是基于可靠数据传输协议的。这里<code>rdt</code>表示可靠数据传输协议，<code>udt</code>表示不可靠数据传输协议。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/20/8Zwpi5OXxILebay.png"                      alt="image-20210520212554486"                ></p><h3 id="3-4-1-构造可靠数据传输协议"><a href="#3-4-1-构造可靠数据传输协议" class="headerlink" title="3.4.1   构造可靠数据传输协议"></a>3.4.1   构造可靠数据传输协议</h3><p>分组中的比特可能受损的，也有可能丢失，因此需要基于重传机制的可靠数据传输协议称为自动重传请求（<code>ARQ</code>）协议。<code>ARQ</code>协议中还需要另外三种协议功能来处理存在比特差错的情况：</p><ul><li><p>接收方反馈。因为发送方和接收方通常在不同端系统上执行，接收方需要提供明确的反馈信息给发送方，也就是<code>ACK</code>（肯定确认）或<code>NAK</code>（否定确认），理论上只需要一个比特长，如用0表示<code>NAK</code>，用1表示<code>ACK</code>。</p></li><li><p>重传。接收方收到<code>NAK</code>或重复的<code>ACK</code>说明分组出错、或发送方长时间没有收到<code>ACK</code>或<code>NAK</code>说明数据分组或<code>ACK</code>或<code>NAK</code>可能丢失，发送方都将重传该分组文。发送方至少需要等待双方之间的一个往返时延加接收方处理一个分组所需的时间，如果数据分组及其<code>ACK</code>都没有丢失，这就可能引入了冗余数据分组。为了实现基于时间的重传机制，需要一个倒计数定时器，发送方需要：1. 每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。2. 响应定时器中断（采取适当的动作）。3. 终止定时器。</p></li><li><p>差错检测。检验和用于检测并可能纠正分组中的比特差错。由于<code>ACK</code>或<code>NAK</code>分组受损的可能性，这又需要在数据分组中添加一新字段，让发送方对其数据分组编号，每次即将发送数据分组的<strong>序号</strong>放在该字段。接收方只需要检查序号的变化即可确定收到的分组是重传还是新的分组。</p></li></ul><p>下图显示了发送方和接收方的有限状态机（<code>FSM</code>）的定义。发送方和接收方有各自的<code>FSM</code>。<code>FSM</code>的初始状态用虚线表示。箭头指示了协议从一个状态变迁到另一个状态。引起状态变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有就事件发生而采取了一个动作，横线上方或下方会使用符号A，来分别表示缺少动作或事件。<code>FSM</code>的初始状态用虚线表示。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/05/ykQ492x6nNfEXFS.png"                      alt="image-20210522204202218"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/05/9Ifvr7O6PNxzl1Q.png"                      alt="image-20210522204443201"                ></p><h3 id="3-4-2-流水线可靠数据传输协议"><a href="#3-4-2-流水线可靠数据传输协议" class="headerlink" title="3.4.2   流水线可靠数据传输协议"></a>3.4.2   流水线可靠数据传输协议</h3><p><code>rdt3.0</code>性能问题的核心在于它是一个停等协议。当发送方处于等待<code>ACK</code>的状态时，它不能从上层获得更多的数据。解决方法是：允许发送方发送多个分组而无须等待确认，这种技术被称为流水线，对可靠数据传输协议带来如下影响：</p><ul><li>必须增加序号范围，因为信道中可能有多个在输送中的未确认报文，而序号又必须唯一。</li><li>协议的发送方应当最低限度缓冲那些已发送但没有确认的分组，接收方可能也需要缓存那些已正确接收但失序的分组。</li><li>通过<strong>回退N步</strong>和<strong>选择重传</strong>解决流水线的差错恢复。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/pVi1b8NyInEATWq.png"                      alt="image-20210522205045618"                ></p><h3 id="3-4-3-回退N步"><a href="#3-4-3-回退N步" class="headerlink" title="3.4.3   回退N步"></a>3.4.3   回退N步</h3><p>在回退N步（<code>GBN</code>）协议中，允许发送方发送多个分组而不需等待确认，但未确认的分组数不能超过某个最大允许数N。控制数量N，是因为需要控制流量以及防止拥塞。</p><p>那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为窗口长度，<code>GBN</code>协议也被称为滑动窗口协议。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/AmldTQDFixpXUGu.png"                      alt="image-20210522210347749"                ></p><p>一个分组的序号承载在分组首部的一个固定长度的字段中。例如TCP有一个32比特的序号字段，但TCP序号是按字节流中的字节进行计数的，而不是按分组计数。</p><p><code>GBN</code>发送方必须响应三种类型的事件：</p><ul><li>上层的调用。当上层调用<code>rdt_send()</code>时，发送方首先检查发送窗口是否已满。如果未满，则产生一个分组并将其发送，并相应地更新变量，否则发送方可能缓存（不立刻发送）这些数据，或者返回给上层。</li><li>收到一个<code>ACK</code>。对序号为n的分组采取累积确认的方式，表明接收方已正确接收到序号包括n在内的所有分组。</li><li>超时事件。如果出现超时，发送方重传所有已发送但还未被确认过的分组。发送方仅使用一个定时器，可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个<code>ACK</code>，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，停止该定时器。</li></ul><p>对于<code>GBN</code>接收方，如果一个序号为n的分组被正确且是按序接收到的，则接收方为分组n发送一个<code>ACK</code>，并将该分组中的数据部分交付到上层。其他情况下，接收方丢弃所有失序分组。因为数据必须按序交付，如果不丢弃失序分组，接收方就要缓存分组n+1，然后在收到并交付分组n后，再将该分组交付到上层。但缺点是如果分组n丢失，则该分组及分组n+1都会被重传。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/vWI9hXgKSkr734T.png"                      alt="image-20210522211721890"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/9TCaYZX6riNLmfz.png"                      alt="image-20210522211745735"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/Aqw5SI8KdsJrypz.png"                      alt="image-20210522215344521"                ></p><h3 id="3-4-4-选择重传-SR"><a href="#3-4-4-选择重传-SR" class="headerlink" title="3.4.4   选择重传(SR)"></a>3.4.4   选择重传(SR)</h3><p>当窗口长度和带宽时延积都很大时，<code>GBN</code>协议使得单个分组的差错就会重传大量分组，选择重传（SR）协议通过让发送方仅个别、按需的重传，这要求接收方逐个确认正确接收的分组。同样用窗口长度N来限制流水线中未完成、未被确认的分组数。与<code>GBN</code>不同的是，发送方已经收到了对窗口中某些分组的<code>ACK</code>，这就意味着发送方和接收方的窗口并不总是一致。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/iKu5VJY7oLrTnkh.png"                      alt="image-20210522222703076"                ></p><p>SR发送方的事件与动作：</p><ul><li>从上层收到数据。当从上层接收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则和<code>GBN</code>一样，要么将数据缓存，要么将其返回给上层以后传输。</li><li>超时。每个分组拥有独自的定时器，因为超时发生后只能发送一个分组。</li><li>收到<code>ACK</code>。如果收到<code>ACK</code>，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。<br>如果该分组的序号等于<code>send_base</code>，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动后有序号落在窗口内的未发送分组，则发送这些分组。</li></ul><p>SR接收方的事件与动作</p><ul><li>序号在<code>[rcv_base，rcv_base+N-1]</code>内的分组被正确接收。收到的分组落在接收方的窗口内，一个选择<code>ACK</code>被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号<code>rcv_base</code>，则该分组以及以前缓存的序号连续的分组交付给上层。最后接收窗口按向前移动分组的编号向上交付这些分组。</li><li>序号在<code>[rcv_base-N，rcv_base-1]</code>内的分组被正确收到。产生一个<code>ACK</code>，即使该分组接收方以前已确认过，否则发送方窗口将永远不能向前滑动。</li><li>其他情况。忽略该分组。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/22/o31ERFQDVaUtd2W.png"                      alt="image-20210522224545110"                >由于序号范围是有限的，发送方和接收方窗口间缺乏同步会产生严重的后果。比如下面例子，接收方没有办法区分序号0的分组是第1个分组的重传还是第5个分组的初次传输。显然，窗口长度必须小于或等于序号空间大小的一半。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/23/16S2VpJwrnWkmuK.png"                      alt="image-20210523174733539"                ></p><p>另外，实际上分组在信道传输中还可能被重新排序，者可能会出现即使发送方或接收方的窗口中都没有包含这个序号的分组。采用的方法是，假定一个分组在网络中的“存活”时间不会超过某个固定最大时间量，以确保一个序号不被重新使用，直到发送方“确信”任何先前发送的序号为x的分组都不再在网络中为止。</p><h2 id="3-5-面向连接的运输：TCP"><a href="#3-5-面向连接的运输：TCP" class="headerlink" title="3.5   面向连接的运输：TCP"></a>3.5   面向连接的运输：TCP</h2><p>TCP依赖于前一节所讨论的许多基本原理，其中包括差错检测、重传、累积确认、定时器以及用于序号和确认号的首部字段。</p><h3 id="3-5-1-TCP连接"><a href="#3-5-1-TCP连接" class="headerlink" title="3.5.1   TCP连接"></a>3.5.1   TCP连接</h3><p>TCP是面向连接的，因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须相互发送某些预备报文段，以建立确保数据传输的参数。TCP协议只在端系统中运行，而不在路由器和链路层交换机中运行，所以中间的网络元素不会维持TCP连接状态。</p><p>客户进程通过套接字传递数据流，TCP将这些数据引导到该连接的发送缓存里，发送缓存是发起三次握手期间设置的缓存之一，接下来TCP从发送缓存里取出数据并放入报文段中传递到网络层，取出并放入报文段中的数据数量受限于最大报文段长度（<code>MSS</code>），而<code>MSS</code>又受限于最大链路层帧长度，即所谓的最大传输单元（<code>MTU</code>）。</p><p><code>MSS</code>是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度。设置<code>MSS</code>要保证当封装在一个<code>IP</code>数据报中的TCP报文段加上<code>TCP/IP</code>首部长度（通常40字节）适合单个链路层帧。而以太网和<code>PPP</code>链路层协议都具有1500字节的<code>MTU</code>，因此<code>MSS</code>的典型值为1460字节。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/25/lhjEur9JTpqHk8C.png"                      alt="image-20210525164914431"                ></p><h3 id="3-5-2-TCP报文段结构"><a href="#3-5-2-TCP报文段结构" class="headerlink" title="3.5.2   TCP报文段结构"></a>3.5.2   TCP报文段结构</h3><p>TCP报文段由首部字段和一个数据字段组成：</p><ul><li>16比特的源端口号和目的端口号，被用于多路复用/分解来自或送到上层应用的数据</li><li>32比特的序号字段和确认号字段，被TCP发送方和接收方用来实现可靠数据传输服务。</li><li>4比特的首部长度字段，指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。</li><li>6比特的标志字段，<code>ACK</code>比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。<code>RST</code>、<code>SYN</code>、<code>FIN</code>比特用于连接建立和拆除，在明确拥塞通告中使用了<code>CWR</code>和<code>ECE</code>比特。当<code>PSH</code>比特被置位时，就指示接收方应立即将数据交给上层。<code>URG</code>比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接收端的上层实体。（在实践中，<code>PSH</code>、<code>URG</code>和紧急数据指针没有使用）</li><li>16比特的接收窗口字段，用于流量控制，用于指示接收方愿意接受的字节数量。</li><li>16比特的检验和字段，用于检查传输时发生的比特错误。</li><li>可选与变长的选项字段，用于发送方与接收方协商最大报文段长度（<code>MSS</code>）时，或在高速网络环境下用作窗口调节因子。首部字段中还定义了一个时间戳选项。通常选项字段为空，所以TCP首部的典型长度是20字节。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/25/1qdGY3mlKzXAjfw.png"                      alt="image-20210525165519556"                ></p><p>TCP对序号的使用是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号是该报文段首字节的字节流编号。</p><p>假定数据流由一个包含500 000字节的文件组成，其<code>MSS</code>为1000字节，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0，第二个报文段分配序号1000，第三个报文段分配序号2000，以此类推。</p><p>一条TCP连接的双方均可随机地选择初始序号。这样可以减少仍在网络中存在的主机之间先前已终止的连接的报文段，却被误认为是后来主机之间新建连接所产生的有效报文段的可能性。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/25/EvKj7XC8oJbUrmA.png"                      alt="image-20210525201018216"                ></p><p>TCP是全双工的，因此主机A在向主机B发送数据的同时，也可能接收来自主机B的数据。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认。</p><p>当主机在一条TCP连接中收到失序报文段时，接收方保留失序的字节，并等待缺少的字节以填补该间隔。</p><h3 id="3-5-3-往返时间的估计与超时"><a href="#3-5-3-往返时间的估计与超时" class="headerlink" title="3.5.3   往返时间的估计与超时"></a>3.5.3   往返时间的估计与超时</h3><p>TCP采用超时/重传机制来处理报文段的丢失问题，超时间隔必须大于该连接的往返时间（<code>RTT</code>），即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。</p><h4 id="3-5-3-1-估计往返时间"><a href="#3-5-3-1-估计往返时间" class="headerlink" title="3.5.3.1   估计往返时间"></a>3.5.3.1   估计往返时间</h4><p>报文段的**样本<code>RTT</code>**（<code>SampleRTT</code>）就是从某报文段被发出到对该报文段的确认被收到之间的时间量。多数TCP的实现不会为每个发送的报文段测量一个<code>SampleRTT</code>，仅在某个时刻做一次测量。</p><p>由于路由器的拥塞和端系统负载的变化，<code>SampleRTT</code>值会随之波动。因此要采取对<code>SampleRTT</code>取平均。TCP维持一个**<code>SampleRTT</code>均值<strong>（<code>EstimatedRTT</code>），一旦获得一个新<code>SampleRTT</code>时，TCP会更新<code>EstimatedRTT</code>：<br>$$<br>EstimatedRTT = 0.875EstimatedRTT +0.125SampleRTT<br>$$<br>测量<code>RTT</code>的变化也是有价值的，</strong><code>RTT</code>偏差**(<code>DevRTT</code>)用于估算<code>SampleRTT</code>一般会偏离<code>EstimatedRTT</code>的程度。</p><p>如果<code>SampleRTT</code>值波动较小，那么<code>DevRTT</code>的值就会很小；否则<code>DevRTT</code>的值就会很大。<br>$$<br>DevRTT = 0.75DevRTT + 0.25|SampleRTT - EstimatedRTT|<br>$$</p><h4 id="3-5-3-1-设置和管理重传超时间隔"><a href="#3-5-3-1-设置和管理重传超时间隔" class="headerlink" title="3.5.3.1   设置和管理重传超时间隔"></a>3.5.3.1   设置和管理重传超时间隔</h4><p>超时间隔应该至少大于等于<code>EstimatedRTT</code>，但是超时间隔也不应该大太多，否则数据传输时延可能变大。通常设置如下：<br>$$<br>TimeoutInterval = EstimatedRTT + 4*DevRTT<br>$$<br>初始的<code>TimeoutInterval</code>值一般为1秒，当每次出现超时重传后，<code>TimeoutInterval</code>值将加倍，以免即将被确认的后继报文段过早出现超时。只要收到报文段就更新<code>EstimatedRTT</code>，再用上述公式计算<code>TimeoutInterval</code>。</p><h3 id="3-5-4-可靠数据传输"><a href="#3-5-4-可靠数据传输" class="headerlink" title="3.5.4   可靠数据传输"></a>3.5.4   可靠数据传输</h3><p>TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。<br>推荐的定时器管理过程仅使用单一的重传定时器，即使有多个已发送但还未被确认的报文段。定时器的过期间隔是<code>TimeoutInterval</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/26/1XyCF7k5JGNuiRQ.png"                      alt="image-20210526214328590"                ></p><h4 id="3-5-4-1-快速重传"><a href="#3-5-4-1-快速重传" class="headerlink" title="3.5.4.1   快速重传"></a>3.5.4.1   快速重传</h4><p>当<code>TimeoutInterval</code>过长时，超时触发重传会增加端到端时延。因此发送方可在超时事件发生前通过注意冗余<code>ACK</code>来检测到丢包情况。冗余<code>ACK</code>就是再次收到先前已经收到对该报文段的<code>ACK</code>。</p><p>当TCP接收方收到一个其序号大于下一个所期望的、按序的报文段时，它检测到了数据流中的一个间隔，这就是说有报文段丢失，这个间隔可能是由于在网络中报文段丢失或重新排序造成的。因为TCP不使用否定确认，它只是对已经接收到的最后一个按序字节数据进行重复确认即产生一个冗余<code>ACK</code>。</p><p>因为发送方接连发送大量的报文段，如果一个报文段丢失，就很可能引起接连的冗余<code>ACK</code>。如果TCP发送方接收到对相同数据的3个冗余<code>ACK</code>，说明跟在这个被确认过3次的报文段之后的报文段已经丢失，TCP在该报文段的定时器过期之前就能快速重传丢失的报文段。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/sBlCG6Aae3NH5O1.png"                      alt="image-20210527151229706"                ></p><h4 id="3-5-4-2-TCP的差错恢复机制"><a href="#3-5-4-2-TCP的差错恢复机制" class="headerlink" title="3.5.4.2   TCP的差错恢复机制"></a>3.5.4.2   TCP的差错恢复机制</h4><p>TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的。因此TCP发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号。但是TCP和<code>GBN</code>协议之间区别在于，TCP会将正确接收但失序的报文段缓存起来。</p><p>TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。即不会重传那些已被接收方选择性地确认过的报文段。因此，TCP的差错恢复机制是<code>GBN</code>协议与<code>SR</code>协议的混合体。</p><h3 id="3-5-5-流量控制"><a href="#3-5-5-流量控制" class="headerlink" title="3.5.5   流量控制"></a>3.5.5   流量控制</h3><p>TCP连接的每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据，但不一定是立即读取。如果读取数据时缓慢、数据发送过大过快，该连接的接收缓存（<code>RevBuffer</code>）就可能溢出。</p><p>因此TCP为它的应用程序提供了流量控制服务，即保证发送速率与读取速率相匹配。TCP发送方也可能因为网络的拥塞而被遏制，这被称为拥塞控制。即使流量控制和拥塞控制采取的动作非常相似，但是它们是针对完全不同的原因而采取的措施。</p><p>假设TCP接收方丢弃失序的报文段。TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制，接收窗口用于给发送方指示接收方还有多少可用的缓存空间。因为TCP是全双工通信，两端都各自维护一个接收窗口。</p><ul><li><p><code>LastByteRevd</code>：从网络中到达并且已放入接收缓存中的数据流的最后一个字节的编号。</p></li><li><p><code>LastByteRead</code>：应用进程从接收缓存读出的数据流的最后一个字节的编号。</p></li></ul><p>TCP要保证已分配的缓存不溢出，下式必须成立：<br>$$<br>LastByteRevd-LastByteRead &lt; RcvBuffer<br>$$<br>接收窗口用<code>rwnd</code>表示，根据缓存可用空间的数量来设置：<br>$$<br>rwnd = RevBuffer-（LastByteRcvd-LastByteRead）<br>$$<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/nsjumKTRQBtJw5G.png"                      alt="image-20210527153144444"                ></p><p>接收方把当前的<code>rwnd</code>值放入发给发送方的报文段接收窗口字段中，最初设定<code>rwnd</code> = <code>RcvBuffer</code>。发送发轮流跟踪两个变量<code>LastByteSent</code>和<code>LastByteAcked</code>，两个变量之间的差就是发送到连接中但未被确认的数据量。因此将未确认的数据量控制在值<code>rwnd</code>以内，就可以保证发送方不会使接收方的接收缓存溢出。<br>$$<br>LastByteSent-LastByteAcked \le rwnd<br>$$<br>当接收缓存已满，在将<code>rwnd</code> = 0通告给发送方之后，进程缓存也被清空，如果没有任何数据要发给发送方了，发送方就不知道接收缓存已经有新的空间，发送方会被阻塞而不能再发送数据。因此TCP规范中要求：当主机B的接收窗口为0时，发送方继续发送只有一个字节数据的报文段，这样被接收方确认后且接收缓存清空后，确认报文里将包含一个新的<code>rwnd</code>值。</p><h3 id="3-5-6-TCP连接管理"><a href="#3-5-6-TCP连接管理" class="headerlink" title="3.5.6   TCP连接管理"></a>3.5.6   TCP连接管理</h3><h4 id="3-5-6-1-建立连接"><a href="#3-5-6-1-建立连接" class="headerlink" title="3.5.6.1 建立连接"></a>3.5.6.1 建立连接</h4><p>假设客户进程想与服务器上的一个进程建立一条连接。TCP会用以下方式建立一条双方的TCP连接：</p><ol><li>第一步：客户端的TCP首先向服务器端的TCP发送一个不包含应用层数据特殊TCP报文段。报文段首部中的标志位（<code>SYN</code>）被置为1，因此这个特殊报文段被称为SYN报文段。客户会随机地选择一个初始序号（<code>client_isn</code>）放置于该报文段的序号字段中。</li><li>第二步：<code>TCP SYN</code>报文段到达服务器，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接但不包含应用层数据的<code>SYN ACK</code>报文段。SYN比特被置为1；确认号被置为<code>client_isn +1</code>；序号被置为<code>server_isn</code>。</li><li>第三步：在收到<code>SYN ACK</code>报文段后，客户也给该连接分配缓存和变量，并向服务器发送另外一个报文段对服务器的允许连接的报文段进行了确认，通过将值<code>server_isn + 1</code>放置首部的确认号中。因为连接已经建立了，所以SYN比特被置为0。这一步可以在报文段携带客户到服务器的数据。</li></ol><p>一旦完成这3个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN比特都将被置为0，这种连接创建过程通常被称为3次握手。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/A9pjFOL7HvSr2bc.png"                      alt="image-20210527161553661"                ></p><p>服务器会监听客户发送其SYN报文段的端口，当接收到一个TCP报文段，其端口号或源<code>IP</code>地址与该主机上进行中的套接字都不匹配时，则该主机将发送<code>RST</code>标志位置为1的特殊重置报文段。如果接收的是<code>UDP</code>分组，它的目的端口与进行中的<code>UDP</code>套接字不匹配，该主机发送一个特殊的<code>ICMP</code>数据报。</p><p>如果某客户不发送<code>ACK</code>来完成该三次握手的第三步，这可能遭受经典的<code>DoS</code>攻击即SYN洪泛攻击。攻击者发送大量的<code>SYN</code>报文段，而不完成第三次握手的步骤，服务器不断为这些半开连接分配资源，导致服务器的连接资源被消耗殆尽。现在有一种有效的防御系统<code>SYN cookie</code>，被部署在大多数主流操作系统中，以下列方式工作：</p><ul><li><p>当服务器接收到一个<code>SYN</code>报文段时，不会为该报文段生成一个半开连接，而是生成一个初始TCP序列号，该序列号（也被称为cookie）是根据SYN报文段的源和目的<code>IP</code>地址与端口号以及服务器的秘密数来运行散列函数计算得出。服务器则发送具有这种特殊初始序号的<code>SYN ACK</code>分组，但服务器并不记忆该cookie或任何对应于SYN的其他状态信息。</p></li><li><p>如果客户是合法的，则它将返回一个<code>ACK</code>报文段。服务器将使用在<code>SYN ACK</code>报文段中与第一步<code>SYN</code>报文段中的相同的源和目的<code>IP</code>地址与端口号以及秘密数又运行相同的散列函数，如果该结果加1与在客户的<code>SYN ACK</code>中的确认号值（cookie）相同的话，服务器认为该<code>ACK</code>对应于较早的SYN报文段，因为一个合法的<code>ACK</code>确认号等于<code>SYN ACK</code>序号值加1，服务器再生成一个具有套接字的全开的连接。</p></li><li><p>如果客户没有返回<code>ACK</code>报文段，则初始的SYN并没有对服务器产生危害，因为服务器没有为它分配任何资源。</p></li></ul><h4 id="3-5-6-2-关闭连接"><a href="#3-5-6-2-关闭连接" class="headerlink" title="3.5.6.2   关闭连接"></a>3.5.6.2   关闭连接</h4><p>参与一条TCP连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的缓存和变量将被释放。假设某客户打算关闭连接：</p><ol><li>客户应用进程发出关闭连接命令，引起TCP向服务器进程发送首部标志位<code>FIN</code>被设置为1的特殊TCP报文段；</li><li>服务器接收到该报文段后，就向发送方回送一个确认报文段。然后服务器也发送<code>FIN</code>被置为1的终止报文段;</li><li>客户对这个服务器的终止报文段也进行确认。此时在两台主机上用于该连接的所有资源都被释放了。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/ozEfuXgdyjKJiD2.png"                      alt="image-20210527164445980"                ></p><h4 id="3-5-6-3-TCP状态变迁"><a href="#3-5-6-3-TCP状态变迁" class="headerlink" title="3.5.6.3   TCP状态变迁"></a>3.5.6.3   TCP状态变迁</h4><p>在一个TCP连接的生命周期内，运行在每台主机中的TCP协议在各种TCP状态之间变迁。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/24OnsS58TuBJLlm.png"                      alt="image-20210527165143425"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/skRvnBqKbojw68l.png"                      alt="image-20210527171610843"                ></p><h2 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6   拥塞控制原理"></a>3.6   拥塞控制原理</h2><h3 id="3-6-1-拥塞原因与代价"><a href="#3-6-1-拥塞原因与代价" class="headerlink" title="3.6.1   拥塞原因与代价"></a>3.6.1   拥塞原因与代价</h3><h4 id="3-6-1-1-情况1：两个发送方和一台具有无穷大缓存的路由器"><a href="#3-6-1-1-情况1：两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="3.6.1.1   情况1：两个发送方和一台具有无穷大缓存的路由器"></a>3.6.1.1   情况1：两个发送方和一台具有无穷大缓存的路由器</h4><p>两台主机A和B都有一条连接，且这两条连接共享源与目的地之间的单跳路由。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/Kb3NRDjrwtxg9A4.png"                      alt="image-20210527194530205"                ></p><p>假设主机A、B中的应用程序都以λ<sub>in</sub>字节/秒的平均速率通过一台路由器在一段容量为R的共享式输出链路上传输。该路由器带有缓存，可用于当分组到达速率超过该输出链路的容量时存储“入分组”。假设路由器有无限大的缓存空间。它的吞吐量只能达R/2，这个吞吐量上限是由两条连接之间共享链路容量造成的。当发送速率接近R/2时，平均时延就会越来越大，当超过R/2时，假设这些连接以此发送速率运行无限长时间并且有无限量的缓存可用，路由器中的平均排队分组数就会无限增长，平均时延也会变成无穷大。因此拥塞网络的代价：即当分组的到达速率接近链路容量时，分组经历巨大的排队时延。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/xd9HXyuJK2B6kl4.png"                      alt="image-20210527194617294"                ></p><h4 id="3-6-1-2-情况2：两个发送方和一台具有有限缓存的路由器"><a href="#3-6-1-2-情况2：两个发送方和一台具有有限缓存的路由器" class="headerlink" title="3.6.1.2   情况2：两个发送方和一台具有有限缓存的路由器"></a>3.6.1.2   情况2：两个发送方和一台具有有限缓存的路由器</h4><p>路由器缓存的容量是有限的，当分组到达一个已满的缓存时会被丢弃，其次分组在路由器中被丢弃将被发送方重传。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/gLQEsDH3zOGhqmr.png"                      alt="image-20210527220137066"                ></p><p>在情况2下实现的性能依赖于重传的方式。如果主机A能确定路由器中的缓存是否空闲来决定是否发送一个分组。在这种情况下，将不会产生丢包，并且连接的吞吐量就等于λ<sub>in</sub>。下图a中描述了这种情况。</p><p>如果发送方仅当在确定了一个分组已经丢失时才重传，性能可能与图b所示的情况相似。因此网络拥塞的另一个代价：发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。</p><p>如果发送方重传的是超时但在队列中被推迟还未丢失的分组。初始数据分组和重传分组都可能到达接收方，路由器转发重传的分组就是在做无用功，路由器本可以去发送另一个分组。图c显示了当假定每个分组被路由器转发（平均）两次时，吞吐量与供给载荷的对比情况。因此网络拥塞的另一种代价：即发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/f6amXC4cDdbJZIN.png"                      alt="image-20210527220156426"                ></p><h4 id="3-6-1-3-情况3-4个发送方和具有有限缓存的多台路由器及多跳路径"><a href="#3-6-1-3-情况3-4个发送方和具有有限缓存的多台路由器及多跳路径" class="headerlink" title="3.6.1.3   情况3:  4个发送方和具有有限缓存的多台路由器及多跳路径"></a>3.6.1.3   情况3:  4个发送方和具有有限缓存的多台路由器及多跳路径</h4><p>在最后一种拥塞情况中，有4台主机发送分组，每台都通过交叠的两跳路径传输。对极小的λ<sub>in</sub>值，路由器缓存的溢出是很少见的，因此，对于较小的λ<sub>in</sub>，λ<sub>in</sub>的增大会导致 λ<sub>out</sub>的增大。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/tQzqw5avPkZJmNF.png"                      alt="image-20210527224007756"                >当</p><p>当λ<sub>in</sub>（因此λ<sup>‘</sup><sub>in</sub>）很大，考虑路由器<code>R2</code>，A-C流量与B-D流量在路由器<code>R2</code>上必须为有限缓存空间而竞争，所以当来自B-D连接的供给载荷越来越大时，A-C连接上成功通过<code>R2</code>的流量会越来越小（由于缓存溢出而未被丢失）。在极限情况下，当供给载荷趋近于无穷大时，<code>R2</code>的空闲缓存会立即被B-D连接的分组占满，因而A-C连接在<code>R2</code>上的吞吐量趋近于0。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/27/vH45QnJbtIP6iGu.png"                      alt="image-20210527224057844"                ></p><p>随着供给载荷的增加而使吞吐量最终减少的原因是，每当有一个分组在第二跳路由器上被丢弃时，第一跳路由器将分组转发到第二跳路由器就是无用功。因此拥塞而丢弃分组的另一种代价，即当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量都被浪费掉了。</p><h3 id="3-6-2-拥塞控制方法"><a href="#3-6-2-拥塞控制方法" class="headerlink" title="3.6.2   拥塞控制方法"></a>3.6.2   拥塞控制方法</h3><p>可根据网络层是否为运输层拥塞控制提供了显式帮助，来区分拥塞控制方法：</p><ul><li>端到端拥塞控制。TCP默认采用。网络层没有为运输层拥塞控制提供显式支持，因为<code>IP</code>层不会向端系统提供有关网络拥塞的反馈信息，而是通过TCP报文段的丢失（通过超时或3次冗余<code>ACK</code>确认），或者通过往返时延值增加作为拥塞程度增加的指示，TCP会相应地减小其窗口长度。</li><li>网络辅助的拥塞控制。路由器向发送方提供关于网络中拥塞状态的显式反馈信息。拥塞信息通常有两种方式。1. 反馈信息可以由网络路由器发给发送方，通常采用了一种阻塞分组的形式。2. 路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生，这种形式的通知至少要经过一个完整的往返时间。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/28/n3fSZbMz79hmyYa.png"                      alt="image-20210528143754066"                ></p><h2 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7   TCP拥塞控制"></a>3.7   TCP拥塞控制</h2><p>当出现过度的拥塞时，路由器的缓存会溢出，引起一个数据报被丢弃，接着会引起发送方的丢包事件（超时或收到3个冗余<code>ACK</code>），发送方就认为路径上出现了拥塞的指示。</p><p>运行在发送方的TCP拥塞控制机制跟踪一个额外的变量拥塞窗口<code>cwnd</code>，对发送流量的速率进行了限制。在一个发送方中未被确认的数据量不会超过<code>cwnd</code>与<code>rwnd</code>中的最小值，调节<code>cwnd</code>值，就能间接限制发送方的发送速率。<br>$$<br>LastByteSent-LastByteAcked \le min{ cwnd,rwnd}<br>$$</p><h3 id="3-7-1-TCP拥塞控制算法"><a href="#3-7-1-TCP拥塞控制算法" class="headerlink" title="3.7.1   TCP拥塞控制算法"></a>3.7.1   TCP拥塞控制算法</h3><p>TCP拥塞控制算法，说明如何控制发送速率使得网络不会拥塞，同时又能充分利用可用的带宽。包括3个主要部分：</p><ol><li><p>慢启动。</p><ul><li>当TCP连接开始时，<code>cwnd</code>的值通常初始置为1个<code>MSS</code>，每当传输的报文段首次被确认就增加1个<code>MSS</code>。</li><li>当出现超时，<code>cwnd</code>设置为1并重新开始慢启动过程，同时将<code>ssthresh</code>（慢启动阈值）设置为<code>cwnd/2</code>。</li><li>当<code>cwnd</code>的值等于<code>ssthresh</code>，转移到拥塞避免模式；</li><li>当收到3个冗余<code>ACK</code>，TCP执行一种快速重传并进入快速恢复状态。</li></ul></li><li><p>拥塞避免。</p><ul><li>一旦进入拥塞避免状态，TCP更为谨慎地增加<code>cwnd</code>，无论何时到达一个新的确认，每个<code>RTT</code>只将<code>cwnd</code>的值增加一个<code>MSS</code>。</li><li>当出现超时，<code>cwnd</code>设置为1个<code>MSS</code>，<code>ssthresh</code>设置为<code>cwnd/2</code>，并进入慢启动状态。</li><li>当收到的3个冗余的<code>ACK</code>时，<code>ssthresh</code>的值被更新为<code>cwnd/2</code>。TCP将<code>cwnd</code>的值减半再加上3个<code>MSS</code>，进入快速恢复状态。</li></ul></li><li><p>快速恢复。</p><ul><li>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的<code>ACK</code>，<code>cwnd</code>的值增加一个<code>MSS</code>。</li><li>当对丢失报文段的一个<code>ACK</code>到达时，降低<code>cwnd</code>后进入拥塞避免状态。</li><li>如果出现超时事件，执行同慢启动和拥塞避免相同的动作后，迁移到慢启动状态：</li></ul></li></ol><p>慢启动和拥塞避免是TCP的强制部分，差异在于对收到的<code>ACK</code>时增加<code>ewnd</code>长度的方式。快速恢复是推荐部分，不是必需的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/28/J2hlu7QI3VFvEGd.png"                      alt="image-20210528152602221"                ></p><h3 id="3-7-2-网络辅助拥塞控制"><a href="#3-7-2-网络辅助拥塞控制" class="headerlink" title="3.7.2   网络辅助拥塞控制"></a>3.7.2   网络辅助拥塞控制</h3><p>允许网络明确向TCP发送方和接收方发出拥塞信号，称为明确拥塞通告（<code>ECN</code>），<code>IP</code>数据报首部的服务类型字段中的两个比特被用于<code>ECN</code>，路由器所使用的一种<code>ECN</code>比特设置指示该路由器正在历经拥塞，该拥塞指示则由被标记的<code>IP</code>数据报所携带，送给目的主机，再由目的主机通知发送主机。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/29/Re9uNlTpBwAdyxt.png"                      alt="image-20210529170823902"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-概述和运输层服务&quot;&gt;&lt;a href=&quot;#3-1-概述和运输层服务&quot; class=&quot;headerlink&quot; title=&quot;3.1   概述和运输层服务&quot;&gt;&lt;/a&gt;3.1   概述和运输层服务&lt;/h2&gt;&lt;h3 id=&quot;3-1-1-运输层和网络层的关系&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络：自顶向下方法" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>02-应用层</title>
    <link href="http://example.com/2021/05/10/note/Computer%20Networking/02-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/05/10/note/Computer%20Networking/02-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-05-10T02:36:52.466Z</published>
    <updated>2021-06-24T13:35:57.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1   应用层协议原理"></a>2.1   应用层协议原理</h2><h3 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1   网络应用程序体系结构"></a>2.1.1   网络应用程序体系结构</h3><p>网络体系结构为应用程序提供了特定的服务集，规定了如何在各种端系统上组织该应用程序。两种主流体系结构：客户—服务器体系结构和对等（<code>P2P</code>）体系结构。</p><p>客户一服务器体系结构：有一个总是打开的主机称为服务器，服务于来自许多其他称为客户的主机的请求。例如Web应用。</p><p><code>P2P</code>体系结构：对位于数据中心的专用服务器有最小甚至没有依赖，应用程序在间断连接的主机对之间直接通信，这些主机对被称为对等方。例如文件共享、迅雷、电话和视频会议。</p><p>某些应用具有混合的体系结构。例如，对于即时讯息应用，服务器被用于跟踪用户的<code>IP</code>地址，但可在用户主机之间直接发送报文。</p><h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2   进程通信"></a>2.1.2   进程通信</h3><p>进行通信的实际上是进程而不是程序，是运行在端系统中的一个程序。进程间通信的规则由端系统上的操作系统确定。在两个不同端系统上的进程，通过交换报文而相互通信。</p><h4 id="2-1-2-1-客户和服务器进程"><a href="#2-1-2-1-客户和服务器进程" class="headerlink" title="2.1.2.1   客户和服务器进程"></a>2.1.2.1   客户和服务器进程</h4><p>网络应用程序由成对的进程组成，发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。</p><p>在Web中，浏览器进程是客户，Web服务器进程是服务器。在<code>P2P</code>文件共享中，当对等方A请求对等方B发送一个特定的文件时对等方A是客户，而对等方B是服务器，而一个进程能够既是客户又是服务器。</p><h4 id="2-1-2-2-进程与计算机网络之间的接口"><a href="#2-1-2-2-进程与计算机网络之间的接口" class="headerlink" title="2.1.2.2   进程与计算机网络之间的接口"></a>2.1.2.2   进程与计算机网络之间的接口</h4><p>进程通过套接字接口向网络发送和接收报文。套接字是主机内应用层与运输层之间的接口。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对于运输层的控制仅限于：1. 选择运输层协议；2. 设定几个运输层参数，如最大缓存和最大报文段长度等。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/13/OgkYyHpXEqRes5W.png"                      alt="image-20210513112006886"                ></p><h3 id="2-1-3-因特网提供的运输服务"><a href="#2-1-3-因特网提供的运输服务" class="headerlink" title="2.1.3   因特网提供的运输服务"></a>2.1.3   因特网提供的运输服务</h3><p>因特网为应用程序提供两个运输层协议，<code>UDP</code>和<code>TCP</code>，每个协议为调用它们的应用程序提供了不同的服务集合。</p><p>TCP服务模型包括<strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong>。</p><p><code>UDP</code>是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。<code>UDP</code>是无连接的，因此在两个进程通信前没有握手过程。<code>UDP</code>协议提供一种不可靠数据传送服务，到达接收进程的报文也可能是乱序到达的。<code>UDP</code>没有包括拥塞控制机制，所以<code>UDP</code>的发送端可以用它选定的任何速率向其网络层注入数据。</p><h4 id="2-1-4-3-TCP安全"><a href="#2-1-4-3-TCP安全" class="headerlink" title="2.1.4.3  TCP安全"></a>2.1.4.3  TCP安全</h4><p>无论TCP还是<code>UDP</code>都没有提供任何加密机制，所以研制了TCP的加强版本，安全套接字（<code>SSL</code>），提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。</p><p><code>SSL</code>对TCP的加强是在应用层上实现的。<code>SSL</code>有自己的套接字<code>API</code>，发送进程向<code>SSL</code>套接字传递明文数据，，<code>SSL</code>加密该数据并将加密的数据传递给TCP套接字。加密的数据经因特网传送到接收进程中的TCP套接字，该接收套接字将加密数据传递给<code>SSL</code>，由其进行解密，最后通过它的<code>SSL</code>套接字将明文数据传递给接收进程。</p><h3 id="2-1-4-应用层协议"><a href="#2-1-4-应用层协议" class="headerlink" title="2.1.4   应用层协议"></a>2.1.4   应用层协议</h3><p>应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/13/SldDW6VtFnbkXEi.png"                      alt="image-20210513203552242"                ></p><h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2   Web和HTTP"></a>2.2   Web和HTTP</h2><h3 id="2-2-1-HTTP概况"><a href="#2-2-1-HTTP概况" class="headerlink" title="2.2.1   HTTP概况"></a>2.2.1   HTTP概况</h3><p>Web的应用层协议是超文本传输协议（HTTP）。HTTP由两个程序实现：一个客户程序和一个服务器程序，通过交换HTTP报文进行会话。</p><p>HTTP使用TCP作为它的支撑运输协议，HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问ТСР。客户向它的套接字接口发送HTTP请求报文并从它的套接字接口接收HTTP响应报文。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。</p><p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器会重新发送该对象，所以我们说HTTP是一个无状态协议。</p><h3 id="2-2-2-非持续连接和持续连接"><a href="#2-2-2-非持续连接和持续连接" class="headerlink" title="2.2.2   非持续连接和持续连接"></a>2.2.2   非持续连接和持续连接</h3><p>非持续连接：每个请求/响应对是经一个单独的TCP连接发送，用户能够配置浏览器来控制连接的并行度。大部分浏览器默认打开5~10个并行的TCP连接，每条连接只处理一个请求响应事务。</p><p>往返时间（<code>RTT</code>）：一个短分组从客户到服务器然后再返回客户所花费的时间。<code>RTT</code>包括分组传播时延、分组排队时延以及分组处理时延。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/13/XjhdIJ1s74gtaoG.png"                      alt="image-20210513213831777"                ></p><p>缺点：1. 必须为每一个请求的对象建立和维护一个新的连接，在客户和服务器中都要分配每个TCP的缓冲区和保持TCP变量。2. 每一个对象经受两倍<code>RTT</code>的交付时延，一个<code>RTT</code>用于创建TCP，另一个<code>RTT</code>用于请求和接收一个对象。</p><p>持续连接：所有的请求及其响应经相同的TCP连接发送呢。HTTP在其默认方式下使用持续连接。</p><h3 id="2-2-3-用户与服务器的交互：cookie"><a href="#2-2-3-用户与服务器的交互：cookie" class="headerlink" title="2.2.3   用户与服务器的交互：cookie"></a>2.2.3   用户与服务器的交互：cookie</h3><p>cookie允许站点对用户进行跟踪，用于标识一个用户。用户首次访问一个站点时提供一个用户标识，在后继会话中，浏览器向服务器传递一个cookie首部，从而向该服务器标识了用户。因此cookie可以在无状态的HTTP之上建立一个用户会话层。cookie技术有4个组件：</p><ol><li>在HTTP响应报文中的一个cookie首部行；</li><li>在HTTP请求报文中的一个cookie首部行；</li><li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；</li><li>位于Web站点的一个后端数据库。</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/13/J296joUDX5hSVfn.png"                      alt="image-20210513214554431"                ></p><h3 id="2-2-4-Web缓存"><a href="#2-2-4-Web缓存" class="headerlink" title="2.2.4   Web缓存"></a>2.2.4   Web缓存</h3><p>Web缓存器也叫代理服务器，在存储空间中保存最近请求过的对象的副本。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器。</p><h2 id="2-3-电子邮件"><a href="#2-3-电子邮件" class="headerlink" title="2.3  电子邮件"></a>2.3  电子邮件</h2><p>电子邮件系统有3个主要组成部分：</p><ol><li><p>用户代理</p><p>用户代理允许用户阅读、回复、转发、保存和撰写报文。比如<code>QQ</code>邮箱向其邮件服务器发送和获取邮件。</p></li><li><p>邮件服务器</p><p>每个接收方在其中的某个邮件服务器上有一个邮箱，管理和维护发送的报文。</p></li><li><p>简单邮件传输协议（SMTP）。</p><p>SMTP是电子邮件中主要的应用层协议，使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。每台邮件服务器上既运行SMTP的客户端也运行SMTP的服务器端。</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/13/PSsoeu3xQLARtIl.png"                      alt="image-20210513223105286"                ></p><h3 id="2-3-2-与HTTP的对比"><a href="#2-3-2-与HTTP的对比" class="headerlink" title="2.3.2 与HTTP的对比"></a>2.3.2 与HTTP的对比</h3><ul><li>HTTP主要是一个<strong>拉协议</strong>，用户使用HTTP从服务器拉取应用层信息。SMTP是一个<strong>推协议</strong>，即发送邮件服务器把文件推向接收邮件服务器。</li><li>SMTP要求每个报文采用7比特<code>ASCI</code>码格式，否则该报文按照7比特<code>ASCI</code>码进行编码。HTTP数据不受限制。</li><li>HTTP把每个对象封装到它自己的HTTP响应报文中，而SMTP则把所有报文对象放在一个报文之中。</li></ul><h2 id="2-4-DNS：因特网的目录服务"><a href="#2-4-DNS：因特网的目录服务" class="headerlink" title="2.4   DNS：因特网的目录服务"></a>2.4   <code>DNS</code>：因特网的目录服务</h2><h3 id="2-4-1-DNS提供的服务"><a href="#2-4-1-DNS提供的服务" class="headerlink" title="2.4.1   DNS提供的服务"></a>2.4.1   <code>DNS</code>提供的服务</h3><p><code>DNS</code>是：1. 由分层的<code>DNS</code>服务器实现的分布式数据库；2.使主机能够查询分布式数据库的应用层协议。<code>DNS</code>服务器通常是运行BIND软件的UNIX机器。<code>DNS</code>还提供了一些重要的服务：</p><ol><li><p>主机别名</p><p>有着复杂主机名的主机能拥有一个或者多个别名。应用程序可以调用<code>DNS</code>来获得主机别名对应的规范主机名以及主机的<code>IP</code>地址。</p></li><li><p>邮件服务器别名</p><p>电子邮件应用程序可以调用<code>DNS</code>，对提供的主机名别名进行解析，以获得该主机的规范主机名及其<code>IP</code>地址。</p></li><li><p>负载分配</p><p><code>DNS</code>数据库中存储与同一个规范主机名相联系的<code>IP</code>地址集合，当客户对映射到某地址集合的名字发出一个<code>DNS</code>请求时，该服务器用<code>IP</code>地址的整个集合进行响应，但在每个回答中循环这些地址次序，所以<code>DNS</code>就在冗余的Web服务器之间循环分配了负载。</p></li></ol><h3 id="2-4-2-DNS工作机理概述"><a href="#2-4-2-DNS工作机理概述" class="headerlink" title="2.4.2   DNS工作机理概述"></a>2.4.2   <code>DNS</code>工作机理概述</h3><p><code>DNS</code>工作过程的总体概括：</p><ol><li>当主机上的应用程序需要将主机名转换为<code>IP</code>地址时，调用主机上的<code>DNS</code>的客户端，指明需要被转换的主机名</li><li><code>DNS</code>客户端接收后向<code>DNS</code>服务器发送<code>DNS</code>查询报文，<code>DNS</code>请求和回答报文使用<code>UDP</code>数据报经端口53发送</li><li><code>DNS</code>客户端接收到包含<code>IP</code>地址的<code>DNS</code>回答报文，然后传递到调用<code>DNS</code>的应用程序</li></ol><h4 id="2-4-2-1-分布式、层次数据库"><a href="#2-4-2-1-分布式、层次数据库" class="headerlink" title="2.4.2.1   分布式、层次数据库"></a>2.4.2.1   分布式、层次数据库</h4><p><code>DNS</code>服务器层次方式组织，有3种类型的<code>DNS</code>服务器：</p><ul><li>根<code>DNS</code>服务器，提供<code>TLD</code>服务器的<code>IP</code>地址。</li><li>顶级域<code>DNS</code>服务器（<code>TLD</code>服务器），提供了权威<code>DNS</code>服务器的<code>IP</code>地址。</li><li>权威<code>DNS</code>服务器，具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构或交由服务提供商的权威<code>DNS</code>服务器收藏和提供公共可访问这些<code>DNS</code>记录。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/18/kqsQnGf149gHYpx.png"                      alt="image-20210518193538282"                ></li></ul><p>还有另一类重要的<code>DNS</code>服务器，本地<code>DNS</code>服务器。主机的本地<code>DNS</code>服务器通常“邻近”主机，它起着代理的作用将该请求转发到<code>DNS</code>服务器层次结构中。实际上过程比下图更复杂，因为通常<code>TLD</code>服务器只是知道中间的某个<code>DNS</code>服务器，该中间<code>DNS</code>服务器依次才能知道用于该主机的权威<code>DNS</code>服务器。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/18/3QZbqu7FHMi9NdA.png"                      alt="image-20210518202037321"                ></p><p>上图利用了<strong>递归查询</strong>和<strong>迭代查询</strong>。从理论上讲，任何<code>DNS</code>查询既可以是迭代的也能是递归的。但实践中查询通常遵循的模式是：从请求主机到本地<code>DNS</code>服务器的查询是递归的，其余的查询是迭代的。</p><h4 id="2-4-2-2-DNS缓存"><a href="#2-4-2-2-DNS缓存" class="headerlink" title="2.4.2.2   DNS缓存"></a>2.4.2.2   <code>DNS</code>缓存</h4><p>为了改善时延性能并减少<code>DNS</code>报文数量，<code>DNS</code>服务器接收一个<code>DNS</code>回答时能将映射缓存在本地存储器中，因此本地<code>DNS</code>服务器也能够缓存<code>TLD</code>服务器的<code>IP</code>地址，从而允许本地<code>DNS</code>绕过根<code>DNS</code>服务器。但由于主机和主机名与<code>IP</code>地址间的映射并不永久，<code>DNS</code>服务器在一段时间后（通常设置为两天）将丢弃缓存的信息。</p><h3 id="2-4-3-DNS记录和报文"><a href="#2-4-3-DNS记录和报文" class="headerlink" title="2.4.3   DNS记录和报文"></a>2.4.3   <code>DNS</code>记录和报文</h3><p>共同实现<code>DNS</code>分布式数据库的所有<code>DNS</code>服务器存储了资源记录（RR），RR提供了主机名到<code>IP</code>地址的映射。<br>资源记录是一个包含了下列字段的4元组：（Name，Value，Tурe，TTL）</p><p>TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。Name和Value的值取决于Type：</p><ul><li>如果Type =<code>A</code>，则Name是主机名，Value是该主机名对应的<code>IP</code>地址。提供了标准的主机名到<code>IP</code>地址的映射。</li><li>如果Type =<code>NS</code>，则Name是个域，Value只是能获得该域中主机<code>IP</code>地址的权威<code>DNS</code>服务器的主机名。这个记录用于沿着查询链来路由<code>DNS</code>查询。</li><li>如果Type =<code> CNAME</code>，则Value是别名为Name的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名。</li><li>如果Type =<code>MX</code>，则Value是个别名为Name的邮件服务器的规范主机名。</li></ul><h2 id="2-5-内容分发网络"><a href="#2-5-内容分发网络" class="headerlink" title="2.5   内容分发网络"></a>2.5   内容分发网络</h2><p><code>CDN</code>管理分布在多个地理位置上的服务器，在服务器中存储内容的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的<code>CDN</code>位置。<code>CDN</code>可以是专用<code>CDN</code>，即由内容提供商自己所拥有。另一种是第三方<code>CDN</code>。</p><p><code>CDN</code>通常采用两种不同的服务器安置原则</p><ul><li>深入。该原则是通过在接入<code>ISP</code>中部署服务器集群来深入到<code>ISP</code>的接入网中。其目标是靠近端用户，通过减少端用户和<code>CDN</code>集群之间链路和路由器的数量，从而改善了用户感受的时延和吞吐量。</li><li>邀请做客。该原则是通过在少量关键位置（通常是<code>IXP</code>）建造大集群来邀请到<code>ISP</code>做客。与深人设计原则相比，邀请做客设计通常产生较低的维护和管理开销，但可能以对端用户的较高时延和较低吞吐量为代价。</li></ul><p>一旦<code>CDN</code>的集群准备就绪，它就可以跨集群复制内容。如果客户向一个未存储该内容的集群请求，则该集群检索该内容，向客户流式传输内容的同时在本地存储一个副本。类似于因特网缓存，会删除不经常请求的内容。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/18/lSiuCAEzgyfxajH.png"                      alt="image-20210518214333982"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-1-应用层协议原理&quot;&gt;&lt;a href=&quot;#2-1-应用层协议原理&quot; class=&quot;headerlink&quot; title=&quot;2.1   应用层协议原理&quot;&gt;&lt;/a&gt;2.1   应用层协议原理&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-网络应用程序体系结构&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络：自顶向下方法" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>01-计算机网络和因特网</title>
    <link href="http://example.com/2021/05/09/note/Computer%20Networking/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
    <id>http://example.com/2021/05/09/note/Computer%20Networking/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</id>
    <published>2021-05-09T13:14:05.127Z</published>
    <updated>2021-06-24T13:36:07.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1   什么是因特网"></a>1.1   什么是因特网</h2><p>互联网中所有设备都称为<strong>主机</strong>（host）或<strong>端系统</strong>（end system）。可以进一步划分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。端系统通过<strong>通信链路</strong>（communication link）和<strong>分组交换机</strong>（packet switch）连接到一起。</p><p>通信链路由不同类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱。当端系统要发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为**<code>分组</code>**（packet），这些分组通过网络发送到目的端系统，在那里被装配成初始数据。</p><p>分组交换机接收并转发分组，著名的类型有<strong>路由器</strong>（router）和<strong>链路层交换机</strong>（link-layer switch）。链路层交换机通常用于接入网中，而路由器通常用于网络核心中。从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<strong>路径</strong>（route或path）。</p><p>端系统通过因特网服务提供商<code>（ISP）</code>接入因特网，每个<code>ISP</code>就是一个由多台分组交换机和多段通信链路组成的网络。<code>ISP</code>为端系统和内容提供者提供了各种不同类型的网络接入。因特网就是将端系统彼此互联，因此为端系统提供接入的<code>ISP</code>也必须互联。</p><p>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>（protocol），定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。<code>TCP</code>（Transmission Control Protocol，传输控制协议）和<code>IP</code>（Internet Protocol，网际协议）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为<code>TCP/IP</code>。</p><p>与因特网相连的端系统提供了一个<strong>套接字接口</strong>（socket interface），是一套发送程序必须遵循的规则集合。该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2   网络边缘"></a>1.2   网络边缘</h2><p><strong>接入网</strong>，是指将端系统物理连接到其边缘路由器（edge router）的网络。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。不同的接入方式如下：    </p><ol><li><p>DSL</p></li><li><p>电缆</p></li><li><p>拨号</p></li><li><p>卫星</p></li><li><p>FTTH</p></li><li><p>以太网</p></li><li><p>WiFi</p></li><li><p>蜂窝</p></li></ol><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3   网络核心"></a>1.3   网络核心</h2><p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>和<strong>分组交换</strong>。</p><h3 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1   分组交换"></a>1.3.1   分组交换</h3><p>端系统彼此交换<strong>报文</strong>（message）。报文可以执行一种控制功能，或者包含数据。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为<strong>分组</strong>（packet）。在源和目的地之间，每个分组都通过通信链路和分组交换机（packet switch）传送。</p><h4 id="1-3-1-1-存储转发传输"><a href="#1-3-1-1-存储转发传输" class="headerlink" title="1.3.1.1   存储转发传输"></a>1.3.1.1   存储转发传输</h4><p>多数分组交换机在链路的输入端使用存储转发传输（store-and-forward transmission）机制，是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/07/UAIxaBy4rboWwN3.png"                      alt="image-20210507152330699"                ></p><h4 id="1-3-1-2-排队时延和分组丢失"><a href="#1-3-1-2-排队时延和分组丢失" class="headerlink" title="1.3.1.2   排队时延和分组丢失"></a>1.3.1.2   排队时延和分组丢失</h4><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>，也称为输出队列，如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的排队时延。这些时延变化的程度取决于网络的拥塞程度。</p><p>因为缓存空间的大小是有限的，当一个到达的分组发现该缓存已被其他等待传输的分组完全充满了，将出现分组丢失（<strong>丢包</strong>），到达的分组或已经排队的分组之一将被丢弃。    </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/07/5f1gaZ94nuvE8oU.png"                      alt="image-20210507153107447"                ></p><h4 id="1-2-1-3-转发表和路由选择协议"><a href="#1-2-1-3-转发表和路由选择协议" class="headerlink" title="1.2.1.3   转发表和路由选择协议"></a>1.2.1.3   转发表和路由选择协议</h4><p>在因特网中，每个端系统都具有一个IP地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。</p><p>每台路由器具有一个由<strong>路由选择协议</strong>自动地设置的转发表，用于将目的地址或目的地址的一部分映射成为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。路由器则将分组导向该出链路。</p><h3 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2   电路交换"></a>1.3.2   电路交换</h3><p>在电路交换网络中，端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。</p><p>在发送方能够发送信息之前，电路交换网络必须在发送方和接收方之间建立一条连接，该连接被称为一条<strong>电路</strong>，同时在连接期间在该网络链路上预留了恒定的传输速率。</p><p>与此相反，一台主机要经过分组交换网络向另一台主机发送分组，该分组被发送进网络，而不预留任何链路资源之类的东西。如果因为此时其他分组也需要经该链路进行传输而使链路之一出现拥塞，则该分组将不得不在传输链路发送侧的缓存中等待而产生时延。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/07/VJATDQ527tz4YmW.png"                      alt="image-20210507155332872"                ></p><h4 id="1-3-2-1-电路交换网络中的复用"><a href="#1-3-2-1-电路交换网络中的复用" class="headerlink" title="1.3.2.1   电路交换网络中的复用"></a>1.3.2.1   电路交换网络中的复用</h4><p>链路中的电路是通过频分复用（FDM）或时分复用（TDM）来实现的。</p><p>对于FDM链路，链路的频谱由跨越链路创建的所有连接共享。在连接期间链路为每条连接专用一个频段。比如在电话网络中，这个频段的宽度通常为4kHz。调频无线电台也使用FDM来共享88MHz~108MHz的频谱，其中每个电台被分配一个特定的频段。</p><p>对于TDM链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/07/pAEQVjugsSnGJex.png"                      alt="image-20210507160841531"                ></p><h4 id="1-3-2-2-分组交换与电路交换的对比"><a href="#1-3-2-2-分组交换与电路交换的对比" class="headerlink" title="1.3.2.2   分组交换与电路交换的对比"></a>1.3.2.2   分组交换与电路交换的对比</h4><p>电路交换不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用。另一方面，分组交换按需分配链路使用。链路传输能力将在所有需要在链路上传输分组的用户之间逐分组地被共享。<br>如今趋势无疑是朝着分组交换方向发展。</p><h3 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3   网络的网络"></a>1.3.3   网络的网络</h3><p>接入ISP自身必须互联。有不同的网络结构实现：</p><ul><li><p>网络结构1</p><p>每个接入ISP直接与每个其他接入ISP连接。当然，这样的网状设计对于接入ISP费用太高，因为这将要求每个接入ISP要与世界上数十万个其他接入ISP有一条单独的通信链路。</p></li><li><p>网络结构2</p><p>一种两层的等级结构，不同的全球传输提供商位于顶层，而接入ISP位于底层，但必须保证全球传输ISP之间必须是互联的。</p></li><li><p>网络结构3</p><p>不仅有多个竞争的第一层ISP，而且在一个区域可能有多个竞争的区域ISP，因此在这个等级结构的每一层，都有客户-提供商关系。</p></li><li><p>网络结构4</p><p>由接入ISP、区域ISP、第一层ISP，PoP，多宿、对等和IXP组成。</p><p>一个PoP只是提供商网络中的一台或多台路由器（在相同位置）群组，其中客户ISP能够与提供商ISP连接。PoP存在于等级结构的所有层次，但底层（接入ISP）等级除外。对于要与提供商PoP连接的客户网络，它能从第三方电信提供商租用高速链路将它的路由器之一直接连接到位于该PoP的一台路由器。任何ISP（除了第一层ISP）可以选择多宿，即可以与多个提供商ISP连接。</p><p>位于相同等级结构层次的邻近一对ISP能够对等（peer），也就是能够直接将它们的网络连到一起，使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输。当两个ISP对等时，通常不进行结算，即任一个ISP不向其对等付费。沿着这些相同路线，第三方公司能创建一个因特网交换点（IXP），IXP是一个汇合点，多个ISP能够在这里一起对等。</p></li><li><p>网络结构5</p><p>在网络结构4顶部增加内容提供商网络构建而成。通过创建自己的网络，内容提供商不仅减少了向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。比如谷歌专用网络可以通过与较低层ISP对等，或者在IXP处与它们连接。</p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/07/37lahxgMJqUr8dR.png"                      alt="image-20210507162728777"                ></p><h2 id="1-4-分组交换网中的时延、丢包和吞吐量"><a href="#1-4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="1.4   分组交换网中的时延、丢包和吞吐量"></a>1.4   分组交换网中的时延、丢包和吞吐量</h2><h3 id="1-4-1-分组交换网中的时延概述"><a href="#1-4-1-分组交换网中的时延概述" class="headerlink" title="1.4.1   分组交换网中的时延概述"></a>1.4.1   分组交换网中的时延概述</h3><p>时延最为重要的是<strong>节点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>和<strong>传播时延</strong>，这些时延总体累加起来是节点总时延。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/08/fDruvzeBnZFTjKa.png"                      alt="image-20210508100453905"                ></p><ol><li><p>节点处理时延<br>包括了检查分组首部、决定将该分组导向何处，检查比特级别的差错间。处理之后，路由器将该分组引向通往路由器B链路之前的队列。</p></li><li><p>排队时延<br>取决于先期到达的正在排队等待向链路传输的分组数量。</p></li><li><p>传输时延<br>路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。</p></li><li><p>传播时延<br>等于两台路由器之间的距离除以传播速率。</p></li></ol><h3 id="1-4-2-丢包"><a href="#1-4-2-丢包" class="headerlink" title="1.4.2   丢包"></a>1.4.2   丢包</h3><p>一条链路前的队列只有有限的容量，当到达的分组将发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，即该分组将会丢失。<br>分组丢失的比例随着流量强度增加而增加。因此，一个节点的性能常常不仅根据时延来度量，而且根据丢包的概率来度量。丢失的分组可能基于端到端的原则重传，以确保所有的数据最终从源传送到了目的地。</p><h3 id="1-4-3-计算机网络中的吞吐量"><a href="#1-4-3-计算机网络中的吞吐量" class="headerlink" title="1.4.3   计算机网络中的吞吐量"></a>1.4.3   计算机网络中的吞吐量</h3><p>为了定义吞吐量，考虑从主机A到主机B跨越计算机网络传送一个大文件。在任何时间瞬间的<strong>瞬时吞吐量</strong>是主机B接收到该文件的速率（以bps计）。如果该文件由F比特组成，主机B接收到所有F比特用去T秒，则文件传送的<strong>平均吞吐量</strong>是F/T bps。对于某些应用程序，希望具有低时延和在某个阈值之上的一致的瞬时吞吐量。而对于其他应用程序，时延不是决定性的，但是希望具有尽可能高的吞吐量。</p><p>当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率。但如果许多其他的数据流也通过这条链路流动，一条具有高传输路仍然可能成为文件传输的瓶颈链路。</p><h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5   协议层次及其服务模型"></a>1.5   协议层次及其服务模型</h2><h3 id="1-5-1-分层的体系结构"><a href="#1-5-1-分层的体系结构" class="headerlink" title="1.5.1   分层的体系结构"></a>1.5.1   分层的体系结构</h3><p>利用分层的体系结构，使某层所提供的服务实现易于改变。只要该层对其上面的层提供相同的服务，并且使用来自下面层次的相同服务，当某层的实现变化时，该系统的其余部分保持不变。</p><p>分层的一个潜在缺点是一层可能冗余较低层的功能。例如，许多协议栈在基于每段链路和基于端到端两种情况下，都提供了差错恢复。第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息（如时间戳值），这违反了层次分离的目标。</p><p>各层的所有协议被称为<strong>协议栈</strong>。因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/08/dHOXRLnIkPEg8fJ.png"                      alt="image-20210508110737337"                ></p><ol><li><p>应用层<br>应用层是网络应用程序及它们的应用层协议存留的地方。包括HTTP（提供Web文档的请求和传送）、SMTP（提供电子邮件报文的传输）和FTP（提供两个端系统之间的文件传送）。域名解析也是借助于应用层协议即域名系统（DNS）完成的。应用层协议分布在多个端系统上，两个端系统中的应用程序使用协议相互交换信息分组，位于应用层的信息分组称为报文。</p></li><li><p>运输层<br>运输层在应用程序端点之间传送应用层报文。有两种运输协议，即TCP和UDP，其中的任一个都能运输应用层报文。TCP向它的应用程序提供了面向连接的服务，包括应用层报文向目的地的确保传递和流量控制，TCP也将长报文划分为短报文，并提供拥塞控制机制。UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制，运输层的分组称为报文段。</p></li><li><p>网络层<br>网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。在一台源主机中的运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址。<br>网络层包括网际协议IP，该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段，IP仅有一个，所有具有网络层的因特网组件必须运行IP。网络层也包括决定路由的路由选择协议，它根据该路由将数据报从源传输到目的地。</p></li><li><p>链路层<br>网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个节点移动到路径上的下一个节点，网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点，链路层将数据报上传给网络层。由链路层提供的服务取决于应用于该链路的特定链路层协议。链路层分组称为帧。</p></li><li><p>物理层<br>物理层将帧中的一个个比特从一个节点移动到下一个节点。在这层中的协议与该链路的实际传输媒体相关</p></li></ol><p>OSI参考模型的7层是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。OSI参考模型中附加的两个层，即表示层和会话层。<br>表示层的作用是使通信的应用程序能够解释交换数据的含义，包括数据压缩和数据加密以及数据描述。会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p><h3 id="1-5-2封装"><a href="#1-5-2封装" class="headerlink" title="1.5.2封装"></a>1.5.2封装</h3><p>在发送主机端，一个应用层报文被传送给运输层，运输层收取到报文并附上附加信息，比如允许接收端运输层向上向适当的应用程序交付报文的信息、差错检测位信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段，运输层报文段因此封装了应用层报文。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，链路层增加链路层首部信息并生成链路层帧。所以在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段。有效载荷通常是来自上一层的分组。</p><p>封装的过程能够比前面描述的更为复杂。例如，一个大报文可能被划分为多个运输层的报文段（这些报文段每个可能被划分为多个网络层数据报）。在接收端，则必须从其连续的数据报中重构这样一个报文段。</p><p>分组交换机是指一台通用分组交换设备，某些分组交换机称为链路层交换机，基于链路层帧中的字段值做出转发决定，因此被称为链路层（第2层）设备。其他分组交换机称为路由器，基于网络层数据报中的首部字段值做出转发决定，因此是网络层（第3层）设备。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/05/09/mzjIy1qAh6pNbZ2.png"                      alt="image-20210509201001252"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1-什么是因特网&quot;&gt;&lt;a href=&quot;#1-1-什么是因特网&quot; class=&quot;headerlink&quot; title=&quot;1.1   什么是因特网&quot;&gt;&lt;/a&gt;1.1   什么是因特网&lt;/h2&gt;&lt;p&gt;互联网中所有设备都称为&lt;strong&gt;主机&lt;/strong&gt;（hos</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络：自顶向下方法" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="Computer Network" scheme="http://example.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>11-期约与异步函数</title>
    <link href="http://example.com/2021/04/22/note/JavaScript/11-%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/22/note/JavaScript/11-%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-22T13:41:19.629Z</published>
    <updated>2021-05-11T09:21:29.327Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 6新增了正式的<code>Promise</code>（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用<code>async</code>和<code>await</code>关键字定义异步函数的机制。</p><blockquote><p><strong>注意</strong>本章示例将大量使用异步日志输出的方式<code>setTimeout(console.log, 0, .. params)</code>，旨在演示执行顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约等返回的值达到其最终状态。<br>此外，浏览器控制台的输出经常能打印出JavaScript运行中无法获取的对象信息（比如期约的状态）。</p></blockquote><h2 id="11-1-异步编程"><a href="#11-1-异步编程" class="headerlink" title="11.1　异步编程"></a>11.1　异步编程</h2><p><strong>异步行为</strong>是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。</p><p>重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。</p><h3 id="11-1-1-同步与异步"><a href="#11-1-1-同步与异步" class="headerlink" title="11.1.1　同步与异步"></a>11.1.1　同步与异步</h3><p><strong>同步行为</strong>对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。这是因为后面的指令总是在前面的指令完成后才会执行。</p><p>相对地，<strong>异步行为</strong>类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待，但无法预知何时完成。</p><h3 id="11-1-2-以往的异步编程模式"><a href="#11-1-2-以往的异步编程模式" class="headerlink" title="11.1.2　以往的异步编程模式"></a>11.1.2　以往的异步编程模式</h3><p>在早期的JavaScript中，只支持定义回调函数来表明异步操作完成。假设有以下异步函数，使用了<code>setTimeout</code>在一秒钟之后执行某些操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>);<span class="comment">// 6（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure><p><code>setTimeout</code>可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000毫秒之后，JavaScript运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对JavaScript代码就完全不可见了。还有一点，<code>double()</code>函数在<code>setTimeout</code>成功调度异步操作之后会立即退出。</p><h4 id="11-1-2-1-异步返回值"><a href="#11-1-2-1-异步返回值" class="headerlink" title="11.1.2.1   异步返回值"></a><strong>11.1.2.1   异步返回值</strong></h4><p>如果<code>setTimeout</code>操作会返回一个有用的值后续要用，策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> callback(value * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>, <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`I was given: <span class="subst">$&#123;x&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// I was given: 6（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure><p>位于函数闭包中的回调及其参数在异步执行时仍然是可用的。</p><h4 id="11-1-2-2-失败处理"><a href="#11-1-2-2-失败处理" class="headerlink" title="11.1.2.2   失败处理"></a><strong>11.1.2.2   失败处理</strong></h4><p>异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      success(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line">double(<span class="string">&#x27;b&#x27;</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 6（大约1000毫秒之后）</span></span><br><span class="line"><span class="comment">// Failure: Must provide number as first argument（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure><p>这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。</p><h4 id="11-1-2-3-嵌套异步回调"><a href="#11-1-2-3-嵌套异步回调" class="headerlink" title="11.1.2.3   嵌套异步回调"></a><strong>11.1.2.3   嵌套异步回调</strong></h4><p>如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。这就要嵌套回调（俗称“回调地狱”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Must provide number as first argument&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      success(<span class="number">2</span> * value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      failure(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> successCallback = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  double(x, <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Success: <span class="subst">$&#123;y&#125;</span>`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> failureCallback = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Failure: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">double(<span class="number">3</span>, successCallback, failureCallback);</span><br><span class="line"><span class="comment">// Success: 12（大约1000毫秒之后）</span></span><br></pre></td></tr></table></figure><h2 id="11-2-期约"><a href="#11-2-期约" class="headerlink" title="11.2　期约"></a>11.2　期约</h2><p>期约是对尚不存在结果的一个替身，描述的是一种异步程序执行的机制。</p><h3 id="11-2-1-Promises-A-规范"><a href="#11-2-1-Promises-A-规范" class="headerlink" title="11.2.1　Promises/A+规范"></a>11.2.1　Promises/A+规范</h3><p>ECMAScript 6增加了对Promises/A+规范的完善支持，即<code>Promise</code>类型，成为了主导性的异步编程机制。所有现代浏览器都支持ES6期约，很多其他浏览器API（如<code>fetch()</code>和Battery Status API）也以期约为基础。</p><h3 id="11-2-2-期约基础"><a href="#11-2-2-期约基础" class="headerlink" title="11.2.2　期约基础"></a>11.2.2　期约基础</h3><p>ECMAScript 6新增的引用类型<code>Promise</code>，可以通过<code>new</code>操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器，因为如果不提供执行器函数，就会抛出<code>SyntaxError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);  <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure><h4 id="11-2-2-1-期约状态机"><a href="#11-2-2-1-期约状态机" class="headerlink" title="11.2.2.1   期约状态机"></a><strong>11.2.2.1   期约状态机</strong></h4><p>把一个期约实例传给<code>console.log()</code>时，控制台输出表明该实例处于<strong>待定</strong>（pending）状态。期约是一个有状态的对象，可能处于如下3种状态之一：</p><pre><code>1. 待定（pending）,表示尚未开始或者正在执行中，最初始状态。2. 兑现（fulfilled，有时候也称为“解决”，resolved）,表示已经成功完成。3. 拒绝（rejected），表示没有成功完成。</code></pre><p>在待定状态下，期约可以<strong>落定</strong>（settled）为代表成功的<strong>兑现</strong>（fulfilled）状态，或者代表失败的<strong>拒绝</strong>（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。</p><p>期约的状态是私有的，不能直接通过JavaScript检测到，这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。</p><h4 id="11-2-2-2-解决值、拒绝理由及期约用例"><a href="#11-2-2-2-解决值、拒绝理由及期约用例" class="headerlink" title="11.2.2.2   解决值、拒绝理由及期约用例"></a><strong>11.2.2.2   解决值、拒绝理由及期约用例</strong></h4><p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。某些情况下，知道一段异步代码已经完成，对于其他代码而言已经足够了。</p><p>其次每个期约只要状态切换为兑现，就会有一个私有的内部<strong>值</strong>（value）。状态切换为拒绝，就会有一个私有的内部<strong>理由</strong>（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，默认值为<code>undefined</code>。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p><h4 id="11-2-2-3-通过执行函数控制期约状态"><a href="#11-2-2-3-通过执行函数控制期约状态" class="headerlink" title="11.2.2.3   通过执行函数控制期约状态"></a><strong>11.2.2.3   通过执行函数控制期约状态</strong></h4><p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。这是通过调用它的两个函数参数<code>resolve()</code>和<code>reject()</code>实现的。调用<code>resolve()</code>会把状态切换为兑现，调用<code>reject()</code>会把状态切换为拒绝，并且也会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught error (in promise)</span></span><br></pre></td></tr></table></figure><p>执行器函数是<strong>同步</strong>执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"><span class="comment">// executor</span></span><br><span class="line"><span class="comment">// promise initialized</span></span><br></pre></td></tr></table></figure><p>添加<code>setTimeout</code>可以推迟切换状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line"><span class="comment">// 在console.log打印期约实例的时候，还不会执行超时回调（即resolve()）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);  <span class="comment">// Promise &lt;pending&gt;</span></span><br></pre></td></tr></table></figure><p>无论<code>resolve()</code>和<code>reject()</code>中的哪个被调用，状态转换都不可撤销了。继续修改状态会静默失败，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  reject(); <span class="comment">// 没有效果</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure><p>为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过<code>setTimeout</code>设置一个10秒钟后无论如何都会拒绝期约的回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">10000</span>);  <span class="comment">// 10秒后调用reject()</span></span><br><span class="line">  <span class="comment">// 执行函数的逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);      <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">11000</span>, p);  <span class="comment">// 11秒后再检查状态</span></span><br><span class="line"><span class="comment">// (After 10 seconds) Uncaught error</span></span><br><span class="line"><span class="comment">// (After 11 seconds) Promise &lt;rejected&gt;</span></span><br></pre></td></tr></table></figure><p>因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。</p><h4 id="11-2-2-4Promise-resolve"><a href="#11-2-2-4Promise-resolve" class="headerlink" title="11.2.2.4Promise.resolve()"></a><strong>11.2.2.4</strong><code>Promise.resolve()</code></h4><p>期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用<code>Promise.resolve()</code>静态方法，可以实例化一个解决的期约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的两个期约实例实际上是一样的</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve();</span><br></pre></td></tr></table></figure><p>这个解决的期约的值对应着传给<code>Promise.resolve()</code>的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 多余的参数会忽略</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: 4</span></span><br></pre></td></tr></table></figure><p>对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，<code>Promise.resolve()</code>可以说是一个幂等方法，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p === <span class="built_in">Promise</span>.resolve(p));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p === <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)));  <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>这个幂等性会保留传入期约的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p);                  <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p === <span class="built_in">Promise</span>.resolve(p)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: Error: foo</span></span><br></pre></td></tr></table></figure><h4 id="11-2-2-5Promise-reject"><a href="#11-2-2-5Promise-reject" class="headerlink" title="11.2.2.5Promise.reject()"></a><strong>11.2.2.5</strong><code>Promise.reject()</code></h4><p><code>Promise.reject()</code>会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过<code>try</code>/<code>catch</code>捕获，只能通过拒绝处理程序捕获）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的两个期约实例实际上是一样的</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br></pre></td></tr></table></figure><p>这个拒绝的期约的理由就是传给<code>Promise.reject()</code>的第一个参数。这个参数也会传给后续的拒绝处理程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;rejected&gt;: 3</span></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, e)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>Promise.reject()</code>并没有照搬<code>Promise.resolve()</code>的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="built_in">Promise</span>.reject(<span class="built_in">Promise</span>.resolve()));</span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;</span></span><br></pre></td></tr></table></figure><h4 id="11-2-2-6-同步-异步执行的二元性"><a href="#11-2-2-6-同步-异步执行的二元性" class="headerlink" title="11.2.2.6   同步/异步执行的二元性"></a><strong>11.2.2.6   同步/异步执行的二元性</strong></h4><p><code>Promise</code>的设计很大程度上会导致一种完全不同于JavaScript的计算模式。下面的例子展示了这一点，其中包含了两种模式下抛出错误的情形：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Error: foo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure><p>第一个<code>try</code>/<code>catch</code>抛出并捕获了错误，第二个<code>try</code>/<code>catch</code>抛出错误却<strong>没有</strong>捕获到。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过<strong>异步模式</strong>捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是<strong>异步</strong>执行模式的媒介。<br>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，<code>try</code>/<code>catch</code>块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构，也就是期约的方法。</p><h3 id="11-2-3-期约的实例方法"><a href="#11-2-3-期约的实例方法" class="headerlink" title="11.2.3　期约的实例方法"></a>11.2.3　期约的实例方法</h3><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p><h4 id="11-2-3-1-实现Thenable接口"><a href="#11-2-3-1-实现Thenable接口" class="headerlink" title="11.2.3.1   实现Thenable接口"></a><strong>11.2.3.1   实现</strong><code>Thenable</code>接口</h4><p>在ECMAScript暴露的异步结构中，任何对象都有一个<code>then()</code>方法。这个方法被认为实现了<code>Thenable</code>接口。下面的例子展示了实现这一接口的最简单的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThenable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript的<code>Promise</code>类型实现了<code>Thenable</code>接口。这个简化的接口跟TypeScript或其他包中的接口或类型定义不同，它们都设定了<code>Thenable</code>接口更具体的形式。</p><h4 id="11-2-3-2Promise-prototype-then"><a href="#11-2-3-2Promise-prototype-then" class="headerlink" title="11.2.3.2Promise.prototype.then()"></a><strong>11.2.3.2</strong><code>Promise.prototype.then()</code></h4><p><code>Promise.prototype.then()</code>是为期约实例添加处理程序的主要方法。这个<code>then()</code>方法接收最多两个参数：<code>onResolved</code>处理程序和<code>onRejected</code>处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p1&#x27;</span>), <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p1&#x27;</span>));</span><br><span class="line">p2.then(<span class="function">() =&gt;</span> onResolved(<span class="string">&#x27;p2&#x27;</span>), <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">//（3秒后）</span></span><br><span class="line"><span class="comment">// p1 resolved</span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure><p>因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。传给<code>then()</code>的任何非函数类型的参数都会被静默忽略。如果想只提供<code>onRejected</code>参数，那就要在<code>onResolved</code>参数的位置上传入<code>undefined</code>。这样有助于避免在内存中创建多余的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, id, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line"><span class="comment">// 非函数处理程序会被静默忽略，不推荐</span></span><br><span class="line">p1.then(<span class="string">&#x27;gobbeltygook&#x27;</span>);</span><br><span class="line"><span class="comment">// 不传onResolved处理程序的规范写法</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> onRejected(<span class="string">&#x27;p2&#x27;</span>));</span><br><span class="line"><span class="comment">// p2 rejected（3秒后）</span></span><br></pre></td></tr></table></figure><p><code>Promise.prototype.then()</code>方法返回一个新的期约实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then();  <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个新期约实例基于<code>onResovled</code>处理程序的返回值构建，也就是通过<code>Promise.resolve()</code>包装生成的新期约。如果没有提供这个处理程序，则<code>Promise.resolve()</code>就会包装上一个期约解决之后的值。如果没有显式的返回语句，则<code>Promise.resolve()</code>会包装默认的返回值<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 若调用then()时不传处理程序，则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); <span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function">() =&gt;</span> <span class="literal">undefined</span>); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="function">() =&gt;</span> &#123;&#125;);  <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br></pre></td></tr></table></figure><p>如果有显式的返回值，则<code>Promise.resolve()</code>会包装这个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="built_in">console</span>.log(p6 === p7); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject()); <span class="comment">//Promise &lt;rejected&gt;: undefine</span></span><br></pre></td></tr></table></figure><p>抛出异常会返回拒绝的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt; baz</span></span><br></pre></td></tr></table></figure><p>注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure><p><code>onRejected</code>处理程序返回的值也会被<code>Promise.resolve()</code>包装，因为<code>onRejected</code>处理程序的任务就是捕获异步错误，如果被<code>Promise.reject()</code>包装则会抛出异常。<br>下面的代码片段展示了用<code>Promise.reject()</code>替代之前例子中的<code>Promise.resolve()</code>之后的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用then()时不传处理程序则原样向后传</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(); <span class="comment">// Uncaught (in promise) foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2);  <span class="comment">// Promise &lt;rejected&gt;: foo</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="literal">undefined</span>);<span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Promise &lt;resolved&gt;: undefined</span></span><br><span class="line">　</span><br><span class="line"><span class="keyword">let</span> p6 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="keyword">let</span> p7 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>)); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p8 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));<span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());  </span><br><span class="line"><span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line">); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br><span class="line"><span class="keyword">let</span> p10 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;); </span><br><span class="line"><span class="keyword">let</span> p11 = p1.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// Promise &lt;resolved&gt;: Error: qux</span></span><br></pre></td></tr></table></figure><h4 id="11-2-3-3Promise-prototype-catch"><a href="#11-2-3-3Promise-prototype-catch" class="headerlink" title="11.2.3.3Promise.prototype.catch()"></a><strong>11.2.3.3</strong><code>Promise.prototype.catch()</code></h4><p><code>Promise.prototype.catch()</code>方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：<code>onRejected</code>处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用<code>Promise.prototype.then(null, onRejected)</code>。</p><p>下面的代码展示了这两种同样的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的方式是一样的：</span></span><br><span class="line">p.then(<span class="literal">null</span>, onRejected);  <span class="comment">// rejected</span></span><br><span class="line">p.catch(onRejected);       <span class="comment">// rejected</span></span><br></pre></td></tr></table></figure><p>在返回新期约实例方面，<code>Promise.prototype.catch()</code>的行为与<code>Promise.prototype.then()</code>的<code>onRejected</code>处理程序是一样的。</p><h4 id="11-2-3-4Promise-prototype-finally"><a href="#11-2-3-4Promise-prototype-finally" class="headerlink" title="11.2.3.4Promise.prototype.finally()"></a><strong>11.2.3.4</strong><code>Promise.prototype.finally()</code></h4><p><code>Promise.prototype.finally()</code>方法用于给期约添加<code>onFinally</code>处理程序，这个处理程序在期约转换为解决<strong>或</strong>拒绝状态时都会执行。这个方法可以避免<code>onResolved</code>和<code>onRejected</code>处理程序中出现冗余代码。但<code>onFinally</code>处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;Finally!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">p1.finally(onFinally); <span class="comment">// Finally</span></span><br><span class="line">p2.finally(onFinally); <span class="comment">// Finally</span></span><br></pre></td></tr></table></figure><p><code>Promise.prototype.finally()</code>方法返回一个新的期约实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();   <span class="comment">// Promise &lt;pending&gt;    </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1 === p2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但这个新期约实例不同于<code>then()</code>或<code>catch()</code>方式返回的实例。因为<code>onFinally</code>被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。对于已解决状态和被拒绝状态都是如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 这里都会原样后传，都是Promise &lt;resolved&gt;: foo</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally();</span><br><span class="line"><span class="keyword">let</span> p3 = p1.finally(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = p1.finally(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p5 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve());</span><br><span class="line"><span class="keyword">let</span> p6 = p1.finally(<span class="function">() =&gt;</span> <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p7 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> p8 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Error</span>(<span class="string">&#x27;qux&#x27;</span>));</span><br></pre></td></tr></table></figure><p>如果返回的是一个待定的期约，或者<code>onFinally</code>处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">let</span> p9 = p1.finally(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;));</span><br><span class="line"><span class="keyword">let</span> p10 = p1.finally(<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.reject());<span class="comment">// Uncaught (in promise): undefined</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p9);  <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p10); <span class="comment">// Promise &lt;rejected&gt;: undefined</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) baz</span></span><br><span class="line"><span class="comment">// Promise &lt;rejected&gt;: baz</span></span><br><span class="line"><span class="keyword">let</span> p11 = p1.finally(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;baz&#x27;</span>; &#125;);</span><br></pre></td></tr></table></figure><p>返回待定期约的情形并不常见，因为只要期约一解决，新期约仍然会原样后传初始的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// 忽略解决的值</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.finally(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&#x27;bar&#x27;</span>), <span class="number">100</span>)));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2), <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 200毫秒后：</span></span><br><span class="line"><span class="comment">// Promise &lt;resolved&gt;: foo</span></span><br></pre></td></tr></table></figure><h4 id="11-2-3-5-非重入期约方法"><a href="#11-2-3-5-非重入期约方法" class="headerlink" title="11.2.3.5   非重入期约方法"></a><strong>11.2.3.5   非重入期约方法</strong></h4><p>当期约进入落定状态时，与该状态相关的处理程序仅仅会被<strong>排期</strong>，推进消息队列，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态，执行顺序也是这样的。这个特性由JavaScript运行时保证，被称为“非重入”（non-reentrancy）特性。下面的例子演示了这个特性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建解决的期约</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="comment">// 添加解决处理程序</span></span><br><span class="line"><span class="comment">// 直觉上，这个处理程序会等期约一解决就执行</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;onResolved handler&#x27;</span>));</span><br><span class="line"><span class="comment">// 同步输出，证明then()已经返回</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;then() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// then() returns</span></span><br><span class="line"><span class="comment">// onResolved handler</span></span><br></pre></td></tr></table></figure><p>先添加处理程序后解决期约也是一样的。如果添加处理程序后，同步代码才改变期约状态，那么处理程序仍然会基于该状态变化表现出非重入特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"><span class="comment">// 创建一个期约并将解决函数保存在一个局部变量中</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  synchronousResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1: invoking resolve()&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2: resolve() returns&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;4: then() handler executes&#x27;</span>));</span><br><span class="line">synchronousResolve();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3: synchronousResolve() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// 实际的输出：</span></span><br><span class="line"><span class="comment">// 1: invoking resolve()</span></span><br><span class="line"><span class="comment">// 2: resolve() returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure><p>非重入适用于<code>onResolved</code>/<code>onRejected</code>处理程序、<code>catch()</code>处理程序和<code>finally()</code>处理程序。下面的例子演示了这些处理程序都只能异步执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p1.then() onResolved&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p1.then() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p2.then() onRejected&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p2.then() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p3.catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p3.catch() onRejected&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p3.catch() returns&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p4.finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;p4.finally() onFinally&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;p4.finally() returns&#x27;</span>);</span><br><span class="line"><span class="comment">// p1.then() returns</span></span><br><span class="line"><span class="comment">// p2.then() returns</span></span><br><span class="line"><span class="comment">// p3.catch() returns</span></span><br><span class="line"><span class="comment">// p4.finally() returns</span></span><br><span class="line"><span class="comment">// p1.then() onResolved</span></span><br><span class="line"><span class="comment">// p2.then() onRejected</span></span><br><span class="line"><span class="comment">// p3.catch() onRejected</span></span><br><span class="line"><span class="comment">// p4.finally() onFinally</span></span><br></pre></td></tr></table></figure><h4 id="11-2-3-6-邻近处理程序的执行顺序"><a href="#11-2-3-6-邻近处理程序的执行顺序" class="headerlink" title="11.2.3.6   邻近处理程序的执行顺序"></a><strong>11.2.3.6   邻近处理程序的执行顺序</strong></h4><p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是<code>then()</code>、<code>catch()</code>还是<code>finally()</code>添加的处理程序都是如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject();</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">2</span>));  <span class="comment">// 2</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">3</span>));  <span class="comment">// 3</span></span><br><span class="line">p2.then(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">4</span>));  <span class="comment">// 4</span></span><br><span class="line">p2.catch(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">5</span>));  <span class="comment">// 5</span></span><br><span class="line">p2.catch(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">6</span>));  <span class="comment">// 6</span></span><br><span class="line">p1.finally(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">7</span>));  <span class="comment">// 7</span></span><br><span class="line">p1.finally(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">8</span>));  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="11-2-3-7-传递解决值和拒绝理由"><a href="#11-2-3-7-传递解决值和拒绝理由" class="headerlink" title="11.2.3.7   传递解决值和拒绝理由"></a><strong>11.2.3.7   传递解决值和拒绝理由</strong></h4><p>到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。</p><p>在执行函数中，解决的值和拒绝的理由是分别作为<code>resolve()</code>和<code>reject()</code>的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为<code>onResolved</code>或<code>onRejected</code>处理程序的唯一参数。下面的例子展示了上述传递过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value));    <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason));  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h4 id="11-2-3-8-拒绝期约与拒绝错误处理"><a href="#11-2-3-8-拒绝期约与拒绝错误处理" class="headerlink" title="11.2.3.8   拒绝期约与拒绝错误处理"></a><strong>11.2.3.8   拒绝期约与拒绝错误处理</strong></h4><p>拒绝期约类似于<code>throw()</code>表达式，因为它们都代表一种程序状态，即需要中断或者特殊处理。在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由。因此以下这些期约都会以一个错误对象为由被拒绝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>); &#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p4);  <span class="comment">// Promise &lt;rejected&gt;: Error: foo</span></span><br><span class="line">　</span><br><span class="line"><span class="comment">// 也会抛出4个未捕获错误</span></span><br></pre></td></tr></table></figure><p>期约可以以任何理由拒绝，包括<code>undefined</code>，但最好统一使用错误对象。这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的4个错误的栈追踪信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at Promise (test.html:5)</span><br><span class="line">    at new Promise (<span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span><br><span class="line">    at test.html:5</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at Promise (test.html:6)</span><br><span class="line">    at new Promise (<span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span><br><span class="line">    at test.html:6</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at test.html:8</span><br><span class="line">Uncaught (in promise) Error: foo</span><br><span class="line">    at Promise.resolve.then (test.html:7)</span><br></pre></td></tr></table></figure><p>所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径。注意错误的顺序：<code>Promise.resolve().then()</code>的错误最后才出现，这是因为它需要在运行时消息队列中<strong>添加</strong>处理程序；也就是说，在最终抛出未捕获错误之前它还会创建另一个期约。<br>这个例子同样揭示了异步错误有意思的副作用。正常情况下，在通过<code>throw()</code>关键字抛出错误时，JavaScript运行时的错误处理机制会停止执行抛出错误之后的任何指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>); <span class="comment">// 这一行不会执行</span></span><br><span class="line"><span class="comment">// Uncaught Error: foo</span></span><br></pre></td></tr></table></figure><p>但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: foo</span></span><br></pre></td></tr></table></figure><p>如本章前面的<code>Promise.reject()</code>示例所示，异步错误只能通过异步的<code>onRejected</code>处理程序捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这不包括捕获执行函数中的错误，在解决或拒绝期约之前，仍然可以使用<code>try</code>/<code>catch</code>在执行函数中捕获错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">  resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;resolved&gt;: bar</span></span><br></pre></td></tr></table></figure><p><code>then()</code>和<code>catch()</code>的<code>onRejected</code>处理程序在语义上相当于<code>try</code>/<code>catch</code>。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，<code>onRejected</code>处理程序的任务应该是在捕获异步错误之后返回一个<strong>解决</strong>的期约。下面的例子中对比了同步错误处理与异步错误处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;begin synchronous execution&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;continue synchronous execution&#x27;</span>);</span><br><span class="line"><span class="comment">// begin synchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: foo</span></span><br><span class="line"><span class="comment">// continue synchronous execution</span></span><br><span class="line">　</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;begin asynchronous execution&#x27;</span>);</span><br><span class="line">  reject(<span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>));</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;caught error&#x27;</span>, e);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;continue asynchronous execution&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// begin asynchronous execution</span></span><br><span class="line"><span class="comment">// caught error Error: bar</span></span><br><span class="line"><span class="comment">// continue asynchronous execution</span></span><br></pre></td></tr></table></figure><h3 id="11-2-4-期约连锁与期约合成"><a href="#11-2-4-期约连锁与期约合成" class="headerlink" title="11.2.4　期约连锁与期约合成"></a>11.2.4　期约连锁与期约合成</h3><p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。</p><h4 id="11-2-4-1-期约连锁"><a href="#11-2-4-1-期约连锁" class="headerlink" title="11.2.4.1   期约连锁"></a><strong>11.2.4.1   期约连锁</strong></h4><p>之所以可以这样把期约逐个地串联起来，是因为每个期约实例的方法（<code>then()</code>、<code>catch()</code>和<code>finally()</code>）都会返回一个<strong>新的</strong>期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;p1 executor&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p2 executor&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p3 executor&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;))</span><br><span class="line"><span class="comment">// p1 executor（1秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3秒后）</span></span><br></pre></td></tr></table></figure><p>把生成期约的代码提取到一个工厂函数中，就可以写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedResolve</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">delayedResolve(<span class="string">&#x27;p1 executor&#x27;</span>)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p2 executor&#x27;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> delayedResolve(<span class="string">&#x27;p3 executor&#x27;</span>))</span><br><span class="line"><span class="comment">// p1 executor（1秒后）</span></span><br><span class="line"><span class="comment">// p2 executor（2秒后）</span></span><br><span class="line"><span class="comment">// p3 executor（3秒后）</span></span><br></pre></td></tr></table></figure><p>因为<code>then()</code>、<code>catch()</code>和<code>finally()</code>都返回期约，所以串联这些方法也很直观。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;initial promise rejects&#x27;</span>);</span><br><span class="line">  reject();</span><br><span class="line">&#125;);</span><br><span class="line">p.catch(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;reject handler&#x27;</span>))</span><br><span class="line"> .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;resolve handler&#x27;</span>))</span><br><span class="line"> .finally(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;finally handler&#x27;</span>));</span><br><span class="line"><span class="comment">// initial promise rejects</span></span><br><span class="line"><span class="comment">// reject handler</span></span><br><span class="line"><span class="comment">// resolve handler</span></span><br><span class="line"><span class="comment">// finally handler</span></span><br></pre></td></tr></table></figure><h4 id="11-2-4-2-期约图"><a href="#11-2-4-2-期约图" class="headerlink" title="11.2.4.2**期约图**"></a><strong>11.2.4.2**</strong>期约图**</h4><p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建<strong>有向非循环图</strong>的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。</p><p>下面的例子展示了一种期约有向图，也就是二叉树：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//      A</span></span><br><span class="line"><span class="comment">//    /   \</span></span><br><span class="line"><span class="comment">//   B     C</span></span><br><span class="line"><span class="comment">//  / \   / \</span></span><br><span class="line"><span class="comment">// D   E F   G</span></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> B = A.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> C = A.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">B.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;D&#x27;</span>));</span><br><span class="line">B.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">C.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">C.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;G&#x27;</span>));</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// E</span></span><br><span class="line"><span class="comment">// F</span></span><br><span class="line"><span class="comment">// G</span></span><br></pre></td></tr></table></figure><p>期约的处理程序是按照它们添加的顺序执行的。由于期约的处理程序是<strong>先</strong>添加到消息队列，<strong>然后</strong>才逐个执行，因此日志的输出语句构成了对二叉树的层序遍历。</p><h4 id="11-2-4-3Promise-all-和Promise-race"><a href="#11-2-4-3Promise-all-和Promise-race" class="headerlink" title="11.2.4.3Promise.all()和Promise.race()"></a><strong>11.2.4.3</strong><code>Promise.all()</code>和<code>Promise.race()</code></h4><p>Promise类提供两个将多个期约实例组合成一个期约的静态方法：<code>Promise.all()</code>和<code>Promise.race()</code>。而合成后期约的行为取决于内部期约的行为。</p><ul><li><code>Promise.all()</code></li></ul><p><code>Promise.all()</code>静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.all([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于Promise.resolve()</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.all([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure><p>合成的期约只会在每个包含的期约都解决之后才解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;all() resolved!&#x27;</span>));</span><br><span class="line"><span class="comment">// all() resolved!（大约1秒后）</span></span><br></pre></td></tr></table></figure><p>如果至少有一个包含的期约待定，则合成的期约也会待定。如果有一个包含的期约拒绝，则合成的期约也会拒绝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 永远待定</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.all([<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;pending&gt;</span></span><br><span class="line"><span class="comment">// 一次拒绝会导致最终期约拒绝</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure><p>如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">4</span>)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function">(<span class="params">values</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, values)); <span class="comment">// [3, undefined, 4]</span></span><br></pre></td></tr></table></figure><p>如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入拒绝处理程序，第二个期约的拒绝也会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure><ul><li><code>Promise.race()</code></li></ul><p><code>Promise.race()</code>静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([<span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 空的可迭代对象等价于new Promise(() =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([]);</span><br><span class="line"><span class="comment">// 无效的语法</span></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race();</span><br><span class="line"><span class="comment">// TypeError: cannot read Symbol.iterator of undefined</span></span><br></pre></td></tr></table></figure><p><code>Promise.race()</code>不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，<code>Promise.race()</code>就会包装其解决值或拒绝理由并返回新期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时后的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p1); <span class="comment">// Promise &lt;resolved&gt;: 3</span></span><br><span class="line"><span class="comment">// 拒绝先发生，超时后的解决被忽略</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p2); <span class="comment">// Promise &lt;rejected&gt;: 4</span></span><br><span class="line"><span class="comment">// 迭代顺序决定了落定顺序</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">5</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">6</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">7</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, p3); <span class="comment">// Promise &lt;resolved&gt;: 5</span></span><br></pre></td></tr></table></figure><p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与<code>Promise.all()</code>类似，合成的期约<strong>会</strong>静默处理所有包含期约的拒绝操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入拒绝处理程序，第二个期约的拒绝也会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))</span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, reason)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure><h4 id="11-2-4-4-串行期约合成"><a href="#11-2-4-4-串行期约合成" class="headerlink" title="11.2.4.4   串行期约合成"></a><strong>11.2.4.4   串行期约合成</strong></h4><p>基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像<strong>函数合成</strong>，即将多个函数合成为一个函数，期约也可以像这样合成起来，渐进地消费一个值，并返回一个结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x)</span><br><span class="line">    .then(addTwo)</span><br><span class="line">    .then(addThree)</span><br><span class="line">    .then(addFive);</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>使用<code>Array.prototype.reduce()</code>可以写成更简洁的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [addTwo, addThree, addFive]</span><br><span class="line">      .reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> addTen = compose(addTwo, addThree, addFive);</span><br><span class="line">addTen(<span class="number">8</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h3 id="11-2-5-期约扩展"><a href="#11-2-5-期约扩展" class="headerlink" title="11.2.5　期约扩展"></a>11.2.5　期约扩展</h3><p>ES6不支持取消期约和进度通知，一个主要原因是这样会导致期约连锁和期约合成过度复杂化。比如在一个期约连锁中，如果某个被其他期约依赖的期约被取消了或者发出了通知，那么接下来应该发生什么完全说不清楚。</p><h4 id="11-2-5-1-期约取消"><a href="#11-2-5-1-期约取消" class="headerlink" title="11.2.5.1   期约取消"></a><strong>11.2.5.1   期约取消</strong></h4><p>ES6期约的逻辑开始执行，就没有办法阻止它执行到完成，但经常会遇到期约正在处理过程中，程序却不再需要其结果的情形。</p><p>这可以用到“取消令牌”（cancel token），在现有实现基础上提供一种临时性的封装，以实现取消期约的功能。生成的令牌实例提供了一个接口，利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;cancel&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params">cancelFn</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        cancelFn(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;delay cancelled&quot;</span>);</span></span><br><span class="line">          resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> startButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#start&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cancelButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#cancel&#x27;</span>);</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">cancellableDelayedResolve</span>(<span class="params">delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;set delay&quot;</span>);</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> id = <span class="built_in">setTimeout</span>((<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&quot;delayed resolve&quot;</span>);</span></span><br><span class="line">        resolve();</span><br><span class="line">      &#125;), delay);</span><br><span class="line">  </span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function">(<span class="params">cancelCallback</span>) =&gt;</span></span></span><br><span class="line"><span class="javascript">        cancelButton.addEventListener(<span class="string">&quot;click&quot;</span>, cancelCallback));</span></span><br><span class="line"><span class="javascript">    cancelToken.promise.then(<span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(id));</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript">startButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> cancellableDelayedResolve(<span class="number">1000</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每次单击“Start”按钮都会开始计时，并实例化一个新的<code>CancelToken</code>的实例。此时，“Cancel”按钮一旦被点击，就会触发令牌实例中的期约解决。而解决之后，单击“Start”按钮设置的超时也会被取消。</p><h4 id="11-2-5-2-期约进度通知"><a href="#11-2-5-2-期约进度通知" class="headerlink" title="11.2.5.2   期约进度通知"></a><strong>11.2.5.2   期约进度通知</strong></h4><p>执行中的期约可能会有不少离散的“阶段”，在最终解决之前必须依次经过。监控期约的执行进度会很有用。</p><p>一种实现方式是扩展<code>Promise</code>类，为它添加<code>notify()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackablePromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">      <span class="built_in">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> executor(resolve, reject, <span class="function">(<span class="params">status</span>) =&gt;</span> &#123;</span><br><span class="line">        notifyHandlers.map(<span class="function">(<span class="params">handler</span>) =&gt;</span> handler(status));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.notifyHandlers = notifyHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params">notifyHandler</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.notifyHandlers.push(notifyHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>TrackablePromise</code>就可以在执行函数中使用<code>notify()</code>函数了。这个期约会连续5次递归地设置1000毫秒的超时。每个超时回调都会调用<code>notify()</code>并传入状态值。假设通知处理程序简单地这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  countdown(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;progress:&#x27;</span>, x));</span><br><span class="line">p.then(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line"><span class="comment">// （约1秒后）progress: 80% remaining</span></span><br><span class="line"><span class="comment">// （约2秒后）progress: 60% remaining</span></span><br><span class="line"><span class="comment">// （约3秒后）progress: 40% remaining</span></span><br><span class="line"><span class="comment">// （约4秒后）progress: 20% remaining</span></span><br><span class="line"><span class="comment">// （约5秒后）completed</span></span><br></pre></td></tr></table></figure><h2 id="11-3-异步函数"><a href="#11-3-异步函数" class="headerlink" title="11.3　异步函数"></a>11.3　异步函数</h2><p>异步函数，也称为“async/await”（语法关键字），让以同步方式写的代码能够异步执行。下面来看一个最简单的例子，这个期约在超时之后会解决为一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>这个期约在1000毫秒之后解决为数值3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; setTimeout(resolve, 1000, 3));</span><br><span class="line">p.then((x) &#x3D;&gt; console.log(x));  &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">x</span>) </span>&#123; <span class="built_in">console</span>.log(x); &#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.then(handler); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>但这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码照样还是要放到处理程序里。ES8为此提供了async/await关键字。</p><h3 id="11-3-1-异步函数"><a href="#11-3-1-异步函数" class="headerlink" title="11.3.1　异步函数"></a>11.3.1　异步函数</h3><p><code>async</code>和<code>await</code>旨在解决利用异步结构组织代码的问题。</p><h4 id="11-3-1-1async"><a href="#11-3-1-1async" class="headerlink" title="11.3.1.1async"></a>11.3.1.1<code>async</code></h4><p><code>async</code>关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">qux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>async</code>关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通JavaScript函数的正常行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>不过，异步函数如果使用<code>return</code>关键字返回了值（如果没有<code>return</code>则会返回<code>undefined</code>），这个值会被<code>Promise.resolve()</code>包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure><p>当然，直接返回一个期约对象也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line">foo().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure><p>异步函数的返回值期待一个实现<code>thenable</code>接口的对象，但常规的值也可以。如果返回的是实现<code>thenable</code>接口的对象，则这个对象可以由提供给<code>then()</code>的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="built_in">console</span>.log);  <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 返回一个没有实现thenable接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">bar().then(<span class="built_in">console</span>.log); <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 返回一个实现了thenable接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">callback</span>)</span> &#123; callback(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line">baz().then(<span class="built_in">console</span>.log);  <span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">qux().then(<span class="built_in">console</span>.log);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure><p>与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure><p>不过，拒绝期约的错误不会被异步函数捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Attach a rejected handler to the returned promise</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Uncaught (in promise): 3</span></span><br></pre></td></tr></table></figure><h4 id="11-3-1-2await"><a href="#11-3-1-2await" class="headerlink" title="11.3.1.2await"></a>11.3.1.2<code>await</code></h4><p>因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用<code>await</code>关键字可以暂停异步函数代码的执行，等待期约解决。来看下面这个本章开始就出现过的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.then(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>使用async/await可以写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>注意，<code>await</code>关键字会暂停执行异步函数后面的代码，让出JavaScript运行时的执行线程。这个行为与生成器函数中的<code>yield</code>关键字是一样的。<code>await</code>关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。<br><code>await</code>关键字的用法与JavaScript的一元操作一样。它可以单独使用，也可以在表达式中使用，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步打印&quot;foo&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo</span></span><br><span class="line">　</span><br><span class="line">　</span><br><span class="line"><span class="comment">// 异步打印&quot;bar&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar().then(<span class="built_in">console</span>.log);  <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 1000毫秒后异步打印&quot;baz&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">baz();  <span class="comment">// baz（1000毫秒后）</span></span><br></pre></td></tr></table></figure><p><code>await</code>关键字期待（但实际上并不要求）一个实现<code>thenable</code>接口的对象，但常规的值也可以。如果是实现<code>thenable</code>接口的对象，则这个对象可以由<code>await</code>来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 等待一个没有实现thenable接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> [<span class="string">&#x27;bar&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line">bar();  <span class="comment">// [&#x27;bar&#x27;]</span></span><br><span class="line"><span class="comment">// 等待一个实现了thenable接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">callback</span>)</span> &#123; callback(<span class="string">&#x27;baz&#x27;</span>); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line">baz();  <span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">qux();  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure><p><code>await</code>会抛出错误的同步操作，会返回拒绝的期约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> <span class="number">3</span>; &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure><p>单独的<code>Promise.reject()</code>不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用<code>await</code>则会释放（unwrap）错误值（将拒绝期约返回）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给返回的期约添加一个拒绝处理程序</span></span><br><span class="line">foo().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3</span></span><br></pre></td></tr></table></figure><h4 id="11-3-1-3await的限制"><a href="#11-3-1-3await的限制" class="headerlink" title="11.3.1.3await的限制"></a>11.3.1.3<code>await</code>的限制</h4><p><code>await</code>关键字必须在异步函数中使用，不能在顶级上下文如<code>&lt;script&gt;</code>标签或模块中使用。不过，定义并立即调用异步函数是没问题的。下面两段代码实际是相同的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 立即调用的异步函数表达式</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>));</span><br><span class="line">&#125;)();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>此外，异步函数的特质不会扩展到嵌套函数。因此，<code>await</code>关键字也只能直接出现在异步函数的定义中。在同步函数内部使用<code>await</code>会抛出<code>SyntaxError</code>。<br>下面展示了一些会出错的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许：await出现在了箭头函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> syncFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await出现在了同步函数声明中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">syncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：await出现在了同步函数表达式中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> syncFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(syncFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不允许：IIFE使用同步函数表达式或箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>)); &#125;)();</span><br><span class="line">  (<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;qux&#x27;</span>)))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-2-停止和恢复执行"><a href="#11-3-2-停止和恢复执行" class="headerlink" title="11.3.2　停止和恢复执行"></a>11.3.2　停止和恢复执行</h3><p><code>await</code>不仅只是等待一个值，并且会记录在哪里暂停执行。等到<code>await</code>右边的值可用了，JavaScript运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。</p><p>因此，即使<code>await</code>后面跟着一个立即可用的值，函数的其余部分也会被<strong>异步</strong>求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">6</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">bar();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 分别打印1、2、3、4、5、6、7、8、9</span></span><br></pre></td></tr></table></figure><h3 id="11-3-3-异步函数策略"><a href="#11-3-3-异步函数策略" class="headerlink" title="11.3.3　异步函数策略"></a>11.3.3　异步函数策略</h3><p>因为简单实用，所以异步函数很快成为JavaScript项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。</p><h4 id="11-3-3-1-实现sleep"><a href="#11-3-3-1-实现sleep" class="headerlink" title="11.3.3.1   实现sleep()"></a><strong>11.3.3.1   实现</strong><code>sleep()</code></h4><p>以前实现Java中<code>Thread.sleep()</code>之类的函数，好在程序中加入非阻塞的暂停，基本上都通过<code>setTimeout()</code>利用JavaScript运行时的行为来实现的。</p><p>有了异步函数之后，就可以简单实现sleep()：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1500</span>); <span class="comment">// 暂停约1500毫秒</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - t0);</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 1502</span></span><br></pre></td></tr></table></figure><h4 id="11-3-3-2-利用平行执行"><a href="#11-3-3-2-利用平行执行" class="headerlink" title="11.3.3.2   利用平行执行"></a><strong>11.3.3.2   利用平行执行</strong></h4><p>就算期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟0~1000毫秒</span></span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">await</span> randomDelay(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 1607ms elapsed</span></span><br></pre></td></tr></table></figure><p>但如果顺序不是必需保证的，那么就可以先一次性初始化所有期约，然后再分别等待它们的结果。虽然期约没有按照顺序执行，但<code>await</code>是按顺序收到了每个期约的值的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> promises = <span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> randomDelay(i));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">await</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 717ms elapsed</span></span><br></pre></td></tr></table></figure><h4 id="11-3-3-3-串行执行期约"><a href="#11-3-3-3-串行执行期约" class="headerlink" title="11.3.3.3   串行执行期约"></a><strong>11.3.3.3   串行执行期约</strong></h4><p>使用async/await，期约连锁会变得很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">    x = <span class="keyword">await</span> fn(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><p>如果要使用期约，则可以把所有函数都改成异步函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">3</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x + <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">    x = <span class="keyword">await</span> fn(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><h4 id="11-3-3-4-栈追踪与内存管理-？"><a href="#11-3-3-4-栈追踪与内存管理-？" class="headerlink" title="11.3.3.4   栈追踪与内存管理 ？"></a><strong>11.3.3.4   栈追踪与内存管理 ？</strong></h4><p>期约与异步函数的功能有相当程度的重叠，但它们在内存中的表示则差别很大。下面的例子，展示了拒绝期约的栈追踪信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">//   setTimeout</span></span><br><span class="line"><span class="comment">//   setTimeout (async)</span></span><br><span class="line"><span class="comment">//   fooPromiseExecutor</span></span><br><span class="line"><span class="comment">//   foo</span></span><br></pre></td></tr></table></figure><p>栈追踪信息应该相当直接地表现JavaScript引擎当前栈内存中函数调用之间的嵌套关系。在超时处理程序执行时和拒绝期约时，我们看到的错误信息包含嵌套函数的标识符，那是被调用以创建最初期约实例的函数。可是，我们知道这些函数<strong>已经返回</strong>了，因此栈追踪信息中不应该看到它们。<br>答案很简单，这是因为JavaScript引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。</p><p>如果在前面的例子中使用的是异步函数，那又会怎样呢？比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">//   foo</span></span><br><span class="line"><span class="comment">//   async function (async)</span></span><br><span class="line"><span class="comment">//   foo</span></span><br></pre></td></tr></table></figure><p>这样栈追踪信息就准确地反映了当前的调用栈。<code>fooPromiseExecutor()</code>已经返回，所以它不在错误信息中。但<code>foo()</code>此时被挂起了，并没有退出。JavaScript运行时可以简单地在嵌套函数中存储指向包含函数的指针，就跟对待同步函数调用栈一样。这个指针实际上存储在内存中，可用于在出错时生成栈追踪信息。这样就不会像之前的例子那样带来额外的消耗，因此在重视性能的应用中是可以优先考虑的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ECMAScript 6新增了正式的&lt;code&gt;Promise&lt;/code&gt;（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;await&lt;/code&gt;关键字定义异步函数的机制。&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>10-函数</title>
    <link href="http://example.com/2021/04/19/note/JavaScript/10-%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/19/note/JavaScript/10-%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-19T06:41:15.900Z</published>
    <updated>2021-06-01T14:04:55.100Z</updated>
    
    <content type="html"><![CDATA[<p>函数实际上是对象，每个函数都是<code>Function</code>类型的实例，而<code>Function</code>也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，函数定义最后没有加分号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的，这里的函数末尾是有分号的，与任何变量初始化语句一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后一种定义函数的方式是使用<code>Function</code>构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>, <span class="string">&quot;return num1 + num2&quot;</span>);  <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure><p>不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规ECMAScript代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是很重要的。而上面这种语法很好地诠释了这些概念。</p><blockquote><p><strong>注意</strong>这几种实例化函数对象的方式之间存在微妙但重要的差别。</p></blockquote><h2 id="10-1-箭头函数"><a href="#10-1-箭头函数" class="headerlink" title="10.1　箭头函数"></a>10.1　箭头函数</h2><p>ECMAScript 6新增了使用胖箭头（<code>=&gt;</code>）语法定义函数表达式的能力。很大程度上，这与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrowSum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> functionExpressionSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数简洁的语法非常适合嵌入函数的场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(ints.map(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123; <span class="keyword">return</span> i + <span class="number">1</span>; &#125;));  <span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; <span class="keyword">return</span> i + <span class="number">1</span> &#125;));        <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">3</span> * x; &#125;;</span><br><span class="line"><span class="comment">// 没有参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> getRandom = <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random(); &#125;;</span><br><span class="line"><span class="comment">// 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, <span class="function"><span class="params">b</span> =&gt;</span> &#123; <span class="keyword">return</span> a * b; &#125;;</span><br></pre></td></tr></table></figure><p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效，而且返回相应的值</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="number">3</span> * x;</span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line"><span class="keyword">let</span> value = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> setName = <span class="function">(<span class="params">x</span>) =&gt;</span> x.name = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line">setName(value);</span><br><span class="line"><span class="built_in">console</span>.log(value.name); <span class="comment">// &quot;Matt&quot;</span></span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="keyword">return</span> a * b;</span><br></pre></td></tr></table></figure><p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用<code>arguments</code>、<code>super</code>和<code>new.target</code>，也不能用作构造函数，箭头函数也没有<code>prototype</code>属性。</p><h2 id="10-2-函数名"><a href="#10-2-函数名" class="headerlink" title="10.2　函数名"></a>10.2　函数名</h2><p>因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称。使用不带括号的函数名会访问函数指针，而不会执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));         <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;</span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>ES6的所有函数对象都会暴露一个只读的<code>name</code>属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用<code>Function</code>构造函数创建的，则会标识成<code>&quot;anonymous&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.name);               <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.name);               <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.name);               <span class="comment">// baz</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function">() =&gt;</span> &#123;&#125;).name);        <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name);  <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure><p>如果函数是一个获取函数、设置函数，或者使用<code>bind()</code>实例化，那么标识符前面会加上一个前缀：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name);    <span class="comment">// bound foo</span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">  years: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.years;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">newAge</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.years = newAge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(dog, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.get.name);  <span class="comment">// get age</span></span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor.set.name);  <span class="comment">// set age</span></span><br></pre></td></tr></table></figure><h2 id="10-3-理解参数"><a href="#10-3-理解参数" class="headerlink" title="10.3　理解参数"></a>10.3　理解参数</h2><p>ECMAScript函数的参数跟大多数其他语言不同。ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型。当定义函数时确定了要接收参数的个数，在调用时可以多传、少传，甚至不传，解释器都不会报错。</p><p>之所以会这样，主要是因为ECMAScript函数的参数在内部表现为一个数组。在使用<code>function</code>关键字定义（非箭头）函数时，可以在函数内部访问<code>arguments</code>对象，从中取得传进来的每个参数值。</p><p><code>arguments</code>对象是一个类数组对象（但不是<code>Array</code>的实例），因此可以使用中括号语法访问其中的元素。</p><p>在下面的例子中，<code>sayHi()</code>函数的第一个参数叫<code>name</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>arguments[0]</code>取得相同的参数值。因此，把函数重写成不声明参数也可以。与其他语言不同，在ECMAScript中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>arguments</code>对象的<code>length</code>属性检查传入的参数个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howManyArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">howManyArgs(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>);  <span class="comment">// 2</span></span><br><span class="line">howManyArgs();              <span class="comment">// 0</span></span><br><span class="line">howManyArgs(<span class="number">12</span>);            <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>arguments</code>对象还可以跟命名参数一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num1 + <span class="number">10</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arguments</code>对象的值始终会与对应的命名参数同步。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只传了一个参数，然后把<code>arguments[1]</code>设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为<code>arguments</code>对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。<br>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是<code>undefined</code>。这就类似于定义了变量而没有初始化。比如，如果只给<code>doAdd()</code>传了一个参数，那么<code>num2</code>的值就是<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>);  <span class="comment">// 1,undefined</span></span><br></pre></td></tr></table></figure><p>严格模式下，<code>arguments</code>会有一些变化。首先，像前面那样给<code>arguments[1]</code>赋值不会再影响<code>num2</code>的值。其次，在函数中尝试重写<code>arguments</code>对象会导致语法错误。（代码也不会执行。）</p><h3 id="10-3-1-箭头函数中的参数"><a href="#10-3-1-箭头函数中的参数" class="headerlink" title="10.3.1   箭头函数中的参数"></a>10.3.1   箭头函数中的参数</h3><p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用<code>arguments</code>关键字访问，而只能通过定义的命名参数访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">bar(<span class="number">5</span>);  <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure><p>虽然箭头函数中没有<code>arguments</code>对象，但可以在包装函数中把它提供给箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 5</span></span><br><span class="line">  &#125;;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>ECMAScript中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</p></blockquote><h2 id="10-4-没有重载"><a href="#10-4-没有重载" class="headerlink" title="10.4　没有重载"></a>10.4　没有重载</h2><p>ECMAScript函数不能像传统编程那样重载。在其他语言如Java，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。</p><p>如果在ECMAScript中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure><p>前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。</p><h2 id="10-5-默认参数值"><a href="#10-5-默认参数值" class="headerlink" title="10.5　默认参数值"></a>10.5　默认参数值</h2><p>在ECMAScript5.1及以前，实现默认参数的一种常用方式就是检测某个参数是否等于<code>undefined</code>，如果是则意味着没有传这个参数，那就给它赋一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = (<span class="keyword">typeof</span> name !== <span class="string">&#x27;undefined&#x27;</span>) ? name : <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());         <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br></pre></td></tr></table></figure><p>ES6写法，只要在函数定义中的参数后面用<code>=</code>就可以为参数赋一个默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing());         <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br></pre></td></tr></table></figure><p>给参数传<code>undefined</code>相当于没有传值，不过这样可以利用多个独立的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                 <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));          <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="literal">undefined</span>, <span class="string">&#x27;VI&#x27;</span>));  <span class="comment">// &#x27;King Henry VI&#x27;</span></span><br></pre></td></tr></table></figure><p>在使用默认参数时，<code>arguments</code>对象的值不反映参数的默认值，只反映传给函数的参数。跟ES5严格模式一样，修改命名参数也不会影响<code>arguments</code>对象，它始终以调用函数时传入的值为准：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;<span class="built_in">arguments</span>[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());         <span class="comment">// &#x27;King undefined&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>));  <span class="comment">// &#x27;King Louis&#x27;</span></span><br></pre></td></tr></table></figure><p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romanNumerals = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;II&#x27;</span>, <span class="string">&#x27;III&#x27;</span>, <span class="string">&#x27;IV&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;VI&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> ordinality = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumerals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每次调用后递增</span></span><br><span class="line">  <span class="keyword">return</span> romanNumerals[ordinality++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = getNumerals()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                <span class="comment">// &#x27;King Henry I&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>, <span class="string">&#x27;XVI&#x27;</span>));  <span class="comment">// &#x27;King Louis XVI&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                <span class="comment">// &#x27;King Henry II&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing());                <span class="comment">// &#x27;King Henry III&#x27;</span></span><br></pre></td></tr></table></figure><p>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。<br>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeKing = <span class="function">(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) =&gt;</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry</span></span><br></pre></td></tr></table></figure><h3 id="10-5-1-默认参数作用域与暂时性死区"><a href="#10-5-1-默认参数作用域与暂时性死区" class="headerlink" title="10.5.1   默认参数作用域与暂时性死区"></a>10.5.1   默认参数作用域与暂时性死区</h3><p>因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。</p><p>给多个参数定义默认值实际上跟使用<code>let</code>关键字顺序声明变量一样。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry VIII</span></span><br></pre></td></tr></table></figure><p>这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> numerals = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry Henry</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;king&#x27;</span>)); <span class="comment">// King King King</span></span><br></pre></td></tr></table></figure><p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第一个参数会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = numerals, numerals = <span class="string">&#x27;VIII&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用时不传第二个参数会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span>, numerals = defaultNumeral</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defaultNumeral = <span class="string">&#x27;VIII&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;numerals&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-6-参数扩展与收集"><a href="#10-6-参数扩展与收集" class="headerlink" title="10.6　参数扩展与收集"></a>10.6　参数扩展与收集</h2><p>ECMAScript 6新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p><h3 id="10-6-1-扩展参数"><a href="#10-6-1-扩展参数" class="headerlink" title="10.6.1　扩展参数"></a>10.6.1　扩展参数</h3><p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。</p><p>假设有如下函数定义，它会将所有传入的参数累加起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用扩展操作符，想把定义在这个函数里的数组拆分，那么就得用<code>apply()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum.apply(<span class="literal">null</span>, values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum(...values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum(-<span class="number">1</span>, ...values));          <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values, <span class="number">5</span>));           <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(-<span class="number">1</span>, ...values, <span class="number">5</span>));       <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]));  <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p>对函数中的<code>arguments</code>对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">countArguments(-<span class="number">1</span>, ...values);          <span class="comment">// 5</span></span><br><span class="line">countArguments(...values, <span class="number">5</span>);           <span class="comment">// 5</span></span><br><span class="line">countArguments(-<span class="number">1</span>, ...values, <span class="number">5</span>);       <span class="comment">// 6</span></span><br><span class="line">countArguments(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]);  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p><code>arguments</code>对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">a, b, c = <span class="number">0</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>]));      <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));    <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]));  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>]));          <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]));        <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(...[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));      <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="10-6-2-收集参数"><a href="#10-6-2-收集参数" class="headerlink" title="10.6.2　收集参数"></a>10.6.2　收集参数</h3><p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似<code>arguments</code>对象的构造机制，只不过收集参数的结果会得到一个<code>Array</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 顺序累加values中的所有值</span></span><br><span class="line">  <span class="comment">// 初始值的总和为0</span></span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">...values, lastValue</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ignoreFirst</span>(<span class="params">firstValue, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line">ignoreFirst();       <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>);      <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// [2]</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><p>箭头函数虽然不支持<code>arguments</code>对象，但支持收集参数的定义方式，因此也可以实现与使用<code>arguments</code>一样的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>使用收集参数并不影响<code>arguments</code>对象，它仍然反映调用时传给函数的参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);         <span class="comment">// [1, 2, 3]</span></span><br><span class="line">  <span class="built_in">console</span>.log(values);            <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h2 id="10-7-函数声明与函数表达式"><a href="#10-7-函数声明与函数表达式" class="headerlink" title="10.7　函数声明与函数表达式"></a>10.7　函数声明与函数表达式</h2><p>函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作<strong>函数声明提升</strong>（function declaration hoisting）。在执行代码时，JavaScript引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明<strong>提升</strong>到顶部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 没问题</span><br><span class="line">console.log(sum(10, 10));</span><br><span class="line">function sum(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数定义包含在一个变量初始化语句中，这意味着代码如果没有执行到那一行，那么执行上下文中就没有函数的定义。这并不是因为使用<code>let</code>而导致的，使用<code>var</code>关键字也会碰到同样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>在使用函数表达式初始化变量时，也可以给函数一个名称，比如<code>let sum = function sum() &#123;&#125;</code>。</p></blockquote><h2 id="10-8-函数作为值"><a href="#10-8-函数作为值" class="headerlink" title="10.8　函数作为值"></a>10.8　函数作为值</h2><p>因为函数名在ECMAScript中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>要注意的是，如果是访问函数而不是调用函数，那就必须不带括号，而不能是它们的执行结果。<br>从一个函数中返回另一个函数也是可以的。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个<code>sort()</code>方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;Zachary&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;</span><br><span class="line">];</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Nicholas</span></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Zachary</span></span><br></pre></td></tr></table></figure><h2 id="10-9-函数内部"><a href="#10-9-函数内部" class="headerlink" title="10.9　函数内部"></a>10.9　函数内部</h2><h3 id="10-9-1arguments"><a href="#10-9-1arguments" class="headerlink" title="10.9.1arguments"></a>10.9.1<code>arguments</code></h3><p><code>arguments</code>是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以<code>function</code>关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但<code>arguments</code>对象其实还有一个<code>callee</code>属性，是一个指向<code>arguments</code>对象所在函数的指针。来看下面这个经典的阶乘函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这个函数要正确执行就必须保证函数名是<code>factorial</code>，从而导致了紧密耦合。使用<code>arguments.callee</code>就可以让函数逻辑与函数名解耦，这意味着无论函数叫什么名称，都可以引用正确的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-9-2this"><a href="#10-9-2this" class="headerlink" title="10.9.2this"></a>10.9.2<code>this</code></h3><p>另一个特殊的对象是<code>this</code>，它在标准函数和箭头函数中有不同的行为。</p><p>在标准函数中，<code>this</code>引用的是把函数当成方法调用的上下文对象，这时候通常称其为<code>this</code>值（在网页的全局上下文中调用函数时，<code>this</code>指向<code>windows</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;  </span><br><span class="line">sayColor();    <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">// &#x27;blue&#x27;</span></span><br></pre></td></tr></table></figure><p>函数名只是保存指针的变量。因此全局定义的<code>sayColor()</code>函数和<code>o.sayColor()</code>是同一个函数，只不过执行的上下文不同。<br>在箭头函数中，<code>this</code>引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对<code>sayColor()</code>的两次调用中，<code>this</code>引用的都是<code>window</code>对象，因为这个箭头函数是在<code>window</code>上下文中定义的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> sayColor = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">sayColor();    <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><p>在事件回调或定时回调中调用某个函数时，<code>this</code>值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的<code>this</code>会保留定义该函数时的上下文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">  <span class="comment">// this引用King的实例</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line">  <span class="comment">// this引用window对象</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King();  <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> Queen(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="10-9-3caller"><a href="#10-9-3caller" class="headerlink" title="10.9.3caller"></a>10.9.3<code>caller</code></h3><p>函数对象上的<code>caller</code>属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为<code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer(); </span><br></pre></td></tr></table></figure><p>如果要降低耦合度，则可以通过<code>arguments.callee.caller</code>来引用同样的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>在严格模式下访问<code>arguments.callee</code>会报错。在非严格模式下<code>arguments.caller</code>始终是<code>undefined</code>，但在严格模式下访问它会报错。<br>严格模式下不能给函数的<code>caller</code>属性赋值，否则会导致错误。</p><h3 id="10-9-4new-target"><a href="#10-9-4new-target" class="headerlink" title="10.9.4new.target"></a>10.9.4<code>new.target</code></h3><p>ECMAScript中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6新增了检测函数是否使用<code>new</code>关键字调用的<code>new.target</code>属性。如果函数是正常调用的，则<code>new.target</code>的值是<code>undefined</code>；如果是使用<code>new</code>关键字调用的，则<code>new.target</code>将引用被调用的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// King instantiated using &quot;new&quot;</span></span><br><span class="line">King();     <span class="comment">// Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure><h2 id="10-10-函数属性与方法"><a href="#10-10-函数属性与方法" class="headerlink" title="10.10　函数属性与方法"></a>10.10　函数属性与方法</h2><p>ECMAScript中的函数是对象，因此有属性和方法。每个函数都有两个属性：<code>length</code>和<code>prototype</code>。其中，<code>length</code>属性保存函数定义的命名参数的个数，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayName.length);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.length);      <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHi.length);    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><code>prototype</code>是保存引用类型所有实例方法的地方，<code>toString()</code>、<code>valueOf()</code>等方法实际上都保存在<code>prototype</code>上，进而由所有实例共享。<code>prototype</code>属性是不可枚举的，因此使用<code>for-in</code>循环不会返回这个属性。<br>函数还有两个方法：<code>apply()</code>和<code>call()</code>。这两个方法都会以指定的<code>this</code>值来调用函数，即会设置调用函数时函数体内<code>this</code>对象的值。<code>apply()</code>方法接收两个参数：函数内<code>this</code>的值和一个参数数组。第二个参数可以是<code>Array</code>的实例或<code>arguments</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入arguments对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>在严格模式下，调用函数时如果没有使用<code>apply()</code>或<code>call()</code>把函数指定给一个对象，也就是没有指定上下文对象，则<code>this</code>值不会指向<code>window</code>，会变成<code>undefined</code>。</p></blockquote><p><code>call()</code>方法与<code>apply()</code>的作用一样，只是传参的形式不同。第一个参数跟<code>apply()</code>一样，也是<code>this</code>值，而剩下的要传给被调用函数的参数则是逐个传递的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="built_in">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>到底是使用<code>apply()</code>还是<code>call()</code>，完全取决于怎么给要调用的函数传参更方便。如果不用给被调用的函数传参，则使用哪个方法都一样。<br><code>apply()</code>和<code>call()</code>真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内<code>this</code>值的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  fn.call(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callFn); <span class="comment">//callFn函数代码</span></span><br><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();             <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">this</span>);    <span class="comment">// red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);  <span class="comment">// red</span></span><br><span class="line">sayColor.call(o);       <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>使用<code>call()</code>或<code>apply()</code>的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。<br>ECMAScript 5出于同样的目的定义了一个新方法：<code>bind()</code>。<code>bind()</code>方法会创建一个新的函数实例，其<code>this</code>值会被<strong>绑定</strong>到传给<code>bind()</code>的对象。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();  <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p>对函数而言，继承的方法<code>toLocaleString()</code>和<code>toString()</code>始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法<code>valueOf()</code>返回函数本身。</p><h2 id="10-11-函数表达式"><a href="#10-11-函数表达式" class="headerlink" title="10.11　函数表达式"></a>10.11　函数表达式</h2><p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样创建的函数叫作<strong>匿名函数</strong>（anonymous funtion），因为<code>function</code>关键字后面没有标识符。（匿名函数有也时候也被称为<strong>兰姆达函数</strong>）。未赋值给其他变量的匿名函数的<code>name</code>属性是空字符串。<br>函数表达式跟JavaScript中的其他表达式一样，需要先赋值再使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();  <span class="comment">// Error! function doesn&#x27;t exist yet</span></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Yo!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来正常，事实上，这种写法不是有效的语法。JavaScript引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略<code>condition</code>直接返回第二个声明。Firefox会在<code>condition</code>为<code>true</code>时返回第一个声明。<br>不过，如果把上面的函数声明换成函数表达式就没问题了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> sayHi;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Yo!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>createComparisonFunction()</code>函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在<code>createComparisonFunction()</code>内部，那个函数是匿名的。任何时候，只要函数被当作值来使用，它就是一个函数表达式。</p><h2 id="10-12-递归"><a href="#10-12-递归" class="headerlink" title="10.12　递归"></a>10.12　递归</h2><p><strong>递归函数</strong>通常的形式是一个函数通过名称调用自己，在编写递归函数时，<code>arguments.callee</code>是引用当前函数的首选。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在严格模式下运行的代码是不能访问<code>arguments.callee</code>的。可以使用命名函数表达式（named function expression）达到目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里创建了一个命名函数表达式<code>f()</code>，然后将它赋值给了变量<code>factorial</code>。即使把函数赋值给另一个变量，函数表达式的名称<code>f</code>也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。</p><h2 id="10-13-尾调用优化"><a href="#10-13-尾调用优化" class="headerlink" title="10.13　尾调用优化"></a>10.13　尾调用优化</h2><p>ECMAScript 6规范新增了一项内存管理优化机制，让JavaScript引擎在满足条件时可以重用栈帧。这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ES6优化之前，执行这个例子会在内存中发生如下操作。</p><ol><li>执行到<code>outerFunction</code>函数体，第一个栈帧被推到栈上。</li><li>执行<code>outerFunction</code>函数体，到<code>return</code>语句。计算返回值必须先计算<code>innerFunction</code>。</li><li>执行到<code>innerFunction</code>函数体，第二个栈帧被推到栈上。</li><li>执行<code>innerFunction</code>函数体，计算其返回值。</li><li>将返回值传回<code>outerFunction</code>，然后<code>outerFunction</code>再返回值。</li><li>将栈帧弹出栈外。</li></ol><p>在ES6优化之后，执行这个例子会在内存中发生如下操作。</p><ol><li>执行到<code>outerFunction</code>函数体，第一个栈帧被推到栈上。</li><li>执行<code>outerFunction</code>函数体，到达<code>return</code>语句。为求值返回语句，必须先求值<code>innerFunction</code>。</li><li>引擎发现把第一个栈帧弹出栈外也没问题，因为<code>innerFunction</code>的返回值也是<code>outerFunction</code>的返回值。</li><li>弹出<code>outerFunction</code>的栈帧。</li><li>执行到<code>innerFunction</code>函数体，栈帧被推到栈上。</li><li>执行<code>innerFunction</code>函数体，计算其返回值。</li><li>将<code>innerFunction</code>的栈帧弹出栈外。</li></ol><p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是ES6尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p><blockquote><p><strong>注意</strong>现在还没有办法测试尾调用优化是否起作用。不过，因为这是ES6规范所规定的，兼容的浏览器实现都能保证在代码满足条件的情况下应用这个优化。</p></blockquote><h3 id="10-13-1-尾调用优化的条件"><a href="#10-13-1-尾调用优化的条件" class="headerlink" title="10.13.1　尾调用优化的条件"></a>10.13.1　尾调用优化的条件</h3><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：</p><ul><li>代码在严格模式下执行；</li><li>外部函数的返回值是对尾调用函数的调用；</li><li>尾调用函数返回后不需要执行额外的逻辑；</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包。</li></ul><p>下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> innerFunctionResult = innerFunction();</span><br><span class="line">  <span class="keyword">return</span> innerFunctionResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是几个符合尾调用优化条件的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunction(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> condition ? innerFunctionA() : innerFunctionB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</p><blockquote><p><strong>注意</strong>之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用<code>f.arguments</code>和<code>f.caller</code>，而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。</p></blockquote><h3 id="10-13-2-尾调用优化的代码"><a href="#10-13-2-尾调用优化的代码" class="headerlink" title="10.13.2　尾调用优化的代码"></a>10.13.2　尾调用优化的代码</h3><p>可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">0</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">1</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">2</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">3</span>));  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">4</span>));  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">5</span>));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">6</span>));  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈帧数的内存复杂度是。<br>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">// 基础框架</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fibImpl(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibImpl</span>(<span class="params">a, b, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibImpl(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-14-闭包"><a href="#10-14-闭包" class="headerlink" title="10.14　闭包"></a>10.14　闭包</h2><p>匿名函数经常被人误认为是闭包（closure）。<strong>闭包</strong>指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部函数（匿名函数）中引用了外部函数的变量<code>propertyName</code>。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含<code>createComparisonFunction()</code>函数的作用域。<br>而这又是因为在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用<code>arguments</code>和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。</p><p>在函数执行时，要从作用域链中查找变量，以便读、写值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义<code>compare()</code>函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的<code>[[Scope]]</code>中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的<code>[[Scope]]</code>来创建其作用域链。接着会创建函数的活动对象并将其推入作用域链的前端。这意味着<code>compare()</code>函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。<br>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。图10-1展示了以上关系。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/04/19/3DP5j2RAqBbulFL.png"                      alt="016.png"                ></p><p><strong>图　10-1</strong></p><p>但是，闭包就不一样了。在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在<code>createComparisonFunction()</code>函数中，匿名函数的作用域链中实际上包含<code>createComparisonFunction()</code>的活动对象。图10-2展示了调用<code>compareNames()</code>之后作用域链之间的关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/04/19/tr1VLpm6fqW2oG4.png"                      alt="017.png"                ></p><p><strong>图　10-2</strong></p><p>在<code>createComparisonFunction()</code>返回匿名函数后，它的作用域链被初始化为包含<code>createComparisonFunction()</code>的活动对象和全局变量对象。这样，匿名函数就可以访问到<code>createComparisonFunction()</code>可以访问的所有变量。副作用是，<code>createComparisonFunction()</code>的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在<code>createComparisonFunction()</code>执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compare = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> result = compare(&#123; <span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span> &#125;); <span class="comment">// 调用函数</span></span><br><span class="line">compare= <span class="literal">null</span>; <span class="comment">// 解除对函数的引用，这样就可以释放内存了</span></span><br></pre></td></tr></table></figure><p>创建的比较函数被保存在变量<code>compareNames</code>中。把<code>compareNames</code>设置为等于<code>null</code>会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p><blockquote><p><strong>注意</strong>因为闭包会保留它们包含函数的作用域，所以过度使用闭包可能导致内存过度占用，建议仅在十分必要时使用。</p></blockquote><h3 id="10-14-1this对象"><a href="#10-14-1this对象" class="headerlink" title="10.14.1this对象"></a>10.14.1<code>this</code>对象</h3><p>如果内部函数没有使用箭头函数定义，则<code>this</code>对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则<code>this</code>在非严格模式下等于<code>window</code>，在严格模式下等于<code>undefined</code>。如果作为某个对象的方法调用，则<code>this</code>等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着<code>this</code>会指向<code>window</code>，除非在严格模式下<code>this</code>是<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure><p>匿名函数之所以没有使用其包含作用域（<code>getIdentityFunc()</code>）的<code>this</code>对象，是因为<br>内部函数永远不可能直接访问外部函数在被调用时都会自动创建两个特殊变量：<code>this</code>和<code>arguments</code>。但如果把<code>this</code>保存到闭包可以访问的另一个变量中，则是行得通的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.identity;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;My Object&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong><code>this</code>和<code>arguments</code>都是不能直接在内部函数中访问的。如果想访问包含作用域中的<code>arguments</code>对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p></blockquote><p>在一些特殊情况下，<code>this</code>值可能并不是我们所期待的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  identity: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">  getIdentity () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">object.getIdentity();             <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.getIdentity)();           <span class="comment">// &#x27;My Object&#x27;</span></span><br><span class="line">(object.getIdentity = object.getIdentity)();  <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure><p>第一次调用时把<code>object.getIdentity</code>放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但<code>this</code>值并没有变。这是因为按照规范，<code>object.getIdentity</code>和<code>(object.getIdentity)</code>是相等的。第二次执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，<code>this</code>值不再与任何对象绑定，所以返回的是<code>&quot;The Window&quot;</code>。</p><h3 id="10-14-2-内存泄漏"><a href="#10-14-2-内存泄漏" class="headerlink" title="10.14.2　内存泄漏"></a>10.14.2　内存泄漏</h3><p>由于IE在IE9之前对JScript对象和COM对象使用了不同的垃圾回收机制，所以闭包在这些旧版本IE中可能会导致问题。比如，把HTML元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line">  element.onclick = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(element.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个闭包，即<code>element</code>元素的事件处理程序。而这个处理程序又创建了一个循环引用。匿名函数引用着<code>assignHandler()</code>的活动对象，阻止了对<code>element</code>的引用计数归零。只要这个匿名函数存在，<code>element</code>的引用计数就至少等于1。也就是说，内存不会被回收。<br>稍加修改，就可以避免这种情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> id = element.id;</span><br><span class="line">  element.onclick = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(id);</span><br><span class="line">  element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包改为引用一个保存着<code>element.id</code>的变量<code>id</code>，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含<code>element</code>。即使闭包没有直接引用<code>element</code>，包含函数的活动对象上还是保存着对它的引用。因此，必须再把<code>element</code>设置为<code>null</code>。这样就解除了对这个COM对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收。</p><h2 id="10-15-立即调用的函数表达式"><a href="#10-15-立即调用的函数表达式" class="headerlink" title="10.15　立即调用的函数表达式"></a>10.15　立即调用的函数表达式</h2><p>立即调用的匿名函数又被称作<strong>立即调用的函数表达式</strong>（IIFE，Immediately Invoked Function Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>使用IIFE可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>在ECMAScript 5.1及以前，尚未支持块级作用域，为了防止变量定义外泄，IIFE是个普遍且有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。<br>在ECMAScript 6以后，IIFE就没有那么必要了，因为块级作用域中的变量无须IIFE就可以实现同样的隔离。下面展示了两种不同的块级作用域形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="comment">// 循环的块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><p>说明IIFE用途的一个实际的例子，就是可以用它锁定参数值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>var</code>关键字声明了循环迭代变量<code>i</code>，但这个变量并不会被限制在<code>for</code>循环的块级作用域内。因此渲染到页面上之后，点击每个<code>&lt;div&gt;</code>都会弹出元素总数。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量<code>i</code>存在于循环体外部，随时可以访问。<br>以前，为了实现点击第几个<code>&lt;div&gt;</code>就显示相应的索引值，需要借助IIFE来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">frozenCounter</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frozenCounter);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用ECMAScript块级作用域变量更加方便简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，事件处理程序执行时就会引用<code>for</code>循环块级作用域中的索引值。这是因为在ECMAScript 6中，如果对<code>for</code>循环使用块级作用域变量关键字，在这里就是<code>let</code>，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。<br>但如果把变量声明拿到<code>for</code>循环外部，会跟在循环中使用<code>var i = 0</code>有同样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 达不到目的！</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.length; ++i) &#123;</span><br><span class="line">  divs[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-16-私有变量"><a href="#10-16-私有变量" class="headerlink" title="10.16　私有变量"></a>10.16　私有变量</h2><p>严格来讲，JavaScript没有私有成员的概念，所有对象属性都公有的。不过有<strong>私有变量</strong>的概念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，函数<code>add()</code>有3个私有变量：<code>num1</code>、<code>num2</code>和<code>sum</code>。这几个变量只能在函数内部使用，不能在函数外部访问。如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的这3个变量。基于这一点，就可以创建出能够访问私有变量的公有方法。<br><strong>特权方法</strong>（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有两种方式创建特权方法。第一种是在构造函数中实现，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="built_in">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。<br>如下面的例子所示，可以定义私有变量和特权方法，以隐藏不能被直接修改的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());  <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person.setName(<span class="string">&#x27;Greg&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());  <span class="comment">// &#x27;Greg&#x27;</span></span><br></pre></td></tr></table></figure><p>这段代码中的构造函数定义了两个特权方法：<code>getName()</code>和<code>setName()</code>。每个方法都可以构造函数外部调用，并通过它们来读写私有的<code>name</code>变量。在<code>Person</code>构造函数外部，没有别的办法访问<code>name</code>。因为两个方法都定义在构造函数内部，所以它们都是能够通过作用域链访问<code>name</code>的闭包。私有变量<code>name</code>对每个<code>Person</code>实例而言都是独一无二的，因为每次调用构造函数都会重新创建一套变量和方法。不过这样也有个问题：必须通过构造函数来实现这种隔离。构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用第二种方式，静态私有变量实现特权方法可以避免这个问题。</p><h3 id="10-16-1-静态私有变量"><a href="#10-16-1-静态私有变量" class="headerlink" title="10.16.1　静态私有变量"></a>10.16.1　静态私有变量</h3><p>特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 公有和特权方法</span></span><br><span class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    <span class="keyword">return</span> privateFunction();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域。公有方法定义在构造函数的原型上。这个模式定义的构造函数没有使用函数声明，使用的是函数表达式。函数声明会创建内部函数，在这里并不是必需的，并且不使用关键字声明的变量会创建在全局作用域中，所以<code>MyObject</code>变成了全局变量，可以在这个私有作用域外部被访问。注意在严格模式下给未声明的变量赋值会导致错误。<br>这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">  Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Nicholas&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());  <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line">person1.setName(<span class="string">&#x27;Matt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());  <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Michael&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());  <span class="comment">// &#x27;Michael&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.getName());  <span class="comment">// &#x27;Michael&#x27;</span></span><br></pre></td></tr></table></figure><p>使用这种模式，<code>name</code>变成了静态变量，可供所有实例使用。这意味着在任何实例上调用<code>setName()</code>修改这个变量都会影响其他实例。调用<code>setName()</code>或创建新的<code>Person</code>实例都要把<code>name</code>变量设置为一个新值。而所有实例都会返回相同的值。<br>像这样创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。</p><blockquote><p><strong>注意</strong>使用闭包和私有变量会导致作用域链变长，作用域链越长，则查找变量所需的时间也越多。</p></blockquote><h3 id="10-16-2-模块模式"><a href="#10-16-2-模块模式" class="headerlink" title="10.16.2　模块模式"></a>10.16.2　模块模式</h3><p>单例对象（singleton）就是只有一个实例的对象。JavaScript是通过对象字面量来创建单例对象的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = &#123;</span><br><span class="line">  name: value,</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。模块模式的样板代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicProperty: <span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">publicMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>模块模式使用了匿名函数返回一个对象。在匿名函数内部，首先定义私有变量和私有函数。之后创建一个要通过匿名函数返回的对象字面量。这个对象字面量中只包含可以公开访问的属性和方法。因为这个对象定义在匿名函数内部，所以它的所有公有方法都可以访问同一个作用域的私有变量和私有函数。本质上，对象字面量定义了单例对象的公共接口。<br>如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用下面这个模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">getComponentCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> components.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">registerComponent</span>(<span class="params">component</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        components.push(component);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>在Web开发中，经常需要使用单例对象管理应用程序级的信息。上面这个例子创建了一个<code>application</code>对象用于管理组件。在创建这个对象之后，内部就会创建一个私有的数组<code>components</code>，然后将一个<code>BaseComponent</code>组件的新实例添加到数组中。<code>BaseComponent</code>组件的代码并不重要，在这里只是为了说明模块模式的用法。对象字面量中定义的<code>getComponentCount()</code>和<code>registerComponent()</code>方法都是可以访问<code>components</code>私有数组的特权方法。<br>以这种方式创建的每个单例对象都是<code>Object</code>的实例，因为最终单例都由一个对象字面量来表示。不过这无关紧要，因为单例对象通常是可以全局访问的，而不是作为参数传给函数的，所以无需使用<code>instanceof</code>操作符确定参数是不是对象类型。</p><h3 id="10-16-3-模块增强模式"><a href="#10-16-3-模块增强模式" class="headerlink" title="10.16.3　模块增强模式"></a>10.16.3　模块增强模式</h3><p>另一种利用模块模式的做法是在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">  <span class="keyword">let</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line">  <span class="comment">// 创建局部变量保存实例</span></span><br><span class="line">  <span class="keyword">let</span> app = <span class="keyword">new</span> BaseComponent();</span><br><span class="line">  <span class="comment">// 公共接口</span></span><br><span class="line">  app.getComponentCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> components.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.registerComponent = <span class="function"><span class="keyword">function</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      components.push(component);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>在这个重写的<code>application</code>单例对象的例子中，首先定义了私有变量和私有函数，跟之前一样。主要区别在于这里创建了一个名为<code>app</code>的变量，其中保存了<code>BaseComponent</code>组件的实例。这是最终要变成<code>application</code>的那个对象的局部版本。在给这个局部变量<code>app</code>添加了能够访问私有变量的公共方法之后，匿名函数返回了这个对象。然后，这个对象被赋值给<code>application</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数实际上是对象，每个函数都是&lt;code&gt;Function&lt;/code&gt;类型的实例，而&lt;code&gt;Function&lt;/code&gt;也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>09-代理与反射</title>
    <link href="http://example.com/2021/04/08/note/JavaScript/09-%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2021/04/08/note/JavaScript/09-%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2021-04-08T12:55:46.535Z</published>
    <updated>2021-05-11T09:21:22.239Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 6新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。</p><blockquote><p><strong>注意</strong>在ES6之前，ECMAScript中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的ECMAScript代码。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。</p></blockquote><h2 id="9-1-代理基础"><a href="#9-1-代理基础" class="headerlink" title="9.1　代理基础"></a>9.1　代理基础</h2><p>代理是目标对象的抽象。从很多方面看，代理类似C++指针但有重大区别，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象可以直接被操作，但直接操作会绕过代理施予的行为，也可以通过代理来操作。</p><h3 id="9-1-1-创建空代理"><a href="#9-1-1-创建空代理" class="headerlink" title="9.1.1　创建空代理"></a>9.1.1　创建空代理</h3><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p><p>代理是使用<code>Proxy</code>构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出<code>TypeError</code>。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p><p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// id属性会访问同一个值</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id);  <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);   <span class="comment">// target</span></span><br><span class="line"><span class="comment">// 给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值</span></span><br><span class="line">target.id = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);  <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 给代理属性赋值会反映在两个对象上，因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.id = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id);  <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方，都会应用到目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target.hasOwnProperty(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.hasOwnProperty(<span class="string">&#x27;id&#x27;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Proxy.prototype是undefined，因此不能使用instanceof操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(target <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>);  <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="built_in">console</span>.log(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="9-1-2-定义捕获器"><a href="#9-1-2-定义捕获器" class="headerlink" title="9.1.2　定义捕获器"></a>9.1.2　定义捕获器</h3><p>使用代理的主要目的是可以定义<strong>捕获器</strong>（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p><blockquote><p><strong>注意</strong>捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流。</p></blockquote><p>例如，可以定义一个<code>get()</code>捕获器，在ECMAScript操作以某种形式调用<code>get()</code>时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>这样，当通过代理对象执行<code>get()</code>操作时，就会触发定义的<code>get()</code>捕获器。当然，<code>get()</code>不是ECMAScript对象可以调用的方法。这个操作在JavaScript代码中可以通过多种形式触发并被<code>get()</code>捕获器拦截到。<code>proxy[property]</code>、<code>proxy.property</code>或<code>Object.create(proxy)[property]</code>等操作都会触发基本的<code>get()</code>操作以获取属性。所有这些操作只要也只能发生在代理对象上，就会触发<code>get()</code>捕获器，否则在目标对象上执行这些操作仍然会产生正常的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 捕获器在处理程序对象中以方法名为键</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;handler override&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(target.foo);                    <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);                     <span class="comment">// handler override</span></span><br><span class="line"><span class="built_in">console</span>.log(target[<span class="string">&#x27;foo&#x27;</span>]);                 <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="string">&#x27;foo&#x27;</span>]);                  <span class="comment">// handler override</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(target)[<span class="string">&#x27;foo&#x27;</span>]);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(proxy)[<span class="string">&#x27;foo&#x27;</span>]);   <span class="comment">// handler override</span></span><br></pre></td></tr></table></figure><h3 id="9-1-3-捕获器参数和反射API"><a href="#9-1-3-捕获器参数和反射API" class="headerlink" title="9.1.3　捕获器参数和反射API"></a>9.1.3　捕获器参数和反射API</h3><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，<code>get()</code>捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(trapTarget === target);</span><br><span class="line">    <span class="built_in">console</span>.log(property);</span><br><span class="line">    <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.foo;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>有了这些参数，就可以重建被捕获方法的原始行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> trapTarget[property];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像<code>get()</code>那么简单。因此，无法如法炮制。实际上，开发者可以通过调用全局<code>Reflect</code>对象上（封装了原始行为）的同名方法来轻松重建。<br>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射API也可以像下面这样定义出空代理对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>甚至还可以写得更简洁一些：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get: <span class="built_in">Reflect</span>.get</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射API的空代理，那么甚至不需要定义处理程序对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, <span class="built_in">Reflect</span>);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>反射API为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="string">&#x27;qux&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">trapTarget, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> decoration = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">      decoration = <span class="string">&#x27;!!!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments) + decoration;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// bar!!!</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.baz);   <span class="comment">// qux</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure><h3 id="9-1-4-捕获器不变式"><a href="#9-1-4-捕获器不变式" class="headerlink" title="9.1.4　捕获器不变式"></a>9.1.4　捕获器不变式</h3><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p><p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出<code>TypeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="9-1-5-可撤销代理"><a href="#9-1-5-可撤销代理" class="headerlink" title="9.1.5　可撤销代理"></a>9.1.5　可撤销代理</h3><p>对于使用<code>new Proxy()</code>创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</p><p>有时候可能需要中断代理对象与目标对象之间的联系。<code>revocable()</code>方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（<code>revoke()</code>）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出<code>TypeError</code>。</p><p>撤销函数和代理对象是在实例化时同时生成的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// intercepted</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// bar</span></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);   <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="9-1-6-实用反射API"><a href="#9-1-6-实用反射API" class="headerlink" title="9.1.6　实用反射API"></a>9.1.6　实用反射API</h3><p>某些情况下应该优先使用反射API，这是有一些理由的。</p><ol><li><strong>反射API与对象API</strong></li></ol><p>在使用反射API时，要记住：</p><ul><li>反射API并不限于捕获处理程序；</li><li>大多数反射API方法在<code>Object</code>类型上有对应的方法。</li></ul><p>通常，<code>Object</code>上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p><ol start="2"><li><strong>状态标记</strong></li></ol><p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API方法更有用。例如，可以使用反射API对下面的代码进行重构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义新属性时如果发生问题，<code>Reflect.defineProperty()</code>会返回<code>false</code>，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Reflect</span>.defineProperty(o, <span class="string">&#x27;foo&#x27;</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>&#125;)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;failure&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下反射方法都会提供状态标记：</p><ul><li> <code>Reflect.defineProperty()</code></li><li> <code>Reflect.preventExtensions()</code></li><li> <code>Reflect.setPrototypeOf()</code></li><li> <code>Reflect.set()</code></li><li> <code>Reflect.deleteProperty()</code></li></ul><ol start="3"><li><strong>用一等函数替代操作符</strong></li></ol><p>以下反射方法提供只有通过操作符才能完成的操作。</p><ul><li><code>Reflect.get()</code>：可以替代对象属性访问操作符。</li><li><code>Reflect.set()</code>：可以替代<code>=</code>赋值操作符。</li><li><code>Reflect.has()</code>：可以替代<code>in</code>操作符或<code>with()</code>。</li><li><code>Reflect.deleteProperty()</code>：可以替代<code>delete</code>操作符。</li><li><code>Reflect.construct()</code>：可以替代<code>new</code>操作符。</li></ul><ol start="4"><li><strong>安全地应用函数</strong></li></ol><p>在通过<code>apply</code>方法调用函数时，被调用的函数可能也定义了自己的<code>apply</code>属性（虽然可能性极小）。为绕过这个问题，可以使用定义在<code>Function</code>原型上的<code>apply</code>方法，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(myFunc, thisVal, argumentList);</span><br></pre></td></tr></table></figure><p>使用<code>Reflect.apply</code>更方便：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(myFunc, thisVal, argumentsList);</span><br></pre></td></tr></table></figure><h3 id="9-1-7-代理另一个代理"><a href="#9-1-7-代理另一个代理" class="headerlink" title="9.1.7　代理另一个代理"></a>9.1.7　代理另一个代理</h3><p>代理可以拦截反射API的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;first proxy&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(firstProxy, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;second proxy&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(secondProxy.foo);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h3 id="9-1-8-代理的问题与不足"><a href="#9-1-8-代理的问题与不足" class="headerlink" title="9.1.8　代理的问题与不足"></a>9.1.8　代理的问题与不足</h3><p>代理是在ECMAScript现有基础之上构建起来的一套新API。虽然很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的ECMAScript机制很好地协同。</p><h4 id="9-1-8-1-代理中的this？"><a href="#9-1-8-1-代理中的this？" class="headerlink" title="9.1.8.1   代理中的this？"></a><strong>9.1.8.1   代理中的</strong><code>this</code>？</h4><p>代理潜在的一个问题来源是<code>this</code>值，<code>this</code>通常指向调用这个方法的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="function"><span class="title">thisValEqualsProxy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> === proxy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(target.thisValEqualsProxy());  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.thisValEqualsProxy());   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这样完全没有问题：调用代理上的任何方法，比如<code>proxy.outerMethod()</code>，而这个方法进而又会调用另一个方法，如<code>this.innerMethod()</code>，实际上都会调用<code>proxy.innerMethod()</code>。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。<br>还记得第6章中通过<code>WeakMap</code>保存私有变量的例子吧，以下是它的简化版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">userId</span>)</span> &#123;</span><br><span class="line">    wm.set(<span class="built_in">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">id</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">    wm.set(<span class="built_in">this</span>, userId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">id</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> wm.get(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个实现依赖<code>User</code>实例的对象标识，在这个实例被代理的情况下就会出问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.id); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">const</span> userInstanceProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(userInstanceProxy.id); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这是因为<code>User</code>实例一开始使用目标对象作为<code>WeakMap</code>的键，代理对象却尝试从<strong>自身</strong>取得这个实例。要解决这个问题，就需要重新配置代理，把代理<code>User</code>实例改为代理<code>User</code>类本身。之后再创建代理的实例就会以代理实例作为<code>WeakMap</code>的键了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserClassProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> UserClassProxy(<span class="number">456</span>);</span><br><span class="line"><span class="built_in">console</span>.log(proxyUser.id);</span><br></pre></td></tr></table></figure><h4 id="9-1-8-2代理与内部槽位"><a href="#9-1-8-2代理与内部槽位" class="headerlink" title="9.1.8.2代理与内部槽位"></a>9.1.8.2<strong>代理与内部槽位</strong></h4><p>代理与内置引用类型（比如<code>Array</code>）的实例通常可以很好地协同，但有些内置类型（比如<code>Date</code>）可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p><p>根据ECMAScript规范，<code>Date</code>类型方法的执行依赖<code>this</code>值上的内部槽位<code>[[NumberDate]]</code>。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的<code>get()</code>和<code>set()</code>操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出<code>TypeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Date</span>);  <span class="comment">// true</span></span><br><span class="line">proxy.getDate();  <span class="comment">// TypeError: &#x27;this&#x27; is not a Date object</span></span><br></pre></td></tr></table></figure><h2 id="9-2-代理捕获器与反射方法"><a href="#9-2-代理捕获器与反射方法" class="headerlink" title="9.2　代理捕获器与反射方法"></a>9.2　代理捕获器与反射方法</h2><p>代理可以捕获13种不同的基本操作。这些操作有各自不同的反射API方法、参数、关联ECMAScript操作和不变式。</p><p>对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</p><p>只要在代理上调用，所有捕获器都会拦截它们对应的反射API操作。</p><h3 id="9-2-1get"><a href="#9-2-1get" class="headerlink" title="9.2.1get()"></a>9.2.1<code>get()</code></h3><p><code>get()</code>捕获器会在获取属性值的操作中被调用。对应的反射API方法为<code>Reflect.get()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.foo;  <span class="comment">// get()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：无限制。</li><li>拦截的操作<ul><li><code>proxy.property</code></li><li><code>proxy[property]</code></li><li><code>Object.create(proxy)[property]</code></li><li><code>Reflect.get(proxy, property, receiver)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>property</code>：引用的目标对象上的字符串键属性。</li><li><code>receiver</code>：代理对象或继承代理对象的对象。</li></ul></li><li>捕获器不变式<ul><li>如果<code>target.property</code>不可写且不可配置，则处理程序返回的值必须与<code>target.property</code>匹配。</li><li>如果<code>target.property</code>不可配置且<code>[[Get]]</code>特性为<code>undefined</code>，处理程序的返回值也必须是<code>undefined</code>。<blockquote><p><strong>注意</strong>严格来讲，property参数除了字符串键，也可能是符（symbol）键。后面几处也一样。</p></blockquote><h3 id="9-2-2set"><a href="#9-2-2set" class="headerlink" title="9.2.2set()"></a>9.2.2<code>set()</code></h3></li></ul></li></ol><p><code>set()</code>捕获器会在设置属性值的操作中被调用。对应的反射API方法为<code>Reflect.set()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.foo = <span class="string">&#x27;bar&#x27;</span>;  <span class="comment">// set()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：<code>true</code>表示成功；<code>false</code>表示失败，严格模式下会抛出<code>TypeError</code>。</li><li>拦截的操作<ul><li><code>proxy.property = value</code></li><li><code>proxy[property] = value</code></li><li><code>Object.create(proxy)[property] = value</code></li><li><code>Reflect.set(proxy, property, value, receiver)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>property</code>：引用的目标对象上的字符串键属性。</li><li><code>value</code>：要赋给属性的值。</li><li><code>receiver</code>：接收最初赋值的对象。</li></ul></li><li>捕获器不变式<ul><li>如果<code>target.property</code>不可写且不可配置，则不能修改目标属性的值。</li><li>如果<code>target.property</code>不可配置且<code>[[Set]]</code>特性为<code>undefined</code>，则不能修改目标属性的值。</li><li>在严格模式下，处理程序中返回<code>false</code>会抛出<code>TypeError</code>。</li></ul></li></ol><h3 id="9-2-3has"><a href="#9-2-3has" class="headerlink" title="9.2.3has()"></a>9.2.3<code>has()</code></h3><p><code>has()</code>捕获器会在<code>in</code>操作符中被调用。对应的反射API方法为<code>Reflect.has()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;has()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy;</span><br><span class="line"><span class="comment">// has()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<ul><li><code>property in proxy</code></li><li><code>property in Object.create(proxy)</code></li><li><code>with(proxy) &#123;(property);&#125;</code></li><li><code>Reflect.has(proxy, property)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>property</code>：引用的目标对象上的字符串键属性。</li></ul></li><li>捕获器不变式<ul><li>如果<code>target.property</code>存在且不可配置，则处理程序必须返回<code>true</code>。</li><li>如果<code>target.property</code>存在且目标对象不可扩展，则处理程序必须返回<code>true</code>。<h3 id="9-2-4defineProperty"><a href="#9-2-4defineProperty" class="headerlink" title="9.2.4defineProperty()"></a>9.2.4<code>defineProperty()</code></h3></li></ul></li></ol><p><code>defineProperty()</code>捕获器会在<code>Object.defineProperty()</code>中被调用。对应的反射API方法为<code>Reflect.defineProperty()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">defineProperty</span>(<span class="params">target, property, descriptor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;defineProperty()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// defineProperty()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<ul><li><code>Object.defineProperty(proxy, property, descriptor)</code></li><li><code>Reflect.defineProperty(proxy, property, descriptor)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>property</code>：引用的目标对象上的字符串键属性。</li><li><code>descriptor</code>：包含可选的<code>enumerable</code>、<code>configurable</code>、<code>writable</code>、<code>value</code>、<code>get</code>和<code>set</code>定义的对象。</li></ul></li><li>捕获器不变式<ul><li>如果目标对象不可扩展，则无法定义属性。</li><li>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。</li><li>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。<h3 id="9-2-5getOwnPropertyDescriptor"><a href="#9-2-5getOwnPropertyDescriptor" class="headerlink" title="9.2.5getOwnPropertyDescriptor()"></a>9.2.5<code>getOwnPropertyDescriptor()</code></h3></li></ul></li></ol><p><code>getOwnPropertyDescriptor()</code>捕获器会在<code>Object.getOwnPropertyDescriptor()</code>中被调用。对应的反射API方法为<code>Reflect.getOwnPropertyDescriptor()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;getOwnPropertyDescriptor()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// getOwnPropertyDescriptor()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：属性不存在时返回<code>undefined</code>，否则必须返回对象。</li><li>拦截的操作<ul><li><code>Object.getOwnPropertyDescriptor(proxy, property)</code></li><li><code>Reflect.getOwnPropertyDescriptor(proxy, property)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>property</code>：引用的目标对象上的字符串键属性。</li></ul></li><li>捕获器不变式<ul><li>如果自有的<code>target.property</code>存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。</li><li>如果自有的<code>target.property</code>存在且可配置，则处理程序必须返回表示该属性可配置的对象。</li><li>如果自有的<code>target.property</code>存在且<code>target</code>不可扩展，则处理程序必须返回一个表示该属性存在的对象。</li><li>如果<code>target.property</code>不存在且<code>target</code>不可扩展，则处理程序必须返回<code>undefined</code>表示该属性不存在。</li><li>如果<code>target.property</code>不存在，则处理程序不能返回表示该属性可配置的对象。<h3 id="9-2-6deleteProperty"><a href="#9-2-6deleteProperty" class="headerlink" title="9.2.6deleteProperty()"></a>9.2.6<code>deleteProperty()</code></h3></li></ul></li></ol><p><code>deleteProperty()</code>捕获器会在<code>delete</code>操作符中被调用。对应的反射API方法为<code>Reflect.deleteProperty()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;deleteProperty()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> proxy.foo  <span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<ul><li><code>delete proxy.property</code></li><li><code>delete proxy[property]</code></li><li><code>Reflect.deleteProperty(proxy, property)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>property</code>：引用的目标对象上的字符串键属性。</li></ul></li><li>捕获器不变式<ul><li>如果自有的<code>target.property</code>存在且不可配置，则处理程序不能删除这个属性。<h3 id="9-2-7ownKeys"><a href="#9-2-7ownKeys" class="headerlink" title="9.2.7ownKeys()"></a>9.2.7<code>ownKeys()</code></h3></li></ul></li></ol><p><code>ownKeys()</code>捕获器会在<code>Object.keys()</code>及类似方法中被调用。对应的反射API方法为<code>Reflect.ownKeys()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ownKeys()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.keys(proxy);  <span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：<code>ownKeys()</code>必须返回包含字符串或符号的可枚举对象。</li><li>拦截的操作<ul><li><code>Object.getOwnPropertyNames(proxy)</code></li><li><code>Object.getOwnPropertySymbols(proxy)</code></li><li><code>Object.keys(proxy)</code></li><li><code>Reflect.ownKeys(proxy)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li></ul></li><li>捕获器不变式<ul><li>返回的可枚举对象必须包含<code>target</code>的所有不可配置的自有属性。</li><li>如果<code>target</code>不可扩展，则返回可枚举对象必须准确地包含自有属性键。<h3 id="9-2-8getPrototypeOf"><a href="#9-2-8getPrototypeOf" class="headerlink" title="9.2.8getPrototypeOf()"></a>9.2.8<code>getPrototypeOf()</code></h3></li></ul></li></ol><p><code>getPrototypeOf()</code>捕获器会在<code>Object.getPrototypeOf()</code>中被调用。对应的反射API方法为<code>Reflect.getPrototypeOf()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">getPrototypeOf</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;getPrototypeOf()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(proxy);  <span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：<code>getPrototypeOf()</code>必须返回对象或<code>null</code>。</li><li>拦截的操作<ul><li><code>Object.getPrototypeOf(proxy)</code></li><li><code>Reflect.getPrototypeOf(proxy)</code></li><li><code>proxy.__proto__</code></li><li><code>Object.prototype.isPrototypeOf(proxy)</code></li><li><code>proxy instanceof Object</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li></ul></li><li>捕获器不变式<ul><li>如果<code>target</code>不可扩展，则<code>Object.getPrototypeOf(proxy)</code>唯一有效的返回值就是<code>Object.getPrototypeOf(target)</code>的返回值。<h3 id="9-2-9setPrototypeOf"><a href="#9-2-9setPrototypeOf" class="headerlink" title="9.2.9setPrototypeOf()"></a>9.2.9<code>setPrototypeOf()</code></h3></li></ul></li></ol><p><code>setPrototypeOf()</code>捕获器会在<code>Object.setPrototypeOf()</code>中被调用。对应的反射API方法为<code>Reflect.setPrototypeOf()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">setPrototypeOf</span>(<span class="params">target, prototype</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setPrototypeOf()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, <span class="built_in">Object</span>);  <span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<ul><li><code>Object.setPrototypeOf(proxy)</code></li><li><code>Reflect.setPrototypeOf(proxy)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>prototype</code>：<code>target</code>的替代原型，如果是顶级原型则为<code>null</code>。</li></ul></li><li>捕获器不变式<ul><li>若<code>target</code>不可扩展，则唯一有效的<code>prototype</code>参数就是<code>Object.getPrototypeOf(target)</code>的返回值。<h3 id="9-2-10isExtensible"><a href="#9-2-10isExtensible" class="headerlink" title="9.2.10isExtensible()"></a>9.2.10<code>isExtensible()</code></h3></li></ul></li></ol><p><code>isExtensible()</code>捕获器会在<code>Object.isExtensible()</code>中被调用。对应的反射API方法为<code>Reflect.isExtensible()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">isExtensible</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;isExtensible()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(proxy);</span><br><span class="line"><span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回布尔值，表示<code>target</code>是否可扩展。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<ul><li><code>Object.isExtensible(proxy)</code></li><li><code>Reflect.isExtensible(proxy)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li></ul></li><li>捕获器不变式<ul><li>如果<code>target</code>可扩展，则处理程序必须返回<code>true</code>。</li><li>如果<code>target</code>不可扩展，则处理程序必须返回<code>false</code>。<h3 id="9-2-11preventExtensions"><a href="#9-2-11preventExtensions" class="headerlink" title="9.2.11preventExtensions()"></a>9.2.11<code>preventExtensions()</code></h3></li></ul></li></ol><p><code>preventExtensions()</code>捕获器会在<code>Object.preventExtensions()</code>中被调用。对应的反射API方法为<code>Reflect.preventExtensions()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">preventExtensions</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;preventExtensions()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</span><br><span class="line"><span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回布尔值，表示<code>target</code>是否已经不可扩展。返回非布尔值会被转型为布尔值。</li><li>拦截的操作<ul><li><code>Object.preventExtensions(proxy)</code></li><li><code>Reflect.preventExtensions(proxy)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li></ul></li><li>捕获器不变式<ul><li>如果<code>Object.isExtensible(proxy)</code>是<code>false</code>，则处理程序必须返回<code>true</code>。<h3 id="9-2-12apply"><a href="#9-2-12apply" class="headerlink" title="9.2.12apply()"></a>9.2.12<code>apply()</code></h3></li></ul></li></ol><p><code>apply()</code>捕获器会在调用函数时中被调用。对应的反射API方法为<code>Reflect.apply()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, ...argumentsList</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;apply()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy();  <span class="comment">// apply()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：返回值无限制。</li><li>拦截的操作<ul><li><code>proxy(...argumentsList)</code></li><li><code>Function.prototype.apply(thisArg, argumentsList)</code></li><li><code>Function.prototype.call(thisArg, ...argumentsList)</code></li><li><code>Reflect.apply(target, thisArgument, argumentsList)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标对象。</li><li><code>thisArg</code>：调用函数时的<code>this</code>参数。</li><li><code>argumentsList</code>：调用函数时的参数列表</li></ul></li><li>捕获器不变式<ul><li><code>target</code>必须是一个函数对象。<h3 id="9-2-13construct"><a href="#9-2-13construct" class="headerlink" title="9.2.13construct()"></a>9.2.13<code>construct()</code></h3></li></ul></li></ol><p><code>construct()</code>捕获器会在<code>new</code>操作符中被调用。对应的反射API方法为<code>Reflect.construct()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="function"><span class="title">construct</span>(<span class="params">target, argumentsList, newTarget</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;construct()&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy;</span><br><span class="line"><span class="comment">// construct()</span></span><br></pre></td></tr></table></figure><ol><li>返回值：必须返回一个对象。</li><li>拦截的操作<ul><li><code>new proxy(...argumentsList)</code></li><li><code>Reflect.construct(target, argumentsList, newTarget)</code></li></ul></li><li>捕获器处理程序参数<ul><li><code>target</code>：目标构造函数。</li><li><code>argumentsList</code>：传给目标构造函数的参数列表。</li><li><code>newTarget</code>：最初被调用的构造函数。</li></ul></li><li>捕获器不变式<ul><li><code>target</code>必须可以用作构造函数。<h2 id="9-3-代理模式"><a href="#9-3-代理模式" class="headerlink" title="9.3　代理模式"></a>9.3　代理模式</h2></li></ul></li></ol><p>使用代理可以在代码中实现一些有用的编程模式。</p><h3 id="9-3-1-跟踪属性访问"><a href="#9-3-1-跟踪属性访问" class="headerlink" title="9.3.1　跟踪属性访问"></a>9.3.1　跟踪属性访问</h3><p>通过捕获<code>get</code>、<code>set</code>和<code>has</code>等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.name;     <span class="comment">// Getting name</span></span><br><span class="line">proxy.age = <span class="number">27</span>; <span class="comment">// Setting age=27</span></span><br></pre></td></tr></table></figure><h3 id="9-3-2-隐藏属性"><a href="#9-3-2-隐藏属性" class="headerlink" title="9.3.2　隐藏属性"></a>9.3.2　隐藏属性</h3><p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  baz: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetObject, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.includes(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.includes(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// get()</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.bar);  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.baz);  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// has()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> proxy);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span> <span class="keyword">in</span> proxy);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span> <span class="keyword">in</span> proxy);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="9-3-3-属性验证"><a href="#9-3-3-属性验证" class="headerlink" title="9.3.3　属性验证"></a>9.3.3　属性验证</h3><p>因为所有赋值操作都会触发<code>set()</code>捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  onlyNumbersGoHere: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.onlyNumbersGoHere = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.onlyNumbersGoHere);  <span class="comment">// 1</span></span><br><span class="line">proxy.onlyNumbersGoHere = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.onlyNumbersGoHere);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="9-3-4-函数与构造函数参数验证"><a href="#9-3-4-函数与构造函数参数验证" class="headerlink" title="9.3.4　函数与构造函数参数验证"></a>9.3.4　函数与构造函数参数验证</h3><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">median</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.sort()[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(median, &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, argumentsList</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Non-number argument provided&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>));  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">4</span>, <span class="string">&#x27;7&#x27;</span>, <span class="number">1</span>));<span class="comment">//Error: Non-number argument provided</span></span><br></pre></td></tr></table></figure><p>类似地，可以要求实例化时必须给构造函数传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id_ = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  <span class="function"><span class="title">construct</span>(<span class="params">target, argumentsList, newTarget</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;User cannot be instantiated without id&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> proxy();  <span class="comment">// Error: User cannot be instantiated without id</span></span><br></pre></td></tr></table></figure><h3 id="9-3-5-数据绑定与可观察对象"><a href="#9-3-5-数据绑定与可观察对象" class="headerlink" title="9.3.5　数据绑定与可观察对象"></a>9.3.5　数据绑定与可观察对象</h3><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。</p><p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name_ = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;</span><br><span class="line">  <span class="function"><span class="title">construct</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="built_in">Reflect</span>.construct(...arguments);</span><br><span class="line">    userList.push(newUser);</span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">&#x27;Jacob&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">&#x27;Jingleheimerschmidt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(userList); <span class="comment">// [User &#123;&#125;, User &#123;&#125;, User&#123;&#125;]</span></span><br></pre></td></tr></table></figure><p>另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(newValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(userList, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      emit(<span class="built_in">Reflect</span>.get(target, property, receiver));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.push(<span class="string">&#x27;John&#x27;</span>);  <span class="comment">// John</span></span><br><span class="line">proxy.push(<span class="string">&#x27;Jacob&#x27;</span>); <span class="comment">// Jacob</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ECMAScript 6新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。&lt;/p&gt;
&lt;bl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>08-对象、类与面向对象编程</title>
    <link href="http://example.com/2021/04/07/note/JavaScript/08-%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/04/07/note/JavaScript/08-%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2021-04-07T14:21:33.811Z</published>
    <updated>2021-06-05T15:08:15.780Z</updated>
    
    <content type="html"><![CDATA[<p>对象：一组属性的无序集合。这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。</p><h2 id="8-1-理解对象"><a href="#8-1-理解对象" class="headerlink" title="8.1　理解对象"></a>8.1　理解对象</h2><p>创建自定义对象的通常方式是创建<code>Object</code>的一个新实例，然后通过点语法再给它添加属性和方法。现在对象字面量创建更流行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherPerson = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-1-1-属性的类型"><a href="#8-1-1-属性的类型" class="headerlink" title="8.1.1　属性的类型"></a>8.1.1　属性的类型</h3><p>一些内部特性用来描述属性的特征，由JavaScript实现引擎的规范定义的。因此不能在JavaScript中直接访问。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如<code>[[Enumerable]]</code>。</p><p>属性分两种：数据属性和访问器属性。</p><h4 id="8-1-1-1-数据属性"><a href="#8-1-1-1-数据属性" class="headerlink" title="8.1.1.1   数据属性"></a><strong>8.1.1.1   数据属性</strong></h4><p>数据属性包含一个保存数据值的位置，并从这个位置读写。数据属性有4个特性描述它们的行为。</p><ul><li><code>[[Configurable]]</code>：表示属性是否可以通过<code>delete</code>删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li><li><code>[[Enumerable]]</code>：表示属性是否可以通过<code>for-in</code>循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li><li><code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是<code>true</code>。</li><li><code>[[Value]]</code>：包含属性实际的值。这个特性的默认值为<code>undefined</code>。</li></ul><p>要修改属性的默认特性，必须使用<code>Object.defineProperty()</code>方法。接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，描述符对象上的属性可以包含：<code>configurable</code>、<code>enumerable</code>、<code>writable</code>和<code>value</code>。根据要修改的特性，可以设置其中一个或多个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;，严格模式下会抛错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherPerson = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(otherPerson, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(otherPerson.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">delete</span> otherPerson.name;</span><br><span class="line"><span class="built_in">console</span>.log(otherPerson.name); <span class="comment">// &quot;Nicholas&quot;，严格模式下会抛错</span></span><br></pre></td></tr></table></figure><p>虽然可以对同一个属性多次调用<code>Object.defineProperty()</code>，但在把<code>configurable</code>设置为<code>false</code>之后，就不能再变回可配置的了。并且再次调用<code>Object.defineProperty()</code>修改除<code>writable</code>以外的属性会导致错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在调用<code>Object.defineProperty()</code>定义一个新的属性特性，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>的值如果不指定，则都将默认改为<code>false</code>。</p><h4 id="8-1-1-2-访问器属性"><a href="#8-1-1-2-访问器属性" class="headerlink" title="8.1.1.2   访问器属性"></a><strong>8.1.1.2   访问器属性</strong></h4><p>访问器属性不包含数据值，它们包含一个非必需的获取（getter）函数和设置（setter）函数。访问器属性有4个特性描述它们的行为：</p><ul><li><code>[[Configurable]]</code>：同数据属性。</li><li><code>[[Enumerable]]</code>：同数据属性。</li><li><code>[[Get]]</code>：获取函数，在读取属性时调用。默认值为<code>undefined</code>。</li><li><code>[[Set]]</code>：设置函数，在写入属性时调用。默认值为<code>undefined</code>。</li></ul><p>访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员year_和公共成员edition</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  year_: <span class="number">2017</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">      <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2018</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>只定义获取函数意味着属性是只读的，尝试修改属性会被忽略，在严格模式下抛错。只有一个设置函数的属性是不能读取的，非严格模式下读取会返回<code>undefined</code>，严格模式下抛错。</p><h3 id="8-1-2-定义多个属性"><a href="#8-1-2-定义多个属性" class="headerlink" title="8.1.2　定义多个属性"></a>8.1.2　定义多个属性</h3><p><code>Object.defineProperties()</code>，在一个对象上通过多个描述符一次性定义多个属性。接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  year_: &#123;</span><br><span class="line">    value: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-1-3-读取属性的特性"><a href="#8-1-3-读取属性的特性" class="headerlink" title="8.1.3　读取属性的特性"></a>8.1.3　读取属性的特性</h3><p>使用<code>Object.getOwnPropertyDescriptor()</code>方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，根据访问器属性和数据属性包含的值不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  year_: &#123;</span><br><span class="line">    value: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.year_;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.year_ = newValue;</span><br><span class="line">        <span class="built_in">this</span>.edition += newValue - <span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);          <span class="comment">// 2017</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);     <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);          <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable);     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get);     <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors()</code>会在每个自有属性上调用<code>Object.getOwnPropertyDescriptor()</code>并在一个新对象中返回它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//book属性定义同上</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(book));</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   edition: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     value: 1,</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   year: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     get: f(),</span></span><br><span class="line"><span class="comment">//     set: f(newValue),</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   year_: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: false,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     value: 2017,</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="8-1-4-合并对象"><a href="#8-1-4-合并对象" class="headerlink" title="8.1.4　合并对象"></a>8.1.4　合并对象</h3><p>合并两个对象就是把源对象所有的本地属性一起复制到目标对象上，这种操作也被称为“混入”，因为目标对象通过混入源对象的属性得到了增强。</p><p><code>Object.assign()</code>用于合并对象，这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中<code>Object.propertyIsEnumerable()</code>返回<code>true</code>的可枚举和<code>object.hasOwnProperty()</code>返回<code>true</code>的自有属性复制到目标对象。以字符串和符号为键的属性会被复制。对符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象上的<code>[[Set]]</code>设置属性的值，返回值为目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">&#x27;src&#x27;</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(dest === src);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取函数与设置函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Invoked src getter&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// Invoked src getter</span></span><br><span class="line"><span class="comment">// Invoked dest setter with param foo</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作，所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>对每个源对象执行的是浅复制，如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。也就是说，不能在两个对象间转移获取函数和设置函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123; <span class="attr">id</span>: <span class="string">&#x27;dest&#x27;</span> &#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;src1&#x27;</span>, <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;src2&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// Object.assign会覆盖重复的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; id: src2, a: foo, b: bar &#125;</span></span><br><span class="line"><span class="comment">// 可以通过目标对象上的设置函数观察到覆盖的过程：</span></span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">id</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, &#123; <span class="attr">id</span>: <span class="string">&#x27;first&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;second&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&#x27;third&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest);              <span class="comment">// &#123; a :&#123;&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest.a === src.a);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。同时不会回滚之前的赋值，因此这个方法只会完成部分复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  a: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">b</span>() &#123;</span><br><span class="line">    <span class="comment">// Object.assign()在调用这个获取函数时会抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.assign(dest, src);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="comment">// Object.assign()没办法回滚已经完成的修改</span></span><br><span class="line"><span class="comment">// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a: foo &#125;</span></span><br></pre></td></tr></table></figure><h3 id="8-1-5-对象标识及相等判定"><a href="#8-1-5-对象标识及相等判定" class="headerlink" title="8.1.5　对象标识及相等判定"></a>8.1.5　对象标识及相等判定</h3><p>在<code>ES6</code>之前，有些特殊情况即使是<code>===</code>操作符也无能为力，因此提供<code>Object.is()</code>方法，必须接收两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === -<span class="number">0</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">0</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">0</span> === <span class="number">0</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 只有使用isNaN()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要检查超过两个值，递归地利用相等性传递即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursivelyCheckEqual</span>(<span class="params">x, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.is(x, rest[<span class="number">0</span>]) &amp;&amp; (rest.length &lt; <span class="number">2</span> || recursivelyCheckEqual(...rest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-6-增强的对象语法"><a href="#8-1-6-增强的对象语法" class="headerlink" title="8.1.6　增强的对象语法"></a>8.1.6　增强的对象语法</h3><h4 id="8-1-6-1-属性值简写"><a href="#8-1-6-1-属性值简写" class="headerlink" title="8.1.6.1   属性值简写"></a><strong>8.1.6.1   属性值简写</strong></h4><p>在给对象添加变量的时候，经常发现属性名和变量名是一样的，而简写属性名只要使用变量名就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出<code>ReferenceError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = makePerson(<span class="string">&#x27;Matt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure><h4 id="8-1-6-2-可计算属性"><a href="#8-1-6-2-可计算属性" class="headerlink" title="8.1.6.2   可计算属性"></a><strong>8.1.6.2   可计算属性</strong></h4><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。也就是说，不能在对象字面量中直接动态命名属性。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[nameKey] = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JavaScript表达式而不是字符串来求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [nameKey]: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Matt&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>因为被当作JavaScript表达式求值，所以可计算属性可以是复杂的表达式，在实例化时再求值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUniqueKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [getUniqueKey(nameKey)]: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  [getUniqueKey(ageKey)]: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person);  <span class="comment">// &#123; name_0: &#x27;Matt&#x27;, age_1: 27 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 可计算属性表达式中抛出任何错误都会中断对象创建。如果表达式抛出错误，那么之前完成的计算是不能回滚的。</p></blockquote><p><strong>8.1.6.3   简写方法名</strong></p><p>在给对象定义方法时，之前通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新的简写方法的语法可以缩短方法声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简写方法名对获取函数和设置函数也是适用的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name_: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name_ = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name_&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简写方法名与可计算属性键相互兼容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&#x27;sayName&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [methodKey](name) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-7-对象解构"><a href="#8-1-7-对象解构" class="headerlink" title="8.1.7　对象解构"></a>8.1.7　对象解构</h3><p>对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName = person.name,</span><br><span class="line">    personAge = person.age;</span><br></pre></td></tr></table></figure><p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对象解构</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(personName);  <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(personAge);   <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>如果想让变量直接使用属性的名称，那么还可以使用简写语法。解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是<code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age, job&#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(age);   <span class="comment">// 27</span></span><br><span class="line"><span class="built_in">console</span>.log(job);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, job=<span class="string">&#x27;Software engineer&#x27;</span> &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(job);  <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure><p>解构在内部使用函数<code>ToObject()</code>（不能在运行时环境中直接访问）把源数据结构转换为对象。这意味着在对象解构的上下文中，原始值会被当成对象。根据<code>ToObject()</code>的定义，<code>null</code>和<code>undefined</code>不能被解构，否则会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; length &#125; = <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(length);        <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">constructor</span>: c &#125; = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);      <span class="comment">// function</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">null</span>;           <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; _ &#125; = <span class="literal">undefined</span>;      <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>解构并不要求变量必须在解构表达式中声明。但如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personName, personAge;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line">(&#123;<span class="attr">name</span>: personName, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line"><span class="built_in">console</span>.log(personName, personAge); <span class="comment">// Matt, 27</span></span><br></pre></td></tr></table></figure><h4 id="8-1-7-1-嵌套解构"><a href="#8-1-7-1-嵌套解构" class="headerlink" title="8.1.7.1   嵌套解构"></a><strong>8.1.7.1   嵌套解构</strong></h4><p>解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line">　</span><br><span class="line">(&#123;</span><br><span class="line">  name: personCopy.name,</span><br><span class="line">  job: personCopy.job</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// 浅复制</span></span><br><span class="line">person.name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line">person.job.title = <span class="string">&#x27;Hacker&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;Jack&#x27;, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(personCopy);<span class="comment">//&#123; name: &#x27;Matt&#x27;, job: &#123; title: &#x27;Hacker&#x27; &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>解构赋值可以使用嵌套结构，以匹配嵌套的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(title); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure><p>在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: <span class="string">&#x27;Software engineer&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// job在目标对象上是undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">  job: &#123;</span><br><span class="line">    title: personCopy.job.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;title&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo在源对象上是undefined</span></span><br><span class="line">(&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: personCopy.bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = person);</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property &#x27;bar&#x27; of &#x27;undefined&#x27; or &#x27;null&#x27;.</span></span><br></pre></td></tr></table></figure><h4 id="8-1-7-2-部分解构"><a href="#8-1-7-2-部分解构" class="headerlink" title="8.1.7.2   部分解构"></a><strong>8.1.7.2   部分解构</strong></h4><p>涉及多个属性的解构赋值是一个输出无关的顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// person.foo是undefined，因此会抛出错误</span></span><br><span class="line">  (&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(personName, personBar, personAge);</span><br><span class="line"><span class="comment">// Matt, undefined, undefined</span></span><br></pre></td></tr></table></figure><h4 id="8-1-7-3-参数上下文匹配"><a href="#8-1-7-3-参数上下文匹配" class="headerlink" title="8.1.7.3   参数上下文匹配"></a><strong>8.1.7.3   参数上下文匹配</strong></h4><p>在函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响<code>arguments</code>对象，但可以在函数签名中声明在函数体内使用局部变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span>,</span><br><span class="line">  age: <span class="number">27</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson</span>(<span class="params">foo, &#123;name, age&#125;, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printPerson2</span>(<span class="params">foo, &#123;name: personName, age: personAge&#125;, bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(personName, personAge);</span><br><span class="line">&#125;</span><br><span class="line">printPerson(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#x27;1st&#x27;, &#123; name: &#x27;Matt&#x27;, age: 27 &#125;, &#x27;2nd&#x27;]</span></span><br><span class="line"><span class="comment">// &#x27;Matt&#x27;, 27</span></span><br><span class="line">printPerson2(<span class="string">&#x27;1st&#x27;</span>, person, <span class="string">&#x27;2nd&#x27;</span>);</span><br><span class="line"><span class="comment">// 与上面打印相同</span></span><br></pre></td></tr></table></figure><h2 id="8-2-创建对象"><a href="#8-2-创建对象" class="headerlink" title="8.2　创建对象"></a>8.2　创建对象</h2><p>使用<code>Object</code>构造函数或对象字面量可以方便地创建对象，但不足在于创建具有同样接口的多个对象需要重复编写很多代码。</p><h3 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1　概述"></a>8.2.1　概述</h3><p><code>ECMAScript 5.1</code>没有正式支持面向对象的结构，比如类或继承，但是运用原型式继承可以成功地模拟同样的行为。<code>ES6</code>开始正式支持类和继承，不过是封装了<code>ES5.1</code>构造函数加原型继承的语法糖。</p><h3 id="8-2-2-工厂模式"><a href="#8-2-2-工厂模式" class="headerlink" title="8.2.2　工厂模式"></a>8.2.2　工厂模式</h3><p>工厂模式是一种设计模式，用于抽象创建特定对象的过程，但没有解决对象标识问题，即新创建的对象是什么类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure><h3 id="8-2-3-构造函数模式"><a href="#8-2-3-构造函数模式" class="headerlink" title="8.2.3　构造函数模式"></a>8.2.3　构造函数模式</h3><p>构造函数是用于创建特定类型对象的。比如像<code>Object</code>和<code>Array</code>这样的原生构造函数。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。有助于区分构造函数和普通函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure><p>实际上，<code>Person()</code>内部的代码跟<code>createPerson()</code>基本是一样的，只是有如下区别：</p><ul><li>没有显式地创建对象。</li><li>属性和方法直接赋值给了<code>this</code>。</li><li>没有<code>return</code>。</li></ul><p>要创建<code>Person</code>的实例，应使用<code>new</code>操作符。以这种方式调用构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性。</li><li>构造函数内部的<code>this</code>被赋值为这个新对象。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><p><code>person1</code>和<code>person2</code>分别保存着<code>Person</code>的不同实例。这两个对象都有一个从原型上继承的<code>constructor</code>属性指向<code>Person</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>constructor</code>本来是用于标识对象类型的。不过，一般将<code>instanceof</code>操作符用于确定对象类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>定义自定义构造函数可以确保实例被标识为特定类型，构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br></pre></td></tr></table></figure><p>在实例化时，如果不想传参数，那么构造函数后面的括号可以不加。只要有<code>new</code>操作符，就可以调用相应的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><h4 id="8-2-3-1-构造函数也是函数"><a href="#8-2-3-1-构造函数也是函数" class="headerlink" title="8.2.3.1   构造函数也是函数"></a><strong>8.2.3.1   构造函数也是函数</strong></h4><p>构造函数与普通函数唯一的区别就是调用方式不同。构造函数也是函数，任何函数只要使用<code>new</code>操作符调用就是构造函数，否则就是普通函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">person.sayName();    <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line">Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);   <span class="comment">// 添加到window对象</span></span><br><span class="line"><span class="built_in">window</span>.sayName();    <span class="comment">// &quot;Greg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">&quot;Kristen&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.sayName();   <span class="comment">// &quot;Kristen&quot;</span></span><br></pre></td></tr></table></figure><p>在调用一个函数而没有明确设置<code>this</code>值的情况下，<code>this</code>始终指向<code>Global</code>对象（在浏览器中就是<code>window</code>对象）。通过<code>call()</code>或<code>apply()</code>调用函数，将特定对象指定为作用域。这里的调用将<code>Person()</code>内部的<code>this</code>值指向对象<code>o</code>。</p><h4 id="8-2-3-2-构造函数的问题"><a href="#8-2-3-2-构造函数的问题" class="headerlink" title="8.2.3.2   构造函数的问题"></a><strong>8.2.3.2   构造函数的问题</strong></h4><p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。函数也是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;console.log(this.name)&quot;</span>); <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不同实例上的函数虽然同名却不相等，但都是做一样的事，所以没必要定义两个不同的<code>Function</code>实例。况且，<code>this</code>对象可以把函数与对象的绑定推迟到运行时，因此可以把函数定义转移到构造函数外部，来解决这个问题，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">person1.sayName();  <span class="comment">// Nicholas</span></span><br><span class="line">person2.sayName();  <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure><p>这样解决了相同逻辑的函数重复定义的问题，但如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数，这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过下面的原型模式来解决。</p><h3 id="8-2-4-原型模式"><a href="#8-2-4-原型模式" class="headerlink" title="8.2.4　原型模式"></a>8.2.4　原型模式</h3><p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。这个对象也就是通过调用构造函数创建的对象的原型，在原型上面定义的属性和方法可以被对象实例共享。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">//使用函数表达式let Person = function() &#123;&#125;也可以</span></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="8-2-4-1-理解原型"><a href="#8-2-4-1-理解原型" class="headerlink" title="8.2.4.1   理解原型"></a><strong>8.2.4.1   理解原型</strong></h4><p>只要创建一个函数，就会为这个函数创建一个<code>prototype</code>属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。<code>Person.prototype.constructor</code>指向<code>Person</code>。</p><p>在自定义构造函数时，原型对象默认只会获得<code>constructor</code>属性，其他的所有方法都继承自<code>Object</code>。每次调用构造函数创建一个新实例，这个实例的内部<code>[[Prototype]]</code>指针就会被赋值为构造函数的原型对象，通过访问实例<code>__proto__</code>属性，可以访问实例的原型。实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明之后，构造函数就有了一个与之关联的原型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   constructor: f Person(),</span></span><br><span class="line"><span class="comment">//   __proto__: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正常的原型链都会终止于Object的原型对象</span></span><br><span class="line"><span class="comment"> * Object原型的原型是null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line">　</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数、原型对象和实例</span></span><br><span class="line"><span class="comment"> * 是3个完全不同的对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 !== Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype !== Person);  <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实例通过__proto__链接到原型对象，它实际上指向隐藏特性[[Prototype]]</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 构造函数通过prototype属性链接到原型对象</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype);   <span class="comment">// true</span></span><br><span class="line">conosle.log(person1.__proto__.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同一个构造函数创建的两个实例</span></span><br><span class="line"><span class="comment"> * 共享同一个原型对象：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === person2.__proto__); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * instanceof检查实例的原型链中是否包含指定构造函数的原型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/06/04/kHADlZVtqBh3TpR.png"                      alt="010.png"                ></p><p><strong>图　8-1</strong></p><p>原型可以使用<code>isPrototypeOf()</code>方法确定一个实例的原型链中指向它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.getPrototypeOf()</code>，返回参数的内部特性<code>[[Prototype]]</code>的值，也就是参数的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.setPrototypeOf()</code>，可以向实例的<code>[[Prototype]]</code>写入一个新值。这样就可以重写一个对象的原型继承关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line">  numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, biped);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);                              <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);                           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.setPrototypeOf()</code>会造成性能下降，因此可以通过<code>Object.create()</code>来创建一个新对象，同时将参数指定为原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biped = &#123;</span><br><span class="line">  numLegs: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(biped);</span><br><span class="line">person.name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);                              <span class="comment">// Matt</span></span><br><span class="line"><span class="built_in">console</span>.log(person.numLegs);                           <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === biped);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="8-2-4-2-原型层级"><a href="#8-2-4-2-原型层级" class="headerlink" title="8.2.4.2   原型层级"></a><strong>8.2.4.2   原型层级</strong></h4><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身，如果存在则返回对应的值，否则搜索会沿着指针进入原型对象，再返回对应的值。这就是原型用于在多个对象实例间共享属性和方法的原理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);  <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure><p>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。给对象实例添加一个和原型的同名属性，不会修改原型上的同名属性，但会屏蔽访问。即使在实例上把这个属性设置为<code>null</code>，也不会恢复它和原型的联系。不过使用<code>delete</code>操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line">person1.name = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// null，来自实例</span></span><br><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name);  <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br></pre></td></tr></table></figure><p><code>hasOwnProperty()</code>方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自<code>Object</code>的，会在属性存在于调用它的对象实例上时返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> <code>Object.getOwnPropertyDescriptor()</code>方法只对实例属性有效。要取得原型属性的描述符，就必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>。</p></blockquote><h4 id="8-2-4-3-原型和in操作符"><a href="#8-2-4-3-原型和in操作符" class="headerlink" title="8.2.4.3   原型和in操作符"></a><strong>8.2.4.3   原型和</strong><code>in</code>操作符</h4><p>有两种方式使用<code>in</code>操作符：单独使用和在<code>for-in</code>循环中使用。在单独使用时，<code>in</code>操作符会在可以通过对象访问指定属性时返回<code>true</code>，无论该属性是在实例还是在原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// &quot;Greg&quot;，来自实例</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// &quot;Nicholas&quot;，来自原型</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用<code>hasOwnProperty()</code>和<code>in</code>操作符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>for-in</code>循环中使用<code>in</code>操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中<code>[[Enumerable]]</code>特性被设置为<code>false</code>的不可枚举属性。</p><p>要获得对象上所有可枚举的实例属性，可以使用<code>Object.keys()</code>，接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(Person.prototype));   <span class="comment">// [name, age, sayName]</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(p1)); <span class="comment">// [name,age]</span></span><br></pre></td></tr></table></figure><p>如果想列出所有实例属性，无论是否可以枚举，可以使用<code>Object.getOwnPropertyNames()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys);   <span class="comment">// &quot;[constructor, name, age, sayName]&quot;</span></span><br></pre></td></tr></table></figure><p><code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>在适当的时候都可用来代替<code>for-in</code>循环。<code>Object.getOwnPropertySymbols()</code>，这个方法与<code>Object.getOwnPropertyNames()</code>类似，只是针对符号而已：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  [k1]: <span class="string">&#x27;k1&#x27;</span>,</span><br><span class="line">  [k2]: <span class="string">&#x27;k2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure><h4 id="8-2-4-4-属性枚举顺序"><a href="#8-2-4-4-属性枚举顺序" class="headerlink" title="8.2.4.4    属性枚举顺序"></a>8.2.4.4    <strong>属性枚举顺序</strong></h4><p><code>for-in</code>循环和<code>Object.keys()</code>的枚举顺序是不确定的，因浏览器而异，取决于JavaScript引擎。<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>和<code>Object.assign()</code>的枚举顺序是确定性的，先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">  first: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">  [k1]: <span class="string">&#x27;sym2&#x27;</span>,</span><br><span class="line">  second: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.third = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure><h3 id="8-2-5-对象迭代"><a href="#8-2-5-对象迭代" class="headerlink" title="8.2.5　对象迭代"></a>8.2.5　对象迭代</h3><p><code>Object.values()</code>和<code>Object.entries()</code>用于将对象内容转换为序列化可迭代的格式，接收一个对象，返回它们内容的数组。<code>Object.values()</code>返回对象值的数组，<code>Object.entries()</code>返回键/值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="number">1</span>,</span><br><span class="line">  qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));   <span class="comment">// [&quot;bar&quot;, 1, &#123;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));  <span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure><p>非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  qux: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)[<span class="number">0</span>] === o.qux);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)[<span class="number">0</span>][<span class="number">1</span>] === o.qux);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>符号属性会被忽略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  [sym]: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));  <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="8-2-5-1-其他原型语法"><a href="#8-2-5-1-其他原型语法" class="headerlink" title="8.2.5.1   其他原型语法"></a><strong>8.2.5.1   其他原型语法</strong></h4><p>在前面的例子中，每次定义一个属性或方法都会把<code>Person.prototype</code>重写一遍。为减少代码冗余，也为了从视觉上更好地封装原型功能，通常直接通过一个包含所有属性和方法的对象字面量来重写原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这样会出现新问题：重写后，<code>Person.prototype</code>的<code>constructor</code>属性就不再指向<code>Person</code>，而是<code>Object</code>构造函数。虽然<code>instanceof</code>操作符还能可靠地返回值，但不能再依靠<code>constructor</code>属性来识别类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person);      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果<code>constructor</code>的值很重要，则可以在重写原型对象时专门设置一下它的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 29,</span><br><span class="line">  <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">  <span class="title">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但以这种方式恢复<code>constructor</code>属性会创建一个<code>[[Enumerable]]</code>为<code>true</code>的属性。而原生<code>constructor</code>属性默认是不可枚举的。因此可以改为使用<code>Object.defineProperty()</code>方法来定义<code>constructor</code>属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 恢复constructor属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="8-2-5-2-原型的动态性"><a href="#8-2-5-2-原型的动态性" class="headerlink" title="8.2.5.2   原型的动态性"></a>8.2.5.2   <strong>原型的动态性</strong></h4><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();   <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但重写整个原型就不一样了。实例的<code>[[Prototype]]</code>指针是在调用构造函数时自动赋值的，重写构造函数上的原型之后再创建的实例会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 29,</span><br><span class="line">  <span class="title">job</span>: &quot;<span class="title">Software</span> <span class="title">Engineer</span>&quot;,</span><br><span class="line">  <span class="title">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName();  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/04/07/cA47BbhJuiXvdQs.png"                      alt="012.png"                ></p><p><strong>图　8-3</strong></p><h4 id="8-2-5-3-原生对象原型"><a href="#8-2-5-3-原生对象原型" class="headerlink" title="8.2.5.3   原生对象原型"></a><strong>8.2.5.3   原生对象原型</strong></h4><p>原型模式，不仅体现在自定义类型上，所有原生引用类型的构造函数（包括<code>Object</code>、<code>Array</code>、<code>String</code>等）都在原型上定义了实例方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);       <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure><p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给String原始值包装类型的实例添加了一`startsWith()方法：</span></span><br><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.indexOf(text) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">&quot;Hello&quot;</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 ** 并不推荐在产品环境中修改原生对象原型。这样做引发命名冲突，还可能意外的重写原生的方法。通常做法是创建一个自定义的类，继承原生类型。</p></blockquote><h4 id="8-2-5-4-原型的问题"><a href="#8-2-5-4-原型的问题" class="headerlink" title="8.2.5.4   原型的问题"></a>8.2.5.4   <strong>原型的问题</strong></h4><p>首先，它弱化了向构造函数传递初始化参数的能力，导致所有实例默认都取得相同的属性值，其次最大的问题是原型上的所有属性是在实例间共享的，虽然可以通过在实例上添加同名属性来遮蔽原型上的属性，但真正的问题来自包含引用值的属性，因此实际开发中通常不单独使用原型模式，除非是有意在多个实例间共享，属性通常会在构造函数中定义而不会定义在原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">Nicholas</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 29,</span><br><span class="line">  <span class="title">friends</span>: [&quot;<span class="title">Shelby</span>&quot;, &quot;<span class="title">Court</span>&quot;],</span><br><span class="line">  <span class="title">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);  <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);  <span class="comment">// &quot;Shelby,Court,Van&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="8-3-继承"><a href="#8-3-继承" class="headerlink" title="8.3　继承"></a>8.3　继承</h2><p>两种继承：接口继承（继承方法签名）和实现继承（继承实际的方法）。接口继承在<code>ECMAScript</code>中是不可能的，因为函数没有签名。</p><h3 id="8-3-1-原型链"><a href="#8-3-1-原型链" class="headerlink" title="8.3.1　原型链"></a>8.3.1　原型链</h3><p><strong>原型链</strong>定义为<code>ECMAScript</code>的主要继承方式，基本思想是通过原型继承多个引用类型的属性和方法。每个构造函数都有一个原型对象，原型有一个属性<code>constructor</code>指回构造函数，而实例有一个内部指针<code>[[Prototype]]</code>指向原型。如果原型是另一个类型的实例，那这个原型本身也有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个例子中实现继承的关键，是<code>SubType</code>没有使用默认原型，而是将其替换成<code>SuperType</code>的实例。这样<code>SubType</code>的实例不仅能从<code>SuperType</code>的实例中继承属性和方法，而且还与<code>SuperType</code>的原型挂上钩。<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/04/07/EXWsTrnYmagNu9c.png"                      alt="013.png"                ></p><p><strong>图　8-4</strong></p><h4 id="8-3-1-1-默认原型"><a href="#8-3-1-1-默认原型" class="headerlink" title="8.3.1.1   默认原型"></a><strong>8.3.1.1   默认原型</strong></h4><p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自<code>Object</code>，这也是通过原型链实现的。任何函数的默认原型都是一个<code>Object</code>的实例，因此这个实例有一个内部指针指向<code>Object.prototype</code>。<code>SubType</code>继承<code>SuperType</code>，而<code>SuperType</code>继承<code>Object</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/04/07/xavmuPejgBVqUib.png"                      alt="014.png"                ></p><p><strong>图　8-5</strong></p><h4 id="8-3-1-2-原型与继承关系"><a href="#8-3-1-2-原型与继承关系" class="headerlink" title="8.3.1.2   原型与继承关系"></a><strong>8.3.1.2   原型与继承关系</strong></h4><p>原型与实例的关系可以通过两种方式来确定。</p><ul><li><code>instanceof</code>操作符，如果一个实例的原型链中出现过相应的构造函数，则<code>true</code>。</li><li><code>isPrototypeOf()</code>方法，原型调用这个方法，只要原型链中包含这个原型，就返回<code>true</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="8-3-1-3-关于方法"><a href="#8-3-1-3-关于方法" class="headerlink" title="8.3.1.3   关于方法"></a><strong>8.3.1.3   关于方法</strong></h4><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果是以对象字面量方式创建原型方法，会破坏之前的原型链，因为这相当于重写了原型链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 通过对象字面量添加新方法，这会导致上一行无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">getSubValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">someOtherMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure><h4 id="8-3-1-4-原型链的问题"><a href="#8-3-1-4-原型链的问题" class="headerlink" title="8.3.1.4   原型链的问题"></a><strong>8.3.1.4   原型链的问题</strong></h4><p>在使用原型实现继承时，原型实际上变成了另一个类型的实例，这意味着原先的实例属性变成为了原型属性，而原型中包含的引用值会在所有实例间共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br></pre></td></tr></table></figure><p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。</p><h3 id="8-3-2-盗用构造函数"><a href="#8-3-2-盗用构造函数" class="headerlink" title="8.3.2　盗用构造函数"></a>8.3.2　盗用构造函数</h3><p>为了解决原型包含引用值导致的继承问题，有一种叫作“盗用构造函数”的技术（也称作“对象伪装”或“经典继承”）。基本思路：通过<code>apply()</code>或<code>call()</code>方法在子类构造函数创建的实例上下文中调用父类构造函数。相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承SuperType并传参</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.name); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.age); <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure><p>通常在调用父类构造函数之后再给子类实例添加其他额外的属性，防止父类构造函数不会覆盖子类构造函数定义的属性。</p><p>但盗用构造函数的主要缺点，和构造函数模式自定义类型一样，都必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。因此盗用构造函数基本上也不能单独使用。</p><h3 id="8-3-3-组合继承"><a href="#8-3-3-组合继承" class="headerlink" title="8.3.3　组合继承"></a>8.3.3　组合继承</h3><p><strong>组合继承</strong>（也叫伪经典继承）综合了原型链和盗用构造函数。基本思路：使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.sayName();            <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line">instance1.sayAge();             <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);  <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);  <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line">instance2.sayName();            <span class="comment">// &quot;Greg&quot;;</span></span><br><span class="line">instance2.sayAge();             <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式，而且也保留了<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法识别合成对象的能力。</p><h3 id="8-3-4-原型式继承"><a href="#8-3-4-原型式继承" class="headerlink" title="8.3.4　原型式继承"></a>8.3.4　原型式继承</h3><p>原型式继承：即使不自定义类型也可以通过原型实现对象之间的信息共享，适用于：有一个对象，想在它的基础上再创建一个新对象。需要把这个对象先传给<code>object()</code>，然后再对返回的对象进行适当修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>object()</code>函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。此时传入对象是新对象的原型对象。本质上，<code>object()</code>是对传入的对象执行了一次浅复制，缺点和原型模式一样，属性中包含的引用值始终会在相关对象间共享。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.friends);  <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure><p>通过<code>Object.create()</code>方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，<code>Object.create()</code>与上面的<code>object()</code>方法效果相同。第二个参数与<code>Object.defineProperties()</code>的第二个参数一样，每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">&quot;Greg&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(anotherPerson.name);  <span class="comment">// &quot;Greg&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-3-5-寄生式继承"><a href="#8-3-5-寄生式继承" class="headerlink" title="8.3.5　寄生式继承"></a>8.3.5　寄生式继承</h3><p><strong>寄生式继承</strong>，基本思路：类似于寄生构造函数和工厂模式，创建一个实现继承的函数，是对原型式继承的再一次封装。以某种方式增强对象，然后返回这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;   <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  friends: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();  <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景，缺点与构造函数模式类似，通过寄生式继承给对象添加函数会导致函数难以重用。</p><h3 id="8-3-6-寄生式组合继承"><a href="#8-3-6-寄生式组合继承" class="headerlink" title="8.3.6　寄生式组合继承"></a>8.3.6　寄生式组合继承</h3><p>组合继承也存在效率问题，父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含父类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);   <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();   <span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如图8-6所示，有两组<code>name</code>和<code>colors</code>属性：一组在实例上，另一组在<code>SubType</code>的原型上。这是调用两次<code>SuperType</code>构造函数的结果。寄生式组合继承可以避免这个问题。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/04/07/ST5YfHkQLc9s4bd.png"                      alt="015.png"                ></p><p><strong>图　8-6</strong></p><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">//创建父类原型副本</span></span><br><span class="line">  prototype.constructor = subType;             <span class="comment">//解决重写原型导致默认constructor丢失问题</span></span><br><span class="line">  subType.prototype = prototype;               <span class="comment">//将父类原型副本赋值给子类型的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里只调用了一次<code>SuperType</code>构造函数，避免了<code>SubType.prototype</code>上不必要也用不到的属性，效率更高。而且原型链仍然保持不变，因此<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法正常有效。寄生式组合继承算是引用类型继承的最佳模式。</p><h2 id="8-4-类"><a href="#8-4-类" class="headerlink" title="8.4　类"></a>8.4　类</h2><p>使用<code>ECMAScript</code> 5的特性来模拟类似于类的行为，各种策略都有自己的问题，也有相应的妥协。<code>ES6</code>新引入的<code>class</code>关键字具有正式定义类的能力，但实际上它背后使用的仍然是原型和构造函数的概念。</p><h3 id="8-4-1-类定义"><a href="#8-4-1-类定义" class="headerlink" title="8.4.1　类定义"></a>8.4.1　类定义</h3><p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用<code>class</code>关键字加大括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;  <span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">const</span> Animal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;  <span class="comment">// 类表达式</span></span><br></pre></td></tr></table></figure><p>类表达式与函数表达式类似，被求值前不能引用。函数声明和类声明不同，函数声明可以提升，但类声明不能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(FunctionExpression);   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> FunctionExpression = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression);      <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> ClassExpression = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration);  <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);     <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>类声明另一个跟函数声明不同的地方是，函数声明受函数作用域限制，而类声明受块作用域限制，类表达式不受限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">FunctionDeclaration</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ClassDeclaration</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> ClassExpression = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDeclaration); <span class="comment">// FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDeclaration);    <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassExpression);     <span class="comment">// class &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="8-4-2-类的构成"><a href="#8-4-2-类的构成" class="headerlink" title="8.4.2　类的构成"></a><strong>8.4.2　类的构成</strong></h3><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。与函数构造函数一样，建议类名的首字母要大写，以区别于通过它创建的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空类定义，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 有构造函数的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有获取函数的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有静态方法的类，有效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">myQux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过<code>name</code>属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(Person.name, PersonName.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.identify();               <span class="comment">// PersonName PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.name);   <span class="comment">// PersonName</span></span><br><span class="line"><span class="built_in">console</span>.log(PersonName);    <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure><h3 id="8-4-3-类构造函数"><a href="#8-4-3-类构造函数" class="headerlink" title="8.4.3　类构造函数"></a>8.4.3　类构造函数</h3><p><code>constructor</code>关键字用于在类定义块内部创建类的构造函数。方法名<code>constructor</code>会告诉解释器在使用<code>new</code>操作符创建类的新实例时，应该调用这个函数，但这不是必需的，可以为空。</p><h4 id="8-4-3-1-实例化"><a href="#8-4-3-1-实例化" class="headerlink" title="8.4.3.1   实例化"></a><strong>8.4.3.1   实例化</strong></h4><p>使用<code>new</code>操作符实例化<code>Person</code>的操作等于使用<code>new</code>调用其构造函数。使用new调用类的构造函数执行的操作如之前所述。类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name || <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vegetable();</span><br><span class="line"><span class="built_in">console</span>.log(v.color);  <span class="comment">// orange</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person;         </span><br><span class="line"><span class="built_in">console</span>.log(p1.name);         <span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jake&#x27;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(p2.name);         <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure><p>默认情况下，类构造函数会在执行之后返回<code>this</code>对象。构造函数返回的对象会被用作实例化的对象。如果返回的不是<code>this</code>对象，而是其他对象，那么这个对象不会通过<code>instanceof</code>操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">override</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (override) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        bar: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    p2 = <span class="keyword">new</span> Person(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);                    <span class="comment">// Person&#123; foo: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2);                    <span class="comment">// &#123; bar: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用<code>new</code>操作符，否则会抛出错误。而普通构造函数如果不使用<code>new</code>调用，那么就会以全局的<code>this</code>（通常是<code>window</code>）作为内部对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 把window作为this来构建实例</span></span><br><span class="line"><span class="keyword">let</span> p = Person();</span><br><span class="line"><span class="keyword">let</span> a = Animal();</span><br><span class="line"><span class="comment">// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>类构造函数实例化之后，它会成为普通的实例方法。实例化之后在实例上仍需要通过new引用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.constructor();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> p1.constructor()); <span class="comment">// Person &#123;&#125;</span></span><br><span class="line"><span class="comment">// 使用对类构造函数的引用创建一个新实例</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.constructor();</span><br></pre></td></tr></table></figure><h4 id="8-4-3-2-把类当成特殊函数"><a href="#8-4-3-2-把类当成特殊函数" class="headerlink" title="8.4.3.2   把类当成特殊函数"></a><strong>8.4.3.2   把类当成特殊函数</strong></h4><p><code>ECMAScript</code>中没有正式的类这个类型。<code>ECMAScript</code>类就是一种特殊函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person);         <span class="comment">// class Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person);  <span class="comment">// function</span></span><br></pre></td></tr></table></figure><p>类标识符有<code>prototype</code>属性，而这个原型也有一个<code>constructor</code>属性指向类自身：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);             <span class="comment">// &#123; constructor: f() &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>同样可以使用<code>instanceof</code>操作符检查构造函数原型是否存在于实例的原型链中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在类的上下文中，类在使用<code>new</code>调用时本身会被当成构造函数，而类中定义的<code>constructor</code>方法不会被当成构造函数，在对它使用<code>instanceof</code>操作符时会返回<code>false</code>。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么<code>instanceof</code>操作符的返回值会反转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor === Person);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);              <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person.constructor);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person.constructor();</span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor === Person);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);              <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person.constructor);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>类可以像其他对象或函数引用一样作为参数传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> classList = [</span><br><span class="line">  <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id_ = id;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`instance <span class="subst">$&#123;<span class="built_in">this</span>.id_&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classDefinition, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> classDefinition(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = createInstance(classList[<span class="number">0</span>], <span class="number">3141</span>);  <span class="comment">// instance 3141</span></span><br></pre></td></tr></table></figure><p>与立即调用函数表达式相似，类也可以立即实例化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为是一个类表达式，所以类名是可选的</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;bar&#x27;</span>);        <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(p);  <span class="comment">// Foo &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="8-4-4-实例、原型和类成员"><a href="#8-4-4-实例、原型和类成员" class="headerlink" title="8.4.4　实例、原型和类成员"></a>8.4.4　实例、原型和类成员</h3><p>类的语法可以方便地去定义成员存在于实例上、原型上还是类本身上。</p><h4 id="8-4-4-1-实例成员"><a href="#8-4-4-1-实例成员" class="headerlink" title="8.4.4.1   实例成员"></a><strong>8.4.4.1   实例成员</strong></h4><p>每次通过<code>new</code>调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例添加“自有”属性。在构造函数执行完毕后，仍然可以给实例继续添加新成员。每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子先使用对象包装类型定义一个字符串</span></span><br><span class="line">    <span class="comment">// 为的是在下面测试两个对象的相等性</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jake&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name === p2.name);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.nicknames === p2.nicknames);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="8-4-4-2-原型方法与访问器"><a href="#8-4-4-2-原型方法与访问器" class="headerlink" title="8.4.4.2   原型方法与访问器"></a><strong>8.4.4.2   原型方法与访问器</strong></h4><p>为了在实例间共享方法，在类块中定义的方法作为原型方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;instance&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">  <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在类块中给原型添加原始值或对象作为成员数据，但在类定义外部，可以手动添加（不推荐，反模式）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">  name: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在类上定义数据成员</span></span><br><span class="line">Person.greeting = <span class="string">&#x27;My name is&#x27;</span>;</span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.sayName();  <span class="comment">// My name is Jake</span></span><br></pre></td></tr></table></figure><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">&#x27;symbolKey&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">stringKey</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;invoked stringKey&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   [symbolKey]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;invoked symbolKey&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   [<span class="string">&#x27;computed&#x27;</span> + <span class="string">&#x27;Key&#x27;</span>]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;invoked computedKey&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name_ = newName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// Jake</span></span><br></pre></td></tr></table></figure><h4 id="8-4-4-3-静态类方法"><a href="#8-4-4-3-静态类方法" class="headerlink" title="**8.4.4.3   静态类方法  **"></a>**8.4.4.3   静态类方法  **</h4><p>使用<code>static</code>关键字作为前缀，可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。在静态成员中，<code>this</code>引用类自身。静态类方法非常适合作为实例工厂：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="built_in">this</span>.age_ = age;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">  <span class="function"><span class="title">sayAge</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类本身上</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用随机年龄创建并返回一个Person实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.create()); <span class="comment">// Person &#123; age_: ... &#125;</span></span><br></pre></td></tr></table></figure><h4 id="8-4-4-4-迭代器与生成器方法"><a href="#8-4-4-4-迭代器与生成器方法" class="headerlink" title="8.4.4.4   迭代器与生成器方法"></a><strong>8.4.4.4   迭代器与生成器方法</strong></h4><p>类定义语法支持在原型和类本身上定义生成器方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="function"><span class="title">createNicknameIterator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;J-Dog&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> *<span class="function"><span class="title">createJobIterator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Butcher&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Baker&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jobIter = Person.createJobIterator();</span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value);  <span class="comment">// Butcher</span></span><br><span class="line"><span class="built_in">console</span>.log(jobIter.next().value);  <span class="comment">// Baker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> nicknameIter = p.createNicknameIterator();</span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value);  <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(nicknameIter.next().value);  <span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span>* <span class="built_in">this</span>.nicknames.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> nickname <span class="keyword">of</span> p) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><p>也可以只返回迭代器实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nicknames = [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;J-Dog&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nicknames.values();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> nickname <span class="keyword">of</span> p) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// J-Dog</span></span><br></pre></td></tr></table></figure><h3 id="8-4-5-继承"><a href="#8-4-5-继承" class="headerlink" title="8.4.5　继承"></a>8.4.5　继承</h3><p><code>ES6</code>原生支持了类继承机制，但背后依旧使用的是原型链。</p><h4 id="8-4-5-1-继承基础"><a href="#8-4-5-1-继承基础" class="headerlink" title="8.4.5.1   继承基础"></a><strong>8.4.5.1   继承基础</strong></h4><p>使用<code>extends</code>关键字，就可以继承任何拥有<code>[[Construct]]</code>和原型的对象。不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle);  <span class="comment">// true</span></span><br><span class="line">　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承普通构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> Engineer();</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>派生类都会通过原型链访问到类和原型上定义的方法。<code>this</code>的值会反映调用相应方法的实例或者类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">identifyPrototype</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">identifyClass</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//extends关键字也可以在类表达式中使用。</span></span><br><span class="line"><span class="keyword">let</span> Bus = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>);       <span class="comment">// bus, Bus &#123;&#125;</span></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>);         <span class="comment">// bus, class Bus &#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="8-4-5-2-构造函数、HomeObject和super"><a href="#8-4-5-2-构造函数、HomeObject和super" class="headerlink" title="8.4.5.2   构造函数、HomeObject和super()"></a><strong>8.4.5.2   构造函数、</strong><code>HomeObject</code>和<code>super()</code></h4><p><code>ES6</code>给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在JavaScript引擎内部访问。<code>super</code>始终会定义为<code>[[HomeObject]]</code>的原型。派生类的方法可以通过<code>super</code>关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。</p><p>在静态方法中通过<code>super</code>调用继承的类上定义的静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;vehicle&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">identify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.identify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bus.identify();  <span class="comment">// vehicle</span></span><br></pre></td></tr></table></figure><p>在类构造函数中使用<code>super</code>调用父类构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hasEngine = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(); <span class="comment">// 相当于super.constructor()</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vehicle);  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);                   <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();</span><br></pre></td></tr></table></figure><h4 id="8-4-5-3-使用super时要注意的问题"><a href="#8-4-5-3-使用super时要注意的问题" class="headerlink" title="8.4.5.3   使用super时要注意的问题"></a>8.4.5.3   使用<code>super</code>时要注意的问题</h4><ol><li><code>super</code>只能在派生类构造函数和静态方法中使用。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>不能单独引用<code>super</code>关键字，要么用它调用构造函数，要么用它引用静态方法。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>);</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>调用<code>super()</code>会调用父类构造函数，并将返回的实例赋值给<code>this</code>，如果需要给父类构造函数传参，则需要手动传入。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">licensePlate</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.licensePlate = licensePlate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">licensePlate</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(licensePlate);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vehicle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus(<span class="string">&#x27;1337H4X&#x27;</span>)); </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>如果没有定义类构造函数，在实例化派生类时自动会调用<code>super()</code>，而且会传入所有传给派生类的参数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">licensePlate</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.licensePlate = licensePlate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus(<span class="string">&#x27;1337H4X&#x27;</span>)); <span class="comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li>如果在派生类中显式定义了构造函数，要么在其中调用<code>super()</code>，要么在其中返回一个对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Bus());  <span class="comment">// Bus &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Van());  <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li>在类构造函数中，不能在调用<code>super()</code>之前引用<code>this</code>添加新的实例成员。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();</span><br><span class="line"><span class="comment">// ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br></pre></td></tr></table></figure><h4 id="8-4-5-4-抽象基类"><a href="#8-4-5-4-抽象基类" class="headerlink" title="8.4.5.4   抽象基类"></a>8.4.5.4   <strong>抽象基类</strong></h4></li></ol><p>有时候需要定义这样一个类，它可供其他类继承，但本身不能被实例化。虽然<code>ECMAScript</code>没有专门支持这种类的语法 ，但通过<code>new.target</code>也很容易实现。<code>new.target</code>保存通过<code>new</code>关键字调用的类或函数。通过在实例化时检测<code>new.target</code>是不是抽象基类，可以阻止对抽象基类的实例化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus();       <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> Vehicle();   <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure><p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过<code>this</code>关键字来检查相应的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Vehicle) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.foo) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Inheriting class must define foo()&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Van</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> Bus(); <span class="comment">// success!</span></span><br><span class="line"><span class="keyword">new</span> Van(); <span class="comment">// Error: Inheriting class must define foo()</span></span><br></pre></td></tr></table></figure><h4 id="8-4-5-5-继承内置类型"><a href="#8-4-5-5-继承内置类型" class="headerlink" title="8.4.5.5   继承内置类型"></a>8.4.5.5   <strong>继承内置类型</strong></h4><p><code>ES6</code>类可以方便地扩展内置类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">shuffle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 洗牌算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</span><br><span class="line">      [<span class="built_in">this</span>[i], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">a.shuffle();</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// [3, 1, 4, 5, 2]</span></span><br></pre></td></tr></table></figure><p>有些内置类型的方法会返回新实例，默认情况下，返回的实例类型与原始实例的类型是一致的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// SuperArray(5) [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// SuperArray(3) [1, 3, 5]</span></span><br></pre></td></tr></table></figure><p>如果想覆盖这个默认行为，则可以覆盖<code>Symbol.species</code>访问器，它决定在创建返回的实例时使用的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> SuperArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = a1.filter(<span class="function"><span class="params">x</span> =&gt;</span> !!(x%<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// [1, 2, 3, 4, 5]，SuperArray类型</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 <span class="keyword">instanceof</span> SuperArray);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="8-4-5-6-类混入"><a href="#8-4-5-6-类混入" class="headerlink" title="**8.4.5.6   类混入 **"></a>**8.4.5.6   类混入 **</h4><p>把不同类的行为集中到一个类是一种常见的JavaScript模式。虽然<code>ES6</code>没有显式支持多类继承，但通过现有特性可以模拟这种行为。</p><blockquote><p><strong>注意</strong>  如果只是需要混入多个对象的属性，那么使用<code>Object.assign()</code>就够了，除非需要混入类的行为时才有必要自己实现混入表达式。</p></blockquote><p><code>extends</code>关键字后面是一个JavaScript表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;evaluated expression&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">getParentClass</span>() </span>&#123;&#125;</span><br><span class="line"><span class="comment">// evaluated expression</span></span><br></pre></td></tr></table></figure><p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。如果<code>Person</code>类需要组合A、B、C，则需要某种机制实现B继承A，C继承B，而<code>Person</code>再继承C，从而把A、B、C组合到这个超类中。实现这种模式有不同的策略。<br>第一种是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> FooMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BarMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> BazMixin = <span class="function">(<span class="params">Superclass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Superclass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">FooMixin</span>(<span class="title">BarMixin</span>(<span class="title">BazMixin</span>(<span class="title">Vehicle</span>))) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo();  <span class="comment">// foo</span></span><br><span class="line">b.bar();  <span class="comment">// bar</span></span><br><span class="line">b.baz();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>第二种通过写一个辅助函数，可以把嵌套调用展开：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">BaseClass, ...Mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mixins.reduce(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> current(accumulator), BaseClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Vehicle</span>, <span class="title">FooMixin</span>, <span class="title">BarMixin</span>, <span class="title">BazMixin</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line">b.foo();  <span class="comment">// foo</span></span><br><span class="line">b.bar();  <span class="comment">// bar</span></span><br><span class="line">b.baz();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 **很多JavaScript框架（特别是React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，不使用继承）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对象：一组属性的无序集合。这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。&lt;/p&gt;
&lt;h2 id=&quot;8-1-理解对象&quot;&gt;&lt;a href=&quot;#8-1-理解对象&quot; class=&quot;headerlink&quot; title=&quot;8.1　理</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>07-迭代器与生成器</title>
    <link href="http://example.com/2021/03/28/note/JavaScript/07-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://example.com/2021/03/28/note/JavaScript/07-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2021-03-28T10:47:40.431Z</published>
    <updated>2021-05-30T07:07:08.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-理解迭代"><a href="#7-1-理解迭代" class="headerlink" title="7.1　理解迭代"></a>7.1　理解迭代</h2><p>计数循环就是一种最简单的迭代：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环是迭代机制的基础，因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; collection.length; ++index) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(collection[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。但由于如下原因，通过这种循环来执行例程并不理想。</p><ul><li><strong>迭代之前需要知道如何使用数据结构</strong>。数组中的每一项都只能先通过引用取得数组对象，然后再通过<code>[]</code>操作符取得特定索引位置上的项。这种情况不适用于所有数据结构。</li><li><strong>遍历顺序并不是数据结构固有的</strong>。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。</li></ul><p><code>Array.prototype.forEach()</code>方法，向通用迭代需求迈进了一步。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line">collection.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><p>这个方法解决了单独记录索引和通过数组对象取得值的问题，但仍然不够理想，没有办法标识迭代何时终止。因此这个方法只适用于数组。</p><h2 id="7-2-迭代器模式"><a href="#7-2-迭代器模式" class="headerlink" title="7.2　迭代器模式"></a>7.2　迭代器模式</h2><p><strong>迭代器模式</strong>描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的<code>Iterable</code>接口，而且可以通过迭代器<code>Iterator</code>消费。</p><p>可迭代对象是一种抽象的说法。可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的元素是有限的，递增索引可以按序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 集合的元素是有限的，可以按插入顺序访问每个元素</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">3</span>).add(<span class="number">1</span>).add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>但可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。</p><p>任何实现<code>Iterable</code>接口的数据结构都可以被实现<code>Iterator</code>接口的结构“消费”。<strong>迭代器</strong>是按需创建的一次性对象。每个迭代器都会关联一个<strong>可迭代对象</strong>，而迭代器会暴露出迭代其关联可迭代对象的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。</p><h3 id="7-2-1-可迭代协议"><a href="#7-2-1-可迭代协议" class="headerlink" title="7.2.1　可迭代协议"></a>7.2.1　可迭代协议</h3><p>实现<code>Iterable</code>接口要求同时具备两种能力：支持迭代的自我识别能力和创建实现<code>Iterator</code>接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而这个属性必须使用特殊的<code>Symbol.iterator</code>作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p><p>很多内置类型都实现了<code>Iterable</code>接口：</p><ul><li>字符串</li><li>数组</li><li>定型数组</li><li>映射</li><li>集合</li><li><code>arguments</code>对象</li><li><code>NodeList</code>等DOM集合类型</li></ul><p>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 这两种类型没有实现迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(num[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).set(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;a&#x27;</span>).add(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> els = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">// 这些类型都实现了迭代器工厂函数，调用会生成一个迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// MapIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// SetIterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(els[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// ArrayIterator &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：</p><ul><li><code>for-of</code>循环</li><li>数组解构</li><li>扩展操作符</li><li><code>Array.from()</code></li><li>创建集合</li><li>创建映射</li><li><code>Promise.all()</code>接收由期约组成的可迭代对象</li><li><code>Promise.race()</code>接收由期约组成的可迭代对象</li><li><code>yield*</code>操作符，在生成器中使用</li></ul><p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="comment">// for-of循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// foo, bar, baz</span></span><br><span class="line"><span class="comment">// 扩展操作符</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.from(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"><span class="comment">// Set构造函数</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set(3) &#123;&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;&#125;</span></span><br><span class="line"><span class="comment">// Map构造函数</span></span><br><span class="line"><span class="keyword">let</span> pairs = arr.map(<span class="function">(<span class="params">x, i</span>) =&gt;</span> [x, i]);</span><br><span class="line"><span class="built_in">console</span>.log(pairs); <span class="comment">// [[&#x27;foo&#x27;, 0], [&#x27;bar&#x27;, 1], [&#x27;baz&#x27;, 2]]</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(pairs);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(3) &#123; &#x27;foo&#x27;=&gt;0, &#x27;bar&#x27;=&gt;1, &#x27;baz&#x27;=&gt;2 &#125;</span></span><br></pre></td></tr></table></figure><p>如果对象原型链上的父类实现了<code>Iterable</code>接口，那这个对象也就实现了这个接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fooArr = <span class="keyword">new</span> FooArray(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> fooArr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><h3 id="7-2-2-迭代器协议"><a href="#7-2-2-迭代器协议" class="headerlink" title="7.2.2　迭代器协议"></a>7.2.2　迭代器协议</h3><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API使用<code>next()</code>方法在可迭代对象中遍历数据。每次成功调用<code>next()</code>，都会返回一个<code>IteratorResult</code>对象，其中包含迭代器返回的下一个值。若不调用<code>next()</code>，则无法知道迭代器的当前位置。</p><p><code>next()</code>方法返回的迭代器对象<code>IteratorResult</code>包含两个属性：<code>done</code>和<code>value</code>。<code>done</code>是一个布尔值，表示是否还可以再次调用<code>next()</code>取得下一个值；<code>value</code>包含可迭代对象的下一个值（<code>done</code>为<code>false</code>），或者<code>undefined</code>（<code>done</code>也为<code>true</code>）。<code>done: true</code>状态称为“耗尽”。只要迭代器到达<code>done: true</code>状态，后续调用<code>next()</code>就一直返回同样的值了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，独立地遍历可迭代对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> iter2 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter2.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter2.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter1.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 在数组中间插入值</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: false, value: &#x27;baz&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 **迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p></blockquote><h3 id="7-2-3-自定义迭代器"><a href="#7-2-3-自定义迭代器" class="headerlink" title="7.2.3　自定义迭代器"></a>7.2.3　自定义迭代器</h3><p>与<code>Iterable</code>接口类似，任何实现<code>Iterator</code>接口的对象都可以作为迭代器使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">// 闭包可以实现生产多个迭代器</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">        limit = <span class="built_in">this</span>.limit;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; <span class="built_in">console</span>.log(i); &#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>而可迭代对象的默认迭代器也实现了<code>Iterable</code>接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> iter2 = iter1[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iter1 === iter2);         <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为每个迭代器也实现了<code>Iterable</code>接口，所以它们也可以用在任何期待可迭代对象的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr ) &#123; <span class="built_in">console</span>.log(item); &#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iter ) &#123; <span class="built_in">console</span>.log(item); &#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="7-2-4-提前终止迭代器"><a href="#7-2-4-提前终止迭代器" class="headerlink" title="7.2.4　提前终止迭代器"></a>7.2.4　提前终止迭代器</h3><p>可选的<code>return()</code>方法用于指定在迭代器提前关闭时执行的逻辑。内置语言结构在发现还有更多值可以迭代，但没有继续消费这些值时，会自动调用<code>return()</code>方法。可能的情况包括：</p><ul><li><code>for-of</code>循环通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>throw</code>提前退出；</li><li>解构操作并未消费所有值。</li></ul><p><code>return()</code>必须返回一个有效的<code>IteratorResult</code>对象，可以只返回<code>&#123; done: true &#125;</code>，因为这个返回值只会用在生成器的上下文中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现迭代器next和return方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="built_in">this</span>.limit;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">return</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Exiting early&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter1 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Exiting early</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3;</span><br><span class="line"><span class="comment">// Exiting early</span></span><br></pre></td></tr></table></figure><p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>因为<code>return()</code>方法是可选的，所以并非所有迭代器都是可关闭的。即便给一个不可关闭的迭代器增加这个方法<strong>也不能</strong>让它变成可关闭的，因为调用<code>return()</code>不会强制迭代器进入关闭状态，当然，<code>return()</code>方法还是会被调用。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的<code>return</code>属性是不是函数对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> iter = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iter.return = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Exiting early&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 提前退出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="7-3-生成器"><a href="#7-3-生成器" class="headerlink" title="7.3　生成器"></a>7.3　生成器</h2><p>生成器是ES6新增的一个结构，拥有在一个函数块内暂停和恢复代码执行的能力。比如，使用生成器可以自定义迭代器和实现协程。</p><h3 id="7-3-1-生成器基础"><a href="#7-3-1-生成器基础" class="headerlink" title="7.3.1　生成器基础"></a>7.3.1　生成器基础</h3><p>只要是可以定义函数的地方（箭头函数不行），在函数名称前面加一个星号（<code>*</code>）就表示它是一个生成器，并且星号不受两侧空格的影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFn = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> * <span class="function"><span class="title">generatorFn</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用生成器函数会产生一个<strong>生成器对象</strong>。生成器对象一开始处于暂停执行的状态。生成器对象也实现了<code>Iterator</code>接口，因此具有<code>next()</code>方法。调用这个方法会让生成器开始或恢复执行。</p><p>返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code>属性。<code>value</code>属性是生成器函数的返回值，默认值为<code>undefined</code>，可以通过生成器函数的返回值指定，函数体为空的生成器函数中间不会停留，调用一次<code>next()</code>就会让生成器到达<code>done: true</code>状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generatorObject = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());  <span class="comment">// &#123; done: true, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject);        <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><p>生成器函数只会在初次调用<code>next()</code>方法后开始执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line">generatorObject.next();  <span class="comment">// foobar</span></span><br></pre></td></tr></table></figure><p>生成器对象实现了<code>Iterable</code>接口，它们默认的迭代器是自引用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn(); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g === g[<span class="built_in">Symbol</span>.iterator]());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="7-3-2-通过yield中断执行"><a href="#7-3-2-通过yield中断执行" class="headerlink" title="7.3.2　通过yield中断执行"></a>7.3.2　通过<code>yield</code>中断执行</h3><p><code>yield</code>关键字可以让生成器停止和开始执行，生成器函数在遇到<code>yield</code>关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用<code>next()</code>方法来恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());  <span class="comment">// &#123; done: false, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());  <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><p>此时的<code>yield</code>关键字有点像函数的中间返回语句，它生成的值会出现在<code>next()</code>方法返回的对象里。通过<code>yield</code>关键字退出的生成器函数会处在<code>done: false</code>状态；通过<code>return</code>关键字退出的生成器函数会处于<code>done: true</code>状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());<span class="comment">//&#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());<span class="comment">//&#123; done: true, value: &#x27;baz&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用<code>next()</code>不会影响其他生成器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject1 = generatorFn();</span><br><span class="line"><span class="keyword">let</span> generatorObject2 = generatorFn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject1.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject2.next()); <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject2.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject1.next()); <span class="comment">// &#123; done: false, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的<code>return</code>关键字，<code>yield</code>关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">validGeneratorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-1-生成器对象作为可迭代对象"><a href="#7-3-2-1-生成器对象作为可迭代对象" class="headerlink" title="7.3.2.1   生成器对象作为可迭代对象"></a><strong>7.3.2.1   生成器对象作为可迭代对象</strong></h4><p>在生成器对象上显式调用<code>next()</code>方法的用处并不大。更方便使用的是把生成器对象用于自定义可迭代对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><h4 id="7-3-2-2-使用yield实现输入和输出"><a href="#7-3-2-2-使用yield实现输入和输出" class="headerlink" title="7.3.2.2   使用yield实现输入和输出"></a><strong>7.3.2.2   使用</strong><code>yield</code>实现输入和输出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rv] = <span class="keyword">yield</span> [expression];</span><br></pre></td></tr></table></figure><p><code>yield</code>可以作为函数的中间参数使用。上一次让生成器函数暂停的<code>yield</code>关键字会接收到传给<code>next()</code>方法的第一个值。同时第一次调用<code>next()</code>传入的值不会被使用，因为这一次调用是为了开始执行生成器函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(initial);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">generatorObject.next(<span class="string">&#x27;bar&#x27;</span>);  <span class="comment">// foo</span></span><br><span class="line">generatorObject.next(<span class="string">&#x27;baz&#x27;</span>);  <span class="comment">// baz</span></span><br><span class="line">generatorObject.next(<span class="string">&#x27;qux&#x27;</span>);  <span class="comment">// qux</span></span><br></pre></td></tr></table></figure><p><code>yield</code>可以同时用于输入和输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next());       <span class="comment">// &#123; done: false, value: &#x27;foo&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next(<span class="string">&#x27;bar&#x27;</span>));  <span class="comment">// &#123; done: true, value: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>关键字并非只能使用一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;;++i) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObject = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next().value);  <span class="comment">// 1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>假设要定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用生成器也可以实现范围和填充数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(end &gt; start) &#123;</span><br><span class="line">    <span class="keyword">yield</span> start++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> range(<span class="number">4</span>, <span class="number">7</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">zeroes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(zeroes(<span class="number">8</span>))); <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><h4 id="7-3-2-3-产生可迭代对象"><a href="#7-3-2-3-产生可迭代对象" class="headerlink" title="7.3.2.3   产生可迭代对象"></a><strong>7.3.2.3   产生可迭代对象</strong></h4><p>可以使用星号增强<code>yield</code>的行为，让它能够迭代一个可迭代对象，从而一次产出一个值，<code>yield</code>星号两侧的空格不影响其行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>yield*</code>是一个表达式，而不是语句，它本身的值是关联迭代器返回<code>done: true</code>时的<code>value</code>属性。对于普通迭代器来说，这个值是<code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value:&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value: 1</span></span><br><span class="line"><span class="comment">// value: 2</span></span><br><span class="line"><span class="comment">// iter value: undefined</span></span><br></pre></td></tr></table></figure><p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">innerGeneratorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outerGeneratorFn</span>(<span class="params">genObj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;iter value:&#x27;</span>, <span class="keyword">yield</span>* innerGeneratorFn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> outerGeneratorFn()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;value:&#x27;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value: foo</span></span><br><span class="line"><span class="comment">// iter value: bar</span></span><br></pre></td></tr></table></figure><h4 id="7-3-2-4-使用yield-实现递归算法"><a href="#7-3-2-4-使用yield-实现递归算法" class="headerlink" title="7.3.2.4   使用yield*实现递归算法"></a><strong>7.3.2.4   使用</strong><code>yield*</code>实现递归算法</h4><p><code>yield*</code>最有用的地方是实现递归操作，此时生成器可以产生自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* nTimes(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用递归生成器结构和<code>yield*</code>可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.neighbors = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connect</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.neighbors.add(node);</span><br><span class="line">      node.neighbors.add(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomGraph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nodes = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      <span class="built_in">this</span>.nodes.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机连接节点</span></span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">1</span> / size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="built_in">this</span>.nodes) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> y <span class="keyword">of</span> <span class="built_in">this</span>.nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &lt; threshold) &#123;</span><br><span class="line">          x.connect(y);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个方法仅用于调试</span></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="built_in">this</span>.nodes) &#123;</span><br><span class="line">      <span class="keyword">const</span> ids = [...node.neighbors]</span><br><span class="line">                      .map(<span class="function">(<span class="params">n</span>) =&gt;</span> n.id)</span><br><span class="line">                      .join(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;node.id&#125;</span>: <span class="subst">$&#123;ids&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> RandomGraph(<span class="number">6</span>);</span><br><span class="line">g.print();</span><br><span class="line"><span class="comment">// 示例输出：</span></span><br><span class="line"><span class="comment">// 0: 2,3,5</span></span><br><span class="line"><span class="comment">// 1: 2,3,4,5</span></span><br><span class="line"><span class="comment">// 2: 1,3</span></span><br><span class="line"><span class="comment">// 3: 0,1,2,4</span></span><br><span class="line"><span class="comment">// 4: 2,3</span></span><br><span class="line"><span class="comment">// 5: 0,4</span></span><br></pre></td></tr></table></figure><p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">connect</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomGraph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">isConnected</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> visitedNodes = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">traverse</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visitedNodes.has(node)) &#123;</span><br><span class="line">          <span class="keyword">yield</span> node;</span><br><span class="line">          <span class="keyword">yield</span>* traverse(node.neighbors);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得集合中的第一个节点</span></span><br><span class="line">    <span class="keyword">const</span> firstNode = <span class="built_in">this</span>.nodes[<span class="built_in">Symbol</span>.iterator]().next().value;</span><br><span class="line">    <span class="comment">// 使用递归生成器迭代每个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> traverse([firstNode])) &#123;</span><br><span class="line">      visitedNodes.add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitedNodes.size === <span class="built_in">this</span>.nodes.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-3-生成器作为默认迭代器"><a href="#7-3-3-生成器作为默认迭代器" class="headerlink" title="7.3.3　生成器作为默认迭代器"></a>7.3.3　生成器作为默认迭代器</h3><p>因为生成器对象实现了<code>Iterable</code>接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="built_in">this</span>.values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> f) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="7-3-4-提前终止生成器"><a href="#7-3-4-提前终止生成器" class="headerlink" title="7.3.4　提前终止生成器"></a>7.3.4　提前终止生成器</h3><p>生成器也有一个可选的<code>return()</code>方法用于提前终止迭代器。除此之外，生成器对象还有第三个方法<code>throw()</code>。<code>return()</code>和<code>throw()</code>方法都可以用于强制生成器进入关闭状态。</p><h4 id="7-3-4-1-return"><a href="#7-3-4-1-return" class="headerlink" title="7.3.4.1   return()"></a>7.3.4.1   <code>return()</code></h4><p><code>return()</code>方法会强制生成器进入关闭状态。提供给<code>return()</code>方法的值，就是终止迭代器对象的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>));  <span class="comment">// &#123; done: true, value: 4 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g);            <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>与迭代器不同，所有生成器对象都有<code>return()</code>方法，只要通过它进入关闭状态，就无法恢复了。后续调用<code>next()</code>会显示<code>done: true</code>状态，而提供的任何返回值都不会被存储或传播：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">yield</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());     <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>));  <span class="comment">// &#123; done: true, value: 4 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());     <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure><p><code>for-of</code>循环等内置语言结构会忽略状态为<code>done: true</code>的<code>IteratorObject</code>内部返回的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> g) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    g.return(<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="7-3-4-2-throw"><a href="#7-3-4-2-throw" class="headerlink" title="7.3.4.2   throw()"></a>7.3.4.2   <code>throw()</code></h4><p><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// foo</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(g);   <span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>但如果生成器函数<strong>内部通过</strong><code>try/catch</code>处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的<code>yield</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFn();</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 1&#125;</span></span><br><span class="line">g.throw(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; done: false, value: 3&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 **如果生成器对象还没有开始执行，那么调用<code>throw()</code>抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;7-1-理解迭代&quot;&gt;&lt;a href=&quot;#7-1-理解迭代&quot; class=&quot;headerlink&quot; title=&quot;7.1　理解迭代&quot;&gt;&lt;/a&gt;7.1　理解迭代&lt;/h2&gt;&lt;p&gt;计数循环就是一种最简单的迭代：&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>06-集合引用类型</title>
    <link href="http://example.com/2021/03/28/note/JavaScript/06-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2021/03/28/note/JavaScript/06-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-03-28T10:46:33.919Z</published>
    <updated>2021-05-19T12:08:53.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-Object"><a href="#6-1-Object" class="headerlink" title="6.1　Object"></a>6.1　Object</h2><p>大多数引用值的示例使用的是<code>Object</code>类型。显式地创建<code>Object</code>的实例有两种方式。第一种是使用<code>new</code>操作符和<code>Object</code>构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure><p>另一种方式是使用<strong>对象字面量</strong>表示法。目的是为了简化包含大量属性的对象的创建。在对象字面量表示法中，属性名可以是字符串或数值，数值属性会自动转换为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：</p><blockquote><p>**注意 **在使用对象字面量表示法定义对象时，并不会实际调用<code>Object</code>构造函数。</p></blockquote><p>属性一般是通过<strong>点语法</strong>来存取的，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&quot;name&quot;</span>]); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>使用中括号的主要优势就是可以通过变量访问属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[propertyName]); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字/保留字时，不能使用点语法来访问，就可以使用中括号语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="6-2-Array"><a href="#6-2-Array" class="headerlink" title="6.2　Array"></a>6.2　Array</h2><p>ECMAScript数组跟其他编程语言的数组有很大区别。ECMAScript数组也同样是一组有序的数据，但数组中每个槽位可以存储任意类型的数据。</p><h3 id="6-2-1-创建数组"><a href="#6-2-1-创建数组" class="headerlink" title="6.2.1　创建数组"></a>6.2.1　创建数组</h3><p>一种是使用<code>Array</code>构造函数，可以给构造函数传一个值。如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);     <span class="comment">// 创建一个包含3个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">3</span>);      <span class="comment">// [2,3]</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Greg&quot;</span>); <span class="comment">// 创建一个只包含一个元素，即字符串&quot;Greg&quot;的数组</span></span><br></pre></td></tr></table></figure><p>在使用<code>Array</code>构造函数时，也可以省略<code>new</code>操作符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>);     <span class="comment">// 创建一个包含3个元素的数组</span></span><br></pre></td></tr></table></figure><p>另一种创建数组的方式是使用<strong>数组字面量</strong>（array literal）表示法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含3个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,];                    <span class="comment">// 创建一个包含2个元素的数组</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 与对象一样，在使用数组字面量表示法创建数组不会调用<code>Array</code>构造函数。</p></blockquote><p><code>Array</code>构造函数有两个用于创建数组的静态方法：<code>from()</code>和<code>of()</code>。</p><p><code>from()</code>用于将类数组结构或可迭代对象转换为数组实例。第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个<code>length</code>属性和可索引元素的结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用from()将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">                   .set(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="number">1</span>)</span><br><span class="line">                   .add(<span class="number">2</span>)</span><br><span class="line">                   .add(<span class="number">3</span>)           </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(m)); <span class="comment">// [[1, 2], [3, 4]]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s)); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1);</span><br><span class="line"><span class="built_in">console</span>.log(a2);        <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">alert(a1 == a2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArgsArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getArgsArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// from()也能转换带有必要属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">  length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(arrayLikeObject));<span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>Array.from()</code>接收第二个可选的映射函数参数,可以直接增强新数组的值，无须<code>Array.from().map()</code>那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中<code>this</code>的值，但在箭头函数中不适用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="built_in">Array</span>.from(a1, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="keyword">return</span> x**<span class="built_in">this</span>.exponent&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="built_in">console</span>.log(a3);  <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p><code>Array.of()</code>把一组参数转换为数组，用于替代在ES6之前常用的<code>Array.prototype.slice.call(arguments)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>));  <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h3 id="6-2-2-数组空位"><a href="#6-2-2-数组空位" class="headerlink" title="6.2.2　数组空位"></a>6.2.2　数组空位</h3><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ES6新增方法普遍将这些空位当成存在的元素，只不过值为<code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(option === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// map()会跳过空位置</span></span><br><span class="line"><span class="built_in">console</span>.log(options.map(<span class="function">() =&gt;</span> <span class="number">6</span>));  <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br><span class="line"><span class="comment">// join()视空位置为空字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(options.join(<span class="string">&#x27;-&#x27;</span>));     <span class="comment">// &quot;1----5&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 **由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用<code>undefined</code>值代替。</p></blockquote><h3 id="6-2-3-数组索引"><a href="#6-2-3-数组索引" class="headerlink" title="6.2.3　数组索引"></a>6.2.3　数组索引</h3><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">alert(colors[<span class="number">0</span>]);                       <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">&quot;black&quot;</span>;                    <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">&quot;brown&quot;</span>;                    <span class="comment">// 添加第四项</span></span><br></pre></td></tr></table></figure><p>数组中元素的数量保存在<code>length</code>属性中，这个属性始终返回0或大于0的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">alert(colors.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>length</code>属性不是只读的。通过修改<code>length</code>属性，可以从数组末尾删除或添加元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果将<code>length</code>设置为大于数组元素数的值，则新添加的元素都将以<code>undefined</code>填充。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">colors.length = <span class="number">4</span>;</span><br><span class="line">alert(colors[<span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>使用<code>length</code>属性可以方便地向数组末尾添加元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  </span><br><span class="line">colors[colors.length] = <span class="string">&quot;black&quot;</span>;        </span><br></pre></td></tr></table></figure><blockquote><p>**注意 **数组最多可以包含4 294 967 295个元素，如果尝试添加更多项，则会导致抛出错误。</p></blockquote><h3 id="6-2-4-检测数组"><a href="#6-2-4-检测数组" class="headerlink" title="6.2.4　检测数组"></a>6.2.4　检测数组</h3><p>判断一个对象是不是数组，在只有一个网页（因而只有一个全局作用域）的情况下，使用<code>instanceof</code>操作符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的<code>Array</code>构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。为解决这个问题，提供了<code>Array.isArray()</code>方法，确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">  <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-5-迭代器方法"><a href="#6-2-5-迭代器方法" class="headerlink" title="6.2.5　迭代器方法"></a>6.2.5　迭代器方法</h3><p>在ES6中，<code>Array</code>的原型上暴露了3个用于检索数组内容的方法：<code>keys()</code>、<code>values()</code>和<code>entries()</code>。<code>keys()</code>返回数组索引的迭代器，<code>values()</code>返回数组元素的迭代器，而<code>entries()</code>返回索引/值对的迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容通过Array.from()直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="built_in">Array</span>.from(a.keys());</span><br><span class="line"><span class="keyword">const</span> aValues = <span class="built_in">Array</span>.from(a.values());</span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="built_in">Array</span>.from(a.entries());</span><br><span class="line"><span class="built_in">console</span>.log(aKeys);     <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(aValues);   <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries);  <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br></pre></td></tr></table></figure><p>使用ES6的解构可以非常容易地在循环中拆分键/值对：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element] <span class="keyword">of</span> a.entries()) &#123;</span><br><span class="line">  alert(idx);</span><br><span class="line">  alert(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// baz</span></span><br></pre></td></tr></table></figure><h3 id="6-2-6-复制和填充方法"><a href="#6-2-6-复制和填充方法" class="headerlink" title="6.2.6　复制和填充方法"></a>6.2.6　复制和填充方法</h3><p>填充数组方法<code>fill()</code>以及批量复制方法<code>copyWithin()</code>，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。这个方法不会改变数组的大小。</p><p>填充数组方法<code>fill()</code>可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。如果有负值索引，则相当于数组长度加上它转换成的一个正索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 用5填充整个数组</span></span><br><span class="line">zeroes.fill(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);       <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用6填充索引大于等于3的元素</span></span><br><span class="line">zeroes.fill(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 6, 6]</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用7填充索引大于等于1且小于3的元素</span></span><br><span class="line">zeroes.fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 7, 7, 0, 0];</span></span><br><span class="line">zeroes.fill(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用8填充索引大于等于1且小于4的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1)</span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4)</span></span><br><span class="line">zeroes.fill(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure><p><code>fill()</code>静默忽略超出数组边界、零长度及方向相反的索引范围：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.fill(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.fill(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(zeroes);  <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure><p><code>copyWithin()</code>会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与<code>fill()</code>使用同样的计算方法，第一个参数，插入到哪个索引的位置，剩下两个参数是复制内容的索引范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line">    reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ints中复制索引0开始的内容，插入到索引5开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.copyWithin(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints);  <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ints中复制索引5开始的内容，插入到索引0开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ints);  <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从ints中复制索引0开始到索引3结束的内容，插入到索引4开始的位置</span></span><br><span class="line">ints.copyWithin(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript引擎在插值前会完整复制范围内的值，因此复制期间不存在重写的风险</span></span><br><span class="line">ints.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]</span></span><br><span class="line">reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.copyWithin(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>); <span class="comment">//  ints.copyWithin(6, 3, 7);</span></span><br><span class="line">alert(ints);  <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><code>copyWithin()</code>静默忽略超出数组边界、零长度及方向相反的索引范围，与上面<code>fill()</code>例子相同。</p><h3 id="6-2-7-转换方法"><a href="#6-2-7-转换方法" class="headerlink" title="6.2.7　转换方法"></a>6.2.7　转换方法</h3><p>所有对象都有<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。<code>valueOf()</code>返回的是数组本身。<code>toString()</code>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其<code>toString()</code>方法，以得到最终的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(colors.toString());   <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf());    <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br><span class="line">alert(colors);                    <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure><p>因为<code>alert()</code>期待字符串，所以会在后台调用数组的<code>toString()</code>方法，从而得到跟前面一样的结果。<br><code>toLocaleString()</code>方法可能返回跟<code>toString()</code>和<code>valueOf()</code>相同的结果。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的<code>toLocaleString()</code>方法。</p><p>如果想使用不同的分隔符，则可以使用<code>join()</code>方法，它接收一个参数，即字符串分隔符，返回包含所有项的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">alert(colors.join(<span class="string">&quot;,&quot;</span>));     <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line">alert(colors.join(<span class="string">&quot;||&quot;</span>));    <span class="comment">// &quot;red||green||blue&quot;</span></span><br></pre></td></tr></table></figure><p>如果不给<code>join()</code>传入任何参数，或者传入<code>undefined</code>，则仍然使用逗号作为分隔符。</p><blockquote><p><strong>注意</strong>  如果数组中某一项是<code>null</code>或<code>undefined</code>，则在<code>join()</code>、<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>返回的结果中会以空字符串表示。</p></blockquote><h3 id="6-2-8-栈方法"><a href="#6-2-8-栈方法" class="headerlink" title="6.2.8　栈方法"></a>6.2.8　栈方法</h3><p>ECMAScript数组提供了<code>push()</code>和<code>pop()</code>方法，以实现类似栈的行为。</p><p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。<code>pop()</code>方法则用于删除数组的最后一项，同时减少数组的<code>length</code>值，返回被删除的项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();                </span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  </span><br><span class="line">alert(colors);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="keyword">let</span> item = colors.pop();       <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(colors);          <span class="comment">// [&quot;red&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="6-2-9-队列方法"><a href="#6-2-9-队列方法" class="headerlink" title="6.2.9　队列方法"></a>6.2.9　队列方法</h3><p><code>shift()</code>，删除数组的第一项并返回它，然后数组长度减1。</p><p><code>shift()</code>和<code>push()</code>，可以把数组当成队列来使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();       </span><br><span class="line"><span class="keyword">let</span> count = colors.push(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);  <span class="comment">// 推入两项</span></span><br><span class="line"><span class="keyword">let</span> item = colors.shift();  <span class="comment">// 取得第一项</span></span><br><span class="line">alert(item);         <span class="comment">// red</span></span><br><span class="line">alert(colors);       <span class="comment">// [&quot;green&quot;]</span></span><br></pre></td></tr></table></figure><p><code>unshift()</code>方法，在数组开头添加任意多个值，然后返回新的数组长度。</p><h3 id="6-2-10-排序方法"><a href="#6-2-10-排序方法" class="headerlink" title="6.2.10　排序方法"></a>6.2.10　排序方法</h3><p><code>reverse()</code>方法就是将数组元素反向排列，会修改原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values);  <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>sort()</code>会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，<code>sort()</code>会在每一项上调用<code>String()</code>转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。因此，10还会排到5前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values);  <span class="comment">// 0,1,10,15,5</span></span><br></pre></td></tr></table></figure><p>为此，<code>sort()</code>方法可以接收一个<strong>比较函数</strong>，用于判断哪个值应该排在前面。<br>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个比较函数可以适用于大多数数据类型，可以把它当作参数传给sort()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);  <span class="comment">// 0,1,5,10,15</span></span><br></pre></td></tr></table></figure><p>比较函数也可以产生降序效果，只要把返回值交换一下即可。此外，这个比较函数还可简写为一个箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a &lt; b ? <span class="number">1</span> : a &gt; b ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">alert(values); <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> <code>reverse()</code>和<code>sort()</code>都返回调用它们的数组的引用。</p></blockquote><p>如果数组的元素是数值，或者是其<code>valueOf()</code>方法返回数值的对象（如<code>Date</code>对象），还可以更简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-11-操作方法"><a href="#6-2-11-操作方法" class="headerlink" title="6.2.11　操作方法"></a>6.2.11　操作方法</h3><p><code>concat()</code>方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则<code>concat()</code>会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。原始数组保持不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.concat(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure><p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcatSpreadable</code>。参见<code>3.4.7.7  </code>。</p><p><code>slice()</code>用于创建一个包含原有数组中一个或多个元素的新数组。如果只有一个参数，则<code>slice()</code>会返回该索引到数组末尾的所有元素。如果有两个参数，则<code>slice()</code>返回从开始索引到结束索引对应的所有元素，不包含结束索引对应的元素。不影响原始数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">alert(colors2);  <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line">alert(colors3);  <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 **如果<code>slice()</code>的参数有负值，那么就以数值长度加上这个负值的结果确定位置。</p></blockquote><p><code>splice()</code>的主要目的是在数组中间插入元素，但有<code>3</code>种不同的方式使用这个方法。</p><ul><li><strong>删除</strong>。需要给<code>splice()</code>传2个参数：开始位置和要删除的元素数量。。</li><li><strong>插入</strong>。需要给<code>splice()</code>传3个参数：开始位置、0（要删除的元素数量）和要插入的任意多个元素，在数组中指定的位置前插入元素。</li><li><strong>替换</strong>。<code>splice()</code>在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。插入和删除的元素数量不一定要一致。</li></ul><p><code>splice()</code>方法始终返回包含了从数组中被删除的元素数组（如果没有删除元素，则返回空数组）。会影响原数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(colors);                     <span class="comment">// [&quot;green&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed);                    <span class="comment">// [&quot;red&quot;]</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>);   <span class="comment">// 在位置1前插入两个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);              <span class="comment">// [&quot;green&quot;, &quot;yellow&quot;, &quot;orange&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed);             <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>);  <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);               <span class="comment">// [&quot;green&quot;, &quot;red&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(removed);              <span class="comment">// [&quot;yellow&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="6-2-12-搜索和位置方法"><a href="#6-2-12-搜索和位置方法" class="headerlink" title="6.2.12　搜索和位置方法"></a>6.2.12　搜索和位置方法</h3><p>ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p><h4 id="6-2-12-1-严格相等"><a href="#6-2-12-1-严格相等" class="headerlink" title="6.2.12.1   严格相等"></a><strong>6.2.12.1   严格相等</strong></h4><p>3个严格相等的搜索方法：<code>indexOf()</code>、<code>lastIndexOf()</code>和<code>includes()</code>。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。<code>indexOf()</code>和<code>includes()</code>方法从起始搜索位置（默认第一项）开始向后搜索，而<code>lastIndexOf()</code>从起始搜索位置（默认最后一项）开始向前搜索。</p><p><code>indexOf()</code>和<code>lastIndexOf()</code>都返回要查找的元素在数组中的位置，如果没找到则返回-1。<code>includes()</code>返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（<code>===</code>）比较，也就是必须严格相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>));          <span class="comment">// 3</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>));      <span class="comment">// 5</span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>));         <span class="comment">// true</span></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>));       <span class="comment">// 5</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>));   <span class="comment">// 3</span></span><br><span class="line">alert(numbers.includes(<span class="number">4</span>, <span class="number">7</span>));      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> morePeople = [person];</span><br><span class="line">alert(people.indexOf(person));      <span class="comment">// -1</span></span><br><span class="line">alert(morePeople.includes(person)); <span class="comment">// true</span></span><br><span class="line">alert(morePeople.indexOf(person));  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="6-2-12-2-断言函数"><a href="#6-2-12-2-断言函数" class="headerlink" title="6.2.12.2   断言函数"></a><strong>6.2.12.2   断言函数</strong></h4><p>按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p><p>断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p><p><code>find()</code>和<code>findIndex()</code>方法使用了断言函数。这两个方法都从数组的最小索引开始。<code>find()</code>返回第一个匹配的元素，<code>findIndex()</code>返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部<code>this</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">    age: <span class="number">27</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">alert(people.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br><span class="line">alert(people.findIndex(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.age &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>找到匹配项后，这两个方法都不再继续搜索。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 找到第一个匹配项后，不会继续搜索</span></span><br><span class="line">evens.find(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element);</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">  <span class="built_in">console</span>.log(array);</span><br><span class="line">  <span class="keyword">return</span> element === <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h3 id="6-2-13-迭代方法"><a href="#6-2-13-迭代方法" class="headerlink" title="6.2.13　迭代方法"></a>6.2.13　迭代方法</h3><p>ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中<code>this</code>的值）。传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。这些方法都不改变调用它们的数组。</p><ul><li><code>every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回<code>true</code>，则这个方法返回<code>true</code>。</li><li><code>filter()</code>：对数组每一项都运行传入的函数，函数返回<code>true</code>的项会组成数组之后返回。适合从数组中筛选满足给定条件的元素。</li><li><code>forEach()</code>：对数组每一项都运行传入的函数，没有返回值。相当于使用<code>for</code>循环遍历数组</li><li><code>map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。适合创建一个与原始数组元素一一对应的新数组。</li><li><code>some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回<code>true</code>，则这个方法返回<code>true</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(everyResult);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(someResult);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line">alert(filterResult);  <span class="comment">// 3,4,5,4,3</span></span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line">alert(mapResult);  <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-2-14-归并方法"><a href="#6-2-14-归并方法" class="headerlink" title="6.2.14　归并方法"></a>6.2.14　归并方法</h3></li></ul><p>ECMAScript为数组提供了两个归并方法：<code>reduce()</code>和<code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。<code>reduce()</code>方法从数组第一项开始遍历到最后一项。而<code>reduceRight()</code>从最后一项开始遍历至第一项。</p><p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。归并函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p><p>可以使用<code>reduce()</code>函数执行累加数组中所有数值的操作，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line">alert(sum);  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><code>reduceRight()</code>方法与之类似，只是方向相反。</p><h2 id="6-3-定型数组"><a href="#6-3-定型数组" class="headerlink" title="6.3　定型数组"></a>6.3　定型数组</h2><p>在WebGL的早期版本中，JavaScript数组与原生数组之间不匹配，因为图形驱动程序API通常不需要以JavaScript默认双精度浮点格式传递给它们的数值，因此每次WebGL与JavaScript运行时之间传递数组时，WebGL绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式。</p><p>定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。</p><h3 id="6-3-1-ArrayBuffer"><a href="#6-3-1-ArrayBuffer" class="headerlink" title="6.3.1   ArrayBuffer"></a>6.3.1   ArrayBuffer</h3><p><code>ArrayBuffer</code>对象代表储存二进制数据的一段内存，不能直接读写，只能通过<code>DataView</code>视图和定型数组来读写，<code>ArrayBuffer</code>是所有定型数组及视图引用的基本单位。视图的作用是以指定格式解读<code>ArrayBuffer</code>存储的二进制数据。</p><blockquote><p>**注意 **<code>SharedArrayBuffer</code>是<code>ArrayBuffer</code>的一个变体，可以无须复制就在执行上下文间传递它。</p></blockquote><p><code>ArrayBuffer()</code>是一个普通的JavaScript构造函数，可用于在内存中分配特定数量的字节空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);  <span class="comment">// 在内存中分配16字节</span></span><br><span class="line">alert(buf.byteLength);            <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p><code>ArrayBuffer</code>一经创建就不能再调整大小。不过可以使用<code>slice()</code>复制其全部或部分到一个新实例中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.slice(<span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line">alert(buf2.byteLength);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><code>ArrayBuffer</code>某种程度上类似于C++的<code>malloc()</code>，但也有几个明显的区别。</p><ul><li><code>malloc()</code>在分配失败时会返回一个<code>null</code>指针。<code>ArrayBuffer</code>在分配失败时会抛出错误。</li><li><code>malloc()</code>可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。<code>ArrayBuffer</code>分配的内存不能超过<code>Number.MAX_SAFE_INTEGER</code>（<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/28/gr45RjvVdkUATbH.gif"                      alt="gif _1_.gif"                >)）字节。</li><li><code>malloc()</code>调用成功不会初始化实际的地址。声明<code>ArrayBuffer</code>则会将所有二进制位初始化为0。</li><li>通过<code>malloc()</code>分配的堆内存除非调用<code>free()</code>或程序退出，否则系统不能再使用。而通过声明<code>ArrayBuffer</code>分配的堆内存可以被当成垃圾回收，不用手动释放。<h3 id="6-3-2-DataView"><a href="#6-3-2-DataView" class="headerlink" title="6.3.2   DataView"></a>6.3.2   DataView</h3></li></ul><p><code>DataView</code>视图专为文件I/O和网络I/O设计，其API支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。<code>DataView</code>对缓冲内容没有任何预设，也不能迭代。</p><p>必须在对已有的<code>ArrayBuffer</code>读取或写入时才能创建<code>DataView</code>实例。这个实例可以使用全部或部分<code>ArrayBuffer</code>，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// DataView默认使用整个ArrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">alert(fullDataView.byteOffset);      <span class="comment">// 0</span></span><br><span class="line">alert(fullDataView.byteLength);      <span class="comment">// 16</span></span><br><span class="line">alert(fullDataView.buffer === buf);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">//   byteOffset=0表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">//   byteLength=8限制视图为前8个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">alert(firstHalfDataView.byteOffset);      <span class="comment">// 0</span></span><br><span class="line">alert(firstHalfDataView.byteLength);      <span class="comment">// 8</span></span><br><span class="line">alert(firstHalfDataView.buffer === buf);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不指定，则DataView会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">//   byteOffset=8表示视图从缓冲的第9个字节开始</span></span><br><span class="line"><span class="comment">//   byteLength未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf, <span class="number">8</span>);</span><br><span class="line">alert(secondHalfDataView.byteOffset);      <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.byteLength);      <span class="comment">// 8</span></span><br><span class="line">alert(secondHalfDataView.buffer === buf);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要通过<code>DataView</code>读取缓冲，还需要几个组件。<br>• 首先是要读或写的字节偏移量。可以看成<code>DataView</code>中的某种“地址”。</p><p>•<code>DataView</code>应该使用<code>ElementType</code>来实现JavaScript的<code>Number</code>类型到缓冲内二进制格式的转换。</p><p>• 最后是内存中值的字节序默认为大端字节序。</p><h4 id="6-3-2-1-ElementType"><a href="#6-3-2-1-ElementType" class="headerlink" title="6.3.2.1   ElementType"></a>6.3.2.1   ElementType</h4><p><code>DataView</code>对存储在缓冲内的数据类型没有预设。它暴露的API强制开发者在读、写时指定一个<code>ElementType</code>，然后<code>DataView</code>为读、写而完成相应的转换。</p><p>ECMAScript 6支持8种不同的<code>ElementType</code>。</p><table><thead><tr><th align="center">ElementType</th><th align="center">字节</th><th align="center">说明</th><th align="center">值的范围</th></tr></thead><tbody><tr><td align="center">Int8</td><td align="center">1</td><td align="center">8位有符号整数</td><td align="center">-128~127</td></tr><tr><td align="center">Uint8</td><td align="center">1</td><td align="center">8位无符号整数</td><td align="center">0~255</td></tr><tr><td align="center">Int16</td><td align="center">2</td><td align="center">16位有符号整数</td><td align="center">-32 768~32 767</td></tr><tr><td align="center">Uint16</td><td align="center">2</td><td align="center">16位无符号整数</td><td align="center">0~65 535</td></tr><tr><td align="center">Int32</td><td align="center">4</td><td align="center">32位有符号整数</td><td align="center">-2 147 483 648~2 147 483 647</td></tr><tr><td align="center">Uint32</td><td align="center">4</td><td align="center">32位无符号整数</td><td align="center">0~4 294 967 295</td></tr><tr><td align="center">Float32</td><td align="center">4</td><td align="center">32位IEEE-754浮点数</td><td align="center">-3.4e+38~+3.4e+38</td></tr><tr><td align="center">Float64</td><td align="center">8</td><td align="center">64位IEEE-754浮点数</td><td align="center">-1.7e+308~+1.7e+308</td></tr></tbody></table><p><code>DataView</code>为上表中的每种类型都暴露了<code>get</code>和<code>set</code>方法，这些方法使用<code>byteOffset</code>定位要读取或写入值的字节开始位置。不同类型之间是可以互换使用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个DataView</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 读取缓冲第一个和第二个字节，说明整个缓冲所有二进制位都是0</span></span><br><span class="line">alert(view.getInt8(<span class="number">0</span>));  <span class="comment">// 0</span></span><br><span class="line">alert(view.getInt8(<span class="number">1</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 读取整个缓冲</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为1</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">255</span>);  <span class="comment">// 255的二进制表示是11111111（2^8 - 1）</span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0xFF</span>); <span class="comment">// DataView会自动将数据转换为特定的ElementType，255的十六进制表示是0xFF</span></span><br><span class="line">alert(view.getInt16(<span class="number">0</span>)); <span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1</span></span><br></pre></td></tr></table></figure><h4 id="6-3-2-2-字节序"><a href="#6-3-2-2-字节序" class="headerlink" title="6.3.2.2   字节序"></a><strong>6.3.2.2   字节序</strong></h4><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。<code>DataView</code>只支持两种约定：大端字节序（也称为网络字节序）和小端字节序。大端字节序是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反。</p><p>JavaScript运行时所在系统的原生字节序决定了如何读取或写入字节，但对一段内存而言，<code>DataView</code>是一个中立接口，它会遵循指定的字节序。<code>DataView</code>的所有API方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为<code>true</code>即可启用小端字节序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 填充缓冲 1000 0000 0000 0001</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">0x80</span>);</span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0x01</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按大端字节序读取Uint16，0x80是高字节，0x01是低字节</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>)); <span class="comment">// 2^15 + 2^0 = 32769</span></span><br><span class="line"><span class="comment">// 按小端字节序读取Uint16，0x01是高字节，0x80是低字节</span></span><br><span class="line">alert(view.getUint16(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 0x0180 = 2^8 + 2^7 = 384</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按大端字节序写入Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0004</span>);</span><br><span class="line"><span class="comment">// 填充缓冲 0000 0000 0000 0100</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按小端字节序写入Uint16</span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 缓冲内容 0000 0010 0000 0000</span></span><br><span class="line">alert(view.getUint8(<span class="number">0</span>)); <span class="comment">// 2</span></span><br><span class="line">alert(view.getUint8(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="6-3-2-3-边界情形"><a href="#6-3-2-3-边界情形" class="headerlink" title="6.3.2.3   边界情形"></a><strong>6.3.2.3   边界情形</strong></h4><p><code>DataView</code>完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出<code>RangeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">3</span>); <span class="comment">// RangeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">6</span>); <span class="comment">// RangeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(-<span class="number">1</span>); <span class="comment">// RangeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.setInt32(<span class="number">3</span>, <span class="number">123</span>); <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p><code>DataView</code>在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0。如果无法转换，则抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">1.5</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">view.setInt8(<span class="number">0</span>, [<span class="number">4</span>]);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="built_in">Symbol</span>());  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="6-3-3-定型数组"><a href="#6-3-3-定型数组" class="headerlink" title="6.3.3   定型数组"></a>6.3.3   定型数组</h3><p>定型数组是另一种形式的<code>ArrayBuffer</code>视图。虽然概念上与<code>DataView</code>接近，但区别在于它特定于一种<code>ElementType</code>且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API和更高的性能。</p><p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过<code>&lt;ElementType&gt;.from()</code>和<code>&lt;ElementType&gt;.of()</code>也可以创建定型数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">12</span>);  <span class="comment">// 创建一个12字节的缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buf); <span class="comment">// 创建一个引用该缓冲的Int32Array</span></span><br><span class="line">alert(ints.length); <span class="comment">// 这个定型数组知道自己的每个元素需要4字节，因此长度为3</span></span><br><span class="line"><span class="keyword">const</span> ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">6</span>); <span class="comment">// 创建一个长度为6的Int32Array，因此ArrayBuffer是24字节</span></span><br><span class="line">alert(ints2.length);             <span class="comment">// 6</span></span><br><span class="line">alert(ints2.buffer.byteLength);  <span class="comment">// 24，定型数组也有一个指向关联缓冲的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints3 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line">alert(ints3.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints3.buffer.byteLength); <span class="comment">// 16</span></span><br><span class="line">alert(ints3[<span class="number">2</span>]);                <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ints4 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(ints3); <span class="comment">//这个新类型数组会分配自己的缓冲，对应索引的每个值也会相应地转换为新格式</span></span><br><span class="line">alert(ints4.length);            <span class="comment">// 4</span></span><br><span class="line">alert(ints4.buffer.byteLength); <span class="comment">// 8</span></span><br><span class="line">alert(ints4[<span class="number">2</span>]);                <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> floats = <span class="built_in">Float32Array</span>.of(<span class="number">3.14</span>, <span class="number">2.718</span>, <span class="number">1.618</span>);</span><br><span class="line">alert(floats.length);            <span class="comment">// 3</span></span><br><span class="line">alert(floats.buffer.byteLength); <span class="comment">// 12</span></span><br><span class="line">alert(floats[<span class="number">2</span>]);                <span class="comment">// 1.6180000305175781</span></span><br></pre></td></tr></table></figure><p>定型数组的构造函数和实例都有一个<code>BYTES_PER_ELEMENT</code>属性，返回该类型数组中每个元素的大小：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT);  <span class="comment">// 2</span></span><br><span class="line">alert(<span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT);  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">1</span>),</span><br><span class="line">      floats = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">1</span>);</span><br><span class="line">alert(ints.BYTES_PER_ELEMENT);        <span class="comment">// 4</span></span><br><span class="line">alert(floats.BYTES_PER_ELEMENT);      <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>如果定型数组没有用任何值初始化，则其关联的缓冲会以0填充：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(<span class="number">2</span>);</span><br><span class="line">alert(ints[<span class="number">0</span>]);  <span class="comment">// 0</span></span><br><span class="line">alert(ints[<span class="number">1</span>]);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="6-3-3-1-定型数组行为"><a href="#6-3-3-1-定型数组行为" class="headerlink" title="6.3.3.1   定型数组行为"></a><strong>6.3.3.1   定型数组行为</strong></h4><p>从很多方面看，定型数组与普通数组都很相似。定型数组支持大多数数组的操作符、方法和属性。</p><p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> doubleints = ints.map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span>*x);</span><br><span class="line">alert(doubleints <span class="keyword">instanceof</span> <span class="built_in">Int16Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>定型数组有一个<code>Symbol.iterator</code>符号属性，因此可以通过<code>for..of</code>循环和扩展操作符来操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> int <span class="keyword">of</span> ints) &#123;</span><br><span class="line">  alert(int);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">alert(<span class="built_in">Math</span>.max(...ints)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="6-3-3-2-合并、复制和修改定型数组"><a href="#6-3-3-2-合并、复制和修改定型数组" class="headerlink" title="6.3.3.2   合并、复制和修改定型数组"></a><strong>6.3.3.2   合并、复制和修改定型数组</strong></h4><p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p><ul><li><code>concat()</code></li><li><code>pop()</code></li><li><code>push()</code></li><li><code>shift()</code></li><li><code>splice()</code></li><li><code>unshift()</code></li></ul><p>不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：<code>set()</code>和<code>subarray()</code>。</p><p><code>set()</code>从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 把定型数组复制为前4个值，偏移量默认为索引0</span></span><br><span class="line">container.set(<span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(container);  <span class="comment">// [1,2,3,4,0,0,0,0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把普通数组复制为后4个值，偏移量4表示从索引4开始插入</span></span><br><span class="line">container.set([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(container);  <span class="comment">// [1,2,3,4,5,6,7,8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出会抛出错误</span></span><br><span class="line">container.set([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="number">7</span>); <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p><code>subarray()</code>执行与<code>set()</code>相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">Int16Array</span>.of(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// 把整个数组复制为一个同类型的新数组</span></span><br><span class="line"><span class="keyword">const</span> fullCopy = source.subarray();</span><br><span class="line"><span class="built_in">console</span>.log(fullCopy);  <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始复制数组</span></span><br><span class="line"><span class="keyword">const</span> halfCopy = source.subarray(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(halfCopy);  <span class="comment">// [6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引1开始复制到索引3</span></span><br><span class="line"><span class="keyword">const</span> partialCopy = source.subarray(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(partialCopy);  <span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure><p>定型数组没有原生的拼接能力，但使用定型数组API提供的很多工具可以手动构建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是应该返回的数组类型</span></span><br><span class="line"><span class="comment">// 其余参数是应该拼接在一起的定型数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typedArrayConcat</span>(<span class="params">typedArrayConstructor, ...typedArrays</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计算所有数组中包含的元素总数</span></span><br><span class="line">  <span class="keyword">const</span> numElements = typedArrays.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> (x.length || x) + y.length);</span><br><span class="line">  <span class="comment">// 按照提供的类型创建一个数组，为所有元素留出空间</span></span><br><span class="line">  <span class="keyword">const</span> resultArray = <span class="keyword">new</span> typedArrayConstructor(numElements);</span><br><span class="line">  <span class="comment">// 依次转移数组</span></span><br><span class="line">  <span class="keyword">let</span> currentOffset = <span class="number">0</span>;</span><br><span class="line">  typedArrays.map(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    resultArray.set(x, currentOffset);</span><br><span class="line">    currentOffset += x.length;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> resultArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> concatArray = typedArrayConcat(<span class="built_in">Int32Array</span>,</span><br><span class="line">                                     <span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                                     <span class="built_in">Int16Array</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">                                     <span class="built_in">Float32Array</span>.of(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line"><span class="built_in">console</span>.log(concatArray);  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(concatArray <span class="keyword">instanceof</span> <span class="built_in">Int32Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="6-3-3-3-下溢和上溢"><a href="#6-3-3-3-下溢和上溢" class="headerlink" title="6.3.3.3   **下溢和上溢 **"></a>6.3.3.3   **下溢和上溢 **</h4><p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">2</span>);  <span class="comment">// 范围是-128~127</span></span><br><span class="line"><span class="keyword">const</span> unsignedInts = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">2</span>);  <span class="comment">//范围是0~255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上溢的位不会影响相邻索引，索引只取最低有效位上的8位</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">256</span>;      <span class="comment">// 0x100</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 0]</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = <span class="number">511</span>;      <span class="comment">// 0x1FF</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下溢的位会被转换为其无符号的等价值</span></span><br><span class="line">unsignedInts[<span class="number">1</span>] = -<span class="number">1</span>        <span class="comment">// 0xFF (truncated to 8 bits)</span></span><br><span class="line"><span class="built_in">console</span>.log(unsignedInts);  <span class="comment">// [0, 255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0x80是无符号整数的128，是二补数形式的-128</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">128</span>;        <span class="comment">// 0x80    1000 0000</span></span><br><span class="line"><span class="built_in">console</span>.log(ints);    <span class="comment">// [0, -128]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下溢自动变成二补数形式</span></span><br><span class="line"><span class="comment">// 0xFF是无符号整数的255，是二补数形式的-1</span></span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">255</span>;        <span class="comment">// 0xFF</span></span><br><span class="line"><span class="built_in">console</span>.log(ints);    <span class="comment">// [0, -1]</span></span><br></pre></td></tr></table></figure><p>除了8种元素类型，还有一种“夹板”数组类型：<code>Uint8ClampedArray</code>，不允许任何方向溢出。超出最大值255的值会被向下舍入为255，而小于最小值0的值会被向上舍入为0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clampedInts = <span class="keyword">new</span> <span class="built_in">Uint8ClampedArray</span>([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">256</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(clampedInts); <span class="comment">// [0, 0, 255, 255]</span></span><br></pre></td></tr></table></figure><p><code>Uint8ClampedArray</code>完全是HTML5<code>canvas</code>元素的历史留存，除非做<code>canvas</code>相关的开发，否则不要使用。</p><h2 id="6-4-Map"><a href="#6-4-Map" class="headerlink" title="6.4　Map"></a>6.4　<code>Map</code></h2><p><code>Map</code>是一种新的集合类型，<code>Map</code>的大多数特性都可以通过<code>Object</code>类型实现，但二者之间还是存在细微差异。</p><h3 id="6-4-1-基本API"><a href="#6-4-1-基本API" class="headerlink" title="6.4.1　基本API"></a>6.4.1　基本API</h3><p>使用<code>new</code>关键字和<code>Map</code>构造函数可以创建一个空映射：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><p>如果想在创建的同时初始化实例，可以给<code>Map</code>构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中。</p><p>初始化之后，可以使用<code>set()</code>方法再添加键/值对，<code>set()</code>方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明。另外，可以使用<code>get()</code>和<code>has()</code>进行查询，可以通过<code>size</code>属性获取映射中的键/值对的数量，还可以使用<code>delete()</code>和<code>clear()</code>删除值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(m1.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>];</span><br><span class="line">    <span class="keyword">yield</span> [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(m2.size); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="built_in">Map</span>([[]]);</span><br><span class="line">alert(m3.has(<span class="literal">undefined</span>));  <span class="comment">// true</span></span><br><span class="line">alert(m3.get(<span class="literal">undefined</span>));  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Matt&quot;</span>)</span><br><span class="line"> .set(<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">alert(m.get(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// Matt</span></span><br><span class="line">alert(m.size);             <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="string">&quot;firstName&quot;</span>);     <span class="comment">// 只删除这一个键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.size);             <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">m.clear(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line">alert(m.has(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">alert(m.has(<span class="string">&quot;lastName&quot;</span>));  <span class="comment">// false</span></span><br><span class="line">alert(m.size);             <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>与<code>Object</code>只能使用数值、字符串或符号作为键不同，<code>Map</code>可以使用任何JavaScript数据类型作为键。映射的值与<code>Object</code>类似，是没有限制的。<code>Map</code>内部使用SameValueZero比较操作（ECMAScript规范内部定义，语言中不能使用），基本上相当于使用严格对象相等的标准来检查键的匹配性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">m.set(functionKey, <span class="string">&quot;functionValue&quot;</span>);</span><br><span class="line">m.set(symbolKey, <span class="string">&quot;symbolValue&quot;</span>);</span><br><span class="line">m.set(objectKey, <span class="string">&quot;objectValue&quot;</span>);</span><br><span class="line">alert(m.get(functionKey));  <span class="comment">// functionValue</span></span><br><span class="line">alert(m.get(symbolKey));    <span class="comment">// symbolValue</span></span><br><span class="line">alert(m.get(objectKey));    <span class="comment">// objectValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SameValueZero比较意味着独立实例不冲突</span></span><br><span class="line">alert(m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>与严格相等一样，在映射中用作键以及值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;,</span><br><span class="line">      objVal = &#123;&#125;,</span><br><span class="line">      arrKey = [],</span><br><span class="line">      arrVal = [];</span><br><span class="line">m.set(objKey, objVal);</span><br><span class="line">m.set(arrKey, arrVal);</span><br><span class="line">objKey.foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arrKey.push(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.get(objKey)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(arrKey)); <span class="comment">// [&quot;bar&quot;]</span></span><br></pre></td></tr></table></figure><p>但SameValueZero比较也可能导致意想不到的冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">&quot;&quot;</span>,   <span class="comment">// NaN</span></span><br><span class="line">      b = <span class="number">0</span>/<span class="string">&quot;&quot;</span>,   <span class="comment">// NaN</span></span><br><span class="line">      pz = +<span class="number">0</span>,</span><br><span class="line">      nz = -<span class="number">0</span>;</span><br><span class="line">alert(a === b);   <span class="comment">// false</span></span><br><span class="line">alert(pz === nz); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.set(a, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">m.set(pz, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">alert(m.get(b));  <span class="comment">// foo</span></span><br><span class="line">alert(m.get(nz)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h3 id="6-4-2-顺序与迭代"><a href="#6-4-2-顺序与迭代" class="headerlink" title="6.4.2　顺序与迭代"></a>6.4.2　顺序与迭代</h3><p>与<code>Object</code>类型的一个主要差异是，<code>Map</code>实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。</p><p>映射实例可以提供一个迭代器（<code>Iterator</code>），能以插入顺序生成<code>[key, value]</code>形式的数组。可以通过<code>entries()</code>方法（或者<code>Symbol.iterator</code>属性，它引用<code>entries()</code>）取得这个迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  alert(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [key1,val1]</span></span><br><span class="line"><span class="comment">// [key2,val2]</span></span><br><span class="line"><span class="comment">// [key3,val3]</span></span><br></pre></td></tr></table></figure><p>因为<code>entries()</code>是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log([...m]); <span class="comment">// [[key1,val1],[key2,val2],[key3,val3]]</span></span><br></pre></td></tr></table></figure><p>如果不使用迭代器，则可以调用映射的<code>forEach(callback, opt_thisArg)</code>方法并传入回调，依次迭代每个键/值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;key&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// key1 -&gt; val1</span></span><br><span class="line"><span class="comment">// key2 -&gt; val2</span></span><br><span class="line"><span class="comment">// key3 -&gt; val3</span></span><br></pre></td></tr></table></figure><p><code>keys()</code>和<code>values()</code>分别返回以插入顺序生成键和值的迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1</span></span><br><span class="line"><span class="comment">// key2</span></span><br><span class="line"><span class="comment">// key3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  alert(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure><p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;val1&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 作为键的字符串原始值是不能修改的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m1.keys()) &#123;</span><br><span class="line">  key = <span class="string">&quot;newKey&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// newKey  </span></span><br><span class="line">  <span class="built_in">console</span>.log(m1.get(<span class="string">&quot;newKey&quot;</span>)); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(m1.get(<span class="string">&quot;key1&quot;</span>));  <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keyObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [keyObj, <span class="string">&quot;val1&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  key.id = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">  alert(key);            <span class="comment">// &#123;id: &quot;2&quot;&#125;</span></span><br><span class="line">  alert(m.get(keyObj));  <span class="comment">// val1</span></span><br><span class="line">&#125;</span><br><span class="line">alert(keyObj);           <span class="comment">// &#123;id: &quot;2&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-4-3-选择Object还是Map"><a href="#6-4-3-选择Object还是Map" class="headerlink" title="6.4.3　选择Object还是Map"></a>6.4.3　选择<code>Object</code>还是<code>Map</code></h3><ol><li><strong>内存占用</strong></li></ol><p>内存会随着键/值对数量增加而线性增加，但固定大小的内存，<code>Map</code>大约可以比<code>Object</code>多存储50%的键/值对。</p><ol start="2"><li><strong>插入性能</strong></li></ol><p>这两个类型的插入速度不会随着键/值对数量增加而线性增加。如果代码涉及大量插入操作，<code>Map</code>的性能更佳。</p><ol start="3"><li><strong>查找速度</strong></li></ol><p>这两个类型的查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，<code>Object</code>更好一些。</p><ol start="4"><li><strong>删除性能</strong></li></ol><p>使用<code>delete</code>删除<code>Object</code>属性的性能不好，为此，出现了一些伪删除对象属性的操作，包括把属性值设置为<code>undefined</code>或<code>null</code>。因此代码涉及大量删除操作，选择<code>Map</code>。</p><h2 id="6-5-WeakMap"><a href="#6-5-WeakMap" class="headerlink" title="6.5　WeakMap"></a>6.5　<code>WeakMap</code></h2><p>ECMAScript 6新增的“弱映射”（<code>WeakMap</code>）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。<code>WeakMap</code>是<code>Map</code>的“兄弟”类型，其API也是<code>Map</code>的子集。<code>WeakMap</code>中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱映射”中键的弱引用。</p><h3 id="6-5-1-基本API"><a href="#6-5-1-基本API" class="headerlink" title="6.5.1　基本API"></a>6.5.1　基本API</h3><p>可以使用<code>new</code>关键字实例化一个空的<code>WeakMap</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br></pre></td></tr></table></figure><p>弱映射中的键只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置键会抛出<code>TypeError</code>。值的类型没有限制。除此之外，可参照<code>6.4.1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      key2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      key3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm21 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([</span><br><span class="line">  [key1, <span class="string">&quot;val1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;BADKEY&quot;</span>, <span class="string">&quot;val2&quot;</span>],</span><br><span class="line">  [key3, <span class="string">&quot;val3&quot;</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="6-5-2-弱键"><a href="#6-5-2-弱键" class="headerlink" title="6.5.2　弱键"></a>6.5.2　弱键</h3><p><code>WeakMap</code>表示弱映射的键不属于正式的引用，不会阻止垃圾回收。但值不是，只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。</p><p>下面这个例子，因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收，而且值也没有被引用，这个键/值对就从弱映射中消失了，使其成为一个空映射。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(&#123;&#125;, <span class="string">&quot;val&quot;</span>);</span><br></pre></td></tr></table></figure><p>再看一个稍微不同的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> container = &#123;</span><br><span class="line">  key: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">wm.set(container.key, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  container.key = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>container</code>对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。但如果调用了<code>removeReference()</code>，就会摧毁键对象的最后一个强引用，垃圾回收程序就可以把这个键/值对清理掉，这也是使用<code>WeakMap</code>的目的。因为当没有任何指向这个对象的强引用的时候，就只剩<code>WeakMap</code>对键对象的弱引用，而弱引用不会阻止垃圾回收。</p><h3 id="6-5-3-不可迭代键"><a href="#6-5-3-不可迭代键" class="headerlink" title="6.5.3　不可迭代键"></a>6.5.3　不可迭代键</h3><p>因为<code>WeakMap</code>中的键/值对任何时候都可能被销毁，所以没有提供迭代其键/值对的能力，同时也没有像<code>clear()</code>这样一次性销毁所有键/值的方法。</p><p>如果<code>WeakMap</code>实例允许原始值，那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。因为原始值是按值传递，这样的话实例中的键与变量<code>key</code>就失去联系了，即便变量<code>key</code>的内存被回收了，实例中的键也还存在，重新创建一个和之前字符串相等的变量就可以获得键值对的信息，所以<code>WeakMap</code>实例只用对象作为键，保证只有通过键对象的引用才能取得值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// const key1 = &#x27;abc&#x27;</span></span><br><span class="line">wm.set(key, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="6-5-4-使用弱映射"><a href="#6-5-4-使用弱映射" class="headerlink" title="6.5.4　使用弱映射"></a>6.5.4　使用弱映射</h3><h4 id="6-5-4-1-私有变量"><a href="#6-5-4-1-私有变量" class="headerlink" title="6.5.4.1   私有变量"></a><strong>6.5.4.1   私有变量</strong></h4><p>弱映射造就了在JavaScript中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line">      <span class="built_in">this</span>.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setPrivate</span>(<span class="params">property, value</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> privateMembers = wm.get(<span class="built_in">this</span>) || &#123;&#125;;</span><br><span class="line">      privateMembers[property] = value;</span><br><span class="line">      wm.set(<span class="built_in">this</span>, privateMembers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getPrivate</span>(<span class="params">property</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> wm.get(<span class="built_in">this</span>)[property];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setPrivate(<span class="built_in">this</span>.idProperty, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getId</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.getPrivate(<span class="built_in">this</span>.idProperty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">alert(user.getId()); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure><p>这样拿不到弱映射中的健，也就无法取得弱映射中对应的值，但也陷入了ES6之前的闭包私有变量模式。</p><h4 id="6-5-4-2-DOM节点元数据"><a href="#6-5-4-2-DOM节点元数据" class="headerlink" title="6.5.4.2   DOM节点元数据"></a><strong>6.5.4.2   DOM节点元数据</strong></h4><p>因为<code>WeakMap</code>实例不会妨碍垃圾回收，所以非常适合保存关联元数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 给这个节点关联一些元数据</span></span><br><span class="line">wm.set(loginButton, &#123;<span class="attr">disabled</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>假设代码执行后，原来的登录按钮从DOM树中被删掉了，那么垃圾回收程序就可以立即释放其内存（假设没有其他地方引用这个对象）。但如果使用映射，由于映射中还保存着按钮的引用，所以对应的DOM节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。</p><h2 id="6-6-Set"><a href="#6-6-Set" class="headerlink" title="6.6　Set"></a>6.6　<code>Set</code></h2><p>ECMAScript 6新增的<code>Set</code>是一种新集合类型。<code>Set</code>在很多方面都像是加强的<code>Map</code>，这是因为它们的大多数API和行为都是共有的。</p><h3 id="6-6-1-基本API"><a href="#6-6-1-基本API" class="headerlink" title="6.6.1　基本API"></a>6.6.1　基本API</h3><p>使用<code>new</code>关键字和<code>Set</code>构造函数可以创建一个空集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>如果想在创建的同时初始化实例，则可以给<code>Set</code>构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素。初始化之后，可以使用<code>add()</code>增加值，<code>add()</code>返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化。也可以使用<code>has()</code>查询，通过<code>size</code>取得元素数量，以及使用<code>delete()</code>和<code>clear()</code>删除元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化集合</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(&#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val1&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val2&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;val3&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">&quot;Matt&quot;</span>)</span><br><span class="line"> .add(<span class="string">&quot;Frisbie&quot;</span>);</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// true</span></span><br><span class="line">alert(s.size);           <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">alert(s.has(<span class="string">&quot;Matt&quot;</span>));    <span class="comment">// false</span></span><br><span class="line">alert(s.size);           <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">s.clear(); <span class="comment">// 销毁集合实例中的所有值</span></span><br><span class="line">alert(s.size);           <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>与<code>Map</code>类似，<code>Set</code>可以包含任何JavaScript数据类型作为值。集合也使用SameValueZero操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> functionVal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">s.add(functionVal);</span><br><span class="line">s.add(symbolVal);</span><br><span class="line">s.add(objectVal);</span><br><span class="line">alert(s.has(functionVal));   <span class="comment">// true</span></span><br><span class="line">alert(s.has(symbolVal));     <span class="comment">// true</span></span><br><span class="line">alert(s.has(objectVal));     <span class="comment">// true</span></span><br><span class="line"><span class="comment">// SameValueZero检查意味着独立的实例不会冲突</span></span><br><span class="line">alert(s.has(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> objVal = &#123;&#125;,</span><br><span class="line">      arrVal = [];</span><br><span class="line">s.add(objVal)</span><br><span class="line"> .add(arrVal);</span><br><span class="line">objVal.bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arrVal.push(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">alert(s.has(objVal)); <span class="comment">// true</span></span><br><span class="line">alert(s.has(arrVal)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>add()</code>和<code>delete()</code>操作是幂等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line">s.add(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">alert(s.size); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 集合里有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 集合里没有这个值</span></span><br><span class="line">alert(s.delete(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="6-6-2-顺序与迭代"><a href="#6-6-2-顺序与迭代" class="headerlink" title="6.6.2　顺序与迭代"></a>6.6.2　顺序与迭代</h3><p><code>Set</code>会维护值插入时的顺序，因此支持按顺序迭代。集合实例可以提供一个迭代器<code>Iterator</code>，能以插入顺序生成集合内容。可以通过<code>values()</code>方法及其别名方法<code>keys()</code>或者<code>Symbol.iterator</code>属性，它引用<code>values()</code>取得这个迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">alert(s.values === s[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line">alert(s.keys === s[<span class="built_in">Symbol</span>.iterator]);   <span class="comment">// true</span></span><br><span class="line">alert(m.entries === m[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val1</span></span><br><span class="line"><span class="comment">// val2</span></span><br><span class="line"><span class="comment">// val3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> s.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;val1&quot;, &quot;val1&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;val2&quot;, &quot;val2&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;val3&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure><p>因为<code>values()</code>是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...s]); <span class="comment">// [&quot;val1&quot;, &quot;val2&quot;, &quot;val3&quot;]</span></span><br></pre></td></tr></table></figure><p>如果使用回调方式，则可以调用集合的<code>forEach()</code>方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>, <span class="string">&quot;val2&quot;</span>, <span class="string">&quot;val3&quot;</span>]);</span><br><span class="line">s.forEach(<span class="function">(<span class="params">val, dupVal</span>) =&gt;</span> alert(<span class="string">`<span class="subst">$&#123;val&#125;</span> -&gt; <span class="subst">$&#123;dupVal&#125;</span>`</span>));</span><br><span class="line"><span class="comment">// val1 -&gt; val1</span></span><br><span class="line"><span class="comment">// val2 -&gt; val2</span></span><br><span class="line"><span class="comment">// val3 -&gt; val3</span></span><br></pre></td></tr></table></figure><p>修改集合中值的属性同样不会影响其作为集合值的身份。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;val1&quot;</span>]);</span><br><span class="line"><span class="comment">// 字符串原始值作为值不会被修改</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s1.values()) &#123;</span><br><span class="line">  value = <span class="string">&quot;newVal&quot;</span>;</span><br><span class="line">  alert(value);          <span class="comment">// newVal</span></span><br><span class="line">  alert(s1.has(<span class="string">&quot;val1&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> valObj = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([valObj]);</span><br><span class="line"><span class="comment">// 修改值对象的属性，但对象仍然存在于集合中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> s2.values()) &#123;</span><br><span class="line">  value.id = <span class="string">&quot;newVal&quot;</span>;</span><br><span class="line">  alert(value);           <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br><span class="line">  alert(s2.has(valObj));  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">alert(valObj);            <span class="comment">// &#123;id: &quot;newVal&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-6-3-定义正式集合操作"><a href="#6-6-3-定义正式集合操作" class="headerlink" title="6.6.3　定义正式集合操作"></a>6.6.3　定义正式集合操作</h3><p>扩展<code>Set</code>操作需要手动实现：通过子类化<code>Set</code>，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。</p><ul><li>某些<code>Set</code>操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</li><li><code>Set</code>保留插入顺序，所有方法返回的集合必须保证顺序。</li><li>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。</li><li>不要修改已有的集合实例。<code>union(a, b)</code>或<code>a.union(b)</code>应该返回包含结果的新集合实例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XSet</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">union</span>(<span class="params">...sets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.union(<span class="built_in">this</span>, ...sets)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">intersection</span>(<span class="params">...sets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.intersection(<span class="built_in">this</span>, ...sets);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">difference</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.difference(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">symmetricDifference</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.symmetricDifference(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">cartesianProduct</span>(<span class="params">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.cartesianProduct(<span class="built_in">this</span>, set);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">powerSet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> XSet.powerSet(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的并集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">union</span>(<span class="params">a, ...bSets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> unionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        unionSet.add(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个或更多集合的交集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">intersection</span>(<span class="params">a, ...bSets</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b.has(aValue)) &#123;</span><br><span class="line">          intersectionSet.delete(aValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intersectionSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">difference</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> XSet(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.has(bValue)) &#123;</span><br><span class="line">        differenceSet.delete(bValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> differenceSet;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">symmetricDifference</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">    <span class="keyword">return</span> a.union(b).difference(a.intersection(b));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line">  <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">cartesianProduct</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> XSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123;</span><br><span class="line">        cartesianProductSet.add([aValue, bValue]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cartesianProductSet;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">powerSet</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> powerSet = <span class="keyword">new</span> XSet().add(<span class="keyword">new</span> XSet());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> set <span class="keyword">of</span> <span class="keyword">new</span> XSet(powerSet)) &#123;</span><br><span class="line">        powerSet.add(<span class="keyword">new</span> XSet(set)</span><br><span class="line">                .add(aValue));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> powerSet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-WeakSet"><a href="#6-7-WeakSet" class="headerlink" title="6.7　WeakSet"></a>6.7　<code>WeakSet</code></h2></li></ul><p>ES 6新增的<code>WeakSet</code>是一种新的集合类型，<code>WeakSet</code>中的“weak”，描述的是JavaScript垃圾回收程序对待“弱集合”中值的弱引用。</p><h3 id="6-7-1-基本API"><a href="#6-7-1-基本API" class="headerlink" title="6.7.1　基本API"></a>6.7.1　基本API</h3><p>可以使用<code>new</code>关键字实例化一个空的<code>WeakSet</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>弱集合中的值只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置值会抛出<code>TypeError</code>。其余参照<code>6.6.1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;,</span><br><span class="line">      val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;,</span><br><span class="line">      val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">&quot;BADVAL&quot;</span>, val3]);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet</span></span><br></pre></td></tr></table></figure><h3 id="6-7-2-弱值"><a href="#6-7-2-弱值" class="headerlink" title="6.7.2　弱值"></a>6.7.2　弱值</h3><p>可参照<code>6.5.2</code>。</p><h3 id="6-7-3-不可迭代值"><a href="#6-7-3-不可迭代值" class="headerlink" title="6.7.3　不可迭代值"></a>6.7.3　不可迭代值</h3><p>可参照<code>6.5.3</code>。</p><h3 id="6-7-4-使用弱集合"><a href="#6-7-4-使用弱集合" class="headerlink" title="6.7.4　使用弱集合"></a>6.7.4　使用弱集合</h3><p>相比于<code>WeakMap</code>实例，<code>WeakSet</code>实例的用处没有那么大。不过，弱集合在给对象打标签时还是有价值的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#login&#x27;</span>);</span><br><span class="line"><span class="comment">// 通过加入对应集合，给这个节点打上“禁用”标签</span></span><br><span class="line">disabledElements.add(loginButton);</span><br></pre></td></tr></table></figure><p>这样，如果查询元素在<code>disabledElements</code>中，就可以知道被禁用了。只要从DOM树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。</p><p>但如果使用<code>Set</code>，它的引用却仍然保存在<code>Set</code>中，因此垃圾回收程序也不能回收它。</p><h2 id="6-8-迭代与扩展操作"><a href="#6-8-迭代与扩展操作" class="headerlink" title="6.8　迭代与扩展操作"></a>6.8　迭代与扩展操作</h2><p>ES6新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。有4种原生集合类型定义了默认迭代器：</p><ul><li><code>Array</code></li><li>所有定型数组</li><li><code>Map</code></li><li><code>Set</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterableThings = [</span><br><span class="line">  <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">  typedArr = <span class="built_in">Int16Array</span>.of(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterableThing <span class="keyword">of</span> iterableThings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> iterableThing) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// [5, 6]</span></span><br><span class="line"><span class="comment">// [7, 8]</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);          <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);          <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">0</span>, ...arr1, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>浅复制意味着只会复制对象引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line">arr1[<span class="number">0</span>].foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">0</span>]); <span class="comment">// &#123; foo: &#x27;bar&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]);</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(map1);</span><br><span class="line"><span class="built_in">console</span>.log(map1); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map2); <span class="comment">// Map &#123;1 =&gt; 2, 3 =&gt; 4&#125;</span></span><br></pre></td></tr></table></figure><p>上面四种类型都支持<code>Array.of()</code>和<code>Array.from()</code>静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 把数组复制到定型数组</span></span><br><span class="line"><span class="keyword">let</span> typedArr1 = <span class="built_in">Int16Array</span>.of(...arr1);</span><br><span class="line"><span class="keyword">let</span> typedArr2 = <span class="built_in">Int16Array</span>.from(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(typedArr1);   <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(typedArr2);   <span class="comment">// Int16Array [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 把数组复制到映射</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, <span class="string">&#x27;val&#x27;</span> + x]));</span><br><span class="line"><span class="built_in">console</span>.log(map);   <span class="comment">// Map &#123;1 =&gt; &#x27;val 1&#x27;, 2 =&gt; &#x27;val 2&#x27;, 3 =&gt; &#x27;val 3&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 把定型数组复制到集合</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(typedArr2);</span><br><span class="line"><span class="built_in">console</span>.log(set);   <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">// 把集合复制回数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [...set];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;6-1-Object&quot;&gt;&lt;a href=&quot;#6-1-Object&quot; class=&quot;headerlink&quot; title=&quot;6.1　Object&quot;&gt;&lt;/a&gt;6.1　Object&lt;/h2&gt;&lt;p&gt;大多数引用值的示例使用的是&lt;code&gt;Object&lt;/code&gt;类型。显式地</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>05-基本引用类型</title>
    <link href="http://example.com/2021/03/14/note/JavaScript/05-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2021/03/14/note/JavaScript/05-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-03-14T13:18:40.410Z</published>
    <updated>2021-05-11T13:34:59.857Z</updated>
    
    <content type="html"><![CDATA[<p>引用值（或者对象）是某个特定<strong>引用类型</strong>的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”，引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法。</p><p>对象被认为是某个特定引用类型的<strong>实例</strong>。新对象通过使用<code>new</code>操作符后跟一个<strong>构造函数</strong>（constructor）来创建。构造函数就是用来创建新对象的函数。</p><blockquote><p>**注意 **函数也是一种引用类型。</p></blockquote><h2 id="5-1-Date"><a href="#5-1-Date" class="headerlink" title="5.1　Date"></a>5.1　Date</h2><p><code>Date</code>类型将日期保存为自协调世界时（UTC）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式，<code>Date</code>类型可以精确表示1970年1月1日之前及之后285616年的日期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><p>在不给<code>Date</code>构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示。为此提供了两个辅助方法：<code>Date.parse()</code>和<code>Date.UTC()</code>。<br><code>Date.parse()</code>方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。所有实现都必须支持下列日期格式：</p><ul><li>“月/日/年”，如<code>&quot;5/23/2019&quot;</code>；</li><li>“月 日, 年”，如<code>&quot;May 23, 2019&quot;</code>；</li><li>“周几 月 日 年 时:分:秒 时区”，如<code>&quot;Tue May 23 2019 00:00:00 GMT-0700&quot;</code>；</li><li>ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如<code>2019-05-23T00:00:00</code>（只适用于兼容ES5的实现）。</li></ul><p>如果传给<code>Date.parse()</code>的字符串并不表示日期，则该方法会返回<code>NaN</code>。如果直接把表示日期的字符串传给<code>Date</code>构造函数，那么<code>Date</code>会在后台调用<code>Date.parse()</code>。换句话说，下面这行代码跟前面那行代码是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">&quot;May 23, 2019&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>**注意 **不同的浏览器对<code>Date</code>类型的实现有很多问题。比如，很多浏览器会选择用当前日期替代越界的日期。</p></blockquote><p><code>Date.UTC()</code>方法也返回日期的毫秒表示。传给<code>Date.UTC()</code>的参数是年、零起点月数（1月是0，2月是1，以此类推）、日（1<del>31）、时（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure><p><code>Date.UTC()</code>也会被<code>Date</code>构造函数隐式调用，但这种情况下创建的是本地日期，不是GMT日期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br></pre></td></tr></table></figure><p><code>Date.now()</code>方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="built_in">Date</span>.now(),</span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure><h3 id="5-1-1-继承的方法"><a href="#5-1-1-继承的方法" class="headerlink" title="5.1.1　继承的方法"></a>5.1.1　继承的方法</h3><p><code>Date</code>类型重写了<code>toLocaleString()</code>、<code>toString()</code>和<code>valueOf()</code>方法。</p><p><code>toLocaleString()</code>，返回与浏览器运行的本地环境一致的日期和时间。格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息。</p><p><code>toString()</code>方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toLocaleString() <span class="comment">// 2/1/2019 12:00:00 AM</span></span><br><span class="line">toString() <span class="comment">// Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)</span></span><br></pre></td></tr></table></figure><p>在比较老的浏览器上，每个方法返回的结果可能在每个浏览器上都是不同的。这些差异意味着<code>toLocaleString()</code>和<code>toString()</code>可能只对调试有用，不能用于显示。<br><code>Date</code>类型的<code>valueOf()</code>方法不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。这也是确保日期先后的一个简单方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 2019年1月1日</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// 2019年2月1日</span></span><br><span class="line"><span class="built_in">console</span>.log(date1 &lt; date2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-日期格式化方法"><a href="#5-1-2-日期格式化方法" class="headerlink" title="5.1.2　日期格式化方法"></a>5.1.2　日期格式化方法</h3><p><code>Date</code>类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ul><li><code>toDateString()</code>显示日期中的周几、月、日、年（格式特定于实现）；</li><li><code>toTimeString()</code>显示日期中的时、分、秒和时区（格式特定于实现）；</li><li><code>toLocaleDateString()</code>显示日期中的周几、月、日、年（格式特定于实现和地区）；</li><li><code>toLocaleTimeString()</code>显示日期中的时、分、秒（格式特定于实现和地区）；</li><li><code>toUTCString()</code>显示完整的UTC日期（格式特定于实现）。</li></ul><p>这些方法的输出与<code>toLocaleString()</code>和<code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p><blockquote><p>**注意 **还有一个方法叫<code>toGMTString()</code>，这个方法跟<code>toUTCString()</code>是一样的，目的是为了向后兼容。不过，规范建议新代码使用<code>toUTCString()</code>。</p></blockquote><h3 id="5-1-3-日期-时间组件方法"><a href="#5-1-3-日期-时间组件方法" class="headerlink" title="5.1.3　日期/时间组件方法"></a>5.1.3　日期/时间组件方法</h3><p><code>Date</code>类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">getTime()/setTime(<em>milliseconds</em>)</td><td align="left">返回/设置日期的毫秒表示；返回与valueOf()相同</td></tr><tr><td align="left">getFullYear()/getUTCFullYear()<br/>setFullYear(<em>year</em>)/setUTCFullYear(<em>year</em>)</td><td align="left">返回/设置4位数年（即2019而不是19）</td></tr><tr><td align="left">getMonth()/getUTCMonth()<br>setMonth(<em>month</em>)/setUTCMonth(<em>month</em>)</td><td align="left">返回/设置日期的月（0表示1月，11表示12月），设置大于11加年</td></tr><tr><td align="left">getDate()/getUTCDate()<br>setUTCDate(<em>date</em>)/setDate(<em>date</em>)</td><td align="left">返回/设置日期中的日（1~31），设置大于该月天数，则加月</td></tr><tr><td align="left">getDay()/getUTCDay()</td><td align="left">返回日期中表示周几的数值（0表示周日，6表示周六）</td></tr><tr><td align="left">getHours()/getUTCHours()<br>setHours(<em>hours</em>)/setUTCHours(<em>hours</em>)</td><td align="left">返回/设置日期中的时（0~23），设置<em>hours</em>大于23，则加日</td></tr><tr><td align="left">getMinutes()/getUTCMinutes()<br>setMinutes(<em>minutes</em>)/setUTCMinutes(<em>minutes</em>)</td><td align="left">返回日期中的分（0~59），设置<em>minutes</em>大于59，则加时</td></tr><tr><td align="left">getSeconds()/getUTCSeconds()<br>setSeconds(<em>seconds</em>)/setUTCSeconds(<em>seconds</em>)</td><td align="left">返回/设置日期中的秒（0~59），设置<em>seconds</em>大于59，则加分</td></tr><tr><td align="left">getMilliseconds()/getUTCMilliseconds()<br>setMilliseconds(<em>milliseconds</em>)/setUTCMilliseconds(<em>milliseconds</em>)</td><td align="left">返回/设置日期中的毫秒</td></tr><tr><td align="left">getTimezoneOffset()</td><td align="left">返回以分钟计的UTC与本地时区的偏移量</td></tr></tbody></table><h2 id="5-2-RegExp"><a href="#5-2-RegExp" class="headerlink" title="5.2　RegExp"></a>5.2　RegExp</h2><p>ECMAScript通过<code>RegExp</code>类型支持正则表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure><p>这个正则表达式的<code>pattern</code>（模式）可以是任何的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个<code>flags</code>（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p><ul><li><code>g</code>：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li><li><code>i</code>：不区分大小写，表示在查找匹配时忽略<code>pattern</code>和字符串的大小写。</li><li><code>m</code>：多行模式，表示查找到一行文本末尾时会继续查找。</li><li><code>y</code>：粘附模式，表示只查找从<code>lastIndex</code>开始及之后的字符串。</li><li><code>u</code>：Unicode模式，启用Unicode匹配。</li><li><code>s</code>：<code>dotAll</code>模式，表示元字符<code>.</code>匹配任何字符（包括<code>\n</code>或<code>\r</code>）。</li></ul><p>使用不同模式和标记可以创建出各种正则表达式，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中的所有&quot;at&quot;</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure><p>与其他语言中的正则表达式类似，所有<strong>元字符</strong>在模式中也必须转义，包括：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ] &#125; ? * + .</span><br></pre></td></tr></table></figure><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;[bc]at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有&quot;.at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure><p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用<code>RegExp</code>构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 跟pattern1一样，只不过是用构造函数创建的</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>RegExp</code>构造函数的两个参数都是字符串。因为<code>RegExp</code>的模式参数是字符串，所以所有元字符都必须二次转义，包括转义字符序列。</p><table><thead><tr><th align="left">字面量模式</th><th align="left">对应的字符串</th></tr></thead><tbody><tr><td align="left"><code>/name\/age/</code></td><td align="left"><code>&quot;name\\/age&quot;</code></td></tr><tr><td align="left"><code>/\w\\hello\\123/</code></td><td align="left"><code>&quot;\\w\\\\hello\\\\123&quot;</code></td></tr></tbody></table><p>此外，使用<code>RegExp</code>也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/cat/g</span>;</span><br><span class="line"><span class="keyword">const</span> re3 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(re3);     <span class="comment">//   /cat/i </span></span><br></pre></td></tr></table></figure><h3 id="5-2-1-RegExp实例属性"><a href="#5-2-1-RegExp实例属性" class="headerlink" title="5.2.1   RegExp实例属性"></a>5.2.1   <code>RegExp</code>实例属性</h3><p>每个<code>RegExp</code>实例都有下列属性，提供有关模式的各方面信息。</p><ul><li><code>global</code>：布尔值，表示是否设置了<code>g</code>标记。</li><li><code>ignoreCase</code>：布尔值，表示是否设置了<code>i</code>标记。</li><li><code>unicode</code>：布尔值，表示是否设置了<code>u</code>标记。</li><li><code>sticky</code>：布尔值，表示是否设置了<code>y</code>标记。</li><li><code>lastIndex</code>：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。</li><li><code>multiline</code>：布尔值，表示是否设置了<code>m</code>标记。</li><li><code>dotAll</code>：布尔值，表示是否设置了<code>s</code>标记。</li><li><code>source</code>：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li><li><code>flags</code>：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回，没有前后斜杠。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);      <span class="comment">// &quot;\[bc\]at&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.flags);       <span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-2-2-RegExp实例方法"><a href="#5-2-2-RegExp实例方法" class="headerlink" title="5.2.2   RegExp实例方法"></a>5.2.2   <code>RegExp</code>实例方法</h3></li></ul><p><code>RegExp</code>实例的主要方法是<code>exec()</code>，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，返回一个数组，否则返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但包含两个额外的属性：<code>index</code>和<code>input</code>。<code>index</code>是字符串中匹配模式的起始位置，<code>input</code>是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input);   <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);      <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);      <span class="comment">// &quot; and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);      <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure><p>如果在这个模式上设置了<code>g</code>标记，则每次调用<code>exec()</code>都会在字符串中向前搜索下一个匹配项，直到搜索到字符串末尾，并且每次调用<code>exec()</code>都会更新<code>lastIndex</code>值，以反映上次匹配的最后一个字符的索引。否则无论对同一个字符串调用多少次<code>exec()</code>，也只会返回第一个匹配的信息，<code>lastIndex</code>在非全局模式下始终不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// sat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>如果模式设置了粘附标记<code>y</code>，则每次调用<code>exec()</code>就只会在<code>lastIndex</code>的位置上寻找匹配项。粘附标记覆盖全局标记。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/y</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以索引3对应的字符开头找不到匹配项，因此exec()返回null</span></span><br><span class="line"><span class="comment">// exec()没找到匹配项，于是将lastIndex设置为0</span></span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches);             <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置lastIndex可以让粘附的模式通过exec()找到下一个匹配项：</span></span><br><span class="line">pattern.lastIndex = <span class="number">5</span>;</span><br><span class="line">matches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);       <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);          <span class="comment">// bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>正则表达式的另一个方法是<code>test()</code>，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回<code>true</code>，否则返回<code>false</code>。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况，常用于验证用户输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;000-00-0000&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;The pattern was matched.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toLocaleString()</code>和<code>toString()</code>都返回正则表达式的字面量表示，而<code>valueOf()</code>方法返回正则表达式本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;gi&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern.toString());        <span class="comment">//  /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.toLocaleString());  <span class="comment">//  /\[bc\]at/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.valueOf() === pattern);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="5-2-3-RegExp构造函数属性"><a href="#5-2-3-RegExp构造函数属性" class="headerlink" title="5.2.3   RegExp构造函数属性"></a>5.2.3   <code>RegExp</code>构造函数属性</h3><p><code>RegExp</code>构造函数本身也有几个属性。这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。</p><table><thead><tr><th align="left">全名</th><th align="left">简写</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">input</td><td align="left">$_</td><td align="left">最后搜索的字符串（非标准特性）</td></tr><tr><td align="left">lastMatch</td><td align="left">$&amp;</td><td align="left">最后匹配的文本</td></tr><tr><td align="left">lastParen</td><td align="left">$+</td><td align="left">最后匹配的捕获组（非标准特性）</td></tr><tr><td align="left">leftContext</td><td align="left">$`</td><td align="left">input字符串中出现在lastMatch前面的文本</td></tr><tr><td align="left">rightContext</td><td align="left">$’</td><td align="left">input字符串中出现在lastMatch后面的文本</td></tr></tbody></table><p>通过这些属性可以提取出与<code>exec()</code>和<code>test()</code>执行的操作相关的信息。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);        <span class="comment">// this has been a short summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);  <span class="comment">// this has been a</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);    <span class="comment">// short</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen);    <span class="comment">// s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用中括号语法来访问，因为大多数简写形式都不是合法的ECMAScript标识符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意：Opera 不支持简写属性名</span></span><br><span class="line"><span class="comment"> * IE 不支持多行匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);      <span class="comment">// this has been a short summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$`&quot;</span>]);   <span class="comment">// this has been a</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]);   <span class="comment">// summer</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]);   <span class="comment">// short</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">&quot;$+&quot;</span>]);   <span class="comment">// s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RegExp</code>还有其他几个构造函数属性，可以存储最多9个捕获组的匹配项。这些属性通过<code>RegExp.$1~RegExp.$9</code>来访问，分别包含第1~9个捕获组的匹配项。在调用<code>exec()</code>或<code>test()</code>时，这些属性就会被填充，然后就可以像下面这样使用它们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short summer&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);  <span class="comment">// sh</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2);  <span class="comment">// t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> <code>RegExp</code>构造函数的所有属性没有任何Web标准出处，因此不要在生产环境中使用它们。</p></blockquote><h3 id="5-2-4-正则表达式（补充）"><a href="#5-2-4-正则表达式（补充）" class="headerlink" title="5.2.4   正则表达式（补充）"></a>5.2.4   正则表达式（补充）</h3><table><thead><tr><th align="center">字符</th><th align="left">含义</th><th align="left">例子</th></tr></thead><tbody><tr><td align="center">\</td><td align="left">只有在特殊字符之前的反斜杠表示下一个字符不是特殊字符，按照字面理解。</td><td align="left"></td></tr><tr><td align="center">^</td><td align="left">匹配输入的开始。如果有标记m，也匹配换行符后紧跟的位置。</td><td align="left"><code>/^A/</code>不匹配 <code>an A</code> 中的 <code>A</code>，但匹配 <code>An E</code> 中的 <code>A</code>。</td></tr><tr><td align="center">$</td><td align="left">匹配输入的结束。如果有标记m，也匹配换行符前的位置。<br>如果 ^和 $ 在一起，表示必须是精确匹配。</td><td align="left"><code>/t$/</code>不匹配 <code>eater</code> 中的 <code>t</code>，但匹配 <code>eat</code> 中的 <code>t</code>。</td></tr><tr><td align="center">*</td><td align="left">匹配前一个表达式 0 次或多次。等价于{0,}。</td><td align="left"><code>/bo*/</code>会匹配 <code>A ghost boooooed</code> 中的 <code>booooo</code> 和 <code>A bird warbled</code> 中的 <code>b</code>。</td></tr><tr><td align="center">+</td><td align="left">匹配前面一个表达式 1 次或者多次。等价于{1,}。</td><td align="left"><code>/a+/</code>会匹配 <code>candy</code> 中的 <code>a</code> 和 <code>caaaaaaandy</code> 中所有的 <code>a</code>。</td></tr><tr><td align="center">?</td><td align="left">匹配前面一个表达式 0 次或者 1 次。等价于{0,1}。<br>如果*<em>紧跟在任何量词 <em>、 +、? 或 {} 的后面</em></em>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）相反。</td><td align="left"><code>/e?le?/</code>匹配 <code>angel</code> 中的 <code>el</code>、<code>angle</code> 中的 <code>le</code> 以及 <code>oslo</code> 中的 <code>l</code>。<br><code>123abc</code> 使用<code>/\d+/</code>将会匹配 <code>123</code>，而使用<code>/\d+?/</code>则只会匹配到 <code>1</code>。</td></tr><tr><td align="center">.</td><td align="left">（小数点）默认匹配除换行符之外的任何单个字符。</td><td align="left"><code>/.n/</code>将会匹配 <code>nay, an apple is on the tree</code> 中的 <code>an</code> 和 <code>on</code>。如果有s标记，也会匹配换行符。</td></tr><tr><td align="center">(x)</td><td align="left">匹配 <code>x</code> 并且记住匹配项，供此后使用。其中括号被称为<em>捕获括号</em>。</td><td align="left"><code>/(foo) (bar) \1 \2/ </code>中的 <code>(foo)</code> 和 <code>(bar)</code> 匹配并记住<code>foo bar foo bar</code> 中的前两个单词<code>foo</code>和<code>bar</code>。模式中的\1和\2表示第一个和第二个被捕获括号匹配的子字符串，即foo和bar，匹配原字符串中的后两个单词。\1、\2、…、\n是用在正则表达式的匹配环节，而在正则表达式的替换环节，则要使用像$1、$2、…、$n，例如”bar foo”.replace(/(…) (…)/,’ $2$1’)。</td></tr><tr><td align="center">\n</td><td align="left">返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)，这里的n是数字。</td><td align="left"><code>/apple(,)\sorange\1/</code>匹配<code>apple, orange, cherry, peach.</code>中的<code>apple, orange,</code> 。</td></tr><tr><td align="center">(?:x)</td><td align="left">匹配 <code>x</code> 但是不记住匹配项。这种括号叫作<em>非捕获括号</em>，使得定义与正则表达式运算符一起使用的子表达式。</td><td align="left"><code>/foo&#123;1,2&#125;/</code>，<code>&#123;1,2&#125;</code> 将只应用于 <code>foo</code> 的最后一个 <code>o</code>。如果使用非捕获括号，<code>/(?:foo)&#123;1,2&#125;/</code>则会应用于整个 <code>foo</code> 单词。</td></tr><tr><td align="center">x(?=y)</td><td align="left">匹配<code>x</code>仅仅当<code>x</code>后面跟着<code>y</code>。这叫做先行断言。</td><td align="left"><code>/Jack(?=Sprat|Frost)/</code>匹配<code>Jack</code>仅当它后面跟着<code>Sprat</code>或者是<code>Frost</code>。但<code>Sprat</code>和<code>Frost</code>都不是匹配结果的一部分。</td></tr><tr><td align="center">(?&lt;=y)x</td><td align="left">匹配<code>x</code>仅当<code>x</code>前面是<code>y</code>。这叫做后行断言。</td><td align="left"><code>/(?&lt;=Jack|Tom)Sprat/</code>匹配<code>Sprat</code>仅仅当它前面是<code>Jack</code>或者是<code>Tom</code>。但<code>Jack</code>和<code>Tom</code>都不是匹配结果的一部分。</td></tr><tr><td align="center">x(?!y)</td><td align="left">仅仅当<code>x</code>后面不跟着<code>y</code>时匹配<code>x</code>，这被称为正向否定查找。</td><td align="left"><code>/\d+(?!.)/</code>匹配<code>141</code>而不是<code>3.141</code>。</td></tr><tr><td align="center">(?&lt;!<em>y</em>)x</td><td align="left">仅仅当<code>x</code>前面不是<code>y</code>时匹配<code>x</code>，这被称为反向否定查找。</td><td align="left"><code>/(?&lt;!-)\d+/</code>匹配 <code>3</code>而不是<code>-3</code>。</td></tr><tr><td align="center">x|y</td><td align="left">匹配<code>x</code>或者<code>y</code>。</td><td align="left"><code>/green|red/</code>匹配<code>green apple</code>中的<code>green</code>。</td></tr><tr><td align="center">{n}</td><td align="left">n 是一个正整数，匹配了前面一个字符必须刚好出现了 n 次。</td><td align="left"><code>/a&#123;2&#125;/ </code>不匹配<code>candy</code>中的<code>a</code>,但匹配<code>caaandy</code>中的前两个<code>a</code>。</td></tr><tr><td align="center">{n,}</td><td align="left">n是一个正整数，匹配前一个字符至少出现了n次。</td><td align="left"><code>/a&#123;2,&#125;/ </code>匹配 <code>aa</code>, <code>aaaa</code> ，但不匹配 <code>a</code>。</td></tr><tr><td align="center">{n,m}</td><td align="left">n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td><td align="left"><code>/a&#123;1, 3&#125;/</code> 匹配<code>candy</code>中的a，也匹配<code>caaaaaaandy</code>中的前三个a。</td></tr><tr><td align="center">[xyz]</td><td align="left">一个字符集合。匹配方括号中的任意字符，包括转义序列。可以使用破折号（-）来指定一个字符范围。点（.）和星号（*）这样的特殊符号在字符集中没有特殊的意义，可以但不用转义。</td><td align="left">[abcd] 和[a-d]是一样的。他们都匹配<code>brisket</code>中的<code>b</code>,也都匹配<code>city</code>中的<code>c</code>。</td></tr><tr><td align="center">[^xyz]</td><td align="left">一个反向字符集。它匹配任何没有包含在方括号中的字符。可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</td><td align="left">[^abc] 和 <code>[^a-c] </code>是一样的。他们匹配<code>brisket</code>中的<code>r</code>，也匹配<code>chop</code>中的<code>h</code>。</td></tr><tr><td align="center">[\b]</td><td align="left">匹配一个退格(U+0008)。（特例）</td><td align="left"></td></tr><tr><td align="center">\b</td><td align="left">匹配一个词的边界。但不包括匹配的字边界。</td><td align="left">/\bm/匹配<code>moon</code>中的<code>m</code>；<code>/oon\b/</code>匹配<code>oon</code>。<br><strong>注意：</strong>大写和小写的罗马字母，十进制数字和下划线字符被视为断词，不作为’’字’’字符。</td></tr><tr><td align="center">\B</td><td align="left">匹配一个非单词边界。</td><td align="left"><code>/\B../</code>匹配<code>noonday</code>中的<code>oo</code>, 而<code>/y\B../</code>匹配<code>possibly yesterday</code>中的<code>yes</code></td></tr><tr><td align="center">\cX</td><td align="left">当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。</td><td align="left"><code>/\cM/</code>匹配字符串中的 control-M (U+000D)。</td></tr><tr><td align="center">\d</td><td align="left">匹配一个数字。等价于[0-9]。</td><td align="left"></td></tr><tr><td align="center">\D</td><td align="left">匹配一个非数字字符。等价于<code>[^0-9]</code>。</td><td align="left"></td></tr><tr><td align="center">\f</td><td align="left">匹配一个换页符 (U+000C)。</td><td align="left"></td></tr><tr><td align="center">\n</td><td align="left">匹配一个换行符 (U+000A)。</td><td align="left"></td></tr><tr><td align="center">\r</td><td align="left">匹配一个回车符 (U+000D)。</td><td align="left"></td></tr><tr><td align="center">\s</td><td align="left">匹配一个空白字符，包括空格、制表符、换页符和换行符。</td><td align="left"><code>/\s\w*/</code>匹配<code>foo bar.</code>中的<code> bar</code>。</td></tr><tr><td align="center">\S</td><td align="left">匹配一个非空白字符。</td><td align="left"><code>/\S\w*/</code>匹配<code>foo bar.</code>中的<code>foo</code>。</td></tr><tr><td align="center">\t</td><td align="left">匹配一个水平制表符 (U+0009)。</td><td align="left"></td></tr><tr><td align="center">\v</td><td align="left">匹配一个垂直制表符 (U+000B)。</td><td align="left"></td></tr><tr><td align="center">\w</td><td align="left">匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</td><td align="left"></td></tr><tr><td align="center">\W</td><td align="left">匹配一个非单字字符。等价于<code>[^A-Za-z0-9_]</code>。</td><td align="left"></td></tr><tr><td align="center">\0</td><td align="left">匹配 NULL（U+0000）字符， 后面不能跟其它小数，因为\0<digits>是一个八进制转义序列。</td><td align="left"></td></tr><tr><td align="center">\xhh</td><td align="left">匹配一个两位十六进制数（\x00-\xFF）表示的字符。</td><td align="left"><code>\x0A</code>等价于\n</td></tr><tr><td align="center">\uhhhh</td><td align="left">匹配一个四位十六进制数表示的 UTF-16 代码单元。</td><td align="left"><code>\u0009</code>等价于\t</td></tr><tr><td align="center">\u{hhhh}或\u{hhhhh}</td><td align="left">（仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。</td><td align="left"></td></tr></tbody></table><h2 id="5-3-原始值包装类型"><a href="#5-3-原始值包装类型" class="headerlink" title="5.3　原始值包装类型"></a>5.3　原始值包装类型</h2><p>ECMAScript提供了3种特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>原始值本身不是对象，因此逻辑上不应该有方法。这是因为当第二行访问<code>s1</code>时，是以读模式访问的，也就是从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3步：<br>(1) 创建一个<code>String</code>类型的实例；</p><p>(2) 调用实例上的特定方法；</p><p>(3) 销毁实例。</p><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也类似如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过<code>new</code>实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间，也就是无法在运行时给原始值添加属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s1.color);  <span class="comment">// undefined 实际上，这里又创建了一个新的String对象，但没有color属性</span></span><br></pre></td></tr></table></figure><p>虽然可以显式地使用<code>Boolean</code>、<code>Number</code>和<code>String</code>构造函数创建原始值包装对象。不过应该在必要时才这样，否则容易让开发者分不清到底是原始值还是引用值。在显式创建的原始值包装类型的实例上调用<code>typeof</code>会返回<code>&quot;object&quot;</code>，所有原始值包装对象都会转换为布尔值<code>true</code>。</p><p>另外，<code>Object</code>构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，使用<code>new</code>调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="built_in">Number</span>(value);    <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number);    <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);   <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);       <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-1-Boolean"><a href="#5-3-1-Boolean" class="headerlink" title="5.3.1   Boolean"></a>5.3.1   <code>Boolean</code></h3><p><code>Boolean</code>是对应布尔值的引用类型。要创建一个<code>Boolean</code>对象，就使用<code>Boolean</code>构造函数并传入<code>true</code>或<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><code>Boolean</code>的实例会重写<code>valueOf()</code>方法，返回一个原始值<code>true</code>或<code>false</code>。<code>toString()</code>方法被调用时也会被覆盖，返回字符串<code>&quot;true&quot;</code>或<code>&quot;false&quot;</code>。</p><p>建议不要使用<code>Boolean</code>对象，因为在布尔表达式中使用<code>Boolean</code>对象时，在布尔表达式中都会自动转换为<code>true</code>，容易引起误会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(falseObject &amp;&amp; <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(falseValue &amp;&amp; <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>原始值和引用值（<code>Boolean</code>对象）还有几个区别。首先，<code>typeof</code>操作符对原始值返回<code>boolean</code>，但对引用值返回<code>&quot;object&quot;</code>。同样，<code>Boolean</code>对象是<code>Boolean</code>类型的实例，在使用<code>instaceof</code>操作符时返回<code>true</code>，但对原始值则返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);             <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);              <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-Number"><a href="#5-3-2-Number" class="headerlink" title="5.3.2   Number"></a>5.3.2   <code>Number</code></h3><p><code>Number</code>是对应数值的引用类型。要创建一个<code>Number</code>对象，就使用<code>Number</code>构造函数并传入一个数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><code>Number</code>类型重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法。<code>valueOf()</code>方法返回<code>Number</code>对象表示的原始数值，另外两个方法返回数值字符串。<code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());   <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));  <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));  <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><code>Number</code>类型还提供了几个用于将数值格式化为字符串的方法，如下：<br><code>toFixed()</code>方法返回包含指定小数点位数的数值字符串，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.00&quot;</span></span><br></pre></td></tr></table></figure><p>结果返回值为<code>&quot;10.00&quot;</code>，小数位填充了0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位。</p><p><code>toFixed()</code>自动舍入的特点可以用于处理货币。不过，多个浮点数值的数学计算不一定得到精确的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// &quot;10.01&quot;</span></span><br></pre></td></tr></table></figure><p><code>toExponential()</code>，返回以科学记数法表示的数值字符串。<code>toExponential()</code>接收一个参数，表示结果中小数的位数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>));  <span class="comment">// &quot;1.0e+1&quot;</span></span><br></pre></td></tr></table></figure><p>如果想得到数值最适当的形式，可以使用<code>toPrecision()</code>，根据数值和精度来决定调用<code>toFixed()</code>还是<code>toExponential()</code>。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// &quot;1e+2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// &quot;99&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// &quot;99.0&quot;</span></span><br></pre></td></tr></table></figure><p>与<code>Boolean</code>对象类似，同样不建议直接实例化<code>Number</code>对象。在处理原始数值和引用数值时，<code>typeof</code>和<code>instacnceof</code>操作符也会返回不同的结果。</p><p><code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>IEEE 754数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从<code>Number.MIN_SAFE_INTEGER</code>（<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/14/rLyY1VZMH5oQtD9.gif"                      alt="gif.gif"                >）到<code>Number.MAX_SAFE_INTEGER</code>（<img                       lazyload                     src="/images/loading.svg"                     data-src="https://i.loli.net/2021/03/14/3YnaD86ptI9Zwly.gif"                      alt="gif _1_.gif"                >）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用<code>Number.isSafeInteger()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>));             <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>));       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="5-3-3-String"><a href="#5-3-3-String" class="headerlink" title="5.3.3   String"></a>5.3.3   <code>String</code></h3><p><code>String</code>是对应字符串的引用类型。要创建一个<code>String</code>对象，使用<code>String</code>构造函数并传入一个数值。<code>String</code>对象的方法可以在所有字符串原始值上调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>3个继承的方法<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值。</p><h4 id="5-3-3-1-JavaScript字符"><a href="#5-3-3-1-JavaScript字符" class="headerlink" title="5.3.3.1   JavaScript字符"></a><strong>5.3.3.1   JavaScript字符</strong></h4><p>JavaScript字符串由16位码元（code unit）组成。对多数字符来说，每16位码元对应一个字符。字符串的<code>length</code>属性表示字符串包含多少16位码元。如果字符串中包含双字节字符，那么<code>length</code>属性返回的值可能不是准确的字符数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><code>charAt()</code>方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16位码元，并返回该码元对应的字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>)); <span class="comment">// &quot;c&quot;</span></span><br></pre></td></tr></table></figure><p>JavaScript字符串使用两种Unicode编码混合的策略：<code>UCS-2</code>和<code>UTF-16</code>。对于可以采用16位编码的字符<code>（U+0000~U+FFFF）</code>，这两种编码实际上是一样的。<br><code>charCodeAt()</code>方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;   <span class="comment">// Unicode &quot;Latin small letter C&quot;的编码是U+0063</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));  <span class="comment">// 99</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>);            <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>fromCharCode()</code>方法用于根据给定的<code>UTF-16</code>码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>));  <span class="comment">// &quot;abcde&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>));          <span class="comment">// &quot;abcde&quot;</span></span><br></pre></td></tr></table></figure><p>对于U+0000~U+FFFF范围内的字符，在Unicode中称为<strong>基本多语言平面</strong><code>（BMP）</code>，都是用16位表示的，<code>length</code>、<code>charAt()</code>、<code>charCodeAt()</code>和<code>fromCharCode()</code>返回的结果都跟预期是一样的。<br>为了表示更多的字符，每个字符使用另外16位去选择一个<strong>增补平面</strong>，这种策略称为<strong>代理对</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;smiling face with smiling eyes&quot; 表情符号的编码是U+1F60A</span></span><br><span class="line"><span class="comment">// 0x1F60A === 128522</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.length);          <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">2</span>));       <span class="comment">// &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charAt(<span class="number">3</span>));       <span class="comment">// &lt;?&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>));   <span class="comment">// 55357</span></span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">3</span>));   <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1F60A</span>)); <span class="comment">// 😊</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55357</span>, <span class="number">56842</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure><p><code>fromCharCode()</code>方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串。浏览器可以正确解析代理对（由两个码元构成）。<br>为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用<code>codePointAt()</code>来代替<code>charCodeAt()</code>。<code>codePointAt()</code>接收16位码元的索引并返回该索引位置上的码点（code point）。<strong>码点</strong>是Unicode中一个字符的完整标识，可能是16位，也可能是32位，但如果传入的码元索引并非代理对的开头，就会返回错误的码点。这种错误只有检测单个字符的时候才会出现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ab😊de&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">2</span>)); <span class="comment">// 128522</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">3</span>)); <span class="comment">// 56842</span></span><br><span class="line"><span class="built_in">console</span>.log(message.codePointAt(<span class="number">4</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>可以通过从左到右按正确的码元数遍历字符串来规避。迭代字符串可以智能地识别代理对的码点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...<span class="string">&quot;ab😊de&quot;</span>]); <span class="comment">//[&quot;a&quot;, &quot;b&quot;, &quot;😊&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure><p><code>fromCharCode()</code>也有一个对应的<code>fromCodePoint()</code>。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>, <span class="number">98</span>, <span class="number">128522</span>, <span class="number">100</span>, <span class="number">101</span>));   <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-2-normalize-方法"><a href="#5-3-3-2-normalize-方法" class="headerlink" title="5.3.3.2   normalize()方法"></a>5.3.3.2   <code>normalize()</code><strong>方法</strong></h4><p>某些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP字符表示，也可以通过一个代理对表示。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>));       <span class="comment">// Å，上面带圆圈的大写拉丁字母A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>));       <span class="comment">// Å，长度单位“埃”</span></span><br><span class="line"><span class="comment">// Å，U+004：大写拉丁字母A， U+030A：上面加个圆圈</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>));</span><br></pre></td></tr></table></figure><p>比较操作符不在乎字符看起来是什么样的，因此这3个字符互不相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a1, a2, a3); <span class="comment">// Å, Å, Å</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a2);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a3);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>为解决这个问题，Unicode提供了4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。</p><ul><li>NFD（Normalization Form D）；</li><li>NFC（Normalization Form C）；</li><li>NFKD（Normalization Form KD）；</li><li>NFKC（Normalization Form KC）。</li></ul><p>可以使用<code>normalize()</code>方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：<code>&quot;NFD&quot;</code>、<code>&quot;NFC&quot;</code>、<code>&quot;NFKD&quot;</code>或<code>&quot;NFKC&quot;</code>。<br>通过比较字符串与其调用<code>normalize()</code>的返回值，就可以知道该字符串是否已经规范化了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>),</span><br><span class="line">    a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>),</span><br><span class="line">    a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>);</span><br><span class="line"><span class="comment">// U+00C5是对0+212B进行NFC/NFKC规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// U+212B是未规范化的</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFC&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// U+0041/U+030A是对0+212B进行NFD/NFKD规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFD&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">&quot;NFKD&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFD&quot;</span>) === a2.normalize(<span class="string">&quot;NFD&quot;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a2.normalize(<span class="string">&quot;NFKC&quot;</span>) === a3.normalize(<span class="string">&quot;NFKC&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">&quot;NFC&quot;</span>) === a3.normalize(<span class="string">&quot;NFC&quot;</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-3-字符串操作方法"><a href="#5-3-3-3-字符串操作方法" class="headerlink" title="5.3.3.3   字符串操作方法"></a><strong>5.3.3.3   字符串操作方法</strong></h4><p><code>concat()</code>，可以接收任意多个参数，用于将一个或多个字符串拼接成一个新字符串。但更常用的方式是使用加号操作符（<code>+</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);      <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>slice()</code>、<code>substr()</code>和<code>substring()</code>。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数都表示子字符串开始的位置，对<code>slice()</code>和<code>substring()</code>而言，第二个参数是提取结束的位置（不包含该位置）。对<code>substr()</code>而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾，且不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));    <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));   <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><p>当某个参数是负值时，这3个方法的行为又有不同。<code>slice()</code>方法将所有负值参数都当成字符串长度加上负参数值。<code>substring()</code>方法会将所有负参数值都转换为0。<code>substr()</code>方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(-<span class="number">3</span>));         <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(-<span class="number">3</span>));     <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(-<span class="number">3</span>));        <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, -<span class="number">4</span>));      <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, -<span class="number">4</span>));  <span class="comment">// &quot;hel&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, -<span class="number">4</span>));     <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure><p><code>substring(3, 0)</code>，等价于<code>substring(0, 3)</code>，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对<code>substr()</code>来说，第二个参数会被转换为<code>0</code>，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</p><h4 id="5-3-3-4-字符串位置方法"><a href="#5-3-3-4-字符串位置方法" class="headerlink" title="5.3.3.4   字符串位置方法"></a><strong>5.3.3.4   字符串位置方法</strong></h4><p>有两个方法用于在字符串中定位子字符串：<code>indexOf()</code>和<code>lastIndexOf()</code>。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回<code>-1</code>）。区别在于，<code>indexOf()</code>方法从字符串开头开始查找子字符串，而<code>lastIndexOf()</code>方法从字符串末尾开始查找子字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>));     <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，<code>indexOf()</code>会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；<code>lastIndexOf()</code>则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>));     <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>使用第二个参数并循环调用<code>indexOf()</code>或<code>lastIndexOf()</code>，就可以在字符串中找到所有的目标子字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> pos = stringValue.indexOf(<span class="string">&quot;e&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">  positions.push(pos);</span><br><span class="line">  pos = stringValue.indexOf(<span class="string">&quot;e&quot;</span>, pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positions); <span class="comment">// [3,24,32,35,52]</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-5-字符串包含方法"><a href="#5-3-3-5-字符串包含方法" class="headerlink" title="5.3.3.5   字符串包含方法"></a>5.3.3.5   <strong>字符串包含方法</strong></h4><p>用于判断字符串中是否包含另一个字符串的方法：<code>startsWith()</code>、<code>endsWith()</code>和<code>includes()</code>。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。区别在于，<code>startsWith()</code>检查开始于索引0的匹配项，<code>endsWith()</code>检查开始于索引<code>(string.length - substring.length)</code>的匹配项，而<code>includes()</code>检查整个字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;bar&quot;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;baz&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;qux&quot;</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>startsWith()</code>和<code>includes()</code>方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>endsWith()</code>方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-6-trim-方法"><a href="#5-3-3-6-trim-方法" class="headerlink" title="5.3.3.6   trim()方法"></a>5.3.3.6   <code>trim()</code><strong>方法</strong></h4><p><code>trim()</code>方法，会创建字符串的一个副本，删除前、后所有空格符，再返回结果，原始字符串不受影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;  hello world  &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.trim();</span><br><span class="line"><span class="built_in">console</span>.log(stringValue);         <span class="comment">// &quot;  hello world &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(trimmedStringValue);  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>另外，<code>trimLeft()</code>和<code>trimRight()</code>方法分别清理字符串开始和末尾空格符。</p><h4 id="5-3-3-7-repeat-方法"><a href="#5-3-3-7-repeat-方法" class="headerlink" title="5.3.3.7   repeat()方法"></a>5.3.3.7   <code>repeat()</code><strong>方法</strong></h4><p>ECMAScript在所有字符串上都提供了<code>repeat()</code>方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;na &quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.repeat(<span class="number">16</span>) + <span class="string">&quot;batman&quot;</span>);</span><br><span class="line"><span class="comment">// na na na na na na na na na na na na na na na na batman</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-8-padStart-和padEnd-方法"><a href="#5-3-3-8-padStart-和padEnd-方法" class="headerlink" title="5.3.3.8   padStart()和padEnd()方法"></a>5.3.3.8   <code>padStart()</code><strong>和</strong><code>padEnd()</code><strong>方法</strong></h4><p><code>padStart()</code>和<code>padEnd()</code>方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">6</span>));       <span class="comment">// &quot;   foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));  <span class="comment">// &quot;......foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">6</span>));         <span class="comment">// &quot;foo   &quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">9</span>, <span class="string">&quot;.&quot;</span>));    <span class="comment">// &quot;foo......&quot;</span></span><br></pre></td></tr></table></figure><p>第二个参数如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padStart(<span class="number">2</span>));        <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>));   <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.padEnd(<span class="number">2</span>));          <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-9-字符串迭代与解构"><a href="#5-3-3-9-字符串迭代与解构" class="headerlink" title="5.3.3.9   字符串迭代与解构"></a>5.3.3.9   <strong>字符串迭代与解构</strong></h4><p>字符串的原型上暴露了一个<code>@@iterator</code>方法，表示可以迭代字符串的每个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = message[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: &quot;c&quot;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next());  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>for-of</code>循环中可以通过这个迭代器按序访问每个字符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>有了这个迭代器之后，字符串就可以通过解构操作符来解构了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...message]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-10-字符串大小写转换"><a href="#5-3-3-10-字符串大小写转换" class="headerlink" title="5.3.3.10   字符串大小写转换"></a><strong>5.3.3.10   字符串大小写转换</strong></h4><p>大小写转换，包括4个方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>和<code>toLocaleUpperCase()</code>。<code>toLocaleLowerCase()</code>和<code>toLocaleUpperCase()</code>方法旨在基于特定地区实现。在少数语言中，Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。通常，如果不知道代码涉及什么语言，则最好使用地区特定的转换方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());  <span class="comment">// &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());  <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-11-字符串模式匹配方法"><a href="#5-3-3-11-字符串模式匹配方法" class="headerlink" title="5.3.3.11   字符串模式匹配方法"></a>5.3.3.11   <strong>字符串模式匹配方法</strong></h4><p><code>match()</code>方法，这个方法本质上跟<code>RegExp</code>对象的<code>exec()</code>方法相同。<code>match()</code>方法接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">// 等价于pattern.exec(text)</span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);         <span class="comment">// &quot;cat&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><code>match()</code>方法返回的数组与<code>RegExp</code>对象的<code>exec()</code>方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。<br>另一个查找模式的字符串方法是<code>search()</code>。这个方法唯一的参数与<code>match()</code>方法一样：正则表达式字符串或<code>RegExp</code>对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。<code>search()</code>始终从字符串开头向后匹配模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pos = text.search(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>replace()</code>方法，接收两个参数，第一个参数可以是一个<code>RegExp</code>对象或一个字符串（不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.replace(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &quot;cond, bat, sat, fat&quot;</span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// &quot;cond, bond, sond, fond&quot;</span></span><br></pre></td></tr></table></figure><p>当第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262中规定了下表中的值。<br>|字符序列|替换文本|<br>|:—:|:—:|<br>|$$|$|<br>|$&amp;|匹配整个模式的子字符串。与RegExp.lastMatch相同。|<br>|$’|匹配的子字符串之前的字符串。与RegExp.rightContext相同。|<br>|$`|匹配的子字符串之后的字符串。与RegExp.leftContext相同。|<br>|$<em>n</em>或$<em>nn</em>|匹配第<em>n</em>个或第<em>nn</em>个捕获组的字符串，其中<em>n</em>是0<del>9或01</del>99。比如，$1是匹配第一个捕获组的字符串，$2是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串。|</p><p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">&quot;word ($1)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br></pre></td></tr></table></figure><p>当<code>replace()</code>的第二个参数是一个函数时，在只有一个匹配项时，这个函数会收到3个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;\&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(htmlEscape(<span class="string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>));</span><br><span class="line"><span class="comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>最后一个与模式匹配相关的字符串方法是<code>split()</code>。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是<code>RegExp</code>对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;red,blue,green,yellow&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.split(<span class="string">&quot;,&quot;</span>);       <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.split(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>);    <span class="comment">// [&quot;red&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.split(<span class="regexp">/[^,]+/</span>);   <span class="comment">// [&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure><p>注意在最后一次调用<code>split()</code>时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（<code>&quot;red&quot;</code>）和末尾（<code>&quot;yellow&quot;</code>）。</p><h4 id="5-3-3-12-localeCompare-方法"><a href="#5-3-3-12-localeCompare-方法" class="headerlink" title="5.3.3.12   localeCompare()方法"></a>5.3.3.12   <code>localeCompare()</code>方法</h4><p><code>localeCompare()</code>，比较两个字符串，返回如下3个值中的一个。</p><ul><li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是<code>-1</code>，具体还要看与实际值相关的实现。）</li><li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是<code>1</code>，具体还要看与实际值相关的实现。）</li><li>如果字符串与字符串参数相等，则返回<code>0</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;brick&quot;</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">&quot;zoo&quot;</span>));    <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用<code>localeCompare()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = stringValue.localeCompare(value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; comes before the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; comes after the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The string &#x27;yellow&#x27; is equal to the string &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">determineOrder(<span class="string">&quot;brick&quot;</span>);</span><br><span class="line">determineOrder(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">determineOrder(<span class="string">&quot;zoo&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>localeCompare()</code>的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串。在美国，英语是ECMAScript实现的标准语言，<code>localeCompare()</code>区分大小写，大写字母排在小写字母前面。</p><h2 id="5-4-单例内置对象"><a href="#5-4-单例内置对象" class="headerlink" title="5.4　单例内置对象"></a>5.4　单例内置对象</h2><p>内置对象：由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象。包括<code>Object</code>、<code>Array</code>和<code>String</code>，还有另外两个单例内置对象：<code>Global</code>和<code>Math</code>。</p><h3 id="5-4-1-Global"><a href="#5-4-1-Global" class="headerlink" title="5.4.1   Global"></a>5.4.1   <code>Global</code></h3><p>代码不会显式地访问<code>Global</code>对象，事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成<code>Global</code>对象的属性 。</p><h4 id="5-4-1-1-URL编码方法"><a href="#5-4-1-1-URL编码方法" class="headerlink" title="5.4.1.1   URL编码方法"></a><strong>5.4.1.1   URL编码方法</strong></h4><p><code>encodeURI()</code>和<code>encodeURIComponent()</code>方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。</p><p><code>ecnodeURI()</code>方法用于对整个URI进行编码，<code>encodeURIComponent()</code>方法用于编码URI中单独的组件，主要区别是，<code>encodeURI()</code>不会编码属于URL组件的特殊字符，比如：、/、?、#，而<code>encodeURIComponent()</code>会编码它发现的所有非标准字符。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http://www.wrox.com/illegal value.js#start&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;http://www.wrox.com/illegal%20value.js#start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));  </span><br><span class="line"><span class="comment">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 一般来说，使用<code>encodeURIComponent()</code>应该频率更高，因为编码查询字符串参数比编码基准URI的次数更多。</p></blockquote><p>与<code>encodeURI()</code>和<code>encodeURIComponent()</code>相对的是<code>decodeURI()</code>和<code>decodeURIComponent()</code>。<code>decodeURI()</code>只对使用<code>encodeURI()</code>编码过的字符解码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));<span class="comment">// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23start</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));<span class="comment">// http:// www.wrox.com/illegal value.js#start</span></span><br></pre></td></tr></table></figure><h4 id="5-4-1-2-eval-方法"><a href="#5-4-1-2-eval-方法" class="headerlink" title="5.4.1.2   eval()方法"></a>5.4.1.2   <code>eval()</code><strong>方法</strong></h4><p><code>eval()</code>方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(&#x27;hi&#x27;)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过<code>eval()</code>执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在<code>eval()</code>调用内部被引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>);  <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;let msg = &#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//Reference Error: msg is not defined</span></span><br></pre></td></tr></table></figure><p>通过<code>eval()</code>定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在<code>eval()</code>执行的时候才会被创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHi();<span class="comment">// sayHi is not defined</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;hi&#x27;); &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>但在严格模式下，在<code>eval()</code>内部创建的变量和函数无法被外部访问，赋值给<code>eval</code>也会导致错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="string">&quot;hi&quot;</span>;  <span class="comment">// 导致错误</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意 ** 使用<code>eval()</code>的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对XSS利用暴露出很大的攻击面。</p></blockquote><h4 id="5-4-1-3-window对象"><a href="#5-4-1-3-window对象" class="headerlink" title="5.4.1.3   window对象"></a>5.4.1.3   <code>window</code><strong>对象</strong></h4><p>虽然ECMA-262没有规定直接访问<code>Global</code>对象的方式，但浏览器将<code>window</code>对象实现为<code>Global</code>对象的代理。因此，所有全局作用域中声明的变量和函数都变成了<code>window</code>的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure><p>另一种获取<code>Global</code>对象的方式是使用如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">global</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="5-4-2-Math"><a href="#5-4-2-Math" class="headerlink" title="5.4.2   Math"></a>5.4.2   <code>Math</code></h3><p><code>Math</code>对象提供了一些辅助计算的属性和方法，它提供的计算要比在JavaScript实现快，因为<code>Math</code>对象上的计算使用了JavaScript引擎中更高效的实现和处理器指令，但问题是精度会因浏览器、操作系统、指令集和硬件而异。</p><h4 id="5-4-2-1-Math对象属性"><a href="#5-4-2-1-Math对象属性" class="headerlink" title="5.4.2.1   Math对象属性"></a>5.4.2.1   <code>Math</code><strong>对象属性</strong></h4><p><code>Math</code>对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>Math.E</code></td><td align="left">自然对数的基数e的值</td></tr><tr><td align="left"><code>Math.LN10</code></td><td align="left">10为底的自然对数</td></tr><tr><td align="left"><code>Math.LN2</code></td><td align="left">2为底的自然对数</td></tr><tr><td align="left"><code>Math.LOG2E</code></td><td align="left">以2为底e的对数</td></tr><tr><td align="left"><code>Math.LOG10E</code></td><td align="left">以10为底e的对数</td></tr><tr><td align="left"><code>Math.PI</code></td><td align="left">π的值</td></tr><tr><td align="left"><code>Math.SQRT1_2</code></td><td align="left">1/2的平方根</td></tr><tr><td align="left"><code>Math.SQRT2</code></td><td align="left">2的平方根</td></tr></tbody></table><h4 id="5-4-2-2-min-和max-方法"><a href="#5-4-2-2-min-和max-方法" class="headerlink" title="5.4.2.2   min()和max()方法"></a>5.4.2.2   <code>min()</code><strong>和</strong><code>max()</code><strong>方法</strong></h4><p><code>min()</code>和<code>max()</code>方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>));  <span class="comment">// 54</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>));  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...val);</span><br></pre></td></tr></table></figure><h4 id="5-4-2-3-舍入方法"><a href="#5-4-2-3-舍入方法" class="headerlink" title="5.4.2.3   舍入方法"></a>5.4.2.3   <strong>舍入方法</strong></h4><p>接下来是用于把小数值舍入为整数的4个方法，这几个方法处理舍入的方式如下所述。</p><ul><li><code>Math.ceil()</code>方法始终向上舍入为最接近的整数。</li><li><code>Math.floor()</code>方法始终向下舍入为最接近的整数。</li><li><code>Math.round()</code>方法执行四舍五入。</li><li><code>Math.fround()</code>方法返回数值最接近的单精度（32位）浮点值表示。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>));   <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>));  <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>));  <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.4</span>));  <span class="comment">// 0.4000000059604645</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">0.5</span>));  <span class="comment">// 0.5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.fround(<span class="number">25.9</span>)); <span class="comment">// 25.899999618530273</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>));  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h4 id="5-4-2-4-random-方法"><a href="#5-4-2-4-random-方法" class="headerlink" title="5.4.2.4   random()方法"></a>5.4.2.4   <code>random()</code><strong>方法</strong></h4><p><code>Math.random()</code>方法返回一个0~1范围内的随机数，其中包含0但不包含1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total_number_of_choices + first_possible_value)</span><br></pre></td></tr></table></figure><p>比如如果想从1~10范围内随机选择一个数，代码就是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>**注意 **如果为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），建议使用<code>window.crypto.getRandomValues()</code>。</p></blockquote><h4 id="5-4-2-5-其他方法"><a href="#5-4-2-5-其他方法" class="headerlink" title="5.4.2.5   其他方法"></a>5.4.2.5   <strong>其他方法</strong></h4><p><code>Math</code>对象还有很多涉及各种简单或高阶数运算的方法。下表总结了<code>Math</code>对象的其他方法。</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>Math.abs(x)</code></td><td align="left">返回x的绝对值</td></tr><tr><td align="left"><code>Math.exp(x)</code></td><td align="left">返回<code>Math.E</code>的x次幂</td></tr><tr><td align="left"><code>Math.expm1(x)</code></td><td align="left">等于<code>Math.exp(x)</code> - 1</td></tr><tr><td align="left"><code>Math.log(x)</code></td><td align="left">返回x的自然对数</td></tr><tr><td align="left"><code>Math.log1p(x)</code></td><td align="left">等于1 +<code> Math.log(x)</code></td></tr><tr><td align="left"><code>Math.pow(x,power)</code></td><td align="left">返回x的<em>power</em>次幂</td></tr><tr><td align="left"><code>Math.hypot(...nums)</code></td><td align="left">返回<code>nums</code>中每个数平方和的平方根</td></tr><tr><td align="left"><code>Math.clz32(x)</code></td><td align="left">返回32位整数x的前置零的数量</td></tr><tr><td align="left"><code>Math.sign(x)</code></td><td align="left">返回表示x符号的1、0、-0或-1</td></tr><tr><td align="left"><code>Math.trunc(x)</code></td><td align="left">返回x的整数部分，删除所有小数</td></tr><tr><td align="left"><code>Math.sqrt(x)</code></td><td align="left">返回x的平方根</td></tr><tr><td align="left"><code>Math.cbrt(x)</code></td><td align="left">返回x的立方根</td></tr><tr><td align="left"><code>Math.atan2(y,x)</code></td><td align="left">返回<em>y</em>/x的反正切</td></tr><tr><td align="left"><code>Math.cos(x)</code>/<code>Math.acos(x)</code>/<code>Math.acosh(x)</code></td><td align="left">返回x的余弦/反余弦/反双曲余弦</td></tr><tr><td align="left"><code>Math.sin(x)</code>/<code>Math.asin(x)</code>/<code>Math.asinh(x)</code></td><td align="left">返回x的正弦/反正弦/反双曲正弦</td></tr><tr><td align="left"><code>Math.tan(x)</code>/<code>Math.atan(x)</code>/<code>Math.atanh(x)</code></td><td align="left">返回x的正切/反正切/反双曲正切</td></tr></tbody></table><p>即便这些方法都是由ECMA-262定义的，对正弦、余弦、正切等计算的实现仍然取决于浏览器，因为计算这些值的方式有很多种。因此，这些方法的精度可能因实现而异。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;引用值（或者对象）是某个特定&lt;strong&gt;引用类型&lt;/strong&gt;的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”，引用类型有时候也被称为&lt;strong&gt;对象定义&lt;/strong&gt;，因为它们描述了自己的对象应有的属性和方</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript高级程序设计(第四版)" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建的想法</title>
    <link href="http://example.com/2021/03/09/diary/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%83%B3%E6%B3%95/"/>
    <id>http://example.com/2021/03/09/diary/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%83%B3%E6%B3%95/</id>
    <published>2021-03-09T02:41:14.138Z</published>
    <updated>2021-05-11T09:18:14.353Z</updated>
    
    <content type="html"><![CDATA[<p>长久的坚持学习并监督自己发布到博客上绝非易事，在我从刚开始浏览他人博客，到自己学习搭建博客这段时间，发现很多人的文章已是很早之前，或许是工作生活和其他压力，早将此事抛之脑后。</p><p>我更希望这个博客记载着我从一个前端小白到略懂一二的树洞，也正如我网站的标语，慢慢来，深几度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;长久的坚持学习并监督自己发布到博客上绝非易事，在我从刚开始浏览他人博客，到自己学习搭建博客这段时间，发现很多人的文章已是很早之前，或许是工作生活和其他压力，早将此事抛之脑后。&lt;/p&gt;
&lt;p&gt;我更希望这个博客记载着我从一个前端小白到略懂一二的树洞，也正如我网站的标语，慢慢来，</summary>
      
    
    
    
    <category term="日记随笔" scheme="http://example.com/categories/%E6%97%A5%E8%AE%B0%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML Standard阅读初体验</title>
    <link href="http://example.com/2021/03/09/tech/HTML%20Standard/"/>
    <id>http://example.com/2021/03/09/tech/HTML%20Standard/</id>
    <published>2021-03-09T01:29:43.971Z</published>
    <updated>2021-05-11T09:22:14.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract："><a href="#Abstract：" class="headerlink" title="Abstract："></a>Abstract：</h1><p>通过背景、针对人群、发展历程等几个方面说明了HTML规范的意义和适用范围，同时对规范中的表单序列化、对其他规范的兼容性、可扩展性三个设计目标进行详细说明。其次引入元素、节点、DOM树等概念简单介绍了HTML，最后举例来说明Web可能存在的安全问题并提供了易行的解决方法。</p><h1 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h1><p>通览目录和前言的介绍，对近期所要学习的内容即HTM规范及其重要性有了一个初步的了解，比如对一些基础知识，譬如元素和节点两个概念的区别、DOM树的概念理解更加清晰。</p><p>另一方面，在之前的前端学习中，只考虑到兼容性，至于安全性，除了post、HTTPS比get和HTTP安全以外就不甚了解，有些攻击甚至能威胁到服务器中的数据。</p><p>如同规范里所说，“对于完整理解本规范的某些技术性部分，必须熟悉DOM的基础”，同时，在阅读途中也能了解到不仅限于所阅读的内容，比如1.10.2中所举的例子，也顺带去了解一下事件的捕获和冒泡机制，这些都要求我需要花更多的时间精力，但我想也才能更好的理解HTML规范，同时全英文的规范阅读对我的英语水平也将有极大的提升，相信不久，目前较为吃力的我也能逐渐以英语来记录我的笔记，</p><p>总而言之，我目前的认知，阅读并理解HTML规范，就如同使用产品之前看说明书一样，能有助于安全、有效的开发的同时，也减少了后期的维护成本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Abstract：&quot;&gt;&lt;a href=&quot;#Abstract：&quot; class=&quot;headerlink&quot; title=&quot;Abstract：&quot;&gt;&lt;/a&gt;Abstract：&lt;/h1&gt;&lt;p&gt;通过背景、针对人群、发展历程等几个方面说明了HTML规范的意义和适用范围，同时对规范</summary>
      
    
    
    
    <category term="日记随笔" scheme="http://example.com/categories/%E6%97%A5%E8%AE%B0%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（四）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-03-08T13:18:00.197Z</published>
    <updated>2021-05-11T09:19:05.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>表单</strong>是一种网页组件，可以包含表单控件如文本，按钮，复选框，范围或颜色选择器控件。 用户可以与这样的表单进行交互并提供数据，随后这些数据被发送到服务器用于进一步处理 （例如返回搜索或计算结果）。</p><p>编写表单的步骤（没有顺序）：编写用户界面、实现服务器端的处理、用户界面与服务器端通信的配置。</p><h1 id="用户界面的编写"><a href="#用户界面的编写" class="headerlink" title="用户界面的编写"></a>用户界面的编写</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;  </span><br><span class="line"> &lt;p&gt;&lt;label&gt;Customer name: &lt;input&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;Telephone: &lt;input type&#x3D;tel&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;E-mail address: &lt;input type&#x3D;email&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;fieldset&gt;</span><br><span class="line">  &lt;legend&gt; Pizza Size &lt;&#x2F;legend&gt;   </span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size&gt; Small &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size&gt; Medium &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;radio name&#x3D;size&gt; Large &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;&#x2F;fieldset&gt;</span><br><span class="line"> &lt;fieldset&gt;</span><br><span class="line">  &lt;legend&gt; Pizza Toppings &lt;&#x2F;legend&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Bacon &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Extra Cheese &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Onion &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;label&gt; &lt;input type&#x3D;checkbox&gt; Mushroom &lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;&#x2F;fieldset&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;Preferred delivery time: &lt;input type&#x3D;time min&#x3D;&quot;11:00&quot; max&#x3D;&quot;21:00&quot; step&#x3D;&quot;900&quot;&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;label&gt;Delivery instructions: &lt;textarea&gt;&lt;&#x2F;textarea&gt;&lt;&#x2F;label&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> &lt;p&gt;&lt;button&gt;Submit order&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">**简要说明：**</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>表单都以form元素开始。多数控件都由 input 元素表示，它默认提供一个文本控件。</li><li>使用 label 元素来描述控件，标签文本和控件自己都会进入 label 元素内。</li><li>表单的每一部分都是一个段落，一般用 p 元素来与其他部分分隔。</li><li>单选按钮用 input 元素，设置 type 属性，值为 radio。 name属性值一样让单选按钮成组。</li><li>fieldset 元素让一批控件成为一组，控件组的标题由 fieldset 中的 legend 表示。</li><li>这些复选框使用 input 元素， type 属性值为 checkbox：。</li><li>电话号码的表单控件（type 属性设为 tel 的 input 元素）， e-mail 地址（type 属性设为 email 的 input 元素）：</li><li>type 属性设为 time 的 input 元素来询问配送时间。 很多控件都可以设置可选值的范围；这个例子中的属性是 min, max 和step。这些属性分别用来设置最小时间，最大时间， 以及允许的值之间的间隔（单位为秒）。</li><li>textarea 元素可以用来提供多行文本。</li><li>为了让表单可以提交，用一个 button 元素。<h1 id="用户界面与服务器端通信的配置"><a href="#用户界面与服务器端通信的配置" class="headerlink" title="用户界面与服务器端通信的配置"></a>用户界面与服务器端通信的配置</h1></li></ol><p>表单提交通常是GET 或 POST 请求。在 form 元素上使用 method 属性来指定使用哪种方法。 指定编码方式要使用 enctype 属性。action 属性来指定处理提交的数据服务的 URL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">enctype</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;https://pizza.example.com/order.cgi&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个需要提交的表单控件都要有一个名字来对应提交的数据。属性name指定了提交的名字。他们之间可以通过 value 属性给它们不同的值来区分。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span> <span class="attr">value</span>=<span class="string">&quot;small&quot;</span>&gt;</span> Small <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span> <span class="attr">value</span>=<span class="string">&quot;medium&quot;</span>&gt;</span> Medium <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">radio</span> <span class="attr">name</span>=<span class="string">size</span> <span class="attr">value</span>=<span class="string">&quot;large&quot;</span>&gt;</span> Large <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="客户端表单验证"><a href="#客户端表单验证" class="headerlink" title="客户端表单验证"></a>客户端表单验证</h1><p>通过表单标记使得用户代理可以在表单提交之前检查用户输入，但服务器仍然必须校验输入是有效的（因为恶意用户可以很容易绕过表单验证）， 但这使我们可以避免因为只能在服务器上检查而造成用户等待。input 元素上的required 属性，表示只有给出值之后表单才可以提交。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Customer name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;custname&quot;</span> <span class="attr">required</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 maxlength 属性来限制输入的长度。 把这个属性添加到 textarea 元素上，我们可以限制用户输入到 1000 字符。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Delivery instructions: <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comments&quot;</span> <span class="attr">maxlength</span>=<span class="string">1000</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>提交表单时，每个不合法的表单控件上，以及 form 元素上都会触发 invalid 事件， 这个事件可以用来显示表单存在哪些问题的一个描述。</p><h1 id="启用表单控件的客户端自动填充"><a href="#启用表单控件的客户端自动填充" class="headerlink" title="启用表单控件的客户端自动填充"></a>启用表单控件的客户端自动填充</h1><p>浏览器可以帮助用户自动填充表单控件，避免让用户每次重新输入。为了帮助用户代理做自动填充，可以使用 autocomplete 属性来描述字段的用途。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Customer name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;custname&quot;</span> <span class="attr">required</span> <span class="attr">autocomplete</span>=<span class="string">&quot;shipping name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="提高用户手机端体验"><a href="#提高用户手机端体验" class="headerlink" title="提高用户手机端体验"></a>提高用户手机端体验</h1><p>有些设备使用inputmode属性为用户提供多种输入方式。例如，在输入信用卡号码时，用户可能希望只看到0-9数字键，而在输入姓名时，用户可能希望看到每个单词默认大写的表单字段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>Buzzer code: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;custbuzz&quot;</span> <span class="attr">inputmode</span>=<span class="string">&quot;number&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="type-autocomplete-inputmode之间的区别"><a href="#type-autocomplete-inputmode之间的区别" class="headerlink" title="type, autocomplete, inputmode之间的区别"></a>type, autocomplete, inputmode之间的区别</h1><p>input元素上的type属性决定用户代理将使用哪种控件来公开字段。</p><p>autocomplete属性描述了用户将输入的值实际表示的内容。</p><p>当控件是文本控件时，inputmode属性决定使用哪种输入方式。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><table><thead><tr><th><strong>element</strong></th><th><strong>meaning</strong></th><th><strong>Categories</strong></th><th><strong>Contexts in which this element can be used</strong></th><th><strong>Content model</strong></th><th><strong>Tag omission in text/html</strong></th><th><strong>Content attributes</strong></th><th><strong>remark</strong></th></tr></thead><tbody><tr><td>form</td><td>表单</td><td>Flow content、Palpable content</td><td>flow content</td><td>Flow content,但没有form元素后代</td><td>不可省略</td><td>accept-charset—服务器处理表单数据的字符集action — 表单提交的urlautocomplete—form内控件设置自动填充enctype—发送表单数据之前如何对其进行编码method —表单提交使用的HTTP方法name — 用于使用API时的名称novalidate —表单提交时不用进行验证target —表单提交的上下文rel</td><td></td></tr><tr><td>label</td><td>为 input 元素定义标注</td><td>Flow content、Phrasing content、Interactive content、Palpable content</td><td>phrasing content</td><td>Phrasing content，但没有后代labelable元素，除非它是元素的 labeled control且没有后代label</td><td>不可省略</td><td>for — 绑定到哪个表单元素</td><td>1.要么通过for属性（属性值和需要绑定控件id一样），要么将控件放在label元素内。</td></tr></tbody></table><h1 id="Input-type"><a href="#Input-type" class="headerlink" title="Input type"></a>Input type</h1><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>button</td><td>定义可单击的按钮（主要与JavaScript一起使用以激活脚本）</td><td></td></tr><tr><td>checkbox</td><td>定义一个复选框</td><td></td></tr><tr><td>color</td><td>定义颜色选择器</td><td></td></tr><tr><td>date</td><td>定义日期控件（年，月，日（无时间））</td><td></td></tr><tr><td>datetime-local</td><td>定义日期和时间控件（年，月，日，时间（无时区））</td><td></td></tr><tr><td>file</td><td>定义文件选择字段和“浏览”按钮（用于文件上载）</td><td></td></tr><tr><td>image</td><td>将图像定义为提交按</td><td></td></tr><tr><td>month</td><td>定义月份和年份控件（无时区）</td><td></td></tr><tr><td>number</td><td>定义用于输入数字的字段</td><td></td></tr><tr><td>password</td><td>定义密码字段</td><td></td></tr><tr><td>radio</td><td>定义单选按钮</td><td></td></tr><tr><td>range</td><td>定义范围控件（如滑块控件）</td><td></td></tr><tr><td>reset</td><td>定义重置按钮</td><td></td></tr><tr><td>submit</td><td>定义提交按钮</td><td></td></tr><tr><td>time</td><td>定义用于输入时间的控件（无时区）</td><td></td></tr><tr><td>week</td><td>定义周和年控制（无时区）</td><td></td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td><td>禁止进行约束验证；如果那么name和 <em>charset</em> 值相同，必须省略value属性。</td></tr><tr><td>text</td><td>定义单行文本字段</td><td>没有指定type值或无效，默认为文本控件。输入值和value值禁止使用回车符或换行符。</td></tr><tr><td>search</td><td>定义用于输入搜索字符串的文本字段</td><td>没有指定type值或无效，默认为文本控件。输入值和value值禁止使用回车符或换行符。</td></tr><tr><td>tel</td><td>定义用于输入电话号码的字段</td><td>输入值和value值禁止使用回车符或换行符。不强制使用特定规则</td></tr><tr><td>url</td><td>定义用于输入URL的字段</td><td>可以为空字符串，但不能使用回车符或换行符。当元素的值既不是空字符串，也不是有效的绝对URL，元素的类型不匹配</td></tr><tr><td>email</td><td>定义电子邮件地址的字段</td><td>定义电子邮件地址的字段当设置了multiple属性：</td></tr></tbody></table><h1 id="定义电子邮件地址的字段当设置了multiple属性：Input-attribute"><a href="#定义电子邮件地址的字段当设置了multiple属性：Input-attribute" class="headerlink" title="定义电子邮件地址的字段当设置了multiple属性：Input attribute"></a>定义电子邮件地址的字段当设置了multiple属性：Input attribute</h1><table><thead><tr><th align="left">accept</th><th align="left">规定通过文件上传来提交</th></tr></thead><tbody><tr><td align="left">alt</td><td align="left">图像不可用的替代文本</td></tr><tr><td align="left">autocomplete</td><td align="left">是否使用输入字段的自动</td></tr><tr><td align="left">checked</td><td align="left">首次加载时是否被选中</td></tr><tr><td align="left">dirname</td><td align="left">输入字段的文本方向</td></tr><tr><td align="left">disabled</td><td align="left">是否禁用此元素</td></tr><tr><td align="left">form</td><td align="left">规定输入字段所属的一个</td></tr><tr><td align="left">formaction</td><td align="left">覆盖表单的 action 属性</td></tr><tr><td align="left">formenctype</td><td align="left">覆盖表单的 enctype 属性</td></tr><tr><td align="left">formmethod</td><td align="left">覆盖表单的 method 属性</td></tr><tr><td align="left">formnovalidate</td><td align="left">覆盖表单的 novalidate</td></tr><tr><td align="left">formtarget</td><td align="left">覆盖表单的 target 属性n</td></tr><tr><td align="left">height</td><td align="left">高</td></tr><tr><td align="left">list</td><td align="left">预定义的选项列表</td></tr><tr><td align="left">max</td><td align="left">输入字段的最大值</td></tr><tr><td align="left">maxlength</td><td align="left">输入字段的最大长度</td></tr><tr><td align="left">min</td><td align="left">输入字段的最小值</td></tr><tr><td align="left">minlength</td><td align="left">输入字段的最小长度</td></tr><tr><td align="left">multiple</td><td align="left">是否允许多个值</td></tr><tr><td align="left">name</td><td align="left">元素名称</td></tr><tr><td align="left">pattern</td><td align="left">输入字段的值的格式</td></tr><tr><td align="left">placeholder</td><td align="left">用户填写输入字段的提示</td></tr><tr><td align="left">readonly</td><td align="left">是否允许用户修改</td></tr><tr><td align="left">required</td><td align="left">是否必须填写</td></tr><tr><td align="left">size</td><td align="left">控件尺寸</td></tr><tr><td align="left">src</td><td align="left">资源地址</td></tr><tr><td align="left">step</td><td align="left">输入的间隔</td></tr><tr><td align="left">type</td><td align="left">控件类型</td></tr><tr><td align="left">value</td><td align="left">元素的值</td></tr><tr><td align="left">width</td><td align="left">宽</td></tr><tr><td align="left">title</td><td align="left">pattern的描述</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;表单&lt;/strong&gt;是一种网页组件，可以包</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（三）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-03-08T12:31:17.696Z</published>
    <updated>2021-05-11T09:19:02.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="area元素"><a href="#area元素" class="headerlink" title="area元素"></a><strong>area元素</strong></h2><p>图像映射上文本和对应区域的超链接或图像映射上的dead area</p><p><strong>Categories</strong>:Flow content、Phrasing content.</p><p><strong>Contexts in which this element can be used</strong>:仅当有一个map祖先，phrasing content</p><p><strong>Content model</strong>:无</p><p><strong>Tag omission in text/html</strong>:没有结束标签</p><p><strong>Content attributes:</strong></p><p><strong>Global attributes：</strong></p><ol><li><p>alt —定义此区域的替换文本。</p></li><li><p>coords — 可点击区域的坐标</p></li><li><p>shape —定义区域的形状</p></li><li><p>href — 超链接地址</p></li><li><p>target — 在何处打开 href 属性指定的目标 URL</p></li><li><p>download — 是否下载资源后不是导航</p></li><li><p>ping — URLs to ping</p></li><li><p>rel —超链接的文档中的位置与目标资源之间的关系</p></li><li><p>referrerpolicy — Referrer policy</p></li></ol><p>1、area的父元素一定是map</p><p>2、area有href属性，代表超链接，这种情况下，必须有alt属性。如果没有href属性，alt属性可以省略，target, download, ping, rel, referrerpolicy 必须省略。</p><p>3、shape</p><table><thead><tr><th>State</th><th>Keywords</th><th>Notes</th></tr></thead><tbody><tr><td>Circle state</td><td>circle/circ</td><td>必须有 coords 属性（3个整数，最后一个非负）</td></tr><tr><td>Default state</td><td>default</td><td>不能有 coords 属性</td></tr><tr><td>Polygon state</td><td>poly/polygon</td><td>必须有 coords 属性（至少6个整数，且是偶数）</td></tr><tr><td>Rectangle state</td><td>rect/rectangle</td><td>必须有 coords 属性（4个整数，第一个小于第三个，第二个小于第四个）</td></tr></tbody></table><p>4、如果area有itemprop属性，则也必须设置href属性</p><h2 id="MathML"><a href="#MathML" class="headerlink" title="MathML"></a><strong>MathML</strong></h2><p>MathML 是数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;math&gt;</span><br><span class="line"></span><br><span class="line">&lt;mi&gt;x&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo&gt;&#x3D;&lt;&#x2F;mo&gt;</span><br><span class="line"></span><br><span class="line">&lt;mfrac&gt;</span><br><span class="line"></span><br><span class="line">&lt;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo form&#x3D;&quot;prefix&quot;&gt;−&lt;&#x2F;mo&gt; &lt;mi&gt;b&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo&gt;±&lt;&#x2F;mo&gt;</span><br><span class="line"></span><br><span class="line">&lt;msqrt&gt;</span><br><span class="line"></span><br><span class="line">&lt;msup&gt; &lt;mi&gt;b&lt;&#x2F;mi&gt; &lt;mn&gt;2&lt;&#x2F;mn&gt; &lt;&#x2F;msup&gt;</span><br><span class="line"></span><br><span class="line">&lt;mo&gt;−&lt;&#x2F;mo&gt;</span><br><span class="line"></span><br><span class="line">&lt;mn&gt;4&lt;&#x2F;mn&gt; &lt;mo&gt;⁢&lt;&#x2F;mo&gt; &lt;mi&gt;a&lt;&#x2F;mi&gt; &lt;mo&gt;⁢&lt;&#x2F;mo&gt; &lt;mi&gt;c&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;msqrt&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;mn&gt;2&lt;&#x2F;mn&gt; &lt;mo&gt;⁢&lt;&#x2F;mo&gt; &lt;mi&gt;a&lt;&#x2F;mi&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mrow&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mfrac&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;math&gt;</span><br></pre></td></tr></table></figure><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a><strong>SVG</strong></h2><p>是一种用于描述二维的矢量图形，基于 XML 的标记语言。SVG 相对于图像，就好比 HTML 相对于文本。</p><p>doc = iframe . getSVGDocument()</p><p>doc = embed . getSVGDocument()</p><p>doc = object . getSVGDocument()</p><p>如果iframe、embed或object元素用于嵌入SVG，则返回Document对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;area元素&quot;&gt;&lt;a href=&quot;#area元素&quot; class=&quot;headerlink&quot; title=&quot;area元素&quot;&gt;&lt;/a&gt;&lt;strong&gt;area元素&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;图像映射上文本和对应区域的超链接或图像映射上的dead area&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（二）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-03-08T12:31:15.086Z</published>
    <updated>2021-05-11T09:18:58.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>基于设备像素比。</strong>缩放级别和屏幕像素密度（上一点）都会影响单个CSS pixel 上的物理屏幕像素。适用当图片的于染大小固定的情况下，在 img 元素上用 src 和 srcset 属性， 使用 x 描述符来提供多个只有大小不同的图片（小图是大图的缩略版）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jpg&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于视口的选择：</strong>作者可能要显示同一张图片，但渲染大小根据 viewport 宽度有所不同。 可以使用 srcset 和 sizes 属性，使用 w 描述符来提供多个只有大小不同的图片 （小图是大图的缩略版）。 用户代理将会根据指定的 w 描述符和 sizes 属性指定的渲染大小为每个图片计算等效像素密度。 然后它可以根据用户屏幕的像素密度、缩放级别和任何可能的其他因素（比如用户网络状态）选择任何一个资源。  通过使用 w 描述符和 sizes 属性， 不论用户设备有多大用户代理都可以选择下载正确的图片资源。 在新的用户代理中，当 srcset 属性使用 w 描述符时， src 属性会被忽略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">sizes</span>=<span class="string">&quot;100vw&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w&quot;</span>   <span class="attr">src</span>=<span class="string">&quot;wolf-400.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The rad wolf&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于艺术选择：</strong>作者可能会根据图片的渲染大小显示不同的图片内容。可以用 picture 元素和 source 元素和 media 属性提供多张内容不同的图片 （例如小的图片是大图的裁剪版）。 用户代理会选择 media 属性中的媒体查询匹配的第一个 source 元素，然后从它的 srcset 属性中选择一个合适的 URL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 45em)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;large.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 32em)&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;med.jpg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;small.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The wolf runs through the snow.&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于图片格式的选择：</strong>作者可能希望显示同样的图片内容但根据用户代理的支持情况使用不同的图片格式。 可以使用 source 元素上的 type 属性来提供多种格式的图片。在这个例子中，用户代理会选择第一个 type 属性为支持的 MIME 类型的源。 如果用户代理支持 WebP 就会选择第一个 source 元素。 如果不支持 WebP，但支持 JPEG XR 就会选择第二个 source 元素。 如果这两种都不支持，就会选择 img 元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/100-marie-lloyd.webp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jxr&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/vnd.ms-photo&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/uploads/100-marie-lloyd.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Decoding"><a href="#Decoding" class="headerlink" title="Decoding"></a><strong>Decoding</strong></h2><table><thead><tr><th align="left">Keyword</th><th align="left">State</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">sync</td><td align="left">Sync</td><td align="left">表示优先同步解码此图像，以便与其他内容进行原子表示。</td></tr><tr><td align="left">async</td><td align="left">Async</td><td align="left">指示优先选择异步解码此图像，以避免延迟其他内容的呈现。</td></tr><tr><td align="left">auto</td><td align="left">Auto</td><td align="left">表示默认值，用户代理可以自由选择任何解码行为。</td></tr></tbody></table><p>可以使用该decode()方法来控制解码行为。由于该decode()方法独立于负责将内容呈现到屏幕的过程执行解码，因此它不受decoding属性的影响</p><h2 id="alt使用"><a href="#alt使用" class="headerlink" title="alt使用"></a><strong>alt使用</strong></h2><p>除非另有说明，必须指定 alt 属性且它的值不能为空，且必须适合替代图片。 对 alt 属性具体的要求取决于它要表示什么图片.编写替代文本时要考虑的最一般规则如下：1、 alt 属性的文本替换每个图像不会改变页面的含义。2、 alt 属性的值不应该包含图片的 caption, title 或 legend 文本。3、 应该包含的替代文本是用于替代图片的，而不是图片的补充， 用 title 属性可以提供补充信息。5、 alt 属性的值不应该重复已经由后面的文字提供的信息。</p><p><strong>使用情况：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、当创建 超链接 的 a 元素或 button 元素没有文本内容只包含一个或更多图片时，alt 属性必须包含一些文字来传达链接或按钮的用途。</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;green.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;green.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>2、具有替代图形表示形式的短语或段落：图表，图表，图形，地图，插图，文本必须在alt属性中给出，并且必须传达与src 属性中指定的图像相同的消息。重要的是要意识到替代文本是图像的替代品，而不是图像的描述。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;house.jpeg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;The house is white, with a boarded front door.&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、一个文档可以包含图标信息，图标是为了帮助视觉浏览器的用户一目了然地识别功能。有些情况下，图标是文本标签的补充，它们传达同样的含义。 那些情况下，alt 属性必须存在且为空。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/help/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/icons/help.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span> Help<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外一些情况下，图标旁边没有文字来描述它的含义；这样的图标就应该解释自己的含义。 那些情况下，同等的文本标签必须通过alt 属性给出。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;movies.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、图像仅由文本组成，并且图像的目的是不是突出显示用于渲染文本的实际印刷效果，而是传达文本本身。在这种情况下，alt必须存在属性，但属性必须包含与图像本身相同的文本。在这种情况下，替代文本就是图像所代表的字符。（ps:如果由于作者的默认系统字体不支持给定字符而使他们倾向于使用图像，那么考虑Web字体。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;initials/o.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;O&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5、图像实际上只是补充，它的存在只会增强周围的文本。在这些情况下，alt必须存在该属性，但其值必须为空字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>According to a study covering several billion pages,about 9% triggered the Standards mode.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;rendering-mode-pie-chart.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6、辅助图像。图像对内容并不重要，但它既不是纯粹的装饰，也不是文本的全部多余。在这些情况下，该alt属性必须存在，并且其值应为空字符串或图像传达的信息的文本表示形式。</p><p>7、纯装饰性图像，这样的图像是装饰性的，但仍构成内容的一部分。alt必须存在该属性，但其值必须为空字符串。</p><p>8、组成但个没有链接的大图的图片组，当一张图片被切分为若干个小图片文件，用来拼装成原来的大图时，这些图片中要有一个的 alt 属性按照相关规则设置为大图的替代文本。 然后其他所有剩余图片必须把 alt 属性设为空字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;XYZ Corp&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo2.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>9、组成单个有链接的大图的图片组。通常带连接的图片应该使用 图片映射 而不是切分图片。但是，如果图片确实已经被切分了，而且切分后的部分是链接的唯一内容， 那么每个链接必须有一个图片必须把它的 alt 属性设置为表示链接用途的替代文本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?go=left&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-left.png&quot;</span>  <span class="attr">alt</span>=<span class="string">&quot;Left side. &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-middle.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;?go=right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;fsm-right.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Right side.&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>10、内容的关键部分，图片是内容的关键部分。比如照片库页面中的图片，如何为内容关键的图片提供替代文本，取决于图片的出处。</p><p>通常情况：通过 alt 属性给出替代图片的文字。</p><p>难以提供完整描述的图片： alt 属性也必须包含一些适当的替代文本， 但可以比较简短。</p><p>未知内容的图片：alt 属性可以忽略，但必须符合以下条件之一：（1）img 元素在 包含 figcaption 的 figure 元素中， 且这个 figcaption 元素包含除元素间空白的内容，而且忽略 figcaption 元素及其后代节点后， figure 元素没有其他 流式内容 后代， 元素间空白 和 img 元素除外。（2）title 属性存在且值非空。</p><p>11、不是给用户看的图片，首先应该避免使用不用来显示的 img 元素。如果一个 img 元素不是用于显示的，比如用于计算页面浏览量的服务。 那么 alt 属性必须为空字符串。在这些场景下，width 和 height 属性必须设为 0。</p><p>12、给特定的、已知一定可以查看图片的人的 e-mail 或私人文档中的图片，可以省略alt 属性。但是，即使在这种情况下，也强烈建议作者包括替代文本，如上所示。</p><p>13、标记生成器指引</p><p>标记生成器应尽可能从用户那里获取替代文本。但是在许多情况下这是不可能的。</p><p>对于仅作为链接内容的图像，标记生成器应检查链接目标以确定目标标题或目标URL，并将以此方式获得的信息用作替代文本。</p><p>对于具有标题的图像，标记生成器应使用figure和 figcaption元素或title属性来提供图像的标题。</p><p>作为最后的选择，实现者应在图像为纯装饰性图像下（第7条），将alt 属性设置为空字符串，或假设图像是内容的关键部分（第10条未知内容的图片）完全省略alt属性。</p><p>标记生成器可以 在img元素上指定generator-unable-to-provide-required-alt 属性，这些元素他们无法为其获取替代文本，因此为其省略了该alt属性。</p><p>14、规范检查工具指引</p><p>规范检查工具必须把缺少 alt 属性报告为错误， 以下除外：上面第10条、12条、13条所举特殊情况。</p><h1 id="Media"><a href="#Media" class="headerlink" title="Media"></a><strong>Media</strong></h1><p>audio和video元素，都可用于音频和视频。主要区别只是audio元素没有视觉内容（例如视频或字幕）的播放区域，而video元素却有 。</p><h2 id="error-codes"><a href="#error-codes" class="headerlink" title="error codes"></a><strong>error codes</strong></h2><p>media.error  返回一个表示该元素当前错误状态的MediaError 对象。如无，返回null</p><p>media.error.code   返回当错错误状态的代码</p><p>media.error.message返回有关遇到的错误情况的特定信息诊断消息。消息和消息格式通常在不同的用户代理之间不一致。如果没有此类消息，则返回空字符串。</p><ul><li>1 = MEDIA_ERR_ABORTED - 取回过程被用户中止</li><li>2 = MEDIA_ERR_NETWORK - 当下载时某种网络发生错误</li><li>3 = MEDIA_ERR_DECODE - 当解码时发生错误</li><li>4 = MEDIA_ERR_SRC_NOT_SUPPORTED - 不支持音频/视频<h2 id="媒体资源位置"><a href="#媒体资源位置" class="headerlink" title="媒体资源位置"></a><strong>媒体资源位置</strong></h2></li></ul><p>media . srcObject [ = source ]    允许为media元素分配一个media provider对象。</p><p>media . currentSrc 返回当前媒体资源的URL。没有媒体资源或没有 URL时返回空字符串。</p><p>有三种方法可以指定媒体资源（优先级从大到小）：srcObjectIDL属性，src内容属性和source元素。</p><h2 id="MIME-types"><a href="#MIME-types" class="headerlink" title="MIME types"></a><strong>MIME types</strong></h2><p>只有不带参数的 application/octet-stream”MIME类型 “是特殊情况；如果出现任何参数，则将其与任何其他MIME type一样对待。</p><p>media . canPlayType(type)    检测浏览器是否能播放指定的音频/视频类型</p><p>返回值：</p><ol><li>“probably” - 浏览器最可能支持该音频/视频类型</li><li>“maybe” - 浏览器也许支持该音频/视频类型</li><li>“” - （空字符串）浏览器不支持该音频/视频类型</li></ol><p>source元素的type属性允许用户代理避免下载使用其无法呈现的格式的资源。</p><h2 id="Network-states"><a href="#Network-states" class="headerlink" title="Network states"></a><strong>Network states</strong></h2><p>media . networkState  从下面的代码列表中，返回该元素网络活动的当前状态。</p><ol><li>0 = NETWORK_EMPTY - 音频/视频尚未初始化</li><li>1 = NETWORK_IDLE - 音频/视频是活动的且已选取资源，但并未使用网络</li><li>2 = NETWORK_LOADING - 浏览器正在下载数据</li><li>3 = NETWORK_NO_SOURCE - 未找到音频/视频来源<h2 id="Loading-the-media-resource"><a href="#Loading-the-media-resource" class="headerlink" title="Loading the media resource"></a><strong>Loading the media resource</strong></h2></li></ol><p>media . load()    重新加载音频/视频元素。</p><p>media . buffered  属性返回 TimeRanges 对象，表示用户的音视频缓冲范围。</p><p>TimeRanges 对象属性：</p><ol><li>length - 获得音视频中已缓冲范围的数量</li><li>start(index) - 获得某个已缓冲范围的开始位置</li><li>end(index) - 获得某个已缓冲范围的结束位置<h2 id="Offsets-into-the-media-resource"><a href="#Offsets-into-the-media-resource" class="headerlink" title="Offsets into the media resource"></a><strong>Offsets into the media resource</strong></h2></li></ol><p>media . duration  返回当前音频/视频的长度，以秒计。如果未设置音频/视频，则返回NaN，如果是无限流，返回 Infinity</p><p>media . currentTime [ = value ]    设置或返回音频/视频播放的当前位置</p><h2 id="Playing-the-media-resource"><a href="#Playing-the-media-resource" class="headerlink" title="Playing the media resource"></a><strong>Playing the media resource</strong></h2><p>media . paused   返回音频/视频是否已暂停。true 指示音频/视频已暂停。否则为 false。</p><p>media . ended  返回音频/视频是否已结束。如果播放已结束，则返回 true。否则返回 false。</p><p>media . defaultPlaybackRate [ = value ]  设置或返回音频/视频的默认播放速度。</p><p>media . playbackRate [ = value ]   属性设置或返回音频/视频的当前播放速度。</p><p>media . played   返回TimeRanges 对象。TimeRanges 对象表示用户已经播放或看到的音频/视频范围。</p><p>media . play() 开始播放当前的音频或视频。</p><p>media . pause()  暂停当前播放的音频/视频</p><h2 id="Seeking"><a href="#Seeking" class="headerlink" title="Seeking"></a><strong>Seeking</strong></h2><p>media . seeking  返回用户目前是否在音频/视频中寻址，如果用户正在寻址，则为 true。否则为 false。</p><p>media . seekable  返回TimeRanges对象。表示音频/视频中用户可寻址的范围。</p><ol><li>length - 获得音频/视频中可寻址范围的数量</li><li>start(<em>index</em>) - 获得可寻址范围的开始位置</li><li>end(<em>index</em>) - 获得可寻址范围的结束位置</li></ol><p>media . fastSeek( time )  寻求尽可能快地接近给定的时间，以精度换取速度。（要查找精确的时间，使用currentTime属性。）如果媒体资源尚未加载，则不执行任何操作。</p><h2 id="Media-resources-with-multiple-media-tracks"><a href="#Media-resources-with-multiple-media-tracks" class="headerlink" title="Media resources with multiple media tracks"></a><strong>Media resources with multiple media tracks</strong></h2><p>media . audioTracks返回一个表示该媒体资源可用的音频轨的AudioTrackList对象(包含有audioTrack对象)</p><p>media . videoTracks   返回一个表示该媒体资源可用的视频轨道的 videoTrackList对象。(包含有videoTrack对象)</p><p>media . audioTracks . length           media . videoTracks . length</p><p>返回可用音轨的数量</p><p>audioTrack=media.audioTracks[index]       videoTrack=media.videoTracks[index]</p><p>通过 index 来获得 AudioTrack或VideoTrack 对象</p><p>audioTrack=media.audioTracks.getTrackById(id)</p><p>videoTrack=media.videoTracks.getTrackById(id)</p><p>通过 id 来获得AudioTrack或VideoTrack 对象</p><p>audioTrack . id           videoTrack . id</p><p>获得音轨、视频轨道的 id</p><p>audioTrack . kind      videoTrack . kind</p><p>获得音轨、视频轨道的类型</p><p>audioTrack . label          videoTrack . label</p><p>获得音轨、视频轨道的标签</p><p>audioTrack . language          videoTrack . language</p><p>获得音轨、视频轨道的语言</p><p>audioTrack . enabled [ = value ]    获得或设置音轨是否是活动的 (true|false)</p><p>videoTrack . selected [ = value ]    获得或设置视频轨道是否是活动的 (true|false)</p><p>media . videoTracks . selectedIndex获得当前 VideoTrack 对象的下标，没有返回-1</p><h2 id="AudioTrack和VideoTrack的kind-关键字"><a href="#AudioTrack和VideoTrack的kind-关键字" class="headerlink" title="AudioTrack和VideoTrack的kind 关键字"></a>AudioTrack和VideoTrack的kind 关键字</h2><p>|类别|定义|适用于|<br>|:—-:|:—-|:—-:|:—-|:—-:|:—-|<br>|“ alternative”|主音轨的一种替代，例如不同的歌曲（音频）或不同的角度（视频）。|音频和视频。|<br>|“ captions”|带有字幕的主视频轨道的版本。（对于旧内容，新内容将使用文本轨道。）|仅视频。|<br>|“ descriptions”|视频轨道的音频描述。|仅音频。|<br>|“ main”|主要音频或视频轨道。|音频和视频。|<br>|“ main-desc”|主要音轨，混合有音频说明。|仅音频。|<br>|“ sign”|音轨的手语解释。|仅视频。|<br>|“ subtitles”|带有字幕的主视频轨道版本。（对于旧内容，新内容将使用文本轨道。）|仅视频。|<br>|“ translation”|主音轨的翻译版本。|仅音频。|<br>|“ commentary”|有关主要音频或视频轨道的评论，例如导演的评论。|音频和视频。|<br>|“ ”|用户代理无法识别任何明确的种类或轨道的元数据给出的种类。|音频和视频。<br>|</p><h2 id="Text-track-API"><a href="#Text-track-API" class="headerlink" title="Text track API"></a><strong>Text track API</strong></h2><p>media . textTracks . length    获得音频/视频中可用的文本轨道的数量</p><p>media . textTracks[ n ]    返回TextTrack对象，表示媒体元素的文本轨道列表中的第n个文本轨道。</p><p>textTrack = media . textTracks . getTrackById( id )     返回给定id的TextTrack对象，如果没有，则返回null。</p><p>textTrack = media . addTextTrack( kind [, label [, language ] ] )</p><p>创建和返回新的文本轨道。新的TextTrack对象会被添加到视频/音频元素的文本轨道列表中。</p><p>textTrack . kind    返回文本轨道的类型。</p><p>textTrack . label   返回文本轨道的标签。</p><p>textTrack . language    返回文本轨道的语言。</p><p>textTrack . id    返回文本轨道的id</p><p>textTrack.inBandMetadataTrackDispatchType     返回文本轨道 in-band metadata track dispatch type字符串。</p><p>textTrack.mode [=value]</p><p>获得或设置该轨道是否是活动的(“disabled”|”hidden”|”showing”)</p><p>textTrack . cues        获得 TextTrackCueList 对象的 cues 列表</p><p>textTrack . activeCues       获得 TextTrackCueList 对象形式的当前活动文本轨道 cues</p><p>textTrack . addCue( cue )          向 cues 列表添加一个 cue</p><p>textTrack . removeCue( cue )      向 cues 列表删除一个 cue</p><p>cuelist . length    返回cuse列表的cue数量</p><p>cuelist[index]        返回给定index的cue</p><p>cuelist . getCueById( id )   返回给定id的cue</p><p>cue . track    返回属于文本轨道cue的TextTract</p><p>cue . id [ = value ]   返回或设置cue的id</p><p>cue . startTime [ = value ]   返回或设置cue的开始时间的id</p><p>cue . endTime [ = value ]    返回或设置cue的结束时间的id</p><p>cue . pauseOnExit [ = value ]   是否设置暂停或退出标志，是则返回true,否则为false</p><h2 id="User-interface"><a href="#User-interface" class="headerlink" title="User interface"></a><strong>User interface</strong></h2><p>media . volume [ = value ]</p><p>设置或返回音频/视频的当前音量,必须是介于 0.0 与 1.0 之间的数字。0是静音，1最大</p><p>media . muted [ = value ]</p><p>设置或返回音频/视频是否应该被静音（true）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Image&quot;&gt;&lt;a href=&quot;#Image&quot; class=&quot;headerlink&quot; title=&quot;Image&quot;&gt;&lt;/a&gt;Image&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>The elements of HTML（一）</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/The%20elements%20of%20HTML%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-03-08T12:31:12.775Z</published>
    <updated>2021-05-11T09:19:09.310Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>element</strong></th><th><strong>meaning</strong></th><th align="center"><strong>Categories</strong></th><th align="left"><strong>Contexts in which this element can be used</strong></th><th align="center"><strong>Content model</strong></th><th align="left"><strong>Tag omission in text/html</strong></th><th align="center"><strong>Content attributes</strong></th><th align="left"><strong>remark</strong></th></tr></thead><tbody><tr><td align="center">html</td><td>文档的根</td><td align="center">none</td><td align="left">document、子片段</td><td align="center">head后面跟一个body</td><td align="left">第一个子元素不是注释，可以省略起始标签。html后没有紧跟注释，可以省略结束标签</td><td align="center">manifest （现已不建议使用）</td><td align="left">建议在htm添加lang属性</td></tr><tr><td align="center">head</td><td>metadata的集合（title、link、script、meta）</td><td align="center">none</td><td align="left">html内的第一个元素</td><td align="center">如果是 iframe srcdoc 文档，可以有没有或多个元数据，title和base最多各有一个,其他类型，至少有一个以上的元数据，且必须有且只有一个title，最多一个base</td><td align="left">head内为空可以省略起始标签，结束标签没有紧跟空格或者注释可以省略</td><td align="center">Global attributes</td><td align="left">大多数情况必须含title,除非html用作电子邮件格式</td></tr><tr><td align="center">titile</td><td>文档标题或名称</td><td align="center">Metadata content</td><td align="left">head内</td><td align="center">text文本</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">text属性的getter方法返回title元素的子文本内容，text属性的setter方法用该元素内的给定值替换所有字符串title。用户代理在其用户界面中引用文档时，应使用文档标题。在用户界面titile的directionality应该设置为文档title的directionality（directionality暂未理解）</td></tr><tr><td align="center">base</td><td>页面上的所有链接规定默认地址或默认目标</td><td align="center">Metadata content</td><td align="left">head内</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">href— 文档基本URL<br>target— 用于超链接导航和表单提交的默认浏览上下文</td><td align="left">target、href两个属性至少有一个。多个base的href,只有第一个有效果。href如果指定了content属性，则该属性必须包含一个有效的URL。base如果有href属性，必须在其他有定义获取url属性的元素之前（除了html元素，它的maifest不受影响）。target的frozen base URL这个概念不理解，那里一坨都没看懂</td></tr><tr><td align="center">link</td><td>文档链接到其他资源</td><td align="center">Metadata content</td><td align="left">head内、在noscript 元素作为head元素的子元素、allowed in the body:phrasing content元素</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">href— 超链接的地址<br>crossorigin —元素如何处理跨域请求<br>rel—包含超链接的文档和目标资源之间的关系<br>media —适用媒体<br>integrity—子资源完整性检查中使用的完整性元数据<br>hreflang —链接资源的语言<br>type —提示所引用资源的类型<br>referrerpolicy-  Referrer policy的取发起由元素<br>sizes—图标的大小（用于“ rel=“ icon”）<br>imagesrcset —在不同情况下使用的图像（例如，高分辨率显示器，小型显示器等）<br>imagesizes —不同页面布局的图像大小<br>as— 预加载请求的Potential destination（对于rel=“ preload”和rel=“ modulepreload”）<br>color—自定义网站图标时使用的颜色（对于rel=“ mask-icon”）<br>disabled —是否禁用链接<br>title —链接的标题；CSS样式表集名称。</td><td align="left">必须有rel或者itemprop属性，不能同时使用。如果link元素具有itemprop属性，或者仅包含关键字的rel属性 ，也就是body-ok.link元素可以创建外部资源链接（stylesheet）和超链接(next)，链接类型和数量取决于rel属性的关键字,每个链接对会被单独处理。link创建的超链接和rel属性作用于全文档，a和area相反。</td></tr><tr><td align="center">meta</td><td>提供有关页面的元信息</td><td align="center">Metadata content</td><td align="left">如果charset存在，或者元素的http-equiv属性处于Encoding声明状态：head内。<br>如果http-equiv存在但不处于Encoding声明状态：head内。<br>如果http-equiv存在，但不处于Encoding声明状态：在作为head元素的子元素的noscript元素中。<br>如果name存在： metadata content。<br>如果itemprop存在： metadata content。<br>如果itemprop属性存在： phrasing content。</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">name —元数据名称<br>http-equiv —编译指示指令<br>content —元素的值<br>charset— 字符编码声明</td><td align="left">每个文档meta的charset属性不得超过一个。name的值：application-name（提供页面代表的Web应用程序的名称）、author（作者）、description（描述页面）、generator（标识用于生成文档的软件包）、keywords（关键字，许多搜索引擎不考虑）、referrer（没懂）、theme-color（定义建议的颜色），以及其他自己定义的。http-equiv：content-language（设置编译设定的默认语言,鼓励使用lang）、content-type（字符编码声明）、default-style（设置默认 CSS样式表集的名称）、refresh（定义文档自动刷新的时间间隔）、set-cookie（此实用程序不符合要求，没有任何效果）、    x-ua-compatible（指定网页的兼容性模式设置）、content-security-policy（启用CSP内容安全策略）。</td></tr><tr><td align="center">style</td><td>将CSS样式表嵌入其文档中</td><td align="center">Metadata content</td><td align="left">metadata content、在作为head元素的子元素的noscript元素中</td><td align="center">Text that gives a conformant style sheet</td><td align="left">不可省略</td><td align="center">media —适用媒体<br>title属性–CSS样式表集名称</td><td align="left">如果media 省略该属性，则默认值为“ all”，这意味着默认情况下样式适用于所有媒体</td></tr><tr><td align="center">body</td><td>文档的内容</td><td align="center">Sectioning root</td><td align="left">html内的第二个元素</td><td align="center">Flow content</td><td align="left">如果元素为空，或第一个子元素不是空格或注释，除非第一个子元素是meta, link, script, style, 或者 template元素，起始标签可以省略。如果元素后面没有紧跟注释，可以省略结束标签。</td><td align="center">onafterprint<br>onbeforeprint<br>onbeforeunload<br>onhashchange<br>onlanguagechange<br>onmessage<br>onmessageerror<br>onoffline<br>ononline<br>onpagehide<br>onpageshow<br>onpopstate<br>onrejectionhandled<br>onstorage<br>onunhandledrejection<br>onunload</td><td align="left">文档只能有一个body元素。onerror事件将从目标冒泡到body、html、document、window，而body上的事件处理程序监视的是window而不是body。但是，使用addEventListener（）添加的事件侦听器将在事件冒泡通过body时运行，而不是在事件到达window对象时运行。</td></tr><tr><td align="center">article</td><td>规定独立的自包含内容，比如论坛帖子、报纸文章、博客条目、用户评论</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">与article元素关联的作者信息不适用于嵌套的article元素。</td></tr><tr><td align="center">scetion</td><td>文档或应用的通用部分，比如比如章节、页眉、页脚等</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当需要syndicate元素内容时，使用article而不是section.使用section时可以一直使h1</td></tr><tr><td align="center">nav</td><td>定义导航链接的部分</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">用于服务条款、版权信息的链接一般放在底部的footer而不是nav</td></tr><tr><td align="center">aside</td><td>与页面主内容无关，比如侧边栏，广告、拉引号</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">aside仅将元素用于括号是不合适的</td></tr><tr><td align="center">h1、h2、h3……</td><td>定义标题</td><td align="center">Flow content<br>Sectioning content<br>Palpable content</td><td align="left">作为hgroup的子元素，flow content 、heading content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">不要因为字体大小，来选择不同的h,一般css里改</td></tr><tr><td align="center">hgroup</td><td>标题部分，比如副标题、标语等</td><td align="center">Flow content<br>Heading conten<br>Palpable content</td><td align="left">flow content、heading content</td><td align="center">包含一个以上h1-h6，并可以选择性的与支持脚本的元素（script、template）一起使用</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">hgroup的rank是其包含的h标签里的最高的一个。hgroup对两个标题进行分组，即便都是同等级的h标签，也是不对等的</td></tr><tr><td align="center">header</td><td>定义文档的页眉（介绍信息、导航辅助）</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">没有footer和header子代的flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">header不会引入新的部分</td></tr><tr><td align="center">footer</td><td>义文档或节的页脚，通常包含文档的作者、版权信息、使用条款链接、联系信息等等</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">没有footer和header子代的flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">通常在底部，但不是绝对的。比如像联系信息等有可能在footer也可以在address</td></tr><tr><td align="center">address</td><td>定义文档或文章作者的联系信息</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">没有heading content 、sectioning content 、header, footer,  address 子代的Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">address可以在articel内，也可以在body内(引用于整个文档)。address不能用于任何地址比如邮政地址（通常用P标签）,也不得用于除联系方式以外的信息，通常和其他信息包含在footer内。</td></tr><tr><td align="center">p</td><td>段落</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">Phrasing content</td><td align="left">结束标签省略：p后紧跟address, p, aside, div, 等，或父元素没有内容，且父元素不是 a, audio, del, ins, map, noscript, video或自定义元素</td><td align="center">Global attributes</td><td align="left">当有更适用的标签时，不应该使用p。p 元素会自动在其前后创建一些空白。列表元素特别是ol、ul不能作为p的子元素。设计由多个结构段落组成的逻辑段落时，用div来代替p。</td></tr><tr><td align="center">hr</td><td>水平线</td><td align="center">Flow content</td><td align="left">Flow content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">Global attributes</td><td align="left">hr不影响文档的轮廓</td></tr><tr><td align="center">pre</td><td>预格式化的文本块</td><td align="center">Flow content<br>Palpable content</td><td align="left">flow content</td><td align="center">Phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">pre的结构是由印刷规定而不是元素来表示。常用于表示：电子邮件、代码块（与code、samp、kbd一起使用）、ASCII文字</td></tr><tr><td align="center">blockquote</td><td>引用块</td><td align="center">Flow content<br>Sectioning root<br>Palpable content</td><td align="left">flow content</td><td align="center">flow content</td><td align="left">不可省略</td><td align="center">Global attributes<br>cite —链接引用和编辑信息资源</td><td align="left">blockquote中的内容是引用的其他资源， blockquote中的内容可以缩写，也可以按照文本语言的传统方式添加上下文。引用内容的属性必须放在blockquote外部。</td></tr><tr><td align="center">ol</td><td>有序列表</td><td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td><td align="left">flow content</td><td align="center">li和脚本支持元素</td><td align="left">不可省略</td><td align="center">reversed —降序<br>start— 列表的起始值<br>type —列表标记的类型</td><td align="left">type关键字：1（十进制数）、a（小写拉丁字母）、A（大写拉丁字母）、i（小写罗马数字）、I（大写罗马数字）</td></tr><tr><td align="center">ul</td><td>无序列表</td><td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td><td align="left">flow content</td><td align="center">li和脚本支持元素</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">menu</td><td>代表命令的工具栏</td><td align="center">Flow content.<br>如果至少含有一个li:Palpable content</td><td align="left">flow content</td><td align="center">li和脚本支持元素</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">li</td><td>列表项</td><td align="center">none</td><td align="left">ol、ul、menu内</td><td align="center">Flow content</td><td align="left">如果li后紧跟另一个li元素或者其父元素没有内容，则结束标签可以省略</td><td align="center">value—只有在ol内情况下，代表列表项的顺序值，必须为整数</td><td align="left">不建议在li内放入h1元素</td></tr><tr><td align="center">dl</td><td>描述性列表</td><td align="center">Flow content、Palpable content</td><td align="left">flow content</td><td align="center">一个以上的dt后面跟着一个以上的dd，或者一个以上的div,可以和脚本支持的元素搭配使用</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">在单个dl元素中，每个名称不应该有多个dt元素。dl可以被包含在div内</td></tr><tr><td align="center">dt</td><td>列表中的项目（术语部分、名称）</td><td align="center">none</td><td align="left">在dl内的dd、dt之前，或者在div内的dd、dt之前</td><td align="center">Flow content(没有footer、header、 sectioning content、heading content后代)</td><td align="left">dt元素后面紧跟其他dd、dt，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">可以使用dfn元素表示术语的定义</td></tr><tr><td align="center">dd</td><td>条目的定义部分</td><td align="center">none</td><td align="left">在dl内的dd、dt之后，或者在div内的dd、dt之后</td><td align="center">Flow content</td><td align="left">dd元素后面紧跟其他dd、dt，或父元素没有内容，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">figure</td><td>独立的流内容（图表，图片，代码）</td><td align="center">Flow content<br>Sectioning root<br>Palpable content</td><td align="left">Flow content</td><td align="center">Flow content 或Flow content后跟figcaption，或者figcaption前跟Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">figure被删除后，不能对文档流产生影响</td></tr><tr><td align="center">figcaption</td><td>figure的标题</td><td align="center">none</td><td align="left">figure内的第一个或最后一个元素</td><td align="center">Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">mian</td><td>文档的主要内容</td><td align="center">Flow content<br>Palpable content</td><td align="left">Flow content，但只能有一个</td><td align="center">Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">如果有多个main必须有hidden属性。main的父元素只能是html, body, div, form</td></tr><tr><td align="center">div</td><td>块级元素，无特殊含义</td><td align="center">Flow content<br>Palpable content</td><td align="left">Flow content，或作为dl的子元素</td><td align="center">如果是dl的子元素：一个以上的dt后跟一个以上dd，且可以与脚本支持元素使用。否则，Flow content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当没有元素适合，建议使用div</td></tr><tr><td align="center">a</td><td>如果有href属性，代表资源的超链接。没有则表示为占位符。</td><td align="center">Flow content.<br>Phrasing content.<br>Interactive content:如果存在href属性.<br>Palpable content.</td><td align="left">phrasing content</td><td align="center">不能有交互式内容的子代，a元素子代，或者带有tabindex属性的子代</td><td align="left">不可省略</td><td align="center">href — 超链接的地址<br>target — 在何处打开链接文档<br>download — 被下载的超链接目标<br>ping — ping 的URL地址<br>rel —当前文档与被链接文档之间的关系<br>hreflang — 被链接资源的语言<br>type —提示被链接资源的的 MIME 类型<br>referrerpolicy— Referrer policy for fetches initiated by the element</td><td align="left">如果没有href属性，则a元素其他属性必须省略。如果有 itemprop 属性，则必须有href属性。</td></tr><tr><td align="center">em</td><td>强调重点的内容</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">强调的级别由em数量决定。</td></tr><tr><td align="center">strong</td><td>对内容极其强调</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">strong通常强调标题、段落、警告、危险标志、用户更需要长时间看见的内容等，比em强调程度更大。</td></tr><tr><td align="center">small</td><td>小号字体</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">常用于免责声明、警告、法律限制、版权信息、属性、许可要求等。使用small并不代表内容不重要，不重要只需不使用em、strong即可，small和strong、em也可嵌套使用。small不适用于大篇幅如段落、列表等。只用于小段文本，也不适用于副标题。</td></tr><tr><td align="center">s</td><td>无关或不准确的内容（文本添加删除线）</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">更推荐使用del元素。</td></tr><tr><td align="center">cite</td><td>引用或参考的内容，也可以是顺带提及的内容，通常是论文、文章、杂志等的标题</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">不能用于人名。</td></tr><tr><td align="center">q</td><td>引用了其他资源的phrasing content</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">cite — 引用的资源链接</td><td align="left">不需要添加标点符号，UA会渲染添加。引用的资源可以是虚构的，不适合引用单独一个单词。不能用q代替不表示引用的引用（讽刺语句，通常会加标点符号，但这并不是引用）</td></tr><tr><td align="center">dfn</td><td>定义术语</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content，不包含dfn的子代</td><td align="left">不可省略</td><td align="center">title— 显示完整的术语或缩写的扩展</td><td align="left">dfn的父元素需包含dfn内术语的定义，且其title属性不影响dfn。title只能是这个术语的定义，不能包含其他。</td></tr><tr><td align="center">abbr</td><td>简称或缩写</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">title— 显示完整的术语或缩写的扩展</td><td align="left">适用情况：开发者想要解释缩写的含义；用户不熟悉的术语；存在需要进行语义注释的缩写。有title的abbr与没有title的abbr不会影响。</td></tr><tr><td align="center">ruby</td><td>定义 ruby 注释（有注音或其他注释）</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">Phrasing content，不包含ruby或ruby子元素。单独的ruby,且自身不喊ruby。一个或多个rt。一个rb包含一个或多个rt</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">在没有ruby父元素的ruby中，内容被分为三段：基本文本片段；注释片段；可忽略片段（空格或rp）。其中tr对应注释片段，通常只有一个。</td></tr><tr><td align="center">rt</td><td>标记ruby注释的ruby文本组件</td><td align="center">none</td><td align="left">ruby的子元素</td><td align="center">Phrasing content</td><td align="left">rt后紧跟rt或tp，或其父元素没有内容，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">当它是ruby元素的子元素时，它本身并不表示任何东西，但是ruby元素使用它来确定它所代表的内容。</td></tr><tr><td align="center">rp</td><td>在ruby注释的ruby文本组件周围提供括号或其他内容</td><td align="center">none</td><td align="left">ruby的子元素，紧跟在rt之前或之后</td><td align="center">Text</td><td align="left">tp后紧跟tr或rp，或其父元素没有内容，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">由不支持ruby注释的UA显示。</td></tr><tr><td align="center">data</td><td>本身的内容及其value的值</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">value — 机器可读的值</td><td align="left">value属性必须存在，并且是以机器可读的格式来代表元素的内容。当内容与时间有关，使用time。适用于：当与微格式或微数据属性相结合时，元素用于提供用于数据处理的机器可读值和用于在Web浏览器中呈现的人可读值。在这种情况下，value的格式由所使用的微格式或微数据决定；当脚本有一个文本值要与人可读的值一起存储时，可以与页面中的脚本一起使用，value格式只取决于脚本的需要。</td></tr><tr><td align="center">time</td><td>时间相关的内容及其value的值</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">当有datatime属性：phrasing content ，否则为Text</td><td align="left">不可省略</td><td align="center">datetime — 机器可读的值</td><td align="left">time的datetime值是datetime内容属性的值，否则为time元素的子文本内容。没有datetime属性的time元素不能有子元素。</td></tr><tr><td align="center">code</td><td>计算机代码片段</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">可以添加一个值为“language-XX”的class属性来指示所使用的语言。</td></tr><tr><td align="center">var</td><td>变量</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">samp</td><td>样本；程序或计算机输出的引用</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">kbd</td><td>用户输入（通常是键盘文本）</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当kbd嵌套在samp中，表示系统回显的输入；当包含samp，表示基于系统输出的输入，例如调用菜单项；当kbd嵌套在另一个kbd中，表示一个实际的键或其他适合输入机制的单个输入单元。code、var、samp、kbd这些常与pre一起使用。</td></tr><tr><td align="center">sub/sup</td><td>上标/下标</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">特殊的排版要求才使用。</td></tr><tr><td align="center">i</td><td>斜体文本效果</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">适用于i的情况，要考虑是否用em和dfn更合适。</td></tr><tr><td align="center">b</td><td>粗体</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">当没有其他元素适合时，才考虑用b。并非有重要的语义。</td></tr><tr><td align="center">u</td><td>下划线</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">注意避免导致用户错认为超链接。</td></tr><tr><td align="center">mark</td><td>突出显示文本</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">bdi</td><td>从周围的文本格式设置中隔离</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">dir –默认为auto,不会继承父元素的样式</td><td align="left">在发布用户生成的内容时，该标签很有用。</td></tr><tr><td align="center">bdo</td><td>可覆盖默认的文本方向</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">dir –定义文字的方向（ltr<br>、rtl）</td><td align="left">必须设置dir属性，不能设置为auto。</td></tr><tr><td align="center">sapn</td><td>行内元素</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">phrasing content</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">br</td><td>换行符</td><td align="center">Flow content<br>Phrasing content</td><td align="left">phrasing content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">Global attributes</td><td align="left">当段落只有br元素，代表占位符空行</td></tr><tr><td align="center">wbr</td><td>换行符的时机</td><td align="center">Flow content<br>Phrasing content</td><td align="left">phrasing content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">Global attributes</td><td align="left">如果文本过长，可能会导致换行，浏览器会按照wbr来换行，避免语义混乱。</td></tr><tr><td align="center">ins</td><td>文档新的添加</td><td align="center">Flow content<br>Phrasing content<br>Palpable content</td><td align="left">phrasing content</td><td align="center">Transparent</td><td align="left">不可省略</td><td align="center">cite —引用文档的URL（解释变动原因）。<br>datetime —变化的日期和时间</td><td align="left">ins 不应该跨越 implied paragraph边界</td></tr><tr><td align="center">del</td><td>文档的删除部分</td><td align="center">Flow content<br>Phrasing content</td><td align="left">phrasing content</td><td align="center">Transparent</td><td align="left">不可省略</td><td align="center">cite —引用文档的URL（解释变动原因）。<br>datetime —变化的日期和时间</td><td align="left">ins和del不能作为ul、ol的子元素。</td></tr><tr><td align="center">img</td><td>图片的展示</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Form-associated element<br>Interactive content(有usemap属性)<br>Palpable content</td><td align="left">embedded content</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">alt —不能正常显示时的替代文本<br>src —资源的地址<br>srcset — 图片应用的场景<br>sizes —图片设置的尺寸<br>crossorigin — 如何处理跨域请求<br>usemap—定义为客户器端图像映射<br>ismap—定义为服务器端图像映射<br>width — 宽度<br>height — 高度<br>referrerpolicy— 设置引用策略<br>decoding —图像解码的首选方法<br>loading — 确定懒加载时使用</td><td align="left">建议懒加载的图片设置宽高属性，防止加载后页面布局改变。img元素不能当做页面的布局工具或展示透明的图片。设置了src和alt属性，但alt属性值为空字符串，图片是内容的装饰或补充，没有设置alt属性，代表图片是内容的关键部分，但没有可替换的文本内容。</td></tr><tr><td align="center">iframe</td><td>嵌套的浏览上下文</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content<br>Palpable content</td><td align="left">embedded content</td><td align="center">无</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>srcdoc —需要渲染的html文档<br>name — 名称<br>sandbox — 嵌套内容的安全规则<br>allow — iframe内容的功能策略<br>allowfullscreen—允许使用requestFullscreen()方法<br>allowpaymentrequest—允许使用PaymentRequest 界面处理支付请求<br>width — 宽度<br>height — 高度<br>referrerpolicy —引用策略</td><td align="left">1、srcdoc属性“”内的&amp;和‘“”符号必须转义的,否则会提前结束，沙盒内容中提到的原始&amp;必须双重转义，以便在最初解析srcdoc属性时保留&amp;，防止再一次解析沙盒内容时误解&amp;。<br>2、同时有src和srcdoc属性，则后者的优先级更高。<br>3、iframe可能会延迟load事件。<br>4、如果没有设置src和srcdoc,或设置了不能解析，浏览上下文会保持在原始的about:blank页面。<br>5、sandbox属性值： allow-forms（重启表单）, allow-modals（重启模态对话框）, allow-orientation-lock（重启屏幕方向锁）, allow-pointer-lock（重启pointer lock API）, allow-popups（重启弹出框）, allow-popups-to-escape-sandbox（重新创建无沙箱的auxiliary浏览器上下文）, allow-presentation（重启presentation API）, allow-same-origin（使得内容被视为来自真实来源，而不是强制其进入唯一的来源）, allow-scripts（重启脚本）, allow-top-navigation（允许内容导航到顶级浏览器上下文）, allow-top-navigation-by-user-activation（只有当浏览器上下文的 active window短暂的激活时）, and allow-downloads。 allow-top-navigation 和allow-top-navigation-by-user-activation不能通知指定，否则只有前者起作用。</td></tr><tr><td align="center">embed</td><td>额外的程序或交互内容</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content<br>Palpable content</td><td align="left">embedded content</td><td align="center">无</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>type —嵌套资源的类型<br>width — 宽度<br>height — 高度</td><td align="left">1、如果跳转到其他浏览器上下文，src属性不会改变<br>2、没有回退内容，子元素会被忽略。</td></tr><tr><td align="center">object</td><td>表示外部资源</td><td align="center">Flow content<br>Phrasing content<br>Embedded content<br>Interactive content（如果有usemap属性）<br>Listed and submittable form-associated element.<br>Palpable content.</td><td align="left">embedded content</td><td align="center">没有或多个param元素</td><td align="left">不可省略</td><td align="center">data — 资源地址<br>type —嵌套资源的类型<br>name — 名称<br>usemap —规定与对象一同使用的客户端图像映射的 URL<br>form — 规定对象所属的一个表单<br>width — 宽度<br>height — 高度</td><td align="left">可以插入HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。</td></tr><tr><td align="center">param</td><td>作为脚本，嵌套在object的参数</td><td align="center">None</td><td align="left">在flow content前面的object子元素</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">name —参数名称<br>value — 参数的值</td><td align="left">两个属性都必须存在。</td></tr><tr><td align="center">video</td><td>播放视频、电影，或带字幕的音频文件</td><td align="center">Flow content.<br>Phrasing content.<br>Embedded content.<br>Interactive content(如果有controls属性 )<br>Palpable content.</td><td align="left">embedded content</td><td align="center">如果有src属性：没有或多个track,并且是透明的，没有媒体子元素。<br>没有src属性：没有或多个source，接着没有或多个track,并且是透明的，没有媒体子元素。</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>crossorigin — 如何处理跨域请求<br>poster — 播放前显示的画面url<br>preload—页面加载时视频也加载<br>autoplay—页面加载好后自动播放<br>playsinline —内联形式播放<br>loop —循环播放<br>muted —默认静音<br>controls —展示控件<br>width —宽<br>height — 高</td><td align="left">1、可以在video内插入文本，当浏览器不支持时，用于提供一些帮助信息。<br>2、字幕、手语、音频描述可以直接嵌入到视频，其中字幕也可以用track外引文件，音频描述可以以文本通过WebVTT 文件，track会将文本合成语音，WebVTT也可以提供章节信息。<br>3、视频中的每一帧对应哪个播放位置由视频流的格式决定。</td></tr><tr><td align="center">audio</td><td>音频</td><td align="center">Flow content.<br>Phrasing content.<br>Embedded content.<br>Interactive content、Palpable content(如果有controls属性 )</td><td align="left">embedded content</td><td align="center">如果有src属性：没有或多个track,并且是透明的，没有媒体子元素。<br>没有src属性：没有或多个source，接着没有或多个track,并且是透明的，没有媒体子元素。</td><td align="left">不可省略</td><td align="center">src — 资源地址<br>crossorigin — 如何处理跨域请求<br>preload—页面加载时音频也加载<br>autoplay—页面加载好后自动播放<br>loop —循环播放<br>muted —默认静音<br>controls —展示控件</td><td align="left">当字幕和手语视频可以使用时，video可以代替audio.</td></tr><tr><td align="center">track</td><td></td><td align="center">none</td><td align="left">在flow content前面的媒体子元素</td><td align="center">无</td><td align="left">没有结束标签</td><td align="center">kind — 轨道的文本类型<br>src — 资源地址<br>srclang — 轨道语言<br>label — 标签<br>default — 默认的轨道</td><td align="left">1、kind关键字（可以省略，缺失默认 subtitles ，无效默认 metadata）<br>captions：播放器中显示的简短说明<br>chapters：定义章节，用于导航媒介资源<br>descriptions：定描述，用于通过音频描述媒介的内容<br>metadata：定义脚本使用的内容<br>subtitles：定义字幕，用于在视频中显示字幕<br>2、媒体元素的最多有一个这样的track（kind属性除metadata以外，并且指定了default）<br>3、track的readstatus：<br>0：未加载<br>1：正在加载<br>2：加载完成<br>3：加载失败</td></tr><tr><td align="center">table</td><td>表格</td><td align="center">Flow content.<br>Palpable content.</td><td align="left">flow content</td><td align="center">顺序如下：caption（可选）、colgroup(0个或多个)、thead 、tbody 或tr（0个或多个）、tfoot0个或多个）、脚本支持元素（可选）</td><td align="left">不可省略</td><td align="center">Global attributes</td><td align="left">1、table不能用于布局的工具<br>2、如果一个表格不以第一行和第一列作为标题，或着其他特殊情况，应该引入介绍该表格的解释性信息。</td></tr><tr><td align="center">caption</td><td>表格标题</td><td align="center">none</td><td align="left">table内的第一个元素</td><td align="center">没有子代table元素的Flow content</td><td align="left">如果caption后没有紧跟空格或注释，则结束标签可以省略</td><td align="center">Global attributes</td><td align="left">1、当figure元素除了figurecaption以外，只有table元素，应该省略caption而使用figurecaption。<br>2、caption可以用来解释表格内容，使得其更容易理解</td></tr><tr><td align="center">colgroup</td><td>对表格中的列进行组合，以便对其进行格式化</td><td align="center">none</td><td align="left">table内，在caption后，在thead, tbody, tfoot或tr前.</td><td align="center">有span属性，nothing，否则，零个或多个col和template元素</td><td align="left">起始标签省略：colgroup内是一个元素col，或元素前面没有紧跟另一个已省略结束标签的colgroup，如元素为空，则不可省略<br>结束标签省略：colgroup后没有紧跟空格或注释</td><td align="center">Global attributes<br>span —列组应该横跨的列数</td><td align="left">1、colgroup内没有col,则应该在元素上设置span属性，值在1—1000之间。</td></tr><tr><td align="center">col</td><td>为表格中一个或多个列定义属性值</td><td align="center">none</td><td align="left">作为没有span属性的colgroup子元素</td><td align="center">nothing</td><td align="left">没有结束标签</td><td align="center">Global attributes<br>span —列组应该横跨的列数</td><td align="left"></td></tr><tr><td align="center">tbody</td><td>表格主体</td><td align="center">none</td><td align="left">table的子元素，在caption、colgroup和thead之后，但前提是没有作为table子元素的tr。</td><td align="center">零个或多个tr以及支持脚本的元素</td><td align="left">起始标签省略：tbody内的第一个元素是tr，或没有紧在省略了结束标签的tbody、thead、tfoot之前，元素内为空时不能省略。<br>结束标签省略：tbody后紧跟tbody、tfoot，或父元素没有内容</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">thead</td><td>表格的表头</td><td align="center">none</td><td align="left">table的子元素，在caption、colgroup之后，在tbody、tfoot之前，但前提是没有其他head。</td><td align="center">零个或多个tr以及支持脚本的元素</td><td align="left">如果thead元素后紧跟tbody或tfoot元素，结束标签可以省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">tfoot</td><td>表格的页脚</td><td align="center">none</td><td align="left">table的子元素，在caption、colgroup和thead、tbody、tr之后，但前提是没有其他tfoot。</td><td align="center">零个或多个tr以及支持脚本的元素</td><td align="left">父元素没有内容，可以省略结束标签</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">tr</td><td>表格中的行</td><td align="center">none</td><td align="left">thead的子元素.<br>tbody的子元素.<br>tfoot 的子元素.<br>table的子元素，在caption, colgroup,thead之后，前提是没有作为table子元素的tbody</td><td align="center">零个或多个 td, th，或支持脚本的元素</td><td align="left">tr后紧跟另一个tr，或父元素没有内容，结束标签可以省略</td><td align="center">Global attributes</td><td align="left"></td></tr><tr><td align="center">td</td><td>表格的标准单元格</td><td align="center">Sectioning root</td><td align="left">tr的子元素</td><td align="center">Flow content</td><td align="left">td后紧跟td或th，或父元素没有内容，结束标签可以省略</td><td align="center">colspan — 单元格可横跨的列数<br>rowspan — 单元格可横跨的行数<br>headers — 与单元格相关的表头</td><td align="left">用户代理，特别是在非可视环境中，或者在无法将表显示为2D网格的情况下，当呈现单元格的内容时，可能会提供单元格的用户上下文；例如，给出单元格在表模型中的位置，或列出单元格的标题单元格（由分配标题单元格的算法确定）。</td></tr><tr><td align="center">th</td><td>表头单元格</td><td align="center">none</td><td align="left">th的子元素</td><td align="center">Flow content,但没有header,footer,sectioning content,heading content后代</td><td align="left">th后紧跟td或th，或父元素没有内容，结束标签可以省略</td><td align="center">colspan — 单元格可横跨的列数<br>rowspan — 单元格可横跨的行数<br>headers — 与单元格相关的表头<br>scope — 表头数据与单元数据相关联的方法<br>abbr — 单元格中内容的缩写版本</td><td align="left">scope属性值字：<br>1、col   规定单元格是列的表头。<br>2、row    规定单元格是行的表头。<br>3、colgroup    规定单元格是列组的表头。<br>4、rowgroup    规定单元格是行组的表头。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;element&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;meaning&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;Categorie</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Semantics, structure, and APIs of HTML documents</title>
    <link href="http://example.com/2021/03/08/note/HTML%20Standard/Semantics_%20structure_%20and%20APIs%20of%20HTML%20documents/"/>
    <id>http://example.com/2021/03/08/note/HTML%20Standard/Semantics_%20structure_%20and%20APIs%20of%20HTML%20documents/</id>
    <published>2021-03-08T12:31:08.694Z</published>
    <updated>2021-05-11T09:18:54.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Document object</strong>:包含<strong>HTTPS state，</strong>代表传输数据的网络信道的安全属性，<strong>referrer policy、module ma、feature policy、CSP list</strong>包含了内容安全策略</p><p>Semantics ，元素、属性、属性值规范都定义了语义，不能用于定义语义以外的目的，不得使用规范以外的元素、属性、属性值。html具有描述进度条的progresss元素。</p><p><strong>Elements in the DOM，</strong>HTML元素必须实现规范列出的接口，并将这些接口expose to 脚本。</p><p><strong>Element definitions</strong>，每一个元素包含以下信息的定义：类别、Contexts in which this element can be used、内容模型、Tag omission in text/html、内容属性、Accessibility considerations、DOM 接口。</p><p><strong>Content models，</strong>每一个元素都内容模型，即对元素预期内容的描述，元素的内容是其dom中的子元素。元素之间允许有空格，元素之间的字符表示为Text，DOM节点，空Text节点和 Text仅由这些字符的序列组成的节点被视为 元素间空格。 在确定元素的内容是否与元素的内容模型匹配时，以及遵循定义文档和元素语义的算法时，必须忽略元素间空格，注释节点和处理指令节点（处理指令节点没懂）。HTML元素可以没有父节点。当元素的内容模型为空，该元素不包含任何Text节点（元素间空格除外）且不包含元素节点。</p><p><strong>Kinds of content，</strong>元素可以属于一个或者多个类别，甚至有些元素不属于任何特定类别，</p><ol><li><strong>Metadata content：</strong>设置其余内容的表示形式或行为、是指文档与其他文档的关系、传达其他 “out of band” 信息的内容。</li><li><strong>Flow content：</strong>大多元素都属于这个类别，常见的a、div、table……。</li><li><strong>Sectioning content：</strong>用于定义内容标题和页脚，比如article、aside、nav、section。</li><li><strong>Heading content：</strong>h1、h2…。</li><li><strong>Phrasing content：</strong>分类为Phrasing content的大多元素只能包含Phrasing content的元素。3.2.5.2.5后面一节暂未理解。</li><li><strong>Embedded content，</strong>将另一个资源导入文档中的内容，或来自插入到文档中的另一个词汇表中的内容，如audio、video,有些有 fallback content，比如外部资源的格式不支持所显示的内容</li><li><strong>Interactive content，</strong>a、button、input。。。。</li><li><strong>Palpable content，</strong>没理解</li><li><strong>Script-supporting elements，</strong>script、template</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Document object&lt;/strong&gt;:包含&lt;strong&gt;HTTPS state，&lt;/strong&gt;代表传输数据的网络信道的安全属性，&lt;strong&gt;referrer policy、module ma、feature policy、CSP lis</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTML standard" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML-standard/"/>
    
    
    <category term="WHATWG" scheme="http://example.com/tags/WHATWG/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
</feed>
